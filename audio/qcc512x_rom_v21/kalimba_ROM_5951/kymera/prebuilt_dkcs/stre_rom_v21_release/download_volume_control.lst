
/home/svc-audio-dspsw/kymera_builds/builds/2020/kymera_2004211534/kalimba/kymera/tools/KCSMaker/out/5951/stre_rom_v21_release/download/debugbin/download_volume_control.elf:     file format elf32-littlekalimba

Disassembly of section .text_maxim:

84200000 <$_vol_ctrl_update_channel>:
.MODULE $M.vol_ctrl_update_channel;
    .MAXIM;
    .CODESEGMENT VOL_CTRL_UPD_CHAN_PM;

$_vol_ctrl_update_channel:
    pushm <r4,r5,r6,r7,r8,r9>;
84200000:	c0 0f 00 f1 	pushm <r4, r5, r6, r7, r8, r9>;
    pushm <I0,I1,I4,I5,M3,L0,L4,L5>;
84200004:	33 d8 01 f1 	pushm <I0, I1, I4, I5, M3, L0, L4, L5>;
    pushm <B0,B4,B5>;
84200008:	00 34 02 f1 	pushm <B0, B4, B5>;
    pushm <FP(=SP),r0,r1,r2,r3,rLink>;
8420000c:	3d 20 00 f1 	pushm <FP(=SP), r0, r1, r2, r3, rLink>;

   LIBS_PUSH_R0_SLOW_SW_ROM_PATCH_POINT($vol_ctrl_update_channel.PATCH_ID_0, r7)

    /* Number of channels */
    r7 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.NUM_CHANNELS_FIELD];
84200010:	5c 00 92 d1 	r7 = M[r0 + 92];
    if LE jump vol_ctrl_apply_volume_abort;
84200014:	72 01 d0 dd 	if LE jump $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_abort;

    // Enable saturate on add/sub
    r4 = M[$ARITHMETIC_MODE];
84200018:	14 e0 60 09 	r4 = Null + M[0xffffe014];
    push r4;
8420001c:	00 00 60 f3 	push r4;
    r4 = r4 OR $ADDSUB_SATURATE_ON_OVERFLOW_MASK;
84200020:	01 00 66 85 	r4 = r4 OR 0x1;
    M[$ARITHMETIC_MODE] = r4;
84200024:	14 e0 60 19 	M[0xffffe014] = r4 + Null;


    /* Update Channel for AUX stream priority.   */
    /* op_extra_data->aux_in_use  = 0; */
    M[r0 + $volume_control_cap._vol_ctrl_data_struct.AUX_IN_USE_FIELD] = NULL;
84200028:	e8 02 02 d5 	M[r0 + 744] = Null;

8420002c <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_next>:
        {
            vol_ctrl_update_channel(op_extra_data,&op_extra_data->channels[i],op_extra_data->lpvols,&volume_tc);
        }
    */
vol_ctrl_update_channel_next:
    push r7;
8420002c:	00 00 90 f3 	push r7;
// r1: vol_ctrl_channel_t   *chan_ptr
// r2: vol_ctrl_gains_t     *volptr
// r3: vol_time_constants_t *lpvcs


    r4 = 1.0;
84200030:	ff 7f 00 fd 	r4 = Null + 2147483647;
84200034:	ff ff 60 01 
    M[r1 + $volume_control_cap.vol_ctrl_channel_struct.LIMITER_GAIN_LINEAR_FIELD]=r4;
84200038:	10 00 63 d5 	M[r1 + 16] = r4;
    // chan_idx
    r4 = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.CHAN_IDX_FIELD];
8420003c:	00 00 63 d1 	r4 = M[r1 + 0];
    // target_vol (r5) = volptr->master_gain;
    r5 = M[r2 + $volume_control_cap.vol_ctrl_gains_struct.MASTER_GAIN_FIELD];
84200040:	00 00 74 d1 	r5 = M[r2 + 0];
    // channel_trim (r6) = volptr->channel_trims[chan_ptr->chan_idx];
    r6 = r4 * ADDR_PER_WORD (int);
84200044:	04 00 86 99 	r6 = r4 * 4 (int);
    r6 = r6 + $volume_control_cap.vol_ctrl_gains_struct.CHANNEL_TRIMS_FIELD;
84200048:	28 00 88 01 	r6 = r6 + 40;
    r6 = M[r2 + r6];
8420004c:	8f 00 84 d0 	r6 = M[r2 + r6];
    // chan_params (r7) = (vol_ctrl_chan_params_t*)&op_extra_data->parameters.OFFSET_CHAN1_AUX_ROUTE;
    // aux_routing (r9) = chan_params[chan_ptr->chan_idx].aux_routing;
    r8 = r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD + $volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_CHAN1_AUX_ROUTE_FIELD);
84200050:	f4 01 a2 01 	r8 = r0 + 500;
    r7 = r4 * ($volume_control_cap.vol_ctrl_chan_params_struct.STRUC_SIZE * ADDR_PER_WORD) (int);
84200054:	14 00 96 99 	r7 = r4 * 20 (int);
    r7 = r7 + r8;
84200058:	00 00 9a 03 	r7 = r7 + r8;
    r9 = M[r7 + $volume_control_cap.vol_ctrl_chan_params_struct.AUX_ROUTING_FIELD];
8420005c:	00 00 b9 d1 	r9 = M[r7 + 0];
    // Pointer (I0) to Channel Aux prim_scale factors
    I0 = r7 + $volume_control_cap.vol_ctrl_chan_params_struct.PRIM_SCALE_FIELD;
84200060:	04 00 09 51 	I0 = r7 + 4;

    // Conditionally add in NDVC adjustment
    NULL = r9 AND $M.VOL_CTRL.CONSTANT.CHAN_NDVC_ENABLE_BIT;
84200064:	10 00 00 fd 	Null = r9 AND 0x100000;
84200068:	00 00 0b 81 
    if Z jump vol_ctrl_update_channel_no_ndvc;
8420006c:	05 00 00 dd 	if EQ jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_no_ndvc;
        r8 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.SHARED_VOLUME_PTR_FIELD];
84200070:	8c 01 a2 d1 	r8 = M[r0 + 396];
        r8 = M[r8 + $volume_control_cap._shared_volume_struct.NDVC_NOISE_LEVEL_FIELD];
84200074:	00 00 aa d1 	r8 = M[r8 + 0];
	    /* NDVC is in 3dB steps */
        r8 = r8 * 180 (int);
84200078:	b4 00 aa 99 	r8 = r8 * 180 (int);
        r6 = r6 + r8;
8420007c:	00 00 8a 03 	r6 = r6 + r8;

84200080 <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_no_ndvc>:
    vol_ctrl_update_channel_no_ndvc:

   /* Bypass Aux */
   NULL = M[r0 + $volume_control_cap._vol_ctrl_data_struct.AUX_ACTIVE_FIELD];
84200080:	e0 02 02 d1 	Null = M[r0 + 736];
   if Z r9 = NULL;
84200084:	00 00 b0 00 	if EQ r9 = Null + Null;

    // channel_trim -= op_extra_data->post_gain;
    r8 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.POST_GAIN_FIELD];
84200088:	f4 00 a2 d1 	r8 = M[r0 + 244];
    r6 = r6 - r8;
8420008c:	00 00 8a 23 	r6 = r6 - r8;
    // target_vol = dB60toLinearQ5(target_vol+channel_trim);
    r0 = r6 + r5;
84200090:	7f 00 28 00 	r0 = r6 + r5;
    call $_dB60toLinearQ5;
84200094:	03 00 00 fd 	call (m) 0x3473e;
84200098:	3f 47 f0 e1 

    // Update Channel Gain (r0 is target)
    r1 = M[FP + $vol_ctrl.cufp.chan_ptr];
8420009c:	08 00 38 f1 	r1 = M[FP + 0x8];
    r2 = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.CHANNEL_GAIN_FIELD];
842000a0:	18 00 43 d1 	r2 = M[r1 + 24];

    r3 = M[FP + $vol_ctrl.cufp.tc_ptr];
842000a4:	10 00 58 f1 	r3 = M[FP + 0x10];
    r3 = M[r3 + $volume_control_cap.vol_time_constants_struct.VOL_TC_FIELD];
842000a8:	04 00 55 d1 	r3 = M[r3 + 4];

    r8 = r0 - r2;
842000ac:	4f 00 a2 20 	r8 = r0 - r2;
    if Z jump vol_ctrl_update_channel_no_vol_change;
842000b0:	09 00 00 dd 	if EQ jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_no_vol_change;
        r8 = ABS r8;
842000b4:	4f 00 aa e4 	r8 = ABS r8;
        r3 = r2 * r3 (frac);
842000b8:	5f 00 54 94 	r3 = r2 * r3 (frac);
        r3 = r3 + $volume_and_limit.VOLUME_RAMP_OFFSET_CONST;
842000bc:	6e 34 55 01 	r3 = r3 + 13422;
        r3 = MIN r8;
842000c0:	5f 00 5a e4 	r3 = MIN r8;
        Null = r0 - r2;
842000c4:	4f 00 02 20 	Null = r0 - r2;
        if NEG r3 = -r3;
842000c8:	54 00 50 20 	if NEG r3 = Null - r3;
        r2 = r2 + r3;
842000cc:	00 00 45 03 	r2 = r2 + r3;
        M[r1 + $volume_control_cap.vol_ctrl_channel_struct.CHANNEL_GAIN_FIELD] = r2;
842000d0:	18 00 43 d5 	M[r1 + 24] = r2;

842000d4 <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_no_vol_change>:
    vol_ctrl_update_channel_no_vol_change:

     r0 = M[FP + $vol_ctrl.cufp.op_data_ptr];
842000d4:	04 00 28 f1 	r0 = M[FP + 0x4];
     r0 = r0 + $volume_control_cap._vol_ctrl_data_struct.AUX_CHANNEL_FIELD;
842000d8:	6c 00 22 01 	r0 = r0 + 108;

// r9=routing, r1=chan_ptr, I0=prim_scale, r0=aux_chan_ptr, r6=chan_trim, r4=chan_idx

    /* Check each aux in channel priority */
    M[r1 + $volume_control_cap.vol_ctrl_channel_struct.AUX_MIX_GAIN_FIELD]  = NULL;
842000dc:	04 00 03 d5 	M[r1 + 4] = Null;
    M[r1 + $volume_control_cap.vol_ctrl_channel_struct.AUX_BUFFER_FIELD]    = NULL;
842000e0:	20 00 03 d5 	M[r1 + 32] = Null;

842000e4 <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_lp>:

    // while(aux_routing&VOL_CTRL_CONSTANT_AUX_PRIORITY_VALID_BIT)
vol_ctrl_update_channel_aux_prio_lp:
    NULL = r9 AND $M.VOL_CTRL.CONSTANT.AUX_PRIORITY_VALID_BIT;
842000e4:	10 00 0b 81 	Null = r9 AND 0x10;
    if NZ jump vol_ctrl_update_channel_aux_prio_valid;
842000e8:	05 00 10 dd 	if NE jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_valid;
        // There is no AUX
        r2 = $volume_and_limit.OneQ5;
842000ec:	00 08 00 fd 	r2 = Null + 134217728;
842000f0:	00 00 40 01 
        M[r1 + $volume_control_cap.vol_ctrl_channel_struct.PRIM_MIX_GAIN_FIELD]      = r2;
842000f4:	08 00 43 d5 	M[r1 + 8] = r2;
        jump vol_ctrl_update_channel_aux_prio_done;
842000f8:	37 00 f0 dd 	jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_done;

842000fc <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_valid>:
vol_ctrl_update_channel_aux_prio_valid:
        // aux_idx =  aux_routing&VOL_CTRL_CONSTANT_AUX_PRIORITY_CHANNEL_MASK;
        r5 = r9 AND $M.VOL_CTRL.CONSTANT.AUX_PRIORITY_CHANNEL_MASK;
842000fc:	07 00 7b 81 	r5 = r9 AND 0x7;
        // op_extra_data->aux_channel[aux_idx].state
        r8 = r5 * ($volume_control_cap.vol_ctrl_aux_channel_struct.STRUC_SIZE * ADDR_PER_WORD) (int);
84200100:	10 00 a7 99 	r8 = r5 * 16 (int);
        r8 = r8 + r0,   r3=M[I0,M1];    // r3 = prim_scale
84200104:	00 51 a2 02 	r8 = r8 + r0, r3 = M[I0,M1];
        r7 = M[r8 + $volume_control_cap.vol_ctrl_aux_channel_struct.STATE_FIELD];
84200108:	04 00 9a d1 	r7 = M[r8 + 4];
        if NZ jump vol_ctrl_update_channel_aux_prio_found;
8420010c:	03 00 10 dd 	if NE jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_found;
            // NO_AUX, Try Next entry
            r9 = r9 LSHIFT -$M.VOL_CTRL.CONSTANT.AUX_PRIORITY_NUM_BITS;
84200110:	fb 00 bb 8d 	r9 = r9 LSHIFT -5;
            jump vol_ctrl_update_channel_aux_prio_lp;
84200114:	f4 ff f0 dd 	jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_lp;

84200118 <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_found>:
vol_ctrl_update_channel_aux_prio_found:
        NULL = r7 - $volume_control_cap.AUX_STATE_IN_AUX;
84200118:	cf 00 09 e4 	Null = r7 - 2;
        if Z jump vol_ctrl_update_channel_aux_prio_in_aux;
8420011c:	16 00 00 dd 	if EQ jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_in_aux;
    	    r2 = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.PRIM_MIX_GAIN_FIELD];
84200120:	08 00 43 d1 	r2 = M[r1 + 8];

            NULL = r7 - $volume_control_cap.AUX_STATE_END_AUX;
84200124:	03 00 09 21 	Null = r7 - 3;
            if NZ jump vol_ctrl_update_channel_aux_prio_transition;
84200128:	0d 00 10 dd 	if NE jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_transition;
                // Leaving AUX mix,  see if a lower priority aux is pending
                r3 = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.PRIM_MIX_GAIN_FIELD];
8420012c:	08 00 53 d1 	r3 = M[r1 + 8];

84200130 <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_prev_lp>:
                vol_ctrl_update_channel_aux_prio_prev_lp:
                    r9 = r9 LSHIFT -$M.VOL_CTRL.CONSTANT.AUX_PRIORITY_NUM_BITS;
84200130:	fb 00 bb 8d 	r9 = r9 LSHIFT -5;
                    NULL = r9 AND $M.VOL_CTRL.CONSTANT.AUX_PRIORITY_VALID_BIT;
84200134:	10 00 0b 81 	Null = r9 AND 0x10;
                    if Z jump vol_ctrl_update_channel_aux_prio_prev_none;
84200138:	07 00 00 dd 	if EQ jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_prev_none;
                        r5 = r9 AND $M.VOL_CTRL.CONSTANT.AUX_PRIORITY_CHANNEL_MASK;
8420013c:	07 00 7b 81 	r5 = r9 AND 0x7;
                        r5 = r5 * ($volume_control_cap.vol_ctrl_aux_channel_struct.STRUC_SIZE * ADDR_PER_WORD) (int);
84200140:	10 00 77 99 	r5 = r5 * 16 (int);
                        r5 = r5 + r0,   r2=M[I0,M1];    // r3 = prim_scale
84200144:	00 41 72 02 	r5 = r5 + r0, r2 = M[I0,M1];
                        r7 = M[r5 + $volume_control_cap.vol_ctrl_aux_channel_struct.STATE_FIELD];
84200148:	04 00 97 d1 	r7 = M[r5 + 4];
                        if Z jump vol_ctrl_update_channel_aux_prio_prev_lp;
8420014c:	f9 ff 00 dd 	if EQ jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_prev_lp;
                        jump vol_ctrl_update_channel_aux_prio_transition;
84200150:	03 00 f0 dd 	jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_transition;

84200154 <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_prev_none>:
                vol_ctrl_update_channel_aux_prio_prev_none:
                r2 = $volume_and_limit.OneQ5;
84200154:	00 08 00 fd 	r2 = Null + 134217728;
84200158:	00 00 40 01 

8420015c <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_transition>:

            vol_ctrl_update_channel_aux_prio_transition:
            // transition = op_extra_data->aux_channel[aux_idx].transition;
            r7 = M[r8 + $volume_control_cap.vol_ctrl_aux_channel_struct.TRANSITION_FIELD];
8420015c:	08 00 9a d1 	r7 = M[r8 + 8];
            // chan_ptr->prim_mix_gain = (MAXINT-transition)*Q5.xx + chan_params->prim_scale[chan_ptr->chan_idx]*transition;
            rMAC = r2;              // r2=1.0  Q5.xx
84200160:	0f 00 14 00 	rMAC = r2 + Null;
            rmAC = rMAC - r7*r2;
84200164:	4f 00 19 bc 	rMAC = rMAC - r7 * r2 (SS);
            rMAC = rMAC + r7*r3;
84200168:	5f 00 19 ac 	rMAC = rMAC + r7 * r3 (SS);
            M[r1 + $volume_control_cap.vol_ctrl_channel_struct.PRIM_MIX_GAIN_FIELD] = rMAC;
8420016c:	08 00 13 d5 	M[r1 + 8] = rMAC;
            jump vol_ctrl_update_channel_aux_prio_done;
84200170:	19 00 f0 dd 	jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_done;

84200174 <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_in_aux>:
        vol_ctrl_update_channel_aux_prio_in_aux:
            // Transition is complete, in aux
            M[r1 + $volume_control_cap.vol_ctrl_channel_struct.PRIM_MIX_GAIN_FIELD] = r3;
84200174:	08 00 53 d5 	M[r1 + 8] = r3;

            // Check if aux mix not muted
            NULL = r9 AND $M.VOL_CTRL.CONSTANT.AUX_PRIORITY_MUTE_BIT;
84200178:	08 00 0b 81 	Null = r9 AND 0x8;
            if NZ jump vol_ctrl_update_channel_aux_prio_done;
8420017c:	16 00 10 dd 	if NE jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_done;
            // chan_ptr->aux_buffer       = op_extra_data->aux_channel[aux_idx].buffer;
            r7 = M[r8 + $volume_control_cap.vol_ctrl_aux_channel_struct.BUFFER_FIELD];
84200180:	00 00 9a d1 	r7 = M[r8 + 0];
            M[r1 + $volume_control_cap.vol_ctrl_channel_struct.AUX_BUFFER_FIELD] = r7;
84200184:	20 00 93 d5 	M[r1 + 32] = r7;

            // r5=aux_idx, r1=chan_ptr, r6=chan_trim, r4 = chan_idx
            r0 = M[FP+$vol_ctrl.cufp.op_data_ptr];
84200188:	04 00 28 f1 	r0 = M[FP + 0x4];

            // aux_in_use |= (1<<aux_idx);
            r2 = 1 LSHIFT r5;
8420018c:	01 00 47 e9 	r2 = 0x1 LSHIFT r5;
            r3 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.AUX_IN_USE_FIELD];
84200190:	e8 02 52 d1 	r3 = M[r0 + 744];
            r3 = r3 OR r2;
84200194:	00 00 54 87 	r3 = r3 OR r2;
            M[r0 + $volume_control_cap._vol_ctrl_data_struct.AUX_IN_USE_FIELD]=r3;
84200198:	e8 02 52 d5 	M[r0 + 744] = r3;

            // aux_params = (vol_ctrl_aux_params_t*)&op_extra_data->parameters.OFFSET_AUX1_SCALE;
            // aux_volume = aux_params[aux_idx].aux_scale;
            r0 = M[FP+$vol_ctrl.cufp.op_data_ptr];
8420019c:	04 00 28 f1 	r0 = M[FP + 0x4];
            r0 = r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD+$volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_AUX1_SCALE_FIELD);
842001a0:	94 01 22 01 	r0 = r0 + 404;
            r2 = r5 * ($volume_control_cap.vol_ctrl_aux_params_struct.STRUC_SIZE * ADDR_PER_WORD) (int);
842001a4:	0c 00 47 99 	r2 = r5 * 12 (int);
            r0 = M[r0 + r2];
842001a8:	00 00 24 d3 	r0 = M[r0 + r2];
            // aux_volume += op_extra_data->lpvols->auxiliary_gain[aux_idx];
            r3 = M[FP + $vol_ctrl.cufp.vol_ptr];
842001ac:	0c 00 58 f1 	r3 = M[FP + 0xc];
            r2 = r5 * ADDR_PER_WORD (int);
842001b0:	04 00 47 99 	r2 = r5 * 4 (int);
            r3 = r3 + r2;
842001b4:	00 00 54 03 	r3 = r3 + r2;
            r3 = M[r3 + $volume_control_cap.vol_ctrl_gains_struct.AUXILIARY_GAIN_FIELD];
842001b8:	08 00 55 d1 	r3 = M[r3 + 8];
            r0 = r0 + r3;
842001bc:	00 00 25 03 	r0 = r0 + r3;
            // chan_ptr->aux_mix_gain  = dB60toLinearQ5(aux_volume+channel_trim);
            r0 = r0 + r6;
842001c0:	00 00 28 03 	r0 = r0 + r6;
            call $_dB60toLinearQ5;
842001c4:	03 00 00 fd 	call (m) 0x3473e;
842001c8:	3f 47 f0 e1 
            r1 = M[FP + $vol_ctrl.cufp.chan_ptr];
842001cc:	08 00 38 f1 	r1 = M[FP + 0x8];
            M[r1 + $volume_control_cap.vol_ctrl_channel_struct.AUX_MIX_GAIN_FIELD]  = r0;
842001d0:	04 00 23 d5 	M[r1 + 4] = r0;

842001d4 <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_aux_prio_done>:

vol_ctrl_update_channel_aux_prio_done:

    r0 = M[FP + $vol_ctrl.cufp.op_data_ptr];
842001d4:	04 00 28 f1 	r0 = M[FP + 0x4];

    // r4=chan_idx, r0=op_data_ptr

    // limiter_attn = 0;
    r5 = NULL;
842001d8:	0f 00 70 00 	r5 = Null + Null;

    r1 = M[r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD+$volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_CONFIG_FIELD)];
842001dc:	90 01 32 d1 	r1 = M[r0 + 400];
    NULL = r1 AND $M.VOL_CTRL.CONFIG.SATURATEENA;
842001e0:	02 00 03 81 	Null = r1 AND 0x2;
    if Z jump vol_ctrl_update_channel_sat_done;
842001e4:	29 00 00 dd 	if EQ jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_sat_done;
    r7 = M[FP + $vol_ctrl.cufp.chan_ptr];
842001e8:	08 00 98 f1 	r7 = M[FP + 0x8];
    r8 = M[r7 + $volume_control_cap.vol_ctrl_channel_struct.CHANNEL_GAIN_FIELD];
842001ec:	18 00 a9 d1 	r8 = M[r7 + 24];
    NULL = r8 - $volume_and_limit.MIN_POSITIVE_VOLUME;
842001f0:	00 08 00 fd 	Null = r8 - 134217728;
842001f4:	00 00 0a 21 
    if LE jump vol_ctrl_update_channel_sat_done;
842001f8:	24 00 d0 dd 	if LE jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_sat_done;

        // Get Data Buffer
        r6 = r4 * ADDR_PER_WORD (int);
842001fc:	04 00 86 99 	r6 = r4 * 4 (int);
        r6 = r6 + $volume_control_cap._vol_ctrl_data_struct.INPUT_BUFFER_FIELD;
84200200:	00 00 88 01 	r6 = r6 + 0;
        r0 = M[r0 + r6];
84200204:	00 00 28 d3 	r0 = M[r0 + r6];
        call $cbuffer.get_read_address_and_size_and_start_address;
84200208:	03 00 00 fd 	call (m) 0x34cea;
8420020c:	eb 4c f0 e1 
        I0 = r0;
84200210:	2f 00 00 50 	I0 = Null + r0;
        L0 = r1;
84200214:	3f 00 c0 50 	L0 = Null + r1;
        push r2;
84200218:	00 00 40 f3 	push r2;
        pop B0;
8420021c:	00 00 a6 f3 	pop B0;

        // Compute Peak
        r3 = M[FP + $vol_ctrl.cufp.tc_ptr];
84200220:	10 00 58 f1 	r3 = M[FP + 0x10];
        r10 = M[r3+$volume_control_cap.vol_time_constants_struct.NUM_WORDS_FIELD];
84200224:	00 00 c5 d1 	r10 = M[r3 + 0];
        r2 = M[r3+$volume_control_cap.vol_time_constants_struct.SAT_TCP5_FIELD];
84200228:	0c 00 45 d1 	r2 = M[r3 + 12];
        r3 = M[r7 + $volume_control_cap.vol_ctrl_channel_struct.LAST_PEAK_FIELD];
8420022c:	14 00 59 d1 	r3 = M[r7 + 20];
        r10 = r10 - 1;
84200230:	3f 00 cc e4 	r10 = r10 - 1;
        // Use history for peak but decay it based on num samples
        r3 = r3 * r2 (frac), r2=M[I0,M1];
84200234:	00 41 54 96 	r3 = r3 * r2 (frac), r2 = M[I0,M1];
        do vol_ctrl_update_channel_peak_lp;
84200238:	03 00 f0 e5 	do $M.vol_ctrl_update_channel.vol_ctrl_update_channel_peak_lp;
            r2 = ABS r2;
8420023c:	4f 00 44 e4 	r2 = ABS r2;
            r3 = MAX r2, r2=M[I0,M1];
84200240:	6f 41 54 e4 	r3 = MAX r2, r2 = M[I0,M1];

84200244 <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_peak_lp>:
        vol_ctrl_update_channel_peak_lp:
        r2 = ABS r2;
84200244:	4f 00 44 e4 	r2 = ABS r2;
        r3 = MAX r2;
84200248:	6f 00 54 e4 	r3 = MAX r2;
        M[r7 + $volume_control_cap.vol_ctrl_channel_struct.LAST_PEAK_FIELD]=r3;
8420024c:	14 00 59 d5 	M[r7 + 20] = r3;

        // max_abs = MAX(ABS(channel data)) * chan_ptr->channel_gain;
        rMAC = r3 * r8;
84200250:	af 00 15 cc 	rMAC = r3 * r8 (SS);

        r0 = M[FP + $vol_ctrl.cufp.op_data_ptr];
84200254:	04 00 28 f1 	r0 = M[FP + 0x4];
        r1 = M[r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD + $volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_LIMIT_THRESHOLD_LINEAR_FIELD)];
84200258:	a4 02 32 d1 	r1 = M[r0 + 676];
        NULL = rMAC - r1;
8420025c:	3f 00 01 20 	Null = rMAC - r1;
        if NEG jump vol_ctrl_update_channel_sat_done;
84200260:	0a 00 40 dd 	if NEG jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_sat_done;

        r7 = M[r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD + $volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_LIMIT_ADAPTATION_RATIO_FIELD)];
84200264:	a8 02 92 d1 	r7 = M[r0 + 680];
        r9 = M[r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD + $volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_LIMIT_THRESHOLD_LOG_FIELD)];
84200268:	ac 02 b2 d1 	r9 = M[r0 + 684];

        // limiter_attn = (LIMIT_THRESHOLD - log2(max_abs)) * LIMIT_RATIO;
        call $math.log2_table;
8420026c:	06 00 00 fd 	call 0x654a0;
84200270:	a0 54 f0 e1 
        /* Input to log was Q5.xx,  need to adjust to Q1.xx */
        r0 = r0 + (4<<(DAWTH-8));
84200274:	00 04 00 fd 	r0 = r0 + 67108864;
84200278:	00 00 22 01 
        r9 = r9 - r0;
8420027c:	00 00 b2 23 	r9 = r9 - r0;
        r5 = r9 * r7 (frac);
84200280:	9f 00 7b 94 	r5 = r9 * r7 (frac);
        if POS r5=NULL;
84200284:	05 00 70 00 	if POS r5 = Null + Null;

84200288 <$M.vol_ctrl_update_channel.vol_ctrl_update_channel_sat_done>:
vol_ctrl_update_channel_sat_done:

    // Time constants are scaled based on num samples
    r1 = M[FP+$vol_ctrl.cufp.chan_ptr];
84200288:	08 00 38 f1 	r1 = M[FP + 0x8];
    r2 = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.LIMIT_GAIN_LOG2_FIELD];
8420028c:	0c 00 43 d1 	r2 = M[r1 + 12];
    r3 = M[FP + $vol_ctrl.cufp.tc_ptr];
84200290:	10 00 58 f1 	r3 = M[FP + 0x10];
    r4 = M[r3 + $volume_control_cap.vol_time_constants_struct.SAT_TC_FIELD];
84200294:	08 00 65 d1 	r4 = M[r3 + 8];
    r3 = M[r3 + $volume_control_cap.vol_time_constants_struct.SAT_TCP5_FIELD];
84200298:	0c 00 55 d1 	r3 = M[r3 + 12];
    NULL = r5 - r2;
8420029c:	4f 00 07 20 	Null = r5 - r2;
    if POS r3 = r4;
842002a0:	05 00 56 00 	if POS r3 = r4 + Null;

    // chan_ptr->limit_gain_log2 = (1.0 - tc)*limiter_attn + tc*chan_ptr->limit_gain_log2;
    // chan_ptr->limit_gain_log2 = MIN(chan_ptr->limit_gain_log2,0);
    rMAC = r5;
842002a4:	0f 00 17 00 	rMAC = r5 + Null;
    rMAC = rMAC - r3*r5;
842002a8:	7f 00 15 bc 	rMAC = rMAC - r3 * r5 (SS);
    rMAC = rMAC + r3*r2;
842002ac:	4f 00 15 ac 	rMAC = rMAC + r3 * r2 (SS);
    if POS rMAC = NULL;
842002b0:	05 00 10 00 	if POS rMAC = Null + Null;

    r3 = r5 - rMAC;
842002b4:	1f 00 57 20 	r3 = r5 - rMAC;
    r3 = ABS r3;
842002b8:	4f 00 55 e4 	r3 = ABS r3;
    NULL = r3 - 0.00001;
842002bc:	e3 53 05 21 	Null = r3 - 21475;
    if LE rMAC = r5;
842002c0:	0d 00 17 00 	if LE rMAC = r5 + Null;

    M[r1 + $volume_control_cap.vol_ctrl_channel_struct.LIMIT_GAIN_LOG2_FIELD]=rMAC;
842002c4:	0c 00 13 d5 	M[r1 + 12] = rMAC;

    // r1 = chan_ptr

    L0 = NULL;
842002c8:	0f 00 c0 50 	L0 = Null + Null;
    push NULL;
842002cc:	00 00 00 f3 	push Null;
    pop B0;
842002d0:	00 00 a6 f3 	pop B0;

    /* channel count */
    pop r7;
842002d4:	00 00 94 f3 	pop r7;

    /* advance channel */
    r1 = r1 + ($volume_control_cap.vol_ctrl_channel_struct.STRUC_SIZE*ADDR_PER_WORD);
842002d8:	24 00 33 01 	r1 = r1 + 36;
    M[FP + $vol_ctrl.cufp.chan_ptr] = r1;
842002dc:	08 00 3c f1 	M[FP + 0x8] = r1;

    /* restore data */
    r0 = M[FP + $vol_ctrl.cufp.op_data_ptr];
842002e0:	04 00 28 f1 	r0 = M[FP + 0x4];
    r2 = M[FP + $vol_ctrl.cufp.vol_ptr];
842002e4:	0c 00 48 f1 	r2 = M[FP + 0xc];

    /* Another channel ? */
    r7 = r7 - 1;
842002e8:	3f 00 99 e4 	r7 = r7 - 1;
    if GT jump vol_ctrl_update_channel_next;
842002ec:	50 ff c0 dd 	if GT jump $M.vol_ctrl_update_channel.vol_ctrl_update_channel_next;

842002f0 <$_vol_ctrl_update_saturation>:
//    Function is C compatible
//
// *****************************************************************************
$_vol_ctrl_update_saturation:
    /* Saturation protection may be per channel or across all channels */
    r1 = M[r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD + $volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_CONFIG_FIELD)];
842002f0:	90 01 32 d1 	r1 = M[r0 + 400];
    NULL = r1 AND $M.VOL_CTRL.CONFIG.SATURATEENA;
842002f4:	02 00 03 81 	Null = r1 AND 0x2;
    if Z jump vol_ctrl_update_saturation_done;
842002f8:	1a 00 00 dd 	if EQ jump $M.vol_ctrl_update_channel.vol_ctrl_update_saturation_conv_lp;

        r2 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.CHANNELS_FIELD];
842002fc:	68 00 42 d1 	r2 = M[r0 + 104];
        r10 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.NUM_CHANNELS_FIELD];
84200300:	5c 00 c2 d1 	r10 = M[r0 + 92];
        M3 = ($volume_control_cap.vol_ctrl_channel_struct.STRUC_SIZE * ADDR_PER_WORD);
84200304:	24 00 b0 51 	M3 = Null + 36;
        I0 = r2 + $volume_control_cap.vol_ctrl_channel_struct.LIMIT_GAIN_LOG2_FIELD;
84200308:	0c 00 04 51 	I0 = r2 + 12;
        I1 = r2 + $volume_control_cap.vol_ctrl_channel_struct.LIMITER_GAIN_LINEAR_FIELD;
8420030c:	10 00 14 51 	I1 = r2 + 16;

        NULL = r1 AND $M.VOL_CTRL.CONFIG.SATURATESYNCENA;
84200310:	04 00 03 81 	Null = r1 AND 0x4;
        if Z jump vol_ctrl_update_saturation_not_sync;
84200314:	0e 00 00 dd 	if EQ jump $M.vol_ctrl_update_channel.vol_ctrl_update_saturation_not_sync;
            // Min log gain of channels
            push r10,    r1 = M[I0,M3];
84200318:	00 33 c0 f2 	push r10, r1 = M[I0,M3];
            r10 = r10 - 1;
8420031c:	3f 00 cc e4 	r10 = r10 - 1;
            r0  = r1;
84200320:	0f 00 23 00 	r0 = r1 + Null;
            do vol_ctrl_update_saturation_min_lp;
84200324:	02 00 f0 e5 	do $M.vol_ctrl_update_channel.vol_ctrl_update_saturation_min_lp;
                r0 = MIN r1, r1 = M[I0,M3];
84200328:	5f 33 23 e4 	r0 = MIN r1, r1 = M[I0,M3];

8420032c <$M.vol_ctrl_update_channel.vol_ctrl_update_saturation_min_lp>:
            vol_ctrl_update_saturation_min_lp:
            r0 = MIN r1;
8420032c:	5f 00 23 e4 	r0 = MIN r1;
            // Convert to linear
            call $math.pow2_table;
84200330:	06 00 00 fd 	call 0x65408;
84200334:	08 54 f0 e1 
            // Apply to all channels
            pop r10;
84200338:	00 00 c4 f3 	pop r10;
            // Nops ensures pipeline for setting r10
            nop;
8420033c:	00 00 00 03 	Null = Null + Null;
            do vol_ctrl_update_saturation_apply_lp;
84200340:	02 00 f0 e5 	do $M.vol_ctrl_update_channel.vol_ctrl_update_saturation_apply_lp;
                M[I1,M3]=r0;
84200344:	00 a7 00 02 	Null = Null + Null, M[I1,M3] = r0;

84200348 <$M.vol_ctrl_update_channel.vol_ctrl_update_saturation_apply_lp>:
            vol_ctrl_update_saturation_apply_lp:
            jump vol_ctrl_update_saturation_done;
84200348:	06 00 f0 dd 	jump $M.vol_ctrl_update_channel.vol_ctrl_update_saturation_conv_lp;

8420034c <$M.vol_ctrl_update_channel.vol_ctrl_update_saturation_not_sync>:

        vol_ctrl_update_saturation_not_sync:
            // Convert to linear
            do vol_ctrl_update_saturation_conv_lp;
8420034c:	05 00 f0 e5 	do $M.vol_ctrl_update_channel.vol_ctrl_update_saturation_conv_lp;
                r0 = M[I0,M3];
84200350:	00 23 00 02 	Null = Null + Null, r0 = M[I0,M3];
                call $math.pow2_table;
84200354:	06 00 00 fd 	call 0x65408;
84200358:	08 54 f0 e1 
                M[I1,M3]=r0;
8420035c:	00 a7 00 02 	Null = Null + Null, M[I1,M3] = r0;

84200360 <$M.vol_ctrl_update_channel.vol_ctrl_update_saturation_conv_lp>:
           vol_ctrl_apply_volume(op_extra_data,&op_extra_data->channels[i],&volume_tc);
       }
   */
$_vol_ctrl_apply_volume:

    r0 = M[FP + $vol_ctrl.cufp.op_data_ptr];
84200360:	04 00 28 f1 	r0 = M[FP + 0x4];

    /* Number of channels */
    r7 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.NUM_CHANNELS_FIELD];
84200364:	5c 00 92 d1 	r7 = M[r0 + 92];

    // Reset chan_ptr
    r1 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.CHANNELS_FIELD];
84200368:	68 00 32 d1 	r1 = M[r0 + 104];
    M[FP + $vol_ctrl.cuup.chan_ptr]=r1;
8420036c:	08 00 3c f1 	M[FP + 0x8] = r1;

    // Move time constants */
    r2 = M[FP + $vol_ctrl.cufp.tc_ptr];
84200370:	10 00 48 f1 	r2 = M[FP + 0x10];
    M[FP + $vol_ctrl.cuup.tc_ptr] = r2;
84200374:	0c 00 4c f1 	M[FP + 0xc] = r2;

84200378 <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_next>:
    // r0: VOL_CTRL_DATA_T *op_extra_data
    // r1: vol_ctrl_channel_t *chan_ptr
    // r2: vol_time_constants_t *lpvcs

vol_ctrl_apply_volume_next:
    push r7;
84200378:	00 00 90 f3 	push r7;
    // r0: VOL_CTRL_DATA_T *op_extra_data
    // r1: vol_ctrl_channel_t *chan_ptr
    // r2: vol_time_constants_t *lpvcs

    // r3: routing
    r7 = r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD + $volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_CHAN1_AUX_ROUTE_FIELD);
8420037c:	f4 01 92 01 	r7 = r0 + 500;
    r6 = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.CHAN_IDX_FIELD];
84200380:	00 00 83 d1 	r6 = M[r1 + 0];
    r6 = r6  * ($volume_control_cap.vol_ctrl_chan_params_struct.STRUC_SIZE * ADDR_PER_WORD) (int);
84200384:	14 00 88 99 	r6 = r6 * 20 (int);
    r3 = M[r7+r6];
84200388:	8f 00 59 d0 	r3 = M[r7 + r6];

    // Boost
    r8 = $volume_and_limit.OneQ5;
8420038c:	00 08 00 fd 	r8 = Null + 134217728;
84200390:	00 00 a0 01 
    r5  = M[r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD + $volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_BOOST_FIELD)];
84200394:	9c 02 72 d1 	r5 = M[r0 + 668];
    NULL = r3 AND $M.VOL_CTRL.CONSTANT.CHAN_BOOST_CLIP_ENABLE_BIT;
84200398:	20 00 00 fd 	Null = r3 AND 0x200000;
8420039c:	00 00 05 81 
    if Z r5 = r8;
842003a0:	00 00 7a 00 	if EQ r5 = r8 + Null;

    // Gains
    r9  = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.CHANNEL_GAIN_FIELD];        // Q5.xx
842003a4:	18 00 b3 d1 	r9 = M[r1 + 24];
    r10 = M[r2 + $volume_control_cap.vol_time_constants_struct.NUM_WORDS_FIELD];
842003a8:	00 00 c4 d1 	r10 = M[r2 + 0];
    r7  = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.PRIM_MIX_GAIN_FIELD];       // Q5.xx
842003ac:	08 00 93 d1 	r7 = M[r1 + 8];
    r6  = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.LIMITER_GAIN_LINEAR_FIELD]; // Q.xx
842003b0:	10 00 83 d1 	r6 = M[r1 + 16];

    // calculate init and final volume for this frame
    rMAC = r9 * r6;
842003b4:	8f 00 1b cc 	rMAC = r9 * r6 (SS);
    rMAC = rMAC * r7;
842003b8:	9f 00 11 cc 	rMAC = rMAC * r7 (SS);
    rMAC = rMAC ASHIFT 4 (56bit);
842003bc:	04 00 11 91 	rMAC = rMAC ASHIFT 4 (56bit);
    rMAC = rMAC * r5;
842003c0:	7f 00 11 cc 	rMAC = rMAC * r5 (SS);
    rMAC = rMAC ASHIFT 4 (56bit);  // Boost
842003c4:	04 00 11 91 	rMAC = rMAC ASHIFT 4 (56bit);

    // Compute the volume step size
    r4  = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.LAST_VOLUME_FIELD];         // Q5.xx
842003c8:	1c 00 63 d1 	r4 = M[r1 + 28];
    r2 = rMAC - r4;
842003cc:	6f 00 41 20 	r2 = rMAC - r4;
    rMAC = r2 ASHIFT 0 (LO);
842003d0:	00 01 e4 91 	rMAC = r2 ASHIFT 0 (LO);
    Div = rMAC / r10;
842003d4:	00 00 1c d9 	Div = rMAC / r10;

    // Aux Mix
    r8  = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.AUX_MIX_GAIN_FIELD];        // Q5.xx
842003d8:	04 00 a3 d1 	r8 = M[r1 + 4];
    rMAC = r8 * r5;
842003dc:	7f 00 1a cc 	rMAC = r8 * r5 (SS);
    r8 = rMAC ASHIFT 4;  // Boost
842003e0:	04 00 a1 91 	r8 = rMAC ASHIFT 4;

    /* Adjust Clip Point
       (might as well do it even if we don't use it, divide takes time anyway) */
    r5 = M[r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD + $volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_CLIP_POINT_FIELD)];
842003e4:	94 02 72 d1 	r5 = M[r0 + 660];
    r2 = M[r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD + $volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_BOOST_CLIP_POINT_FIELD)];
842003e8:	98 02 42 d1 	r2 = M[r0 + 664];
    // Multiply the Clip Point (r5) with the Inverse Post Gain (r7)
    r7 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.SHARED_VOLUME_PTR_FIELD];
842003ec:	8c 01 92 d1 	r7 = M[r0 + 396];
    r7 = M[r7 + $volume_control_cap._shared_volume_struct.INV_POST_GAIN_FIELD];
842003f0:	0c 00 99 d1 	r7 = M[r7 + 12];
    // The inverse DAC gain is Q5.xx, so we need to shift r7 to get Q1.xx
    rMAC = r5 * r7;
842003f4:	9f 00 17 cc 	rMAC = r5 * r7 (SS);
    r7 = rMAC ASHIFT 4;
842003f8:	04 00 91 91 	r7 = rMAC ASHIFT 4;
    // limit the clipper threshold so DAC wrap bug doesn't occur
    Null = r7 - r2;
842003fc:	4f 00 09 20 	Null = r7 - r2;
    if POS r7 = r2;
84200400:	05 00 94 00 	if POS r7 = r2 + Null;

    // Step for main volume
    r5 = DivResult;
84200404:	01 00 70 d9 	r5 = DivResult;

    // Setup Buffers
    pushm <r3,r10>;
84200408:	20 10 00 f1 	pushm <r3, r10>;

    r1 = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.CHAN_IDX_FIELD];
8420040c:	00 00 33 d1 	r1 = M[r1 + 0];
    r1 = r1 * ADDR_PER_WORD (int);
84200410:	04 00 33 99 	r1 = r1 * 4 (int);
    r0 = r0 + r1;
84200414:	00 00 23 03 	r0 = r0 + r1;
    push r0;
84200418:	00 00 20 f3 	push r0;
    r0 = M[r0];
8420041c:	00 00 20 d3 	r0 = M[r0 + Null];
    call $cbuffer.get_read_address_and_size_and_start_address;
84200420:	03 00 00 fd 	call (m) 0x34cea;
84200424:	eb 4c f0 e1 
    I0 = r0;
84200428:	2f 00 00 50 	I0 = Null + r0;
    push r2;
8420042c:	00 00 40 f3 	push r2;
    pop  B0;
84200430:	00 00 a6 f3 	pop B0;
    L0 = r1;
84200434:	3f 00 c0 50 	L0 = Null + r1;

    pop r0;
84200438:	00 00 24 f3 	pop r0;
    r0 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.OUTPUT_BUFFER_FIELD];
8420043c:	20 00 22 d1 	r0 = M[r0 + 32];
    call $cbuffer.get_write_address_and_size_and_start_address;
84200440:	03 00 00 fd 	call (m) 0x34d20;
84200444:	21 4d f0 e1 
    I5 = r0;
84200448:	2f 00 50 50 	I5 = Null + r0;
    push r2;
8420044c:	00 00 40 f3 	push r2;
    pop B5;
84200450:	00 00 d6 f3 	pop B5;
    L5 = r1;
84200454:	3f 00 f0 50 	L5 = Null + r1;

    r1 = M[FP + $vol_ctrl.cuup.chan_ptr];
84200458:	08 00 38 f1 	r1 = M[FP + 0x8];
    r0 = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.AUX_BUFFER_FIELD];
8420045c:	20 00 23 d1 	r0 = M[r1 + 32];
    if NZ jump vol_ctrl_apply_volume_get_aux;
84200460:	06 00 10 dd 	if NE jump $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_get_aux;
        r0 = FP + $vol_ctrl.cuup.dummy;
84200464:	10 00 27 f1 	r0 = FP + 16;
        r1 = ADDR_PER_WORD;
84200468:	bf 00 30 e4 	r1 = Null + 4;
        r2 = r0;
8420046c:	0f 00 42 00 	r2 = r0 + Null;
        r8 = NULL;
84200470:	0f 00 a0 00 	r8 = Null + Null;
        jump vol_ctrl_apply_volume_get_aux_ok;
84200474:	03 00 f0 dd 	jump $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_get_aux_ok;

84200478 <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_get_aux>:
    vol_ctrl_apply_volume_get_aux:
        call $cbuffer.get_read_address_and_size_and_start_address;
84200478:	03 00 00 fd 	call (m) 0x34cea;
8420047c:	eb 4c f0 e1 

84200480 <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_get_aux_ok>:
  vol_ctrl_apply_volume_get_aux_ok:
    // Set Aux pointer
    I4 = r0;
84200480:	2f 00 40 50 	I4 = Null + r0;
    push r2;
84200484:	00 00 40 f3 	push r2;
    pop B4;
84200488:	00 00 c6 f3 	pop B4;
    L4 = r1;
8420048c:	3f 00 e0 50 	L4 = Null + r1;

    popm <r3,r10>;
84200490:	20 10 04 f1 	popm <r3, r10>;
    // r7=clip, r4=main gain, r8=aux gain, r3=routing, r10 = amount

    /* Check Mute */
    r0 = M[FP + $vol_ctrl.cuup.op_data_ptr];
84200494:	04 00 28 f1 	r0 = M[FP + 0x4];
    r6 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.CUR_MUTE_GAIN_FIELD];
84200498:	04 03 82 d1 	r6 = M[r0 + 772];
    r9 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.MUTE_INCREMENT_FIELD];
8420049c:	08 03 b2 d1 	r9 = M[r0 + 776];
    if NZ jump vol_ctrl_apply_volume_mute;
842004a0:	16 00 10 dd 	if NE jump $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_mute;

    NULL = r3 AND $M.VOL_CTRL.CONSTANT.CHAN_BOOST_CLIP_ENABLE_BIT;
842004a4:	20 00 00 fd 	Null = r3 AND 0x200000;
842004a8:	00 00 05 81 
    if NZ jump vol_ctrl_apply_volume_clip;
842004ac:	08 00 10 dd 	if NE jump $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip;
        do vol_ctrl_apply_volume_lp;
842004b0:	06 00 f0 e5 	do $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_lp;
            r4 = r4 + r5,   r2 = M[I0,MK1];
842004b4:	00 41 67 03 	r4 = r4 + r5, r2 = M[I0,4];
            rMAC = r2 * r4, r2 = M[I4,MK1];
842004b8:	41 00 46 cf 	rMAC = r2 * r4 (SS), r2 = M[I4,4];
            rMAC = rMAC + r2 * r8;
842004bc:	af 00 14 ac 	rMAC = rMAC + r2 * r8 (SS);
            rMAC = rMAC ASHIFT 4 (56bit);
842004c0:	04 00 11 91 	rMAC = rMAC ASHIFT 4 (56bit);
            M[I5,MK1] = rMAC;
842004c4:	95 00 00 03 	Null = Null + Null, M[I5,4] = rMAC;

842004c8 <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_lp>:
        vol_ctrl_apply_volume_lp:
        jump vol_ctrl_apply_volume_done;
842004c8:	26 00 f0 dd 	jump $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip_mute_lp;

842004cc <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip>:

    vol_ctrl_apply_volume_clip:
        do vol_ctrl_apply_volume_clip_lp;
842004cc:	0a 00 f0 e5 	do $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip_lp;
            r4 = r4 + r5,   r2 = M[I0,MK1];
842004d0:	00 41 67 03 	r4 = r4 + r5, r2 = M[I0,4];
            rMAC = r2 * r4, r2 = M[I4,MK1];
842004d4:	41 00 46 cf 	rMAC = r2 * r4 (SS), r2 = M[I4,4];
            rMAC = rMAC + r2 * r8;
842004d8:	af 00 14 ac 	rMAC = rMAC + r2 * r8 (SS);
            rMAC = rMAC ASHIFT 4 (56bit);
842004dc:	04 00 11 91 	rMAC = rMAC ASHIFT 4 (56bit);
            // Hard Clip
            r1 = rMAC ASHIFT (8 + 2 * DAWTH);
842004e0:	48 00 31 91 	r1 = rMAC ASHIFT 72;
            r2 = ABS rMAC;
842004e4:	4f 00 41 e4 	r2 = ABS rMAC;
            r2 = MIN r7;
842004e8:	5f 00 49 e4 	r2 = MIN r7;
            r2 = r2 * r1 (frac);
842004ec:	00 00 43 97 	r2 = r2 * r1 (frac);
            M[I5,MK1] = r2;
842004f0:	c5 00 00 03 	Null = Null + Null, M[I5,4] = r2;

842004f4 <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip_lp>:
        vol_ctrl_apply_volume_clip_lp:
        jump vol_ctrl_apply_volume_done;
842004f4:	1b 00 f0 dd 	jump $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip_mute_lp;

842004f8 <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_mute>:

vol_ctrl_apply_volume_mute:
        NULL = r3 AND $M.VOL_CTRL.CONSTANT.CHAN_BOOST_CLIP_ENABLE_BIT;
842004f8:	20 00 00 fd 	Null = r3 AND 0x200000;
842004fc:	00 00 05 81 
        if NZ jump vol_ctrl_apply_volume_clip_mute;
84200500:	0b 00 10 dd 	if NE jump $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip_mute;

        do vol_ctrl_apply_volume_mute_lp;
84200504:	09 00 f0 e5 	do $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_mute_lp;
            r4 = r4 + r5,   r2 = M[I0,MK1];
84200508:	00 41 67 03 	r4 = r4 + r5, r2 = M[I0,4];
            rMAC = r2 * r4, r2 = M[I4,MK1];
8420050c:	41 00 46 cf 	rMAC = r2 * r4 (SS), r2 = M[I4,4];
            rMAC = rMAC + r2 * r8;
84200510:	af 00 14 ac 	rMAC = rMAC + r2 * r8 (SS);
            rMAC = rMAC ASHIFT 4 (56bit);
84200514:	04 00 11 91 	rMAC = rMAC ASHIFT 4 (56bit);
            // Mute
            r6 = r6 + r9;
84200518:	00 00 8b 03 	r6 = r6 + r9;
            if NEG r6=NULL;
8420051c:	04 00 80 00 	if NEG r6 = Null + Null;
            rMAC = rMAC * r6 (frac);
84200520:	00 00 18 97 	rMAC = rMAC * r6 (frac);
            // Save result
            M[I5,MK1] = rMAC;
84200524:	95 00 00 03 	Null = Null + Null, M[I5,4] = rMAC;

84200528 <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_mute_lp>:
        vol_ctrl_apply_volume_mute_lp:
        jump vol_ctrl_apply_volume_done;
84200528:	0e 00 f0 dd 	jump $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip_mute_lp;

8420052c <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip_mute>:

vol_ctrl_apply_volume_clip_mute:
        do vol_ctrl_apply_volume_clip_mute_lp;
8420052c:	0d 00 f0 e5 	do $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip_mute_lp;
            r4 = r4 + r5,   r2 = M[I0,MK1];
84200530:	00 41 67 03 	r4 = r4 + r5, r2 = M[I0,4];
            rMAC = r2 * r4, r2 = M[I4,MK1];
84200534:	41 00 46 cf 	rMAC = r2 * r4 (SS), r2 = M[I4,4];
            rMAC = rMAC + r2 * r8;
84200538:	af 00 14 ac 	rMAC = rMAC + r2 * r8 (SS);
            rMAC = rMAC ASHIFT 4 (56bit);
8420053c:	04 00 11 91 	rMAC = rMAC ASHIFT 4 (56bit);
            // Hard Clip
            r1 = rMAC ASHIFT (8 + 2 * DAWTH);
84200540:	48 00 31 91 	r1 = rMAC ASHIFT 72;
            r2 = ABS rMAC;
84200544:	4f 00 41 e4 	r2 = ABS rMAC;
            r2 = MIN r7;
84200548:	5f 00 49 e4 	r2 = MIN r7;
            r2 = r2 * r1 (frac);
8420054c:	00 00 43 97 	r2 = r2 * r1 (frac);
            // Mute
            r6 = r6 + r9;
84200550:	00 00 8b 03 	r6 = r6 + r9;
            if NEG r6=NULL;
84200554:	04 00 80 00 	if NEG r6 = Null + Null;
            r2 = r2 * r6 (frac);
84200558:	00 00 48 97 	r2 = r2 * r6 (frac);
            // Save result
            M[I5,MK1] = r2;
8420055c:	c5 00 00 03 	Null = Null + Null, M[I5,4] = r2;

84200560 <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_clip_mute_lp>:
        vol_ctrl_apply_volume_clip_mute_lp:

vol_ctrl_apply_volume_done:

    // Save last gain
    r1 = M[FP +$vol_ctrl.cuup.chan_ptr];
84200560:	08 00 38 f1 	r1 = M[FP + 0x8];
    M[r1 + $volume_control_cap.vol_ctrl_channel_struct.LAST_VOLUME_FIELD] = r4;
84200564:	1c 00 63 d5 	M[r1 + 28] = r4;

    // Update Buffer
    r1 = M[r1 + $volume_control_cap.vol_ctrl_channel_struct.CHAN_IDX_FIELD];
84200568:	00 00 33 d1 	r1 = M[r1 + 0];
    r1 = r1 * ADDR_PER_WORD(int);
8420056c:	04 00 33 99 	r1 = r1 * 4 (int);
    r0 = M[FP + $vol_ctrl.cuup.op_data_ptr];
84200570:	04 00 28 f1 	r0 = M[FP + 0x4];
    r0 = r0 + r1;
84200574:	00 00 23 03 	r0 = r0 + r1;
    push r0;
84200578:	00 00 20 f3 	push r0;
    r0 = M[r0];
8420057c:	00 00 20 d3 	r0 = M[r0 + Null];
    r1 = I0;
84200580:	0f 00 30 44 	r1 = Null + I0;
    call $cbuffer.set_read_address;
84200584:	03 00 00 fd 	call (m) 0x34d56;
84200588:	57 4d f0 e1 
    pop r0;
8420058c:	00 00 24 f3 	pop r0;
    r0 = M[r0 + $volume_control_cap._vol_ctrl_data_struct.OUTPUT_BUFFER_FIELD];
84200590:	20 00 22 d1 	r0 = M[r0 + 32];
    r1 = I5;
84200594:	5f 00 30 44 	r1 = Null + I5;
    call $cbuffer.set_write_address;
84200598:	03 00 00 fd 	call (m) 0x34d90;
8420059c:	91 4d f0 e1 

    /* Next Channel */
    pop r7;
842005a0:	00 00 94 f3 	pop r7;

    /* Restore parameters */
    r0 = M[FP + $vol_ctrl.cuup.op_data_ptr];
842005a4:	04 00 28 f1 	r0 = M[FP + 0x4];
    r1 = M[FP + $vol_ctrl.cuup.chan_ptr];
842005a8:	08 00 38 f1 	r1 = M[FP + 0x8];
    r2 = M[FP + $vol_ctrl.cuup.tc_ptr];
842005ac:	0c 00 48 f1 	r2 = M[FP + 0xc];

    /* advance chan_ptr */
    r1 = r1 + ($volume_control_cap.vol_ctrl_channel_struct.STRUC_SIZE*ADDR_PER_WORD);
842005b0:	24 00 33 01 	r1 = r1 + 36;
    M[FP + $vol_ctrl.cuup.chan_ptr]=r1;
842005b4:	08 00 3c f1 	M[FP + 0x8] = r1;

    /* Another channel */
    r7 = r7 - 1;
842005b8:	3f 00 99 e4 	r7 = r7 - 1;
    if GT jump vol_ctrl_apply_volume_next;
842005bc:	6f ff c0 dd 	if GT jump $M.vol_ctrl_update_channel.vol_ctrl_apply_volume_next;

    // Save current mute
    M[r0 + $volume_control_cap._vol_ctrl_data_struct.CUR_MUTE_GAIN_FIELD]=r6;
842005c0:	04 03 82 d5 	M[r0 + 772] = r6;
    NULL = r6 - 1.0;
842005c4:	ff 7f 00 fd 	Null = r6 - 2147483647;
842005c8:	ff ff 08 21 
    if Z r9=NULL;
842005cc:	00 00 b0 00 	if EQ r9 = Null + Null;
    M[r0 + $volume_control_cap._vol_ctrl_data_struct.MUTE_INCREMENT_FIELD]=r9;
842005d0:	08 03 b2 d5 	M[r0 + 776] = r9;

    // Restore arithmetic mode */
    pop r4;
842005d4:	00 00 64 f3 	pop r4;
    M[$ARITHMETIC_MODE]=r4;
842005d8:	14 e0 60 19 	M[0xffffe014] = r4 + Null;

842005dc <$M.vol_ctrl_update_channel.vol_ctrl_apply_volume_abort>:

vol_ctrl_apply_volume_abort:

    popm <FP,r0,r1,r2,r3,rlink>;
842005dc:	3d 20 04 f1 	popm <FP, r0, r1, r2, r3, rLink>;
    popm <B0,B4,B5>;
842005e0:	00 34 06 f1 	popm <B0, B4, B5>;
    popm <I0,I1,I4,I5,M3,L0,L4,L5>;
842005e4:	33 d8 05 f1 	popm <I0, I1, I4, I5, M3, L0, L4, L5>;
    popm <r4,r5,r6,r7,r8,r9>;
842005e8:	c0 0f 04 f1 	popm <r4, r5, r6, r7, r8, r9>;

    rts;
842005ec:	0f 00 0d dc 	rts;
Disassembly of section .text_minim:

842005f0 <$_setup_processing>:
    op_extra_data->mute_increment = (bMute) ? -mute_increment : mute_increment;

}

bool setup_processing(VOL_CTRL_DATA_T   *op_extra_data)
{
842005f0:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
842005f2:	11 09       	r7 = r0 + Null;
    unsigned touched_sink = TOUCHED_NOTHING;
842005f4:	06 00       	r4 = Null + Null;
    unsigned touched_src  = TOUCHED_NOTHING;
842005f6:	07 00       	r5 = Null + Null;
    unsigned i,sink_bit,initial_channel_gain,chan_count=0;
842005f8:	00 09       	r6 = Null + Null;
    vol_ctrl_channel_t *chan_ptr;
	vol_ctrl_gains_t *lpvols =&op_extra_data->host_vol;
842005fa:	9a f0 f8 20 	r8 = r7 + 248;

    patch_fn_shared(volume_control_wrapper);

    /* Release data object */
    destroy_processing(op_extra_data);
842005fe:	6a 4e       	call (m) $_destroy_processing;


    /* Validate channel sinks and sources.  Count connected channels   */
    for(i=0,sink_bit=0;i<VOL_CTRL_CONSTANT_NUM_CHANNELS;i++,sink_bit+=2)
84200600:	01 00       	rMAC = Null + Null;
84200602:	02 00       	r0 = Null + Null;
84200604:	93 f0 20 20 	r1 = r7 + 32;

84200608 <Lc_setup_processing_2>:
    {
        if(op_extra_data->input_buffer[i])
84200608:	34 f3 f8 b9 	r2 = M[r1 + -32];
8420060c:	43 60       	if EQ jump (m) Lc_setup_processing_12;

8420060e <Lc_setup_processing_3>:
        {
            if(op_extra_data->output_buffer[i])
8420060e:	1c e8       	r2 = M[r1 + Null];
84200610:	43 60       	if EQ jump (m) Lc_setup_processing_13;

84200612 <Lc_setup_processing_4>:
            {
                chan_count++;
84200612:	08 75       	r6 = r6 + 1;
                touched_sink |= ( TOUCHED_SINK_0 <<sink_bit );
84200614:	14 00       	r2 = r0 + Null;
84200616:	00 f4 94 de 	r2 = 0x1 LSHIFT r2;
8420061a:	36 13       	r4 = r4 OR r2;
                touched_src  |=  (TOUCHED_SOURCE_0 << i);
8420061c:	0c 00       	r2 = rMAC + Null;
8420061e:	00 f4 94 de 	r2 = 0x1 LSHIFT r2;
84200622:	3f 13       	r5 = r5 OR r2;

84200624 <Lc_setup_processing_5>:
    /* Release data object */
    destroy_processing(op_extra_data);


    /* Validate channel sinks and sources.  Count connected channels   */
    for(i=0,sink_bit=0;i<VOL_CTRL_CONSTANT_NUM_CHANNELS;i++,sink_bit+=2)
84200624:	49 20       	rMAC = rMAC + 1;
84200626:	92 20       	r0 = r0 + 2;
84200628:	1b 21       	r1 = r1 + 4;
8420062a:	08 26       	Null = rMAC - 8;
8420062c:	ee 65       	if NC jump (m) Lc_setup_processing_2;

8420062e <Lc_setup_processing_6>:
            return FALSE;
        }
    }

    /* Must have at least one channel */
    if(chan_count<1)
8420062e:	0f f8 00 c2 	Null = r6 - Null;
84200632:	32 60       	if EQ jump (m) Lc_setup_processing_13;

84200634 <Lc_setup_processing_7>:
    {
        return FALSE;
    }

    /* A valid set of channels is connected */
    op_extra_data->channels = (vol_ctrl_channel_t*)xzpmalloc(chan_count*sizeof(vol_ctrl_channel_t));
84200634:	c3 20       	r1 = Null + 3;
84200636:	12 f8 92 c9 	r0 = r6 * 36 (int);
8420063a:	ff fd 40 f0 	call (m) 0x86f2;
8420063e:	39 e5 
    if(!op_extra_data->channels)
84200640:	92 f0 1a 8e 	M[r7 + 104] = r0;
84200644:	29 60       	if EQ jump (m) Lc_setup_processing_13;

84200646 <Lc_setup_processing_8>:
    {
        return FALSE;
    }
    op_extra_data->touched_src  = touched_src;
84200646:	97 f0 19 8e 	M[r7 + 100] = r5;
    op_extra_data->touched_sink = touched_sink;
8420064a:	96 f0 18 8e 	M[r7 + 96] = r4;
    op_extra_data->num_channels = chan_count;
8420064e:	98 f0 17 8e 	M[r7 + 92] = r6;

    /* Initialize Mute */
    op_extra_data->cur_mute_gain = 0;
84200652:	90 f0 c1 8e 	M[r7 + 772] = Null;
    vol_ctrl_setup_mute(op_extra_data,lpvols->mute);
84200656:	a3 f0 01 88 	r1 = M[r8 + 4];
8420065a:	4a 08       	r0 = r7 + Null;
8420065c:	08 f0 33 e6 	call (m) Lc_vol_ctrl_setup_mute_1;

    /* Link Channels with channel object */
    chan_ptr = op_extra_data->channels;
84200660:	96 f0 1a 88 	r4 = M[r7 + 104];
    for(i=0;i<VOL_CTRL_CONSTANT_NUM_CHANNELS;i++)
84200664:	07 00       	r5 = Null + Null;
84200666:	98 f0 20 20 	r6 = r7 + 32;

8420066a <Lc_setup_processing_9>:
    {
        if(op_extra_data->output_buffer[i])
8420066a:	81 f0 00 e8 	rMAC = M[r6 + Null];
8420066e:	21 60       	if EQ jump (m) Lc_setup_processing_16;

84200670 <Lc_setup_processing_10>:
        {
		    /* If initial value not specified before operator start, use -96db as default
			 * If an initial value is specified calculate channel gain as master_gain + channel_trim - post gain
			 */
		    if(op_extra_data->vol_initialised)
84200670:	90 f0 bf 88 	Null = M[r7 + 764];
84200674:	13 60       	if EQ jump (m) Lc_setup_processing_14;

84200676 <Lc_setup_processing_11>:
		    {
			    initial_channel_gain = dB60toLinearQ5(op_extra_data->lpvols->channel_trims[i] + op_extra_data->lpvols->master_gain - op_extra_data->post_gain);
84200676:	91 f0 62 88 	rMAC = M[r7 + 392];
8420067a:	7a 54       	r0 = r5 LSHIFT 2;
8420067c:	8a 00       	r0 = rMAC + r0;
8420067e:	92 98       	r0 = M[r0 + 40];
84200680:	1f f2 81 c0 	rMAC = r0 + M[rMAC];
84200684:	92 f0 3d 88 	r0 = M[r7 + 244];
84200688:	8a 04       	r0 = rMAC - r0;
8420068a:	ff fd a0 f1 	call (m) 0x3473e;
8420068e:	35 e5 
84200690:	06 6e       	jump (m) Lc_setup_processing_15;

84200692 <Lc_setup_processing_12>:
            else
            {
                return FALSE;
            }
        }
        else if(op_extra_data->output_buffer[i])
84200692:	1c e8       	r2 = M[r1 + Null];
84200694:	c8 61       	if EQ jump (m) Lc_setup_processing_5;

84200696 <Lc_setup_processing_13>:
                touched_sink |= ( TOUCHED_SINK_0 <<sink_bit );
                touched_src  |=  (TOUCHED_SOURCE_0 << i);
            }
            else
            {
                return FALSE;
84200696:	02 00       	r0 = Null + Null;
84200698:	1b 6e       	jump (m) Lc_setup_processing_18;

8420069a <Lc_setup_processing_14>:
		    {
			    initial_channel_gain = dB60toLinearQ5(op_extra_data->lpvols->channel_trims[i] + op_extra_data->lpvols->master_gain - op_extra_data->post_gain);
			}
			else
			{
				initial_channel_gain = 0;
8420069a:	02 00       	r0 = Null + Null;

8420069c <Lc_setup_processing_15>:
			};

			chan_ptr->chan_idx = i;
8420069c:	37 ee       	M[r4 + Null] = r5;
			chan_ptr->channel_gain = initial_channel_gain;
8420069e:	b2 8f       	M[r4 + 24] = r0;
			chan_ptr->prim_mix_gain = dB60toLinearQ5(0); /*set to 0db. this will be recalculated as part of the update function*/
842006a0:	02 00       	r0 = Null + Null;
842006a2:	ff fd a0 f1 	call (m) 0x3473e;
842006a6:	3d e4 
842006a8:	b2 8e       	M[r4 + 8] = r0;
			chan_ptr->last_volume  = chan_ptr->channel_gain;
842006aa:	b1 89       	rMAC = M[r4 + 24];
842006ac:	f1 8f       	M[r4 + 28] = rMAC;
			chan_ptr++;
842006ae:	36 31       	r4 = r4 + 36;

842006b0 <Lc_setup_processing_16>:
    op_extra_data->cur_mute_gain = 0;
    vol_ctrl_setup_mute(op_extra_data,lpvols->mute);

    /* Link Channels with channel object */
    chan_ptr = op_extra_data->channels;
    for(i=0;i<VOL_CTRL_CONSTANT_NUM_CHANNELS;i++)
842006b0:	7f 20       	r5 = r5 + 1;
842006b2:	20 75       	r6 = r6 + 4;
842006b4:	38 26       	Null = r5 - 8;
842006b6:	da 65       	if NC jump (m) Lc_setup_processing_9;

842006b8 <Lc_setup_processing_17>:
			chan_ptr->last_volume  = chan_ptr->channel_gain;
			chan_ptr++;
        }
    }

    op_extra_data->vol_initialised = 0;
842006b8:	90 f0 bf 8e 	M[r7 + 764] = Null;
    op_extra_data->wait_on_space_buffer=NULL;
842006bc:	90 f0 10 8e 	M[r7 + 64] = Null;
    op_extra_data->wait_on_data_buffer=NULL;
842006c0:	90 f0 11 8e 	M[r7 + 68] = Null;
    op_extra_data->aux_pending = FALSE;
842006c4:	90 f0 bc 8e 	M[r7 + 752] = Null;
    op_extra_data->used_all_input = FALSE;
842006c8:	90 f0 bd 8e 	M[r7 + 756] = Null;

    return TRUE;
842006cc:	42 20       	r0 = Null + 1;

842006ce <Lc_setup_processing_18>:
}
842006ce:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
842006d0:	d8 4c       	rts;

842006d2 <$_destroy_processing>:
}

/* ************************************* Data processing-related functions and wrappers **********************************/

void destroy_processing(VOL_CTRL_DATA_T *op_extra_data)
{
842006d2:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
842006d4:	16 00       	r4 = r0 + Null;
    timer_cancel_event_atomic(&op_extra_data->pending_timer);
842006d6:	67 f0 f8 22 	r5 = r4 + 760;
    (void) timer_cancel_event_ret(timer_id, NULL, NULL);
}

INLINE_SECTION static inline void timer_cancel_event_atomic(tTimerId *timer_id)
{
    interrupt_block();
842006da:	ff fd ac f1 	call (m) 0x360c6;
842006de:	2d ef 
    if (*timer_id != TIMER_ID_INVALID)
842006e0:	3a e8       	r0 = M[r5 + Null];
842006e2:	07 60       	if EQ jump (m) Lc_destroy_processing_3;

842006e4 <Lc_destroy_processing_2>:
    {
        (void) timer_cancel_event_ret(*timer_id, NULL, NULL);
842006e4:	04 00       	r2 = Null + Null;
842006e6:	03 00       	r1 = Null + Null;
842006e8:	ff fd 3c f0 	call (m) 0x80e0;
842006ec:	39 ef 
        *timer_id = TIMER_ID_INVALID;
842006ee:	38 ee       	M[r5 + Null] = Null;

842006f0 <Lc_destroy_processing_3>:
    }
    interrupt_unblock();
842006f0:	ff fd ac f1 	call (m) 0x360e2;
842006f4:	33 ef 

    if(!op_extra_data->channels)
842006f6:	b2 b8       	r0 = M[r4 + 104];
842006f8:	05 60       	if EQ jump (m) Lc_destroy_processing_5;

842006fa <Lc_destroy_processing_4>:
    {
        return;
    }

    pfree(op_extra_data->channels);
842006fa:	ff fd 40 f0 	call (m) 0x8724;
842006fe:	2b e1 
    op_extra_data->channels = NULL;
84200700:	b0 be       	M[r4 + 104] = Null;

84200702 <Lc_destroy_processing_5>:
}
84200702:	f2 48       	popm <FP, r4, r5, rLink>;
84200704:	d8 4c       	rts;

84200706 <$_vol_ctlr_create>:


/* ********************************** API functions ************************************* */

bool vol_ctlr_create(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200706:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84200708:	17 00       	r5 = r0 + Null;
8420070a:	19 09       	r7 = r1 + Null;
8420070c:	20 09       	r6 = r2 + Null;
8420070e:	2a 09       	r8 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
84200710:	ef fd fd ff 	call (m) 0x1e2;
84200714:	33 e6 
84200716:	16 00       	r4 = r0 + Null;
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);

    patch_fn_shared(volume_control_wrapper);

    if (!base_op_create(op_data, message_data, response_id, response_data))
84200718:	55 08       	r3 = r8 + Null;
8420071a:	44 08       	r2 = r6 + Null;
8420071c:	4b 08       	r1 = r7 + Null;
8420071e:	3a 00       	r0 = r5 + Null;
84200720:	ef fd fc ff 	call (m) 0x56;
84200724:	37 e9 
84200726:	10 04       	Null = r0 - Null;
84200728:	03 62       	if NE jump (m) Lc_vol_ctlr_create_3;

8420072a <Lc_vol_ctlr_create_2>:
    {
        return FALSE;
8420072a:	02 00       	r0 = Null + Null;
8420072c:	31 6e       	jump (m) Lc_vol_ctlr_create_7;

8420072e <Lc_vol_ctlr_create_3>:
    }

    /*allocate the volume control shared memory*/
    op_extra_data->shared_volume_ptr = allocate_shared_volume_cntrl();
8420072e:	ff fd a9 f0 	call (m) 0x15a6e;
84200732:	21 ea 
84200734:	62 f0 63 8e 	M[r4 + 396] = r0;
    if(!op_extra_data->shared_volume_ptr)
84200738:	61 f0 63 88 	rMAC = M[r4 + 396];
8420073c:	08 62       	if NE jump (m) Lc_vol_ctlr_create_6;

8420073e <Lc_vol_ctlr_create_4>:
 * \param  response_data Pointer to the pointer to message that is allocated in the function.
 * \param  new_status  A status ID that is to be sent in the message.
 */
inline static void base_op_change_response_status(void **response_data, STATUS_KYMERA new_status)
{
    (((OP_STD_RSP *)(*response_data))->status = new_status);
8420073e:	01 f0 00 60 	rMAC = Null + 4096;
84200742:	a2 f0 00 e8 	r0 = M[r8 + Null];
84200746:	51 8e       	M[r0 + 4] = rMAC;

84200748 <Lc_vol_ctlr_create_5>:
    {
        base_op_change_response_status(response_data, STATUS_CMD_FAILED);
        return TRUE;
84200748:	42 20       	r0 = Null + 1;
8420074a:	22 6e       	jump (m) Lc_vol_ctlr_create_7;

8420074c <Lc_vol_ctlr_create_6>:
    }

    op_extra_data->lpvols = &op_extra_data->host_vol;
8420074c:	61 f0 f8 20 	rMAC = r4 + 248;
84200750:	61 f0 62 8e 	M[r4 + 392] = rMAC;
    op_extra_data->stream_based = FALSE;
84200754:	60 f0 c3 8e 	M[r4 + 780] = Null;

    /* Initialize mute control */
    op_extra_data->mute_period = 10;
84200758:	81 22       	rMAC = Null + 10;
8420075a:	61 f0 c0 8e 	M[r4 + 768] = rMAC;

    /* Initialize extended data for operator.  Assume initialized to zero*/
    op_extra_data->ReInitFlag = 1;
8420075e:	41 20       	rMAC = Null + 1;
84200760:	61 f0 ac 8e 	M[r4 + 688] = rMAC;

    op_extra_data->pending_timer = TIMER_ID_INVALID;
84200764:	60 f0 be 8e 	M[r4 + 760] = Null;

    if(!cpsInitParameters(&op_extra_data->parms_def,(unsigned*)VOL_CTRL_GetDefaults(base_op_get_cap_id(op_data)),(unsigned*)&op_extra_data->parameters,sizeof(VOL_CTRL_PARAMETERS)))
84200768:	3a 00       	r0 = r5 + Null;
8420076a:	ef fd fd ff 	call (m) 0x1e6;
8420076e:	3d e3 
84200770:	08 f0 2d e2 	call (m) $_VOL_CTRL_GetDefaults;
84200774:	13 00       	r1 = r0 + Null;
84200776:	05 f0 20 41 	r3 = Null + 288;
8420077a:	64 f0 90 21 	r2 = r4 + 400;
8420077e:	62 f0 b4 22 	r0 = r4 + 692;
84200782:	ef fd fe ff 	call (m) 0x448;
84200786:	27 e6 
84200788:	10 04       	Null = r0 - Null;
8420078a:	df 63       	if NE jump (m) Lc_vol_ctlr_create_5;

8420078c <Lc_11>:
8420078c:	d9 6f       	jump (m) Lc_vol_ctlr_create_4;

8420078e <Lc_vol_ctlr_create_7>:
        base_op_change_response_status(response_data, STATUS_CMD_FAILED);
        return TRUE;
    }

    return TRUE;
}
8420078e:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84200790:	d8 4c       	rts;

84200792 <$_vol_ctlr_destroy>:



bool vol_ctlr_destroy(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200792:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84200794:	10 09       	r6 = r0 + Null;
84200796:	1a 09       	r8 = r1 + Null;
84200798:	27 00       	r5 = r2 + Null;
8420079a:	29 09       	r7 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
8420079c:	ef fd fd ff 	call (m) 0x1e2;
842007a0:	27 e2 
842007a2:	16 00       	r4 = r0 + Null;
bool vol_ctlr_destroy(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);

    /* call base_op destroy that creates and fills response message, too */
    if(!base_op_destroy(op_data, message_data, response_id, response_data))
842007a4:	4d 08       	r3 = r7 + Null;
842007a6:	3c 00       	r2 = r5 + Null;
842007a8:	53 08       	r1 = r8 + Null;
842007aa:	42 08       	r0 = r6 + Null;
842007ac:	ef fd fc ff 	call (m) 0x6c;
842007b0:	21 e6 
842007b2:	10 04       	Null = r0 - Null;
842007b4:	03 62       	if NE jump (m) Lc_vol_ctlr_destroy_3;

842007b6 <Lc_vol_ctlr_destroy_2>:
    {
        return(FALSE);
842007b6:	02 00       	r0 = Null + Null;
842007b8:	0b 6e       	jump (m) Lc_vol_ctlr_destroy_4;

842007ba <Lc_vol_ctlr_destroy_3>:
    }

    /*free volume control shared memory*/
    release_shared_volume_cntrl(op_extra_data->shared_volume_ptr);
842007ba:	62 f0 63 88 	r0 = M[r4 + 396];
842007be:	ff fd a9 f0 	call (m) 0x15a92;
842007c2:	35 e6 
    op_extra_data->shared_volume_ptr = NULL;
842007c4:	60 f0 63 8e 	M[r4 + 396] = Null;

    /* Release Channels */
    destroy_processing(op_extra_data);
842007c8:	32 00       	r0 = r4 + Null;
842007ca:	84 4f       	call (m) $_destroy_processing;

    return TRUE;
842007cc:	42 20       	r0 = Null + 1;

842007ce <Lc_vol_ctlr_destroy_4>:
}
842007ce:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
842007d0:	d8 4c       	rts;

842007d2 <$_vol_ctlr_connect>:
    }
    op_extra_data->aux_buff_size = aux_buffer_min_size;
}

bool vol_ctlr_connect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
842007d2:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
842007d4:	11 09       	r7 = r0 + Null;
842007d6:	18 09       	r6 = r1 + Null;
842007d8:	2a 09       	r8 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
842007da:	ef fd fd ff 	call (m) 0x1e2;
842007de:	29 e0 
842007e0:	16 00       	r4 = r0 + Null;
}

bool vol_ctlr_connect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);
    unsigned terminal_id = OPMGR_GET_OP_CONNECT_TERMINAL_ID(message_data);    /* extract the terminal_id */
842007e2:	87 f0 00 e8 	r5 = M[r6 + Null];
    tCbuffer* pterminal_buf = OPMGR_GET_OP_CONNECT_BUFFER(message_data);
842007e6:	88 f0 01 88 	r6 = M[r6 + 4];

    /* Setup Response to Connection Request. */
    if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
842007ea:	03 00       	r1 = Null + Null;
842007ec:	54 08       	r2 = r8 + Null;
842007ee:	4a 08       	r0 = r7 + Null;
842007f0:	ef fd fc ff 	call (m) 0x1b8;
842007f4:	29 ee 
842007f6:	10 04       	Null = r0 - Null;
842007f8:	03 62       	if NE jump (m) Lc_vol_ctlr_connect_3;

842007fa <Lc_vol_ctlr_connect_2>:
    {
        return FALSE;
842007fa:	02 00       	r0 = Null + Null;
842007fc:	6a 6e       	jump (m) Lc_vol_ctlr_connect_23;

842007fe <Lc_vol_ctlr_connect_3>:
    }

    /* (i)  check if the terminal ID is valid . The number has to be less than the maximum number of sinks or sources .  */
    /* (ii) check if we are connecting to the right type . It has to be a buffer pointer and not endpoint connection */
    if( !base_op_is_terminal_valid(op_data, terminal_id) || !pterminal_buf)
842007fe:	3b 00       	r1 = r5 + Null;
84200800:	4a 08       	r0 = r7 + Null;
84200802:	ef fd fc ff 	call (m) 0x192;
84200806:	31 ec 
84200808:	10 04       	Null = r0 - Null;
8420080a:	04 60       	if EQ jump (m) Lc_vol_ctlr_connect_5;

8420080c <Lc_vol_ctlr_connect_4>:
8420080c:	0f f8 00 c2 	Null = r6 - Null;
84200810:	07 62       	if NE jump (m) Lc_vol_ctlr_connect_6;

84200812 <Lc_vol_ctlr_connect_5>:
84200812:	01 f0 00 60 	rMAC = Null + 4096;
84200816:	a2 f0 00 e8 	r0 = M[r8 + Null];
8420081a:	51 8e       	M[r0 + 4] = rMAC;
8420081c:	49 6e       	jump (m) Lc_vol_ctlr_connect_19;

8420081e <Lc_vol_ctlr_connect_6>:
    {
        base_op_change_response_status(response_data, STATUS_CMD_FAILED);
        return TRUE;
    }

    if (opmgr_op_is_running(op_data))
8420081e:	4a 08       	r0 = r7 + Null;
84200820:	ff fd 36 f0 	call (m) 0x7586;
84200824:	27 eb 
84200826:	10 04       	Null = r0 - Null;
84200828:	07 60       	if EQ jump (m) Lc_vol_ctlr_connect_9;

8420082a <Lc_vol_ctlr_connect_7>:
    {
        /* Only Auxiliary Terminals Can be Altered while running */
        if(!(terminal_id & TERMINAL_SINK_MASK) || !(terminal_id&0x1))
8420082a:	40 f0 71 f0 	rMAC = r5 AND 0x800000;
8420082e:	00 00 
84200830:	f1 61       	if EQ jump (m) Lc_vol_ctlr_connect_5;

84200832 <Lc_vol_ctlr_connect_8>:
84200832:	39 c0       	rMAC = r5 AND 0x1;
84200834:	ef 61       	if EQ jump (m) Lc_vol_ctlr_connect_5;

84200836 <Lc_vol_ctlr_connect_9>:
            base_op_change_response_status(response_data, STATUS_CMD_FAILED);
            return TRUE;
        }
    }

    if(terminal_id&TERMINAL_SINK_MASK)
84200836:	40 f0 71 f0 	rMAC = r5 AND 0x800000;
8420083a:	00 00 
8420083c:	3b 60       	if EQ jump (m) Lc_vol_ctlr_connect_20;

8420083e <Lc_vol_ctlr_connect_10>:
    {
        unsigned term_idx = (terminal_id&TERMINAL_NUM_MASK)>>1;
8420083e:	3a 50       	r0 = r5 LSHIFT -1;
84200840:	2a f0 1f 00 	r8 = r0 AND 0x1f;

        if(terminal_id&0x1)
84200844:	39 c0       	rMAC = r5 AND 0x1;
84200846:	24 60       	if EQ jump (m) Lc_vol_ctlr_connect_15;

84200848 <Lc_vol_ctlr_connect_11>:
        {
            opmgr_op_suspend_processing(op_data);
84200848:	4a 08       	r0 = r7 + Null;
8420084a:	ff fd 36 f0 	call (m) 0x7592;
8420084e:	29 ea 
            op_extra_data->aux_connected |= (1<<term_idx);
84200850:	51 08       	rMAC = r8 + Null;
84200852:	00 f1 92 de 	r0 = 0x1 LSHIFT rMAC;
84200856:	61 f0 b7 88 	rMAC = M[r4 + 732];
8420085a:	89 12       	rMAC = rMAC OR r0;
8420085c:	61 f0 b7 8e 	M[r4 + 732] = rMAC;
            op_extra_data->aux_channel[term_idx].buffer = pterminal_buf;
84200860:	02 fa d2 c8 	r0 = r8 LSHIFT 4;
84200864:	31 00       	rMAC = r4 + Null;
84200866:	51 00       	rMAC = r0 + rMAC;
84200868:	17 f0 6c 20 	r5 = rMAC + 108;
8420086c:	78 f0 00 ee 	M[r5 + Null] = r6;
            opmgr_op_resume_processing(op_data);
84200870:	4a 08       	r0 = r7 + Null;
84200872:	ff fd 36 f0 	call (m) 0x75c0;
84200876:	2f ea 
#ifdef INSTALL_METADATA
            if(op_extra_data->metadata_aux_channel == NULL)
84200878:	31 a9       	rMAC = M[r4 + 80];
8420087a:	06 62       	if NE jump (m) Lc_vol_ctlr_connect_14;

8420087c <Lc_vol_ctlr_connect_12>:
            {
                if (buff_has_metadata(op_extra_data->aux_channel[term_idx].buffer))
8420087c:	39 e8       	rMAC = M[r5 + Null];
 *
 * \return TRUE if the buffer supports metadata. FALSE if it doesn't.
 */
static inline bool buff_has_metadata(tCbuffer *buff)
{
    if (BUFF_METADATA(buff))
8420087e:	49 89       	rMAC = M[rMAC + 20];
84200880:	49 c6       	rMAC = rMAC AND 0x8000;
84200882:	02 60       	if EQ jump (m) Lc_vol_ctlr_connect_14;

84200884 <Lc_vol_ctlr_connect_13>:
                {
                    op_extra_data->metadata_aux_channel = &op_extra_data->aux_channel[term_idx];
84200884:	37 af       	M[r4 + 80] = r5;

84200886 <Lc_vol_ctlr_connect_14>:
                }
            }
#endif /* INSTALL_METADATA */
            vol_ctrl_recalc_aux_buffer_size(op_extra_data);
84200886:	32 00       	r0 = r4 + Null;
84200888:	05 f0 3b ea 	call (m) Lc_vol_ctrl_recalc_aux_buffer_size_1;
8420088c:	11 6e       	jump (m) Lc_vol_ctlr_connect_19;

8420088e <Lc_vol_ctlr_connect_15>:
        }
        else
        {
            op_extra_data->input_buffer[term_idx] = pterminal_buf;
8420088e:	01 fa d2 c8 	r0 = r8 LSHIFT 2;
84200892:	68 f0 02 ee 	M[r4 + r0] = r6;
#ifdef INSTALL_METADATA
            if(op_extra_data->metadata_ip_buffer == NULL)
84200896:	b1 a8       	rMAC = M[r4 + 72];
84200898:	07 62       	if NE jump (m) Lc_vol_ctlr_connect_18;

8420089a <Lc_vol_ctlr_connect_16>:
8420089a:	81 f0 05 88 	rMAC = M[r6 + 20];
8420089e:	49 c6       	rMAC = rMAC AND 0x8000;
842008a0:	03 60       	if EQ jump (m) Lc_vol_ctlr_connect_18;

842008a2 <Lc_vol_ctlr_connect_17>:
            {
                if (buff_has_metadata(op_extra_data->input_buffer[term_idx]))
                {
                    op_extra_data->metadata_ip_buffer = op_extra_data->input_buffer[term_idx];
842008a2:	68 f0 12 8e 	M[r4 + 72] = r6;

842008a6 <Lc_vol_ctlr_connect_18>:
            {
                op_extra_data->metadata_op_buffer = op_extra_data->output_buffer[term_idx];
            }
        }
#endif /* INSTALL_METADATA */
        vol_ctrl_recalc_main_buffer_size(op_extra_data, terminal_id);
842008a6:	3b 00       	r1 = r5 + Null;
842008a8:	32 00       	r0 = r4 + Null;
842008aa:	05 f0 37 e9 	call (m) Lc_vol_ctrl_recalc_main_buffer_size_1;

842008ae <Lc_vol_ctlr_connect_19>:
    /* (i)  check if the terminal ID is valid . The number has to be less than the maximum number of sinks or sources .  */
    /* (ii) check if we are connecting to the right type . It has to be a buffer pointer and not endpoint connection */
    if( !base_op_is_terminal_valid(op_data, terminal_id) || !pterminal_buf)
    {
        base_op_change_response_status(response_data, STATUS_CMD_FAILED);
        return TRUE;
842008ae:	42 20       	r0 = Null + 1;
842008b0:	10 6e       	jump (m) Lc_vol_ctlr_connect_23;

842008b2 <Lc_vol_ctlr_connect_20>:
            vol_ctrl_recalc_main_buffer_size(op_extra_data, terminal_id);
        }
    }
    else
    {
        unsigned term_idx = terminal_id&TERMINAL_NUM_MASK;
842008b2:	ba c2       	r0 = r5 AND 0x3f;
        op_extra_data->output_buffer[term_idx] = pterminal_buf;
842008b4:	52 54       	r0 = r0 LSHIFT 2;
842008b6:	31 00       	rMAC = r4 + Null;
842008b8:	51 00       	rMAC = r0 + rMAC;
842008ba:	18 f0 08 8e 	M[rMAC + 32] = r6;
#ifdef INSTALL_METADATA
        if(op_extra_data->metadata_op_buffer == NULL)
842008be:	f1 a8       	rMAC = M[r4 + 76];
842008c0:	f3 63       	if NE jump (m) Lc_vol_ctlr_connect_18;

842008c2 <Lc_vol_ctlr_connect_21>:
842008c2:	81 f0 05 88 	rMAC = M[r6 + 20];
842008c6:	49 c6       	rMAC = rMAC AND 0x8000;
842008c8:	ef 61       	if EQ jump (m) Lc_vol_ctlr_connect_18;

842008ca <Lc_vol_ctlr_connect_22>:
        {
            if (buff_has_metadata(op_extra_data->output_buffer[term_idx]))
            {
                op_extra_data->metadata_op_buffer = op_extra_data->output_buffer[term_idx];
842008ca:	68 f0 13 8e 	M[r4 + 76] = r6;
842008ce:	ec 6f       	jump (m) Lc_vol_ctlr_connect_18;

842008d0 <Lc_vol_ctlr_connect_23>:
        }
#endif /* INSTALL_METADATA */
        vol_ctrl_recalc_main_buffer_size(op_extra_data, terminal_id);
    }
    return TRUE;
}
842008d0:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
842008d2:	d8 4c       	rts;

842008d4 <$_vol_ctlr_disconnect>:

bool vol_ctlr_disconnect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
842008d4:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
842008d6:	10 09       	r6 = r0 + Null;
842008d8:	1f 00       	r5 = r1 + Null;
842008da:	29 09       	r7 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
842008dc:	ef fd fc ff 	call (m) 0x1e2;
842008e0:	27 e8 
842008e2:	16 00       	r4 = r0 + Null;
}

bool vol_ctlr_disconnect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);
    unsigned terminal_id = OPMGR_GET_OP_DISCONNECT_TERMINAL_ID(message_data);
842008e4:	3f e8       	r5 = M[r5 + Null];

    /* Setup Response to Disconnection Request. */
    if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
842008e6:	03 00       	r1 = Null + Null;
842008e8:	4c 08       	r2 = r7 + Null;
842008ea:	42 08       	r0 = r6 + Null;
842008ec:	ef fd fc ff 	call (m) 0x1b8;
842008f0:	2d e6 
842008f2:	10 04       	Null = r0 - Null;
842008f4:	03 62       	if NE jump (m) Lc_vol_ctlr_disconnect_3;

842008f6 <Lc_vol_ctlr_disconnect_2>:
    {
        return FALSE;
842008f6:	02 00       	r0 = Null + Null;
842008f8:	96 6e       	jump (m) Lc_vol_ctlr_disconnect_39;

842008fa <Lc_vol_ctlr_disconnect_3>:
    }

    /* (i)  check if the terminal ID is valid . The number has to be less than the maximum number of sinks or sources .  */
    /* (ii) check if we are connecting to the right type . It has to be a buffer pointer and not endpoint connection */
    if( !base_op_is_terminal_valid(op_data, terminal_id))
842008fa:	3b 00       	r1 = r5 + Null;
842008fc:	42 08       	r0 = r6 + Null;
842008fe:	ef fd fc ff 	call (m) 0x192;
84200902:	35 e4 
84200904:	10 04       	Null = r0 - Null;
84200906:	08 62       	if NE jump (m) Lc_vol_ctlr_disconnect_6;

84200908 <Lc_vol_ctlr_disconnect_4>:
84200908:	01 f0 00 60 	rMAC = Null + 4096;
8420090c:	92 f0 00 e8 	r0 = M[r7 + Null];
84200910:	51 8e       	M[r0 + 4] = rMAC;

84200912 <Lc_vol_ctlr_disconnect_5>:
    {
        base_op_change_response_status(response_data, STATUS_CMD_FAILED);
        return TRUE;
84200912:	42 20       	r0 = Null + 1;
84200914:	88 6e       	jump (m) Lc_vol_ctlr_disconnect_39;

84200916 <Lc_vol_ctlr_disconnect_6>:
    }

    if (opmgr_op_is_running(op_data))
84200916:	42 08       	r0 = r6 + Null;
84200918:	ff fd 36 f0 	call (m) 0x7586;
8420091c:	2f e3 
8420091e:	10 04       	Null = r0 - Null;
84200920:	07 60       	if EQ jump (m) Lc_vol_ctlr_disconnect_9;

84200922 <Lc_vol_ctlr_disconnect_7>:
    {
        /* Only Auxiliary Terminals Can be Altered while running */
        if(!(terminal_id & TERMINAL_SINK_MASK) || !(terminal_id&0x1))
84200922:	40 f0 71 f0 	rMAC = r5 AND 0x800000;
84200926:	00 00 
84200928:	f0 61       	if EQ jump (m) Lc_vol_ctlr_disconnect_4;

8420092a <Lc_vol_ctlr_disconnect_8>:
8420092a:	39 c0       	rMAC = r5 AND 0x1;
8420092c:	ee 61       	if EQ jump (m) Lc_vol_ctlr_disconnect_4;

8420092e <Lc_vol_ctlr_disconnect_9>:
            base_op_change_response_status(response_data, STATUS_CMD_FAILED);
            return TRUE;
        }
    }

    if(terminal_id&TERMINAL_SINK_MASK)
8420092e:	40 f0 71 f0 	rMAC = r5 AND 0x800000;
84200932:	00 00 
84200934:	53 60       	if EQ jump (m) Lc_vol_ctlr_disconnect_28;

84200936 <Lc_vol_ctlr_disconnect_10>:
    {
        unsigned term_idx = (terminal_id&TERMINAL_NUM_MASK)>>1;
84200936:	3a 50       	r0 = r5 LSHIFT -1;
84200938:	29 f0 1f 00 	r7 = r0 AND 0x1f;

        if(terminal_id&0x1)
8420093c:	39 c0       	rMAC = r5 AND 0x1;
8420093e:	30 60       	if EQ jump (m) Lc_vol_ctlr_disconnect_19;

84200940 <Lc_vol_ctlr_disconnect_11>:
        {
#ifdef INSTALL_METADATA
            if (op_extra_data->metadata_aux_channel == &op_extra_data->aux_channel[term_idx])
84200940:	02 f9 d2 c8 	r0 = r7 LSHIFT 4;
84200944:	31 00       	rMAC = r4 + Null;
84200946:	51 00       	rMAC = r0 + rMAC;
84200948:	17 f0 6c 20 	r5 = rMAC + 108;
8420094c:	31 a9       	rMAC = M[r4 + 80];
8420094e:	c8 05       	Null = rMAC - r5;
84200950:	11 62       	if NE jump (m) Lc_vol_ctlr_disconnect_18;

84200952 <Lc_vol_ctlr_disconnect_12>:
            {
                unsigned i;
                bool found_alternative = FALSE;
                vol_ctrl_aux_channel_t *aux_chan = NULL;
                for (i = 0, aux_chan = &op_extra_data->aux_channel[0];
84200952:	01 00       	rMAC = Null + Null;
84200954:	62 f0 6c 20 	r0 = r4 + 108;

84200958 <Lc_vol_ctlr_disconnect_13>:
                     i < VOL_CTRL_CONSTANT_NUM_CHANNELS;
                     i++, aux_chan++)
                {
                    if (i == term_idx)
84200958:	9f f1 00 c2 	Null = rMAC - r7;
8420095c:	06 60       	if EQ jump (m) Lc_vol_ctlr_disconnect_16;

8420095e <Lc_vol_ctlr_disconnect_14>:
                    {
                        continue;
                    }
                    if (aux_chan->buffer != NULL && buff_has_metadata(aux_chan->buffer))
8420095e:	13 e8       	r1 = M[r0 + Null];
84200960:	04 60       	if EQ jump (m) Lc_vol_ctlr_disconnect_16;

84200962 <Lc_vol_ctlr_disconnect_15>:
84200962:	5b 89       	r1 = M[r1 + 20];
84200964:	5b c6       	r1 = r1 AND 0x8000;
84200966:	53 62       	if NE jump (m) Lc_vol_ctlr_disconnect_36;

84200968 <Lc_vol_ctlr_disconnect_16>:
                unsigned i;
                bool found_alternative = FALSE;
                vol_ctrl_aux_channel_t *aux_chan = NULL;
                for (i = 0, aux_chan = &op_extra_data->aux_channel[0];
                     i < VOL_CTRL_CONSTANT_NUM_CHANNELS;
                     i++, aux_chan++)
84200968:	49 20       	rMAC = rMAC + 1;
8420096a:	12 28       	r0 = r0 + 16;
            {
                unsigned i;
                bool found_alternative = FALSE;
                vol_ctrl_aux_channel_t *aux_chan = NULL;
                for (i = 0, aux_chan = &op_extra_data->aux_channel[0];
                     i < VOL_CTRL_CONSTANT_NUM_CHANNELS;
8420096c:	08 26       	Null = rMAC - 8;
8420096e:	f5 65       	if NC jump (m) Lc_vol_ctlr_disconnect_13;

84200970 <Lc_vol_ctlr_disconnect_17>:
                        break;
                    }
                }
                if (!found_alternative)
                {
                    op_extra_data->metadata_aux_channel = NULL;
84200970:	30 af       	M[r4 + 80] = Null;

84200972 <Lc_vol_ctlr_disconnect_18>:
                }
            }
#endif /* INSTALL_METADATA */
            opmgr_op_suspend_processing(op_data);
84200972:	42 08       	r0 = r6 + Null;
84200974:	ff fd 36 f0 	call (m) 0x7592;
84200978:	3f e0 
            op_extra_data->aux_connected &= ~(1<<term_idx);
8420097a:	00 f9 92 de 	r0 = 0x1 LSHIFT r7;
8420097e:	ff f2 51 d6 	rMAC = -1 - r0;
84200982:	62 f0 b7 88 	r0 = M[r4 + 732];
84200986:	89 10       	rMAC = rMAC AND r0;
84200988:	61 f0 b7 8e 	M[r4 + 732] = rMAC;
            op_extra_data->aux_channel[term_idx].buffer = NULL;
8420098c:	38 ee       	M[r5 + Null] = Null;
            opmgr_op_resume_processing(op_data);
8420098e:	42 08       	r0 = r6 + Null;
84200990:	ff fd 36 f0 	call (m) 0x75c0;
84200994:	31 e1 
            vol_ctrl_recalc_aux_buffer_size(op_extra_data);
84200996:	32 00       	r0 = r4 + Null;
84200998:	05 f0 2b e2 	call (m) Lc_vol_ctrl_recalc_aux_buffer_size_1;
8420099c:	bb 6f       	jump (m) Lc_vol_ctlr_disconnect_5;

8420099e <Lc_vol_ctlr_disconnect_19>:
        }
        else
        {
#ifdef INSTALL_METADATA
            if (op_extra_data->metadata_ip_buffer == op_extra_data->input_buffer[term_idx])
8420099e:	01 f9 d2 c8 	r0 = r7 LSHIFT 2;
842009a2:	31 00       	rMAC = r4 + Null;
842009a4:	51 00       	rMAC = r0 + rMAC;
842009a6:	0b 00       	r1 = rMAC + Null;
842009a8:	b1 a8       	rMAC = M[r4 + 72];
842009aa:	1a e8       	r0 = M[r1 + Null];
842009ac:	88 04       	Null = rMAC - r0;
842009ae:	10 62       	if NE jump (m) Lc_vol_ctlr_disconnect_26;

842009b0 <Lc_vol_ctlr_disconnect_20>:
            {
                unsigned i;
                bool found_alternative = FALSE;
                for (i = 0; i < VOL_CTRL_CONSTANT_NUM_CHANNELS; i++)
842009b0:	02 00       	r0 = Null + Null;
842009b2:	31 00       	rMAC = r4 + Null;

842009b4 <Lc_vol_ctlr_disconnect_21>:
                {
                    if (i == term_idx)
842009b4:	9f f2 00 c2 	Null = r0 - r7;
842009b8:	06 60       	if EQ jump (m) Lc_vol_ctlr_disconnect_24;

842009ba <Lc_vol_ctlr_disconnect_22>:
                    {
                        continue;
                    }
                    if (op_extra_data->input_buffer[i] != NULL && buff_has_metadata(op_extra_data->input_buffer[i]))
842009ba:	0c e8       	r2 = M[rMAC + Null];
842009bc:	04 60       	if EQ jump (m) Lc_vol_ctlr_disconnect_24;

842009be <Lc_vol_ctlr_disconnect_23>:
842009be:	64 89       	r2 = M[r2 + 20];
842009c0:	64 c6       	r2 = r2 AND 0x8000;
842009c2:	27 62       	if NE jump (m) Lc_vol_ctlr_disconnect_37;

842009c4 <Lc_vol_ctlr_disconnect_24>:
#ifdef INSTALL_METADATA
            if (op_extra_data->metadata_ip_buffer == op_extra_data->input_buffer[term_idx])
            {
                unsigned i;
                bool found_alternative = FALSE;
                for (i = 0; i < VOL_CTRL_CONSTANT_NUM_CHANNELS; i++)
842009c4:	52 20       	r0 = r0 + 1;
842009c6:	09 21       	rMAC = rMAC + 4;
842009c8:	10 26       	Null = r0 - 8;
842009ca:	f5 65       	if NC jump (m) Lc_vol_ctlr_disconnect_21;

842009cc <Lc_vol_ctlr_disconnect_25>:
                        break;
                    }
                }
                if (!found_alternative)
                {
                    op_extra_data->metadata_ip_buffer = NULL;
842009cc:	b0 ae       	M[r4 + 72] = Null;

842009ce <Lc_vol_ctlr_disconnect_26>:
                }
            }
#endif /* INSTALL_METADATA */
            op_extra_data->input_buffer[term_idx] = NULL;
842009ce:	18 ee       	M[r1 + Null] = Null;

842009d0 <Lc_vol_ctlr_disconnect_27>:
                op_extra_data->metadata_op_buffer = NULL;
            }
        }
#endif /* INSTALL_METADATA */
        op_extra_data->output_buffer[term_idx] = NULL;
        vol_ctrl_recalc_main_buffer_size(op_extra_data, terminal_id);
842009d0:	3b 00       	r1 = r5 + Null;
842009d2:	32 00       	r0 = r4 + Null;
842009d4:	05 f0 2d e0 	call (m) Lc_vol_ctrl_recalc_main_buffer_size_1;
842009d8:	9d 6f       	jump (m) Lc_vol_ctlr_disconnect_5;

842009da <Lc_vol_ctlr_disconnect_28>:
            vol_ctrl_recalc_main_buffer_size(op_extra_data, terminal_id);
        }
    }
    else
    {
        unsigned term_idx = terminal_id&TERMINAL_NUM_MASK;
842009da:	ba c2       	r0 = r5 AND 0x3f;
#ifdef INSTALL_METADATA
        if (op_extra_data->metadata_op_buffer == op_extra_data->output_buffer[term_idx])
842009dc:	53 54       	r1 = r0 LSHIFT 2;
842009de:	31 00       	rMAC = r4 + Null;
842009e0:	59 00       	rMAC = r1 + rMAC;
842009e2:	0c 30       	r2 = rMAC + 32;
842009e4:	f1 a8       	rMAC = M[r4 + 76];
842009e6:	23 e8       	r1 = M[r2 + Null];
842009e8:	c8 04       	Null = rMAC - r1;
842009ea:	0f 62       	if NE jump (m) Lc_vol_ctlr_disconnect_35;

842009ec <Lc_vol_ctlr_disconnect_29>:
        {
            unsigned i;
            bool found_alternative = FALSE;
            for (i = 0; i < VOL_CTRL_CONSTANT_NUM_CHANNELS; i++)
842009ec:	03 00       	r1 = Null + Null;
842009ee:	31 30       	rMAC = r4 + 32;

842009f0 <Lc_vol_ctlr_disconnect_30>:
            {
                if (i == term_idx)
842009f0:	98 04       	Null = r1 - r0;
842009f2:	06 60       	if EQ jump (m) Lc_vol_ctlr_disconnect_33;

842009f4 <Lc_vol_ctlr_disconnect_31>:
                {
                    continue;
                }
                if (op_extra_data->output_buffer[i] != NULL && buff_has_metadata(op_extra_data->output_buffer[i]))
842009f4:	0d e8       	r3 = M[rMAC + Null];
842009f6:	04 60       	if EQ jump (m) Lc_vol_ctlr_disconnect_33;

842009f8 <Lc_vol_ctlr_disconnect_32>:
842009f8:	6d 89       	r3 = M[r3 + 20];
842009fa:	6d c6       	r3 = r3 AND 0x8000;
842009fc:	0e 62       	if NE jump (m) Lc_vol_ctlr_disconnect_38;

842009fe <Lc_vol_ctlr_disconnect_33>:
#ifdef INSTALL_METADATA
        if (op_extra_data->metadata_op_buffer == op_extra_data->output_buffer[term_idx])
        {
            unsigned i;
            bool found_alternative = FALSE;
            for (i = 0; i < VOL_CTRL_CONSTANT_NUM_CHANNELS; i++)
842009fe:	5b 20       	r1 = r1 + 1;
84200a00:	09 21       	rMAC = rMAC + 4;
84200a02:	18 26       	Null = r1 - 8;
84200a04:	f6 65       	if NC jump (m) Lc_vol_ctlr_disconnect_30;

84200a06 <Lc_vol_ctlr_disconnect_34>:
                    break;
                }
            }
            if (!found_alternative)
            {
                op_extra_data->metadata_op_buffer = NULL;
84200a06:	f0 ae       	M[r4 + 76] = Null;

84200a08 <Lc_vol_ctlr_disconnect_35>:
            }
        }
#endif /* INSTALL_METADATA */
        op_extra_data->output_buffer[term_idx] = NULL;
84200a08:	20 ee       	M[r2 + Null] = Null;
84200a0a:	e3 6f       	jump (m) Lc_vol_ctlr_disconnect_27;

84200a0c <Lc_vol_ctlr_disconnect_36>:
                    {
                        continue;
                    }
                    if (aux_chan->buffer != NULL && buff_has_metadata(aux_chan->buffer))
                    {
                        op_extra_data->metadata_aux_channel = aux_chan;
84200a0c:	32 af       	M[r4 + 80] = r0;
                        found_alternative = TRUE;
                        break;
84200a0e:	b2 6f       	jump (m) Lc_vol_ctlr_disconnect_18;

84200a10 <Lc_vol_ctlr_disconnect_37>:
                    {
                        continue;
                    }
                    if (op_extra_data->input_buffer[i] != NULL && buff_has_metadata(op_extra_data->input_buffer[i]))
                    {
                        op_extra_data->metadata_ip_buffer = op_extra_data->input_buffer[i];
84200a10:	52 54       	r0 = r0 LSHIFT 2;
84200a12:	b1 e8       	rMAC = M[r4 + r0];
84200a14:	b1 ae       	M[r4 + 72] = rMAC;
                        found_alternative = TRUE;
                        break;
84200a16:	dc 6f       	jump (m) Lc_vol_ctlr_disconnect_26;

84200a18 <Lc_vol_ctlr_disconnect_38>:
                {
                    continue;
                }
                if (op_extra_data->output_buffer[i] != NULL && buff_has_metadata(op_extra_data->output_buffer[i]))
                {
                    op_extra_data->metadata_op_buffer = op_extra_data->output_buffer[i];
84200a18:	5a 54       	r0 = r1 LSHIFT 2;
84200a1a:	31 00       	rMAC = r4 + Null;
84200a1c:	51 00       	rMAC = r0 + rMAC;
84200a1e:	09 98       	rMAC = M[rMAC + 32];
84200a20:	f1 ae       	M[r4 + 76] = rMAC;
                    found_alternative = TRUE;
                    break;
84200a22:	f3 6f       	jump (m) Lc_vol_ctlr_disconnect_35;

84200a24 <Lc_vol_ctlr_disconnect_39>:
        op_extra_data->output_buffer[term_idx] = NULL;
        vol_ctrl_recalc_main_buffer_size(op_extra_data, terminal_id);
    }

    return TRUE;
}
84200a24:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84200a26:	d8 4c       	rts;

84200a28 <$_vol_ctlr_start>:

bool vol_ctlr_start(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200a28:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84200a2a:	17 00       	r5 = r0 + Null;
84200a2c:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
84200a2e:	ef fd fb ff 	call (m) 0x1e2;
84200a32:	35 ed 
84200a34:	16 00       	r4 = r0 + Null;

bool vol_ctlr_start(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);
    /* Setup Response to Start Request.   Assume Failure*/
    if (!base_op_build_std_response_ex(op_data, STATUS_OK, response_data))
84200a36:	03 00       	r1 = Null + Null;
84200a38:	44 08       	r2 = r6 + Null;
84200a3a:	3a 00       	r0 = r5 + Null;
84200a3c:	ef fd fb ff 	call (m) 0x1b8;
84200a40:	3d eb 
84200a42:	10 04       	Null = r0 - Null;
84200a44:	03 62       	if NE jump (m) Lc_vol_ctlr_start_3;

84200a46 <Lc_vol_ctlr_start_2>:
    {
        return FALSE;
84200a46:	02 00       	r0 = Null + Null;
84200a48:	39 6e       	jump (m) Lc_vol_ctlr_start_11;

84200a4a <Lc_vol_ctlr_start_3>:
    }

    if (opmgr_op_is_running(op_data))
84200a4a:	3a 00       	r0 = r5 + Null;
84200a4c:	ff fd 35 f0 	call (m) 0x7586;
84200a50:	3b e9 
84200a52:	10 04       	Null = r0 - Null;
84200a54:	32 62       	if NE jump (m) Lc_vol_ctlr_start_10;

84200a56 <Lc_vol_ctlr_start_4>:
    {
        return TRUE;
    }

    if (!setup_processing(op_extra_data))
84200a56:	32 00       	r0 = r4 + Null;
84200a58:	fd ff 39 ec 	call (m) .L0;
84200a5c:	10 04       	Null = r0 - Null;
84200a5e:	06 62       	if NE jump (m) Lc_vol_ctlr_start_6;

84200a60 <Lc_vol_ctlr_start_5>:
84200a60:	01 f0 00 60 	rMAC = Null + 4096;
84200a64:	82 f0 00 e8 	r0 = M[r6 + Null];
84200a68:	51 8e       	M[r0 + 4] = rMAC;

84200a6a <Lc_vol_ctlr_start_6>:
     *
     * User can set that via DOWNSTREAM_LATENCY_EST parameter, if hasn't
     * been set by the user we will find a suitable value.
     */
    op_extra_data->downstream_latency_estimate =
        VOL_CTRL_DOWNSTREAM_LATENCY_EST(op_extra_data)*MILLISECOND;
84200a6a:	61 f0 d2 88 	rMAC = M[r4 + 840];
84200a6e:	03 f0 e8 f1 	rMAC = rMAC * 1000 (int);
84200a72:	91 d9 
    if(0 == op_extra_data->downstream_latency_estimate &&
       NULL != op_extra_data->metadata_op_buffer)
84200a74:	61 f0 d0 8e 	M[r4 + 832] = rMAC;
84200a78:	18 62       	if NE jump (m) Lc_vol_ctlr_start_9;

84200a7a <Lc_vol_ctlr_start_7>:
84200a7a:	f2 a8       	r0 = M[r4 + 76];
84200a7c:	16 60       	if EQ jump (m) Lc_vol_ctlr_start_9;

84200a7e <Lc_vol_ctlr_start_8>:
        /* user hasn't set the parameter, a good achievable latency with the
         * assumption that the operator's output buffer is directly consumed
         * by a timed playback module at the end of chain is 75% of the buffers
         * size plus one system kick period.
         */
        unsigned buf_size = cbuffer_get_size_in_words(op_extra_data->metadata_op_buffer);
84200a7e:	ff fd 01 f0 	call (m) 0xc80;
84200a82:	23 e0 
84200a84:	10 09       	r6 = r0 + Null;
        op_extra_data->downstream_latency_estimate =
            convert_samples_to_time(buf_size, op_extra_data->sample_rate)*3/4 +
            stream_if_get_system_kick_period();
84200a86:	ff fd 4a f0 	call (m) 0x9f30;
84200a8a:	2b e5 
84200a8c:	17 00       	r5 = r0 + Null;
84200a8e:	63 f0 3b 88 	r1 = M[r4 + 236];
84200a92:	42 08       	r0 = r6 + Null;
84200a94:	ff fd b3 f0 	call (m) 0x17230;
84200a98:	3d ec 
84200a9a:	d2 40       	r0 = r0 * 3 (int);
84200a9c:	01 21       	rMAC = Null + 4;
84200a9e:	8a 4c       	Div = r0 / rMAC;
84200aa0:	c1 4c       	rMAC = DivResult;
84200aa2:	79 00       	rMAC = r5 + rMAC;
84200aa4:	61 f0 d0 8e 	M[r4 + 832] = rMAC;

84200aa8 <Lc_vol_ctlr_start_9>:
    }
    /* Reset timestamp references used for aux TTP*/
    op_extra_data->current_timestamp_valid = FALSE;
84200aa8:	60 f0 cd 8e 	M[r4 + 820] = Null;
    op_extra_data->main_timestamp_valid = FALSE;
84200aac:	60 f0 ca 8e 	M[r4 + 808] = Null;
    op_extra_data->prev_consumed_samples = 0;
84200ab0:	60 f0 cf 8e 	M[r4 + 828] = Null;
    op_extra_data->aux0_ttp.generate_ttp = FALSE;
84200ab4:	60 f0 c8 8e 	M[r4 + 800] = Null;

84200ab8 <Lc_vol_ctlr_start_10>:
        return FALSE;
    }

    if (opmgr_op_is_running(op_data))
    {
        return TRUE;
84200ab8:	42 20       	r0 = Null + 1;

84200aba <Lc_vol_ctlr_start_11>:
    op_extra_data->prev_consumed_samples = 0;
    op_extra_data->aux0_ttp.generate_ttp = FALSE;
#endif /* VOLUME_CONTROL_AUX_TTP_SUPPORT */

    return TRUE;
}
84200aba:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84200abc:	d8 4c       	rts;

84200abe <$_vol_ctlr_buffer_details>:
    return TRUE;
}


bool vol_ctlr_buffer_details(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200abe:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
84200ac0:	12 09       	r8 = r0 + Null;
84200ac2:	18 09       	r6 = r1 + Null;
84200ac4:	23 09       	r9 = r2 + Null;
84200ac6:	29 09       	r7 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
84200ac8:	ef fd fb ff 	call (m) 0x1e2;
84200acc:	3b e8 
84200ace:	17 00       	r5 = r0 + Null;
bool vol_ctlr_buffer_details(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    VOL_CTRL_DATA_T* opx_data = get_instance_data(op_data);
    OP_BUF_DETAILS_RSP *resp;
    unsigned buffer_size, base_buffer_size;
    unsigned terminal_id = OPMGR_GET_OP_BUF_DETAILS_TERMINAL_ID(message_data);
84200ad0:	86 f0 00 e8 	r4 = M[r6 + Null];
#if !defined(DISABLE_IN_PLACE) && !defined(VC_NOT_RUN_IN_PLACE)
    unsigned term_idx;
#endif /* !defined(DISABLE_IN_PLACE) && !defined(VC_NOT_RUN_IN_PLACE) */

    if (!base_op_buffer_details(op_data, message_data, response_id, response_data))
84200ad4:	4d 08       	r3 = r7 + Null;
84200ad6:	5c 08       	r2 = r9 + Null;
84200ad8:	43 08       	r1 = r6 + Null;
84200ada:	52 08       	r0 = r8 + Null;
84200adc:	ef fd fa ff 	call (m) 0x78;
84200ae0:	3d ec 
84200ae2:	10 04       	Null = r0 - Null;
84200ae4:	03 62       	if NE jump (m) Lc_vol_ctlr_buffer_details_3;

84200ae6 <Lc_vol_ctlr_buffer_details_2>:
    {
        return FALSE;
84200ae6:	02 00       	r0 = Null + Null;
84200ae8:	57 6e       	jump (m) Lc_vol_ctlr_buffer_details_20;

84200aea <Lc_vol_ctlr_buffer_details_3>:
    }

    resp = (OP_BUF_DETAILS_RSP*)*response_data;
84200aea:	94 f0 00 e8 	r2 = M[r7 + Null];
    base_buffer_size = resp->b.buffer_size;
84200aee:	21 89       	rMAC = M[r2 + 16];
        /* If an input/output connection is already present and has metadata then
         * we are obliged to return that buffer so that metadata can be shared
         * between channels. */
        tCbuffer *meta_buff;

        if ((terminal_id & TERMINAL_SINK_MASK) == TERMINAL_SINK_MASK)
84200af0:	40 f0 62 f0 	r0 = r4 AND 0x800000;
84200af4:	00 00 
84200af6:	31 60       	if EQ jump (m) Lc_vol_ctlr_buffer_details_16;

84200af8 <Lc_vol_ctlr_buffer_details_4>:
        {
            /* Only the main input channels consume metadata, the aux inputs do not */
            if ((terminal_id & 0x1) == 0)
84200af8:	32 c0       	r0 = r4 AND 0x1;
84200afa:	03 62       	if NE jump (m) Lc_vol_ctlr_buffer_details_6;

84200afc <Lc_vol_ctlr_buffer_details_5>:
            {
                meta_buff = opx_data->metadata_ip_buffer;
84200afc:	ba a8       	r0 = M[r5 + 72];
84200afe:	06 6e       	jump (m) Lc_vol_ctlr_buffer_details_9;

84200b00 <Lc_vol_ctlr_buffer_details_6>:
                resp->supports_metadata = TRUE;
            }
            else
            {
                if(NULL != opx_data->metadata_aux_channel)
84200b00:	3a a9       	r0 = M[r5 + 80];
84200b02:	03 60       	if EQ jump (m) Lc_vol_ctlr_buffer_details_8;

84200b04 <Lc_vol_ctlr_buffer_details_7>:
                {
                    meta_buff = opx_data->metadata_aux_channel->buffer;
84200b04:	12 e8       	r0 = M[r0 + Null];
84200b06:	02 6e       	jump (m) Lc_vol_ctlr_buffer_details_9;

84200b08 <Lc_vol_ctlr_buffer_details_8>:
                }
                else
                {
                    meta_buff = NULL;
84200b08:	02 00       	r0 = Null + Null;

84200b0a <Lc_vol_ctlr_buffer_details_9>:
            }
        }
        else
        {
            meta_buff = opx_data->metadata_op_buffer;
            resp->supports_metadata = TRUE;
84200b0a:	23 92       	r1 = MBU[r2 + 8];
84200b0c:	33 ff ef 1f 	r1 = r1 AND 0xffffffef;
84200b10:	db c9       	r1 = r1 OR 0x10;
84200b12:	23 9a       	MB[r2 + 8] = r1;
        }

        resp->metadata_buffer = meta_buff;
84200b14:	e2 8e       	M[r2 + 12] = r0;

    }
#endif /* INSTALL_METADATA */

    /* buffer size of 2.5ms worth at the sample rate of the operator */
    buffer_size = frac_mult(opx_data->sample_rate,FRACTIONAL(0.0025));
84200b16:	72 f0 3b 88 	r0 = M[r5 + 236];
84200b1a:	05 f0 f3 f0 	r1 = Null + 5368709;
84200b1e:	85 53 
84200b20:	00 f3 72 c9 	r0 = r0 * r1 (frac);

    if (buffer_size==0)
84200b24:	10 04       	Null = r0 - Null;
84200b26:	03 62       	if NE jump (m) Lc_vol_ctlr_buffer_details_11;

84200b28 <Lc_vol_ctlr_buffer_details_10>:
    {
        buffer_size = VOL_CTRL_BUFFER_SIZE;
84200b28:	02 f0 80 40 	r0 = Null + 128;

84200b2c <Lc_vol_ctlr_buffer_details_11>:
    }

    if (buffer_size < base_buffer_size)
84200b2c:	50 04       	Null = r0 - rMAC;
84200b2e:	02 f0 87 e0 	if C jump (m) Lc_vol_ctlr_buffer_details_13;

84200b32 <Lc_vol_ctlr_buffer_details_12>:
    {
        buffer_size = base_buffer_size;
84200b32:	0a 00       	r0 = rMAC + Null;

84200b34 <Lc_vol_ctlr_buffer_details_13>:
    }
#if !defined(DISABLE_IN_PLACE) && !defined(VC_NOT_RUN_IN_PLACE)
    if(terminal_id&TERMINAL_SINK_MASK)
84200b34:	40 f0 61 f0 	rMAC = r4 AND 0x800000;
84200b38:	00 00 
84200b3a:	1a 60       	if EQ jump (m) Lc_vol_ctlr_buffer_details_18;

84200b3c <Lc_vol_ctlr_buffer_details_14>:
    {
        if(terminal_id&0x1)
84200b3c:	31 c0       	rMAC = r4 AND 0x1;
84200b3e:	0f 60       	if EQ jump (m) Lc_vol_ctlr_buffer_details_17;

84200b40 <Lc_vol_ctlr_buffer_details_15>:
        {
            /* Don't run in place on the aux inputs. */
            resp->runs_in_place = FALSE;
84200b40:	21 92       	rMAC = MBU[r2 + 8];
84200b42:	11 ff f7 1f 	rMAC = rMAC AND 0xfffffff7;
84200b46:	21 9a       	MB[r2 + 8] = rMAC;

            /* Set the asked buffer size. */
            resp->b.buffer_size = buffer_size;
84200b48:	22 8f       	M[r2 + 16] = r0;
            opx_data->aux_buff_size = buffer_size;
84200b4a:	72 f0 bb 8e 	M[r5 + 748] = r0;

            return vol_ctrl_fixup_buffer_details(opx_data, terminal_id, resp);
84200b4e:	33 00       	r1 = r4 + Null;
84200b50:	3a 00       	r0 = r5 + Null;
84200b52:	04 f0 2b e4 	call (m) Lc_vol_ctrl_fixup_buffer_details_1;
84200b56:	20 6e       	jump (m) Lc_vol_ctlr_buffer_details_20;

84200b58 <Lc_vol_ctlr_buffer_details_16>:
                resp->supports_metadata = TRUE;
            }
        }
        else
        {
            meta_buff = opx_data->metadata_op_buffer;
84200b58:	fa a8       	r0 = M[r5 + 76];
84200b5a:	d8 6f       	jump (m) Lc_vol_ctlr_buffer_details_9;

84200b5c <Lc_vol_ctlr_buffer_details_17>:

            return vol_ctrl_fixup_buffer_details(opx_data, terminal_id, resp);
        }
        else
        {
            term_idx = (terminal_id&TERMINAL_NUM_MASK)>>1;
84200b5c:	33 50       	r1 = r4 LSHIFT -1;
84200b5e:	1b c2       	r1 = r1 AND 0x1f;

            /*input terminal. give the output buffer for the channel */
            resp->b.in_place_buff_params.buffer = opx_data->output_buffer[term_idx] ;
84200b60:	5d 54       	r3 = r1 LSHIFT 2;
84200b62:	39 00       	rMAC = r5 + Null;
84200b64:	69 00       	rMAC = r3 + rMAC;
84200b66:	09 98       	rMAC = M[rMAC + 32];
84200b68:	a1 8f       	M[r2 + 24] = rMAC;

            /* Choose terminal associated with the term_idx. */
            resp->b.in_place_buff_params.in_place_terminal = term_idx;
84200b6a:	23 8f       	M[r2 + 16] = r1;
84200b6c:	0b 6e       	jump (m) Lc_vol_ctlr_buffer_details_19;

84200b6e <Lc_vol_ctlr_buffer_details_18>:
        }
    }
    else
    {
        /* The output terminal index is directly mapped to the input_buffer array */
        unsigned buffer_idx = (terminal_id&TERMINAL_NUM_MASK);
84200b6e:	b3 c2       	r1 = r4 AND 0x3f;
        /* The input terminal index is the buffer index multiplied by 2. */
        term_idx = buffer_idx << 1;
84200b70:	1d 54       	r3 = r1 LSHIFT 1;

        /*output terminal. give the input buffer for the channel */
        resp->b.in_place_buff_params.buffer = opx_data->input_buffer[buffer_idx];
84200b72:	5b 54       	r1 = r1 LSHIFT 2;
84200b74:	f9 e8       	rMAC = M[r5 + r1];
84200b76:	a1 8f       	M[r2 + 24] = rMAC;

        /* Choose terminal associated with the term_idx. */
        resp->b.in_place_buff_params.in_place_terminal = term_idx | TERMINAL_SINK_MASK;
84200b78:	08 f0 00 f0 	rMAC = r3 OR 0x800000;
84200b7c:	00 f5 51 c8 
84200b80:	21 8f       	M[r2 + 16] = rMAC;

84200b82 <Lc_vol_ctlr_buffer_details_19>:
    }

    /* Run in place*/
    resp->runs_in_place = TRUE;
84200b82:	21 92       	rMAC = MBU[r2 + 8];
84200b84:	11 ff f7 1f 	rMAC = rMAC AND 0xfffffff7;
84200b88:	49 c9       	rMAC = rMAC OR 0x8;
84200b8a:	21 9a       	MB[r2 + 8] = rMAC;

    /* Set the asked buffer size. */
    resp->b.in_place_buff_params.size = buffer_size;
84200b8c:	62 8f       	M[r2 + 20] = r0;

#else  /* !defined(DISABLE_IN_PLACE) && !defined(VC_NOT_RUN_IN_PLACE) */
    resp->b.buffer_size = buffer_size;
#endif /* !defined(DISABLE_IN_PLACE) && !defined(VC_NOT_RUN_IN_PLACE) */

    return vol_ctrl_fixup_buffer_details(opx_data, terminal_id, resp);
84200b8e:	33 00       	r1 = r4 + Null;
84200b90:	3a 00       	r0 = r5 + Null;
84200b92:	04 f0 2b e2 	call (m) Lc_vol_ctrl_fixup_buffer_details_1;

84200b96 <Lc_vol_ctlr_buffer_details_20>:
}
84200b96:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200b98:	d8 4c       	rts;

84200b9a <$_vol_ctlr_get_sched_info>:

    return TRUE;
}

bool vol_ctlr_get_sched_info(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200b9a:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84200b9c:	17 00       	r5 = r0 + Null;
84200b9e:	2e 00       	r4 = r3 + Null;
    OP_SCHED_INFO_RSP* resp;

    resp = base_op_get_sched_info_ex(op_data, message_data, response_id);
84200ba0:	ef fd fa ff 	call (m) 0x118;
84200ba4:	39 eb 
    if (resp == NULL)
84200ba6:	10 04       	Null = r0 - Null;
84200ba8:	09 62       	if NE jump (m) Lc_vol_ctlr_get_sched_info_3;

84200baa <Lc_vol_ctlr_get_sched_info_2>:
    {
        return base_op_build_std_response_ex(op_data, STATUS_CMD_FAILED, response_data);
84200baa:	03 f0 00 60 	r1 = Null + 4096;
84200bae:	34 00       	r2 = r4 + Null;
84200bb0:	3a 00       	r0 = r5 + Null;
84200bb2:	ef fd fb ff 	call (m) 0x1b8;
84200bb6:	27 e0 
84200bb8:	05 6e       	jump (m) Lc_vol_ctlr_get_sched_info_4;

84200bba <Lc_vol_ctlr_get_sched_info_3>:
    }
    *response_data = resp;
84200bba:	32 ee       	M[r4 + Null] = r0;

    resp->block_size = VOL_CTRL_BLOCK_SIZE;
84200bbc:	41 20       	rMAC = Null + 1;
84200bbe:	91 8e       	M[r0 + 8] = rMAC;

    return TRUE;
84200bc0:	0a 00       	r0 = rMAC + Null;

84200bc2 <Lc_vol_ctlr_get_sched_info_4>:
}
84200bc2:	f2 48       	popm <FP, r4, r5, rLink>;
84200bc4:	d8 4c       	rts;

84200bc6 <$_vol_ctlr_timer_task>:

    return TRUE;
}

void vol_ctlr_timer_task(void *kick_object)
{
84200bc6:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84200bc8:	16 00       	r4 = r0 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
84200bca:	ef fd fb ff 	call (m) 0x1e2;
84200bce:	39 e0 
84200bd0:	17 00       	r5 = r0 + Null;
    OPERATOR_DATA *op_data = (OPERATOR_DATA*) kick_object;
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);

    patch_fn_shared(volume_control_wrapper);

    base_op_profiler_start(op_data);
84200bd2:	32 00       	r0 = r4 + Null;
84200bd4:	ef fd fb ff 	call (m) 0x21e;
84200bd8:	2b e2 

    op_extra_data->pending_timer = TIMER_ID_INVALID;
84200bda:	70 f0 be 8e 	M[r5 + 760] = Null;

    /* Raise a bg int to process */
    opmgr_kick_operator(op_data);
84200bde:	32 00       	r0 = r4 + Null;
84200be0:	ff fd 25 f0 	call (m) 0x5602;
84200be4:	23 e1 

    base_op_profiler_stop(op_data);
84200be6:	32 00       	r0 = r4 + Null;
84200be8:	ef fd fb ff 	call (m) 0x22c;
84200bec:	25 e2 

84200bee <Lc_vol_ctlr_timer_task_2>:
}
84200bee:	f2 48       	popm <FP, r4, r5, rLink>;
84200bf0:	d8 4c       	rts;

84200bf2 <$_vol_ctlr_process_data>:
}
#endif

RUN_FROM_PM_RAM
void vol_ctlr_process_data(OPERATOR_DATA *op_data, TOUCHED_TERMINALS *touched)
{
84200bf2:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
84200bf4:	42 de       	M[FP + 32] = r0;
84200bf6:	4b de       	M[FP + 36] = r1;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
84200bf8:	ef fd fa ff 	call (m) 0x1e2;
84200bfc:	2b ef 
84200bfe:	12 09       	r8 = r0 + Null;
    unsigned         i,samples_to_process,num_channels,amount,touched_sink;
    unsigned         block_size = VOL_CTRL_BLOCK_SIZE;

    patch_fn(volume_control_process_data_patch);

    op_extra_data->used_all_input = FALSE;
84200c00:	a0 f0 bd 8e 	M[r8 + 756] = Null;


#ifdef VOLUME_CONTROL_AUX_TTP_SUPPORT
    /* update timestamp for using aux TTP */
    vol_ctrl_update_current_timestamp(op_extra_data);
84200c04:	04 f0 31 ec 	call (m) Lc_vol_ctrl_update_current_timestamp_1;
#endif

    /* Accelerators for data/space */
    samples_to_process = MAXINT;
84200c08:	ff f7 f6 f7 	r4 = Null + 2147483647;
84200c0c:	ff 7b 
    if(op_extra_data->stream_based)
84200c0e:	a0 f0 c3 88 	Null = M[r8 + 780];
84200c12:	03 60       	if EQ jump (m) Lc_vol_ctlr_process_data_3;

84200c14 <Lc_vol_ctlr_process_data_2>:
    {
        num_channels = 1;
84200c14:	0b 71       	r9 = Null + 1;
84200c16:	25 6e       	jump (m) Lc_vol_ctlr_process_data_12;

84200c18 <Lc_vol_ctlr_process_data_3>:
    }
    else
    {
        if(op_extra_data->wait_on_space_buffer)
84200c18:	a2 f0 10 88 	r0 = M[r8 + 64];
84200c1c:	0f 60       	if EQ jump (m) Lc_vol_ctlr_process_data_7;

84200c1e <Lc_vol_ctlr_process_data_4>:
        {
            samples_to_process = cbuffer_calc_amount_space_in_words(op_extra_data->wait_on_space_buffer);
84200c1e:	ff fd 9d f1 	call (m) 0x347f8;
84200c22:	3b ee 
84200c24:	16 00       	r4 = r0 + Null;
            if(samples_to_process<block_size)
84200c26:	08 62       	if NE jump (m) Lc_vol_ctlr_process_data_6;

84200c28 <Lc_vol_ctlr_process_data_5>:
            {
                vol_ctrl_kick_waiting(op_extra_data, touched, VOL_CTRL_KICK_WAIT_ON_SPACE_LATE);
84200c28:	c4 20       	r2 = Null + 3;
84200c2a:	52 08       	r0 = r8 + Null;
84200c2c:	4b d8       	r1 = M[FP + 36];
84200c2e:	03 f0 29 ef 	call (m) Lc_vol_ctrl_kick_waiting_1;
84200c32:	0f f0 b3 e6 	jump (m) Lc_vol_ctlr_process_data_73;

84200c36 <Lc_vol_ctlr_process_data_6>:
                return;
            }
            op_extra_data->wait_on_space_buffer=NULL;
84200c36:	a0 f0 10 8e 	M[r8 + 64] = Null;

84200c3a <Lc_vol_ctlr_process_data_7>:
        }
        if(op_extra_data->wait_on_data_buffer)
84200c3a:	a2 f0 11 88 	r0 = M[r8 + 68];
84200c3e:	0f 60       	if EQ jump (m) Lc_vol_ctlr_process_data_11;

84200c40 <Lc_vol_ctlr_process_data_8>:
        {
            amount = cbuffer_calc_amount_data_in_words(op_extra_data->wait_on_data_buffer);
84200c40:	ff fd 9e f1 	call (m) 0x34844;
84200c44:	25 e0 
            if(amount<block_size)
84200c46:	10 04       	Null = r0 - Null;
84200c48:	08 62       	if NE jump (m) Lc_vol_ctlr_process_data_10;

84200c4a <Lc_vol_ctlr_process_data_9>:
            {
                vol_ctrl_kick_waiting(op_extra_data, touched, VOL_CTRL_KICK_WAIT_ON_DATA_LATE);
84200c4a:	84 20       	r2 = Null + 2;
84200c4c:	52 08       	r0 = r8 + Null;
84200c4e:	4b d8       	r1 = M[FP + 36];
84200c50:	03 f0 27 ee 	call (m) Lc_vol_ctrl_kick_waiting_1;
84200c54:	0f f0 91 e6 	jump (m) Lc_vol_ctlr_process_data_73;

84200c58 <Lc_vol_ctlr_process_data_10>:
                return;
            }
            op_extra_data->wait_on_data_buffer=NULL;
84200c58:	a0 f0 11 8e 	M[r8 + 68] = Null;

84200c5c <Lc_vol_ctlr_process_data_11>:
        }
        num_channels = op_extra_data->num_channels;
84200c5c:	ab f0 17 88 	r9 = M[r8 + 92];

84200c60 <Lc_vol_ctlr_process_data_12>:
84200c60:	41 20       	rMAC = Null + 1;
84200c62:	51 de       	M[FP + 40] = rMAC;
    }

    /* Compute channel transfer amount */
    for(i=0;i<num_channels;i++)
84200c64:	07 00       	r5 = Null + Null;
84200c66:	05 6e       	jump (m) Lc_vol_ctlr_process_data_15;

84200c68 <Lc_vol_ctlr_process_data_13>:
            {
                op_extra_data->wait_on_space_buffer = buffer;
                vol_ctrl_kick_waiting(op_extra_data, touched, VOL_CTRL_KICK_WAIT_ON_SPACE);
                return;
            }
            samples_to_process=amount;
84200c68:	16 00       	r4 = r0 + Null;
            op_extra_data->used_all_input = FALSE;
84200c6a:	a0 f0 bd 8e 	M[r8 + 756] = Null;

84200c6e <Lc_vol_ctlr_process_data_14>:
        }
        num_channels = op_extra_data->num_channels;
    }

    /* Compute channel transfer amount */
    for(i=0;i<num_channels;i++)
84200c6e:	7f 20       	r5 = r5 + 1;

84200c70 <Lc_vol_ctlr_process_data_15>:
84200c70:	bf f7 00 c2 	Null = r5 - r9;
84200c74:	02 f0 ef e0 	if C jump (m) Lc_vol_ctlr_process_data_23;

84200c78 <Lc_vol_ctlr_process_data_16>:
    {
        unsigned term_idx = op_extra_data->channels[i].chan_idx;
84200c78:	a1 f0 1a 88 	rMAC = M[r8 + 104];
84200c7c:	12 f7 92 c9 	r0 = r5 * 36 (int);
84200c80:	8a e8       	r0 = M[rMAC + r0];
        tCbuffer *buffer;

      buffer = op_extra_data->input_buffer[term_idx];
84200c82:	52 54       	r0 = r0 LSHIFT 2;
84200c84:	51 08       	rMAC = r8 + Null;
84200c86:	51 00       	rMAC = r0 + rMAC;
84200c88:	08 09       	r6 = rMAC + Null;
84200c8a:	89 f0 00 e8 	r7 = M[r6 + Null];
      amount = cbuffer_calc_amount_data_in_words(buffer);
84200c8e:	4a 08       	r0 = r7 + Null;
84200c90:	ff fd 9d f1 	call (m) 0x34844;
84200c94:	35 ed 
      if(amount<=samples_to_process)
84200c96:	90 05       	Null = r0 - r4;
84200c98:	08 f0 a3 e0 	if HI jump (m) Lc_vol_ctlr_process_data_20;

84200c9c <Lc_vol_ctlr_process_data_17>:
      {
            if(amount < block_size)
84200c9c:	10 04       	Null = r0 - Null;
84200c9e:	0a 62       	if NE jump (m) Lc_vol_ctlr_process_data_19;

84200ca0 <Lc_vol_ctlr_process_data_18>:
            {
                op_extra_data->wait_on_data_buffer = buffer;
84200ca0:	a9 f0 11 8e 	M[r8 + 68] = r7;
                vol_ctrl_kick_waiting(op_extra_data, touched, VOL_CTRL_KICK_WAIT_ON_DATA);
84200ca4:	04 00       	r2 = Null + Null;
84200ca6:	52 08       	r0 = r8 + Null;
84200ca8:	4b d8       	r1 = M[FP + 36];
84200caa:	03 f0 2d eb 	call (m) Lc_vol_ctrl_kick_waiting_1;
84200cae:	0f f0 b7 e5 	jump (m) Lc_vol_ctlr_process_data_73;

84200cb2 <Lc_vol_ctlr_process_data_19>:
                return;
            }
            samples_to_process=amount;
84200cb2:	16 00       	r4 = r0 + Null;
            op_extra_data->used_all_input = TRUE;
84200cb4:	51 d8       	rMAC = M[FP + 40];
84200cb6:	a1 f0 bd 8e 	M[r8 + 756] = rMAC;

84200cba <Lc_vol_ctlr_process_data_20>:
        }

        buffer = op_extra_data->output_buffer[term_idx];
84200cba:	88 f0 08 88 	r6 = M[r6 + 32];
        amount = cbuffer_calc_amount_space_in_words(buffer);
84200cbe:	42 08       	r0 = r6 + Null;
84200cc0:	ff fd 9d f1 	call (m) 0x347f8;
84200cc4:	39 e9 

        /* Relatively likely to need changes below */
        patch_fn(volume_control_adjust_amount);

        if(amount<samples_to_process)
84200cc6:	90 05       	Null = r0 - r4;
84200cc8:	f2 ff a7 ef 	if C jump (m) Lc_vol_ctlr_process_data_14;

84200ccc <Lc_vol_ctlr_process_data_21>:
        {
            if(amount<block_size)
84200ccc:	10 04       	Null = r0 - Null;
84200cce:	cd 63       	if NE jump (m) Lc_vol_ctlr_process_data_13;

84200cd0 <Lc_vol_ctlr_process_data_22>:
            {
                op_extra_data->wait_on_space_buffer = buffer;
84200cd0:	a8 f0 10 8e 	M[r8 + 64] = r6;
                vol_ctrl_kick_waiting(op_extra_data, touched, VOL_CTRL_KICK_WAIT_ON_SPACE);
84200cd4:	44 20       	r2 = Null + 1;
84200cd6:	52 08       	r0 = r8 + Null;
84200cd8:	4b d8       	r1 = M[FP + 36];
84200cda:	03 f0 3d e9 	call (m) Lc_vol_ctrl_kick_waiting_1;
84200cde:	0f f0 87 e5 	jump (m) Lc_vol_ctlr_process_data_73;

84200ce2 <Lc_vol_ctlr_process_data_23>:
    }

    /* Update AUX state.
       If the aux stream doesn't have enough data it indicates a state change */
    unsigned aux_check = (op_extra_data->aux_active | op_extra_data->aux_connected)
        & VOL_CTRL_CHANNEL_MASK;
84200ce2:	a1 f0 b8 88 	rMAC = M[r8 + 736];
84200ce6:	a2 f0 b7 88 	r0 = M[r8 + 732];
84200cea:	89 12       	rMAC = rMAC OR r0;
84200cec:	89 c3       	rMAC = rMAC AND 0xff;
84200cee:	59 de       	M[FP + 44] = rMAC;

    /* Relatively likely to need changes below */
    patch_fn(volume_control_aux_check);

    op_extra_data->tc.num_words = samples_to_process;
84200cf0:	a6 f0 b2 8e 	M[r8 + 712] = r4;

    if (aux_check != 0)
84200cf4:	08 04       	Null = rMAC - Null;
84200cf6:	cd 60       	if EQ jump (m) Lc_vol_ctlr_process_data_54;

84200cf8 <Lc_vol_ctlr_process_data_24>:
    {
        vol_ctrl_aux_channel_t* aux_ch;
        unsigned aux_kick = 0;
84200cf8:	01 09       	r7 = Null + Null;
        unsigned aux_limit = MAXINT;
84200cfa:	ff f7 fb f7 	r9 = Null + 2147483647;
84200cfe:	ff 7b 

        for (i = 0, aux_ch = &op_extra_data->aux_channel[0];
84200d00:	00 09       	r6 = Null + Null;
84200d02:	a7 f0 6c 20 	r5 = r8 + 108;

84200d06 <Lc_vol_ctlr_process_data_25>:
             i < VOL_CTRL_CONSTANT_NUM_CHANNELS;
             i += 1, aux_ch += 1)
        {
            if (aux_ch->buffer == NULL)
84200d06:	3a e8       	r0 = M[r5 + Null];
84200d08:	03 62       	if NE jump (m) Lc_vol_ctlr_process_data_27;

84200d0a <Lc_vol_ctlr_process_data_26>:
            {
                aux_ch->advance_buffer = 0;
84200d0a:	f8 8e       	M[r5 + 12] = Null;
84200d0c:	21 6e       	jump (m) Lc_vol_ctlr_process_data_32;

84200d0e <Lc_vol_ctlr_process_data_27>:
            }
            else
            {
                amount = cbuffer_calc_amount_data_in_words(aux_ch->buffer);
84200d0e:	ff fd 9d f1 	call (m) 0x34844;
84200d12:	37 e9 
84200d14:	14 00       	r2 = r0 + Null;

                /* Kick back any aux inputs which have no data, regardless
                 * of state. This helps to prime aux sources which have not
                 * started yet, or recover from false stall detections.
                 */
                if (amount == 0)
84200d16:	fc 8e       	M[r5 + 12] = r2;
84200d18:	0a 62       	if NE jump (m) Lc_vol_ctlr_process_data_29;

84200d1a <Lc_vol_ctlr_process_data_28>:
                {
                    touched->sinks |= (2 << (2 * i));
84200d1a:	00 f8 d2 d8 	r0 = r6 LSHIFT 1;
84200d1e:	49 d8       	rMAC = M[FP + 36];
84200d20:	01 f2 92 ce 	r0 = 0x2 LSHIFT r0;
84200d24:	49 88       	rMAC = M[rMAC + 4];
84200d26:	89 12       	rMAC = rMAC OR r0;
84200d28:	4a d8       	r0 = M[FP + 36];
84200d2a:	51 8e       	M[r0 + 4] = rMAC;

84200d2c <Lc_vol_ctlr_process_data_29>:
                }

                /* Only active aux inputs limit the amount of data to process,
                 * because in other states, aux data is not consumed.
                 */
                if (aux_ch->state == AUX_STATE_IN_AUX)
84200d2c:	39 81       	rMAC = MBS[r5 + 4];
84200d2e:	88 24       	Null = rMAC - 2;
84200d30:	0f 62       	if NE jump (m) Lc_vol_ctlr_process_data_32;

84200d32 <Lc_vol_ctlr_process_data_30>:
                {
                    aux_limit = pl_min(aux_limit, amount);
84200d32:	5b 08       	r1 = r9 + Null;
84200d34:	22 00       	r0 = r2 + Null;
84200d36:	5f f2 43 ce 	r1 = MIN r0;
84200d3a:	1b 09       	r9 = r1 + Null;
                    if (amount < samples_to_process)
84200d3c:	a0 05       	Null = r2 - r4;
84200d3e:	02 f0 91 e0 	if C jump (m) Lc_vol_ctlr_process_data_32;

84200d42 <Lc_vol_ctlr_process_data_31>:
                    {
                        aux_kick |= (2 << (2 * i));
84200d42:	00 f8 d2 d8 	r0 = r6 LSHIFT 1;
84200d46:	01 f2 92 ce 	r0 = 0x2 LSHIFT r0;
84200d4a:	00 f2 79 c8 	r7 = r7 OR r0;

84200d4e <Lc_vol_ctlr_process_data_32>:
        unsigned aux_kick = 0;
        unsigned aux_limit = MAXINT;

        for (i = 0, aux_ch = &op_extra_data->aux_channel[0];
             i < VOL_CTRL_CONSTANT_NUM_CHANNELS;
             i += 1, aux_ch += 1)
84200d4e:	08 75       	r6 = r6 + 1;
84200d50:	3f 28       	r5 = r5 + 16;
        vol_ctrl_aux_channel_t* aux_ch;
        unsigned aux_kick = 0;
        unsigned aux_limit = MAXINT;

        for (i = 0, aux_ch = &op_extra_data->aux_channel[0];
             i < VOL_CTRL_CONSTANT_NUM_CHANNELS;
84200d52:	80 f0 08 24 	Null = r6 - 8;
84200d56:	d8 65       	if NC jump (m) Lc_vol_ctlr_process_data_25;

84200d58 <Lc_vol_ctlr_process_data_33>:
         * 1/2 kick period of being kicked backwards (details see B-255916).
         * Currently there is one overall state for aux_pending, which means
         * that the handling of more than one independent aux source is
         * likely to be flawed (B-255917).
         */
        if (aux_limit >= samples_to_process)
84200d58:	6f fb 00 c2 	Null = r9 - r4;
84200d5c:	04 64       	if NC jump (m) Lc_vol_ctlr_process_data_35;

84200d5e <Lc_vol_ctlr_process_data_34>:
        {
            op_extra_data->aux_pending = FALSE;
84200d5e:	a0 f0 bc 8e 	M[r8 + 752] = Null;
84200d62:	44 6e       	jump (m) Lc_vol_ctlr_process_data_43;

84200d64 <Lc_vol_ctlr_process_data_35>:
        }
        else
        {
            if (op_extra_data->aux_pending && (aux_limit == 0))
84200d64:	a0 f0 bc 88 	Null = M[r8 + 752];
84200d68:	1d 60       	if EQ jump (m) Lc_vol_ctlr_process_data_42;

84200d6a <Lc_vol_ctlr_process_data_36>:
84200d6a:	0f fb 00 c2 	Null = r9 - Null;
84200d6e:	0a 62       	if NE jump (m) Lc_vol_ctlr_process_data_39;

84200d70 <Lc_vol_ctlr_process_data_37>:
            {
                /* Since entering aux_pending state, no aux data has arrived */
                if (op_extra_data->pending_timer != TIMER_ID_INVALID)
84200d70:	a0 f0 be 88 	Null = M[r8 + 760];
84200d74:	f5 61       	if EQ jump (m) Lc_vol_ctlr_process_data_34;

84200d76 <Lc_vol_ctlr_process_data_38>:
                {
                    vol_ctrl_kick_waiting(op_extra_data, touched, VOL_CTRL_KICK_STILL_AUX_PENDING);
84200d76:	44 21       	r2 = Null + 5;
84200d78:	52 08       	r0 = r8 + Null;
84200d7a:	4b d8       	r1 = M[FP + 36];
84200d7c:	03 f0 3b e4 	call (m) Lc_vol_ctrl_kick_waiting_1;
84200d80:	f2 6e       	jump (m) Lc_vol_ctlr_process_data_73;

84200d82 <Lc_vol_ctlr_process_data_39>:
            else
            {
                if (op_extra_data->aux_pending)
                {
                    /* Cleanup the timer before restarting it */
                    timer_cancel_event_atomic(&op_extra_data->pending_timer);
84200d82:	a6 f0 f8 22 	r4 = r8 + 760;
    (void) timer_cancel_event_ret(timer_id, NULL, NULL);
}

INLINE_SECTION static inline void timer_cancel_event_atomic(tTimerId *timer_id)
{
    interrupt_block();
84200d86:	ff fd a9 f1 	call (m) 0x360c6;
84200d8a:	21 ea 
    if (*timer_id != TIMER_ID_INVALID)
84200d8c:	32 e8       	r0 = M[r4 + Null];
84200d8e:	07 60       	if EQ jump (m) Lc_vol_ctlr_process_data_41;

84200d90 <Lc_vol_ctlr_process_data_40>:
    {
        (void) timer_cancel_event_ret(*timer_id, NULL, NULL);
84200d90:	04 00       	r2 = Null + Null;
84200d92:	03 00       	r1 = Null + Null;
84200d94:	ff fd 39 f0 	call (m) 0x80e0;
84200d98:	2d ea 
        *timer_id = TIMER_ID_INVALID;
84200d9a:	30 ee       	M[r4 + Null] = Null;

84200d9c <Lc_vol_ctlr_process_data_41>:
    }
    interrupt_unblock();
84200d9c:	ff fd a9 f1 	call (m) 0x360e2;
84200da0:	27 ea 

84200da2 <Lc_vol_ctlr_process_data_42>:
                }

                /* (Re-)Start aux_pending */
                touched->sinks |= aux_kick;
84200da2:	49 d8       	rMAC = M[FP + 36];
84200da4:	0a 00       	r0 = rMAC + Null;
84200da6:	49 88       	rMAC = M[rMAC + 4];
84200da8:	00 f9 71 c8 	rMAC = rMAC OR r7;
84200dac:	51 8e       	M[r0 + 4] = rMAC;
                op_extra_data->pending_timer = timer_schedule_event_in(
                    stream_if_get_system_kick_period() / 2,
                    vol_ctlr_timer_task, (void*)op_data );
84200dae:	ff fd 48 f0 	call (m) 0x9f30;
84200db2:	23 ec 
84200db4:	42 f0 06 f0 	r4 = Null + 69209031;
84200db8:	c7 53 
84200dba:	93 53       	r1 = r0 LSHIFT -31;
84200dbc:	9a 00       	r0 = r1 + r0;
84200dbe:	17 58       	r5 = r0 ASHIFT -1;
        TIME_INTERVAL time_in,
        tTimerEventFunction TimerEventFunction,
        void *data_pointer)
{
    return create_add_strict_event(
            time_add(time_get_time(), time_in), TimerEventFunction, data_pointer);
84200dc0:	ff fd 38 f0 	call (m) 0x7f4e;
84200dc4:	2f ec 
84200dc6:	ba 00       	r0 = r5 + r0;
84200dc8:	33 00       	r1 = r4 + Null;
84200dca:	44 d8       	r2 = M[FP + 32];
84200dcc:	ff fd 38 f0 	call (m) 0x7f58;
84200dd0:	2d ec 
}
84200dd2:	a2 f0 be 8e 	M[r8 + 760] = r0;
                op_extra_data->aux_pending = TRUE;
84200dd6:	41 20       	rMAC = Null + 1;
84200dd8:	a1 f0 bc 8e 	M[r8 + 752] = rMAC;
                vol_ctrl_kick_waiting(op_extra_data, touched, VOL_CTRL_KICK_AUX_PENDING);
84200ddc:	04 21       	r2 = Null + 4;
84200dde:	52 08       	r0 = r8 + Null;
84200de0:	4b d8       	r1 = M[FP + 36];
84200de2:	03 f0 35 e1 	call (m) Lc_vol_ctrl_kick_waiting_1;

                /* Proceed with processing; consume all data from at least one
                 * of the active aux inputs.
                 */
                op_extra_data->tc.num_words = aux_limit;
84200de6:	ab f0 b2 8e 	M[r8 + 712] = r9;

84200dea <Lc_vol_ctlr_process_data_43>:
        }

        /* Time constants based on samples to process and sample rate */
        vol_ctrl_compute_time_constants(op_extra_data->sample_rate,
                                        op_extra_data->parameters.OFFSET_VOLUME_TC,
                                        &op_extra_data->tc);
84200dea:	a4 f0 c8 22 	r2 = r8 + 712;
84200dee:	a3 f0 a8 88 	r1 = M[r8 + 672];
84200df2:	a2 f0 3b 88 	r0 = M[r8 + 236];
84200df6:	05 f0 25 eb 	call (m) $_vol_ctrl_compute_time_constants;
#ifdef VOLUME_CONTROL_AUX_TTP_SUPPORT
        /* There is a possibility that vol_ctrl_update_aux_state
         * limits the number of samples to process, so keep a copy
         * of that now.
         */
        samples_to_process = op_extra_data->tc.num_words;
84200dfa:	a6 f0 b2 88 	r4 = M[r8 + 712];
#endif

        vol_ctrl_update_aux_state(op_extra_data, aux_check, &op_extra_data->tc);
84200dfe:	a4 f0 c8 22 	r2 = r8 + 712;
84200e02:	52 08       	r0 = r8 + Null;
84200e04:	5b d8       	r1 = M[FP + 44];
84200e06:	04 f0 3b ee 	call (m) $_vol_ctrl_update_aux_state;
#ifdef VOLUME_CONTROL_AUX_TTP_SUPPORT
        /* whole of this block is for debugging purpose only,
         * showing to user whether aux is being mixed in timed mode
         * or normal mode.
         */
        if(op_extra_data->dbg_aux_mixing_started)
84200e0a:	a0 f0 d1 88 	Null = M[r8 + 836];
84200e0e:	23 60       	if EQ jump (m) Lc_vol_ctlr_process_data_51;

84200e10 <Lc_vol_ctlr_process_data_44>:
        {
            if(op_extra_data->current_timestamp_valid && op_extra_data->aux0_ttp.enabled)
84200e10:	a0 f0 cd 88 	Null = M[r8 + 820];
84200e14:	14 60       	if EQ jump (m) Lc_vol_ctlr_process_data_48;

84200e16 <Lc_vol_ctlr_process_data_45>:
84200e16:	a0 f0 c4 88 	Null = M[r8 + 784];
84200e1a:	11 60       	if EQ jump (m) Lc_vol_ctlr_process_data_48;

84200e1c <Lc_vol_ctlr_process_data_46>:
                L2_DBG_MSG3("Volume Control: Started mixing auxiliary input in playback mode, "
                            "requested ttp: %d, mixed at=%d, diff=%d",
                            op_extra_data->aux0_ttp.time_to_play,
                            op_extra_data->current_timestamp,
                            time_sub(op_extra_data->current_timestamp,
                                     op_extra_data->aux0_ttp.time_to_play));
84200e1c:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84200e20:	88 24       	Null = rMAC - 2;
84200e22:	17 68       	if LT jump (m) Lc_vol_ctlr_process_data_50;

84200e24 <Lc_vol_ctlr_process_data_47>:
84200e24:	a3 f0 c5 88 	r1 = M[r8 + 788];
84200e28:	a4 f0 cc 88 	r2 = M[r8 + 816];
84200e2c:	e5 04       	r3 = r2 - r1;
84200e2e:	55 f1 02 f0 	r0 = Null + 357564595;
84200e32:	b3 40 
84200e34:	ef fd fd ff 	call (m) 0xa08;
84200e38:	35 ee 
84200e3a:	0b 6e       	jump (m) Lc_vol_ctlr_process_data_50;

84200e3c <Lc_vol_ctlr_process_data_48>:
            }
            else
            {
                L2_DBG_MSG("Volume Control: Started mixing auxiliary input in non-timed playback mode");
84200e3c:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84200e40:	88 24       	Null = rMAC - 2;
84200e42:	07 68       	if LT jump (m) Lc_vol_ctlr_process_data_50;

84200e44 <Lc_vol_ctlr_process_data_49>:
84200e44:	55 f1 02 f0 	r0 = Null + 357564700;
84200e48:	1c 41 
84200e4a:	ef fd fd ff 	call (m) 0x9cc;
84200e4e:	23 ec 

84200e50 <Lc_vol_ctlr_process_data_50>:
            }
            op_extra_data->dbg_aux_mixing_started = FALSE;
84200e50:	a0 f0 d1 8e 	M[r8 + 836] = Null;

84200e54 <Lc_vol_ctlr_process_data_51>:
        }

        if(samples_to_process > op_extra_data->tc.num_words)
84200e54:	a1 f0 b2 88 	rMAC = M[r8 + 712];
84200e58:	70 04       	Null = r4 - rMAC;
84200e5a:	09 f0 cb e0 	if LS jump (m) Lc_vol_ctlr_process_data_55;

84200e5e <Lc_vol_ctlr_process_data_52>:
             */

            /* recalculate time constants based on limited amount */
            vol_ctrl_compute_time_constants(op_extra_data->sample_rate,
                                            op_extra_data->parameters.OFFSET_VOLUME_TC,
                                            &op_extra_data->tc);
84200e5e:	a4 f0 c8 22 	r2 = r8 + 712;
84200e62:	a3 f0 a8 88 	r1 = M[r8 + 672];
84200e66:	a2 f0 3b 88 	r0 = M[r8 + 236];
84200e6a:	05 f0 31 e7 	call (m) $_vol_ctrl_compute_time_constants;

            /* Also do a self kick to process the rest of chunk immediately.*/
            if (op_extra_data->pending_timer == TIMER_ID_INVALID)
84200e6e:	a0 f0 be 88 	Null = M[r8 + 760];
84200e72:	19 62       	if NE jump (m) Lc_vol_ctlr_process_data_55;

84200e74 <Lc_vol_ctlr_process_data_53>:
            {
                op_extra_data->pending_timer =
                    timer_schedule_event_in(0, vol_ctlr_timer_task, (void*)op_data );
84200e74:	42 f0 06 f0 	r4 = Null + 69209031;
84200e78:	c7 53 
        TIME_INTERVAL time_in,
        tTimerEventFunction TimerEventFunction,
        void *data_pointer)
{
    return create_add_strict_event(
            time_add(time_get_time(), time_in), TimerEventFunction, data_pointer);
84200e7a:	ff fd 38 f0 	call (m) 0x7f4e;
84200e7e:	35 e6 
84200e80:	33 00       	r1 = r4 + Null;
84200e82:	44 d8       	r2 = M[FP + 32];
84200e84:	ff fd 38 f0 	call (m) 0x7f58;
84200e88:	35 e6 
}
84200e8a:	a2 f0 be 8e 	M[r8 + 760] = r0;
84200e8e:	0b 6e       	jump (m) Lc_vol_ctlr_process_data_55;

84200e90 <Lc_vol_ctlr_process_data_54>:
#endif  /* VOLUME_CONTROL_AUX_TTP_SUPPORT  */

    }
    else
    {
        op_extra_data->aux_pending = FALSE;
84200e90:	a0 f0 bc 8e 	M[r8 + 752] = Null;

        /* Time constants based on samples to process and sample rate */
        vol_ctrl_compute_time_constants(op_extra_data->sample_rate,
                                        op_extra_data->parameters.OFFSET_VOLUME_TC,
                                        &op_extra_data->tc);
84200e94:	a4 f0 c8 22 	r2 = r8 + 712;
84200e98:	a3 f0 a8 88 	r1 = M[r8 + 672];
84200e9c:	a2 f0 3b 88 	r0 = M[r8 + 236];
84200ea0:	05 f0 3b e5 	call (m) $_vol_ctrl_compute_time_constants;

84200ea4 <Lc_vol_ctlr_process_data_55>:
    }

    if (! op_extra_data->aux_pending)
84200ea4:	a0 f0 bc 88 	Null = M[r8 + 752];
84200ea8:	11 62       	if NE jump (m) Lc_vol_ctlr_process_data_59;

84200eaa <Lc_vol_ctlr_process_data_56>:
    {
        timer_cancel_event_atomic(&op_extra_data->pending_timer);
84200eaa:	a6 f0 f8 22 	r4 = r8 + 760;
    (void) timer_cancel_event_ret(timer_id, NULL, NULL);
}

INLINE_SECTION static inline void timer_cancel_event_atomic(tTimerId *timer_id)
{
    interrupt_block();
84200eae:	ff fd a9 f1 	call (m) 0x360c6;
84200eb2:	39 e0 
    if (*timer_id != TIMER_ID_INVALID)
84200eb4:	32 e8       	r0 = M[r4 + Null];
84200eb6:	07 60       	if EQ jump (m) Lc_vol_ctlr_process_data_58;

84200eb8 <Lc_vol_ctlr_process_data_57>:
    {
        (void) timer_cancel_event_ret(*timer_id, NULL, NULL);
84200eb8:	04 00       	r2 = Null + Null;
84200eba:	03 00       	r1 = Null + Null;
84200ebc:	ff fd 39 f0 	call (m) 0x80e0;
84200ec0:	25 e1 
        *timer_id = TIMER_ID_INVALID;
84200ec2:	30 ee       	M[r4 + Null] = Null;

84200ec4 <Lc_vol_ctlr_process_data_58>:
    }
    interrupt_unblock();
84200ec4:	ff fd a9 f1 	call (m) 0x360e2;
84200ec8:	3f e0 

84200eca <Lc_vol_ctlr_process_data_59>:
    }

#ifdef VOLUME_CONTROL_AUX_TTP_SUPPORT
    /* update amount that is consumed this run */
    op_extra_data->prev_consumed_samples = op_extra_data->tc.num_words;
84200eca:	a1 f0 b2 88 	rMAC = M[r8 + 712];
#endif
    if (op_extra_data->tc.num_words > 0)
84200ece:	a1 f0 cf 8e 	M[r8 + 828] = rMAC;
84200ed2:	11 60       	if EQ jump (m) Lc_vol_ctlr_process_data_61;

84200ed4 <Lc_vol_ctlr_process_data_60>:
    {
#ifdef INSTALL_METADATA
        metadata_tag* eoftag = vol_ctrl_handle_aux_metadata(op_extra_data);
84200ed4:	52 08       	r0 = r8 + Null;
84200ed6:	02 f0 23 ea 	call (m) Lc_vol_ctrl_handle_aux_metadata_1;
        vol_ctrl_handle_input_metadata(op_extra_data, eoftag);
84200eda:	13 00       	r1 = r0 + Null;
84200edc:	52 08       	r0 = r8 + Null;
84200ede:	02 f0 2f ec 	call (m) Lc_vol_ctrl_handle_input_metadata_1;
#endif  /* INSTALL_METADATA */

        /* Update Main Channels */
        vol_ctrl_update_channel(op_extra_data,op_extra_data->channels,op_extra_data->lpvols,&op_extra_data->tc);
84200ee2:	a5 f0 c8 22 	r3 = r8 + 712;
84200ee6:	a4 f0 62 88 	r2 = M[r8 + 392];
84200eea:	a3 f0 1a 88 	r1 = M[r8 + 104];
84200eee:	52 08       	r0 = r8 + Null;
84200ef0:	f8 ff 30 e8 	call $_vol_ctrl_update_channel;

84200ef4 <Lc_vol_ctlr_process_data_61>:
    }

    /* Handle backwards kicks for main channels */
    touched_sink = (op_extra_data->used_all_input) ? op_extra_data->touched_sink : 0;
84200ef4:	a0 f0 bd 88 	Null = M[r8 + 756];
84200ef8:	04 60       	if EQ jump (m) Lc_vol_ctlr_process_data_63;

84200efa <Lc_vol_ctlr_process_data_62>:
84200efa:	a6 f0 18 88 	r4 = M[r8 + 96];
84200efe:	02 6e       	jump (m) Lc_vol_ctlr_process_data_64;

84200f00 <Lc_vol_ctlr_process_data_63>:
84200f00:	06 00       	r4 = Null + Null;

84200f02 <Lc_vol_ctlr_process_data_64>:

    /* Update Aux Buffers */
    op_extra_data->aux_state   = 0;
84200f02:	a0 f0 b9 8e 	M[r8 + 740] = Null;
    amount    = op_extra_data->aux_connected;
    if(amount)
84200f06:	a8 f0 b7 88 	r6 = M[r8 + 732];
84200f0a:	25 60       	if EQ jump (m) Lc_vol_ctlr_process_data_72;

84200f0c <Lc_vol_ctlr_process_data_65>:
    {
        vol_ctrl_aux_channel_t *aux_ptr=op_extra_data->aux_channel;
84200f0c:	a7 f0 6c 20 	r5 = r8 + 108;
        i = 0;
84200f10:	01 09       	r7 = Null + Null;

84200f12 <Lc_vol_ctlr_process_data_66>:
        do
        {
            if(aux_ptr->state==AUX_STATE_IN_AUX)
84200f12:	39 81       	rMAC = MBS[r5 + 4];
84200f14:	88 24       	Null = rMAC - 2;
84200f16:	0e 62       	if NE jump (m) Lc_vol_ctlr_process_data_69;

84200f18 <Lc_vol_ctlr_process_data_67>:
            {
                unsigned index_mask = (1<<i);
84200f18:	49 08       	rMAC = r7 + Null;
84200f1a:	00 f1 92 de 	r0 = 0x1 LSHIFT rMAC;
                op_extra_data->aux_state |= index_mask;
84200f1e:	a1 f0 b9 88 	rMAC = M[r8 + 740];
84200f22:	89 12       	rMAC = rMAC OR r0;
84200f24:	a1 f0 b9 8e 	M[r8 + 740] = rMAC;
                // only advance if used by a channel?
                if(!(op_extra_data->aux_in_use&index_mask))
84200f28:	a1 f0 ba 88 	rMAC = M[r8 + 744];
84200f2c:	89 10       	rMAC = rMAC AND r0;
84200f2e:	02 62       	if NE jump (m) Lc_vol_ctlr_process_data_69;

84200f30 <Lc_vol_ctlr_process_data_68>:
                {
                    aux_ptr->advance_buffer=0;
84200f30:	f8 8e       	M[r5 + 12] = Null;

84200f32 <Lc_vol_ctlr_process_data_69>:
                }
            }
            if(aux_ptr->advance_buffer)
84200f32:	fb 88       	r1 = M[r5 + 12];
84200f34:	0b 60       	if EQ jump (m) Lc_vol_ctlr_process_data_71;

84200f36 <Lc_vol_ctlr_process_data_70>:
            {
                touched_sink |= ( TOUCHED_SINK_0 << ((i<<1)+1) );
84200f36:	00 f9 d2 d8 	r0 = r7 LSHIFT 1;
84200f3a:	51 20       	rMAC = r0 + 1;
84200f3c:	00 f1 92 de 	r0 = 0x1 LSHIFT rMAC;
84200f40:	b6 12       	r4 = r4 OR r0;
                cbuffer_advance_read_ptr(aux_ptr->buffer,aux_ptr->advance_buffer);
84200f42:	3a e8       	r0 = M[r5 + Null];
84200f44:	ff fd 9c f1 	call (m) 0x34852;
84200f48:	2f e8 

84200f4a <Lc_vol_ctlr_process_data_71>:
            }
            i++;
84200f4a:	09 75       	r7 = r7 + 1;
            aux_ptr++;
84200f4c:	3f 28       	r5 = r5 + 16;
            amount>>=1;
        }while(amount);
84200f4e:	7f f8 d8 d8 	r6 = r6 LSHIFT -1;
84200f52:	e0 63       	if NE jump (m) Lc_vol_ctlr_process_data_66;

84200f54 <Lc_vol_ctlr_process_data_72>:
    }

   touched->sinks |= touched_sink;
84200f54:	49 d8       	rMAC = M[FP + 36];
84200f56:	0a 00       	r0 = rMAC + Null;
84200f58:	49 88       	rMAC = M[rMAC + 4];
84200f5a:	89 13       	rMAC = rMAC OR r4;
84200f5c:	51 8e       	M[r0 + 4] = rMAC;
   touched->sources = op_extra_data->touched_src;
84200f5e:	a1 f0 19 88 	rMAC = M[r8 + 100];
84200f62:	11 ee       	M[r0 + Null] = rMAC;

84200f64 <Lc_vol_ctlr_process_data_73>:

}
84200f64:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200f66:	d8 4c       	rts;

84200f68 <$_vol_ctlr_opmsg_obpm_set_control>:


/* **************************** Operator message handlers ******************************** */

bool vol_ctlr_opmsg_obpm_set_control(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200f68:	f6 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x20;
84200f6a:	11 09       	r7 = r0 + Null;
84200f6c:	43 de       	M[FP + 32] = r1;
84200f6e:	27 00       	r5 = r2 + Null;
84200f70:	4d de       	M[FP + 36] = r3;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
84200f72:	ef fd f9 ff 	call (m) 0x1e2;
84200f76:	31 e3 
84200f78:	16 00       	r4 = r0 + Null;
bool vol_ctlr_opmsg_obpm_set_control(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    VOL_CTRL_DATA_T    *op_extra_data = get_instance_data(op_data);
    unsigned            i,num_controls,cntrl_value;
    CPS_CONTROL_SOURCE  cntrl_src;
    unsigned result = OPMSG_RESULT_STATES_NORMAL_STATE;
84200f7a:	50 de       	M[FP + 40] = Null;
    vol_ctrl_gains_t *lpvols =&op_extra_data->host_vol;
84200f7c:	68 f0 f8 20 	r6 = r4 + 248;
    bool              bIsOBPM=FALSE;
84200f80:	02 09       	r8 = Null + Null;

    patch_fn(volume_control_opmsg_obpm_set_control_patch);

    if(!cps_control_setup(message_data, resp_length, resp_data,&num_controls))
84200f82:	c5 12       	r3 = FP + 44;
84200f84:	3b 00       	r1 = r5 + Null;
84200f86:	4c d8       	r2 = M[FP + 36];
84200f88:	42 d8       	r0 = M[FP + 32];
84200f8a:	ef fd fc ff 	call (m) 0x7ee;
84200f8e:	25 e3 
84200f90:	10 04       	Null = r0 - Null;
84200f92:	03 62       	if NE jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_3;

84200f94 <Lc_vol_ctlr_opmsg_obpm_set_control_2>:
84200f94:	02 00       	r0 = Null + Null;
84200f96:	8b 6e       	jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_31;

84200f98 <Lc_vol_ctlr_opmsg_obpm_set_control_3>:
84200f98:	0b 71       	r9 = Null + 1;
    {
        return FALSE;
    }

    for(i=0;i<num_controls;i++)
84200f9a:	07 00       	r5 = Null + Null;
84200f9c:	0e 6e       	jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_8;

84200f9e <Lc_vol_ctlr_opmsg_obpm_set_control_4>:
                 (cntrl_id<=VOL_CTRL_CONSTANT_TRIM8_GAIN_CTRL) )
        {
            lpvols->channel_trims[cntrl_id-VOL_CTRL_CONSTANT_TRIM1_GAIN_CTRL] = cntrl_value;
        }
        else if( (cntrl_id>=VOL_CTRL_CONSTANT_AUX_GAIN_CTRL1) &&
                 (cntrl_id<=VOL_CTRL_CONSTANT_AUX_GAIN_CTRL8) )
84200f9e:	10 3c       	Null = r0 - 48;
84200fa0:	29 64       	if NC jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_14;

84200fa2 <Lc_vol_ctlr_opmsg_obpm_set_control_5>:
84200fa2:	d0 3d       	Null = r0 - 55;
84200fa4:	08 f0 cf e0 	if HI jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_14;

84200fa8 <Lc_vol_ctlr_opmsg_obpm_set_control_6>:
        {
            lpvols->auxiliary_gain[cntrl_id-VOL_CTRL_CONSTANT_AUX_GAIN_CTRL1] = cntrl_value;
84200fa8:	63 d8       	r1 = M[FP + 48];
84200faa:	f2 f7 d0 7f 	r0 = r0 + -48;
84200fae:	41 08       	rMAC = r6 + Null;
84200fb0:	52 54       	r0 = r0 LSHIFT 2;
84200fb2:	51 00       	rMAC = r0 + rMAC;
84200fb4:	8b 8e       	M[rMAC + 8] = r1;

84200fb6 <Lc_vol_ctlr_opmsg_obpm_set_control_7>:
    if(!cps_control_setup(message_data, resp_length, resp_data,&num_controls))
    {
        return FALSE;
    }

    for(i=0;i<num_controls;i++)
84200fb6:	7f 20       	r5 = r5 + 1;

84200fb8 <Lc_vol_ctlr_opmsg_obpm_set_control_8>:
84200fb8:	59 d8       	rMAC = M[FP + 44];
84200fba:	78 04       	Null = r5 - rMAC;
84200fbc:	02 f0 bb e0 	if C jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_15;

84200fc0 <Lc_vol_ctlr_opmsg_obpm_set_control_9>:
    {
        unsigned  cntrl_id=cps_control_get(message_data,i,&cntrl_value,&cntrl_src);
84200fc0:	45 13       	r3 = FP + 52;
84200fc2:	04 13       	r2 = FP + 48;
84200fc4:	3b 00       	r1 = r5 + Null;
84200fc6:	42 d8       	r0 = M[FP + 32];
84200fc8:	ef fd fc ff 	call (m) 0x83c;
84200fcc:	35 e3 

        /* Check for OBPM and Override.   Override is all or none, not per control */
        if((i==0)&&(cntrl_src != CPS_SOURCE_HOST))
84200fce:	38 04       	Null = r5 - Null;
84200fd0:	0c 62       	if NE jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_12;

84200fd2 <Lc_vol_ctlr_opmsg_obpm_set_control_10>:
84200fd2:	a1 d1       	rMAC = MBS[FP + 52];
84200fd4:	0a 60       	if EQ jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_12;

84200fd6 <Lc_vol_ctlr_opmsg_obpm_set_control_11>:
        {
            bIsOBPM = TRUE;
84200fd6:	5a 09       	r8 = r9 + Null;
            lpvols  = &op_extra_data->obpm_vol;
84200fd8:	68 f0 40 21 	r6 = r4 + 320;
            /* Polarity of override enable/disable is inverted */
            op_extra_data->Ovr_Control = (cntrl_src == CPS_SOURCE_OBPM_DISABLE) ?  VOL_CTRL_CONTROL_VOL_OVERRIDE : 0;
84200fdc:	03 00       	r1 = Null + Null;
84200fde:	c8 24       	Null = rMAC - 3;
84200fe0:	20 f0 43 ce 	if EQ r1 = Null + 1;
84200fe4:	63 f0 3c 8e 	M[r4 + 240] = r1;

84200fe8 <Lc_vol_ctlr_opmsg_obpm_set_control_12>:
        }

        if(cntrl_id==VOL_CTRL_CONSTANT_POST_GAIN_CTRL)
84200fe8:	10 34       	Null = r0 - 32;
84200fea:	1a 62       	if NE jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_18;

84200fec <Lc_vol_ctlr_opmsg_obpm_set_control_13>:
        {
            if(bIsOBPM)
84200fec:	0f fa 00 c2 	Null = r8 - Null;
84200ff0:	0c 60       	if EQ jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_17;

84200ff2 <Lc_vol_ctlr_opmsg_obpm_set_control_14>:
            {
                /* OBPM can not set post gain */
                result = OPMSG_RESULT_STATES_UNSUPPORTED_CONTROL;
84200ff2:	01 21       	rMAC = Null + 4;
84200ff4:	51 de       	M[FP + 40] = rMAC;

84200ff6 <Lc_vol_ctlr_opmsg_obpm_set_control_15>:
            result = OPMSG_RESULT_STATES_UNSUPPORTED_CONTROL;
            break;
        }
    }

    if(op_extra_data->Ovr_Control&VOL_CTRL_CONTROL_VOL_OVERRIDE)
84200ff6:	61 f0 3c 88 	rMAC = M[r4 + 240];
84200ffa:	09 c0       	rMAC = rMAC AND 0x1;
84200ffc:	48 60       	if EQ jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_29;

84200ffe <Lc_vol_ctlr_opmsg_obpm_set_control_16>:
    {
        op_extra_data->lpvols = &op_extra_data->obpm_vol;
84200ffe:	61 f0 40 21 	rMAC = r4 + 320;
84201002:	61 f0 62 8e 	M[r4 + 392] = rMAC;
84201006:	47 6e       	jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_30;

84201008 <Lc_vol_ctlr_opmsg_obpm_set_control_17>:
                /* OBPM can not set post gain */
                result = OPMSG_RESULT_STATES_UNSUPPORTED_CONTROL;
                break;
            }

            op_extra_data->post_gain = cntrl_value;
84201008:	61 d8       	rMAC = M[FP + 48];
8420100a:	61 f0 3d 8e 	M[r4 + 244] = rMAC;

            op_extra_data->shared_volume_ptr->inv_post_gain = dB60toLinearQ5(-op_extra_data->post_gain);
8420100e:	42 04       	r0 = Null - rMAC;
84201010:	ff fd 9b f1 	call (m) 0x3473e;
84201014:	2f e9 
84201016:	61 f0 63 88 	rMAC = M[r4 + 396];
8420101a:	ca 8e       	M[rMAC + 12] = r0;
8420101c:	cd 6f       	jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_7;

8420101e <Lc_vol_ctlr_opmsg_obpm_set_control_18>:
        }
        else if(cntrl_id==VOL_CTRL_CONSTANT_MASTER_GAIN_CTRL)
8420101e:	50 34       	Null = r0 - 33;
84201020:	0d 62       	if NE jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_21;

84201022 <Lc_vol_ctlr_opmsg_obpm_set_control_19>:
        {
            lpvols->master_gain = cntrl_value;
84201022:	61 d8       	rMAC = M[FP + 48];
84201024:	81 f0 00 ee 	M[r6 + Null] = rMAC;
            if (!opmgr_op_is_running(op_data))
84201028:	4a 08       	r0 = r7 + Null;
8420102a:	ff fd 32 f0 	call (m) 0x7586;
8420102e:	3d ea 
84201030:	10 04       	Null = r0 - Null;
84201032:	c2 63       	if NE jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_7;

84201034 <Lc_vol_ctlr_opmsg_obpm_set_control_20>:
            {
                op_extra_data->vol_initialised = 1;
84201034:	6b f0 bf 8e 	M[r4 + 764] = r9;
84201038:	bf 6f       	jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_7;

8420103a <Lc_vol_ctlr_opmsg_obpm_set_control_21>:
            }
        }
        else if(cntrl_id==OPMSG_CONTROL_MUTE_ID)
8420103a:	90 24       	Null = r0 - 2;
8420103c:	10 62       	if NE jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_24;

8420103e <Lc_vol_ctlr_opmsg_obpm_set_control_22>:
        {
            lpvols->mute = cntrl_value;
8420103e:	61 d8       	rMAC = M[FP + 48];
84201040:	81 f0 01 8e 	M[r6 + 4] = rMAC;
            if (opmgr_op_is_running(op_data))
84201044:	4a 08       	r0 = r7 + Null;
84201046:	ff fd 32 f0 	call (m) 0x7586;
8420104a:	21 ea 
8420104c:	10 04       	Null = r0 - Null;
8420104e:	b4 61       	if EQ jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_7;

84201050 <Lc_vol_ctlr_opmsg_obpm_set_control_23>:
            {
                vol_ctrl_setup_mute(op_extra_data,lpvols->mute);
84201050:	83 f0 01 88 	r1 = M[r6 + 4];
84201054:	32 00       	r0 = r4 + Null;
84201056:	03 f0 39 e6 	call (m) Lc_vol_ctrl_setup_mute_1;
8420105a:	ae 6f       	jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_7;

8420105c <Lc_vol_ctlr_opmsg_obpm_set_control_24>:
            }
        }
        else if(cntrl_id==VOL_CTRL_CONSTANT_MUTE_PERIOD_CTRL)
8420105c:	90 34       	Null = r0 - 34;
8420105e:	0b 62       	if NE jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_26;

84201060 <Lc_vol_ctlr_opmsg_obpm_set_control_25>:
        {
            op_extra_data->mute_period = cntrl_value;
84201060:	61 d8       	rMAC = M[FP + 48];
84201062:	61 f0 c0 8e 	M[r4 + 768] = rMAC;
            if (opmgr_op_is_running(op_data))
84201066:	4a 08       	r0 = r7 + Null;
84201068:	ff fd 32 f0 	call (m) 0x7586;
8420106c:	3f e8 
8420106e:	10 04       	Null = r0 - Null;
84201070:	f0 63       	if NE jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_23;

84201072 <Lc_12>:
84201072:	a2 6f       	jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_7;

84201074 <Lc_vol_ctlr_opmsg_obpm_set_control_26>:
            {
                vol_ctrl_setup_mute(op_extra_data,lpvols->mute);
            }
        }
        else if( (cntrl_id>=VOL_CTRL_CONSTANT_TRIM1_GAIN_CTRL) &&
                 (cntrl_id<=VOL_CTRL_CONSTANT_TRIM8_GAIN_CTRL) )
84201074:	10 2c       	Null = r0 - 16;
84201076:	be 65       	if NC jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_14;

84201078 <Lc_vol_ctlr_opmsg_obpm_set_control_27>:
84201078:	d0 2d       	Null = r0 - 23;
8420107a:	f8 ff a5 ee 	if HI jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_4;

8420107e <Lc_vol_ctlr_opmsg_obpm_set_control_28>:
        {
            lpvols->channel_trims[cntrl_id-VOL_CTRL_CONSTANT_TRIM1_GAIN_CTRL] = cntrl_value;
8420107e:	63 d8       	r1 = M[FP + 48];
84201080:	82 7c       	r0 = r0 + -16;
84201082:	41 08       	rMAC = r6 + Null;
84201084:	52 54       	r0 = r0 LSHIFT 2;
84201086:	51 00       	rMAC = r0 + rMAC;
84201088:	8b 9e       	M[rMAC + 40] = r1;
8420108a:	96 6f       	jump (m) Lc_vol_ctlr_opmsg_obpm_set_control_7;

8420108c <Lc_vol_ctlr_opmsg_obpm_set_control_29>:
    {
        op_extra_data->lpvols = &op_extra_data->obpm_vol;
    }
    else
    {
        op_extra_data->lpvols = &op_extra_data->host_vol;
8420108c:	61 f0 f8 20 	rMAC = r4 + 248;
84201090:	61 f0 62 8e 	M[r4 + 392] = rMAC;

84201094 <Lc_vol_ctlr_opmsg_obpm_set_control_30>:
    }
    op_extra_data->shared_volume_ptr->current_volume_level = op_extra_data->lpvols->master_gain;
84201094:	61 f0 62 88 	rMAC = M[r4 + 392];
84201098:	62 f0 63 88 	r0 = M[r4 + 396];
8420109c:	09 e8       	rMAC = M[rMAC + Null];
8420109e:	91 8e       	M[r0 + 8] = rMAC;


    cps_response_set_result(resp_data,result);
842010a0:	53 d8       	r1 = M[FP + 40];
842010a2:	4a d8       	r0 = M[FP + 36];
842010a4:	ef fd fb ff 	call (m) 0x87a;
842010a8:	37 ee 

    return TRUE;
842010aa:	5a 08       	r0 = r9 + Null;

842010ac <Lc_vol_ctlr_opmsg_obpm_set_control_31>:
}
842010ac:	f6 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
842010ae:	d8 4c       	rts;

842010b0 <$_vol_ctlr_opmsg_obpm_get_params>:

bool vol_ctlr_opmsg_obpm_get_params(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842010b0:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
842010b2:	1f 00       	r5 = r1 + Null;
842010b4:	26 00       	r4 = r2 + Null;
842010b6:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
842010b8:	ef fd f8 ff 	call (m) 0x1e2;
842010bc:	2b e9 

bool vol_ctlr_opmsg_obpm_get_params(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);

    return cpsGetParameterMsgHandler(&op_extra_data->parms_def ,message_data, resp_length,resp_data);
842010be:	02 f0 b4 46 	r0 = r0 + 692;
842010c2:	45 08       	r3 = r6 + Null;
842010c4:	34 00       	r2 = r4 + Null;
842010c6:	3b 00       	r1 = r5 + Null;
842010c8:	ef fd f9 ff 	call (m) 0x4a6;
842010cc:	3f ee 

842010ce <Lc_vol_ctlr_opmsg_obpm_get_params_2>:
}
842010ce:	f3 48       	popm <FP, r4, r5, r6, rLink>;
842010d0:	d8 4c       	rts;

842010d2 <$_vol_ctlr_opmsg_obpm_get_defaults>:

bool vol_ctlr_opmsg_obpm_get_defaults(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842010d2:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
842010d4:	1f 00       	r5 = r1 + Null;
842010d6:	26 00       	r4 = r2 + Null;
842010d8:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
842010da:	ef fd f8 ff 	call (m) 0x1e2;
842010de:	29 e8 

bool vol_ctlr_opmsg_obpm_get_defaults(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);

    return cpsGetDefaultsMsgHandler(&op_extra_data->parms_def ,message_data, resp_length,resp_data);
842010e0:	02 f0 b4 46 	r0 = r0 + 692;
842010e4:	45 08       	r3 = r6 + Null;
842010e6:	34 00       	r2 = r4 + Null;
842010e8:	3b 00       	r1 = r5 + Null;
842010ea:	ef fd fa ff 	call (m) 0x558;
842010ee:	2f e3 

842010f0 <Lc_vol_ctlr_opmsg_obpm_get_defaults_2>:
}
842010f0:	f3 48       	popm <FP, r4, r5, r6, rLink>;
842010f2:	d8 4c       	rts;

842010f4 <$_vol_ctlr_opmsg_obpm_set_params>:

bool vol_ctlr_opmsg_obpm_set_params(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842010f4:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
842010f6:	19 09       	r7 = r1 + Null;
842010f8:	27 00       	r5 = r2 + Null;
842010fa:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
842010fc:	ef fd f8 ff 	call (m) 0x1e2;
84201100:	27 e7 
84201102:	16 00       	r4 = r0 + Null;
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);
    bool retval;

    patch_fn(volume_control_opmsg_obpm_set_params_patch);

    retval = cpsSetParameterMsgHandler(&op_extra_data->parms_def ,message_data, resp_length,resp_data);
84201104:	62 f0 b4 22 	r0 = r4 + 692;
84201108:	45 08       	r3 = r6 + Null;
8420110a:	3c 00       	r2 = r5 + Null;
8420110c:	4b 08       	r1 = r7 + Null;
8420110e:	ef fd fa ff 	call (m) 0x638;
84201112:	2b e9 

    /* Set the Reinit flag after setting the parameters */
    op_extra_data->ReInitFlag = 1;
84201114:	41 20       	rMAC = Null + 1;
84201116:	61 f0 ac 8e 	M[r4 + 688] = rMAC;

8420111a <Lc_vol_ctlr_opmsg_obpm_set_params_2>:

    return retval;
8420111a:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
8420111c:	d8 4c       	rts;

8420111e <$_vol_ctlr_opmsg_obpm_get_status>:
}

bool vol_ctlr_opmsg_obpm_get_status(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420111e:	f5 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>, SP = SP + 0x10;
84201120:	19 09       	r7 = r1 + Null;
84201122:	27 00       	r5 = r2 + Null;
84201124:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
84201126:	ef fd f8 ff 	call (m) 0x1e2;
8420112a:	3d e5 
8420112c:	12 09       	r8 = r0 + Null;
}

bool vol_ctlr_opmsg_obpm_get_status(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);
    vol_ctrl_gains_t *lpvols = op_extra_data->lpvols;
8420112e:	a6 f0 62 88 	r4 = M[r8 + 392];
    unsigned  *resp;

    patch_fn_shared(volume_control_wrapper);

    if(!common_obpm_status_helper(message_data,resp_length,resp_data,sizeof(VOL_CTRL_STATISTICS),&resp))
84201132:	c1 11       	rMAC = FP + 28;
84201134:	09 1c       	pushm <rMAC>;
84201136:	05 f0 50 40 	r3 = Null + 80;
8420113a:	44 08       	r2 = r6 + Null;
8420113c:	3b 00       	r1 = r5 + Null;
8420113e:	4a 08       	r0 = r7 + Null;
84201140:	ef fd fb ff 	call (m) 0x890;
84201144:	31 ea 
84201146:	7f 4c       	SP = SP + -4;
84201148:	10 04       	Null = r0 - Null;
8420114a:	03 62       	if NE jump (m) Lc_vol_ctlr_opmsg_obpm_get_status_3;

8420114c <Lc_vol_ctlr_opmsg_obpm_get_status_2>:
    {
        return FALSE;
8420114c:	02 00       	r0 = Null + Null;
8420114e:	4c 6e       	jump (m) Lc_vol_ctlr_opmsg_obpm_get_status_6;

84201150 <Lc_vol_ctlr_opmsg_obpm_get_status_3>:
    }

    if (resp)
84201150:	3c d8       	r2 = M[FP + 28];
84201152:	49 60       	if EQ jump (m) Lc_vol_ctlr_opmsg_obpm_get_status_5;

84201154 <Lc_vol_ctlr_opmsg_obpm_get_status_4>:
    {
        resp = cpsPack2Words(op_extra_data->Ovr_Control, op_extra_data->post_gain, resp);
84201154:	a3 f0 3d 88 	r1 = M[r8 + 244];
84201158:	a2 f0 3c 88 	r0 = M[r8 + 240];
8420115c:	ff fd 9a f1 	call (m) 0x3468c;
84201160:	31 e9 
84201162:	3a de       	M[FP + 28] = r0;
        resp = cpsPack2Words(lpvols->master_gain, lpvols->auxiliary_gain[0], resp);
84201164:	3c d8       	r2 = M[FP + 28];
84201166:	b3 88       	r1 = M[r4 + 8];
84201168:	32 e8       	r0 = M[r4 + Null];
8420116a:	ff fd 9a f1 	call (m) 0x3468c;
8420116e:	23 e9 
84201170:	3a de       	M[FP + 28] = r0;
        resp = cpsPack2Words(lpvols->auxiliary_gain[1], lpvols->auxiliary_gain[2], resp);
84201172:	3c d8       	r2 = M[FP + 28];
84201174:	33 89       	r1 = M[r4 + 16];
84201176:	f2 88       	r0 = M[r4 + 12];
84201178:	ff fd 9a f1 	call (m) 0x3468c;
8420117c:	35 e8 
8420117e:	3a de       	M[FP + 28] = r0;
        resp = cpsPack2Words(lpvols->auxiliary_gain[3], lpvols->auxiliary_gain[4], resp);
84201180:	3c d8       	r2 = M[FP + 28];
84201182:	b3 89       	r1 = M[r4 + 24];
84201184:	72 89       	r0 = M[r4 + 20];
84201186:	ff fd 9a f1 	call (m) 0x3468c;
8420118a:	27 e8 
8420118c:	3a de       	M[FP + 28] = r0;
        resp = cpsPack2Words(lpvols->auxiliary_gain[5], lpvols->auxiliary_gain[6], resp);
8420118e:	3c d8       	r2 = M[FP + 28];
84201190:	33 98       	r1 = M[r4 + 32];
84201192:	f2 89       	r0 = M[r4 + 28];
84201194:	ff fd 9a f1 	call (m) 0x3468c;
84201198:	39 e7 
8420119a:	3a de       	M[FP + 28] = r0;
        resp = cpsPack2Words(lpvols->auxiliary_gain[7], lpvols->channel_trims[0], resp);
8420119c:	3c d8       	r2 = M[FP + 28];
8420119e:	b3 98       	r1 = M[r4 + 40];
842011a0:	72 98       	r0 = M[r4 + 36];
842011a2:	ff fd 9a f1 	call (m) 0x3468c;
842011a6:	2b e7 
842011a8:	3a de       	M[FP + 28] = r0;
        resp = cpsPack2Words(lpvols->channel_trims[1], lpvols->channel_trims[2], resp);
842011aa:	3c d8       	r2 = M[FP + 28];
842011ac:	33 99       	r1 = M[r4 + 48];
842011ae:	f2 98       	r0 = M[r4 + 44];
842011b0:	ff fd 9a f1 	call (m) 0x3468c;
842011b4:	3d e6 
842011b6:	3a de       	M[FP + 28] = r0;
        resp = cpsPack2Words(lpvols->channel_trims[3], lpvols->channel_trims[4], resp);
842011b8:	3c d8       	r2 = M[FP + 28];
842011ba:	b3 99       	r1 = M[r4 + 56];
842011bc:	72 99       	r0 = M[r4 + 52];
842011be:	ff fd 9a f1 	call (m) 0x3468c;
842011c2:	2f e6 
842011c4:	3a de       	M[FP + 28] = r0;
        resp = cpsPack2Words(lpvols->channel_trims[5], lpvols->channel_trims[6], resp);
842011c6:	3c d8       	r2 = M[FP + 28];
842011c8:	33 a8       	r1 = M[r4 + 64];
842011ca:	f2 99       	r0 = M[r4 + 60];
842011cc:	ff fd 9a f1 	call (m) 0x3468c;
842011d0:	21 e6 
842011d2:	3a de       	M[FP + 28] = r0;
        resp = cpsPack2Words(lpvols->channel_trims[7], op_extra_data->aux_state, resp);
842011d4:	3c d8       	r2 = M[FP + 28];
842011d6:	a3 f0 b9 88 	r1 = M[r8 + 740];
842011da:	72 a8       	r0 = M[r4 + 68];
842011dc:	ff fd 9a f1 	call (m) 0x3468c;
842011e0:	31 e5 
842011e2:	3a de       	M[FP + 28] = r0;

842011e4 <Lc_vol_ctlr_opmsg_obpm_get_status_5>:
    }

    return TRUE;
842011e4:	42 20       	r0 = Null + 1;

842011e6 <Lc_vol_ctlr_opmsg_obpm_get_status_6>:
}
842011e6:	f5 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, rLink>;
842011e8:	d8 4c       	rts;

842011ea <$_vol_ctlr_opmsg_set_ucid>:

    return TRUE;
}

bool vol_ctlr_opmsg_set_ucid(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842011ea:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
842011ec:	11 09       	r7 = r0 + Null;
842011ee:	1a 09       	r8 = r1 + Null;
842011f0:	27 00       	r5 = r2 + Null;
842011f2:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
842011f4:	ef fd f7 ff 	call (m) 0x1e2;
842011f8:	2f ef 
842011fa:	16 00       	r4 = r0 + Null;
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);
    PS_KEY_TYPE key;
    bool retval;

    retval = cpsSetUcidMsgHandler(&op_extra_data->parms_def,message_data,resp_length,resp_data);
842011fc:	62 f0 b4 22 	r0 = r4 + 692;
84201200:	45 08       	r3 = r6 + Null;
84201202:	3c 00       	r2 = r5 + Null;
84201204:	53 08       	r1 = r8 + Null;
84201206:	ef fd fa ff 	call (m) 0x6d6;
8420120a:	31 e6 
8420120c:	17 00       	r5 = r0 + Null;

    key = MAP_CAPID_UCID_SBID_TO_PSKEYID(base_op_get_cap_id(op_data),op_extra_data->parms_def.ucid,OPMSG_P_STORE_PARAMETER_SUB_ID);
8420120e:	4a 08       	r0 = r7 + Null;
84201210:	ef fd f7 ff 	call (m) 0x1e6;
84201214:	37 ee 
84201216:	92 c6       	r0 = r0 AND 0xffff;
84201218:	61 f0 b1 88 	rMAC = M[r4 + 708];
8420121c:	92 55       	r0 = r0 LSHIFT 7;
8420121e:	8b c2       	r1 = rMAC AND 0x3f;
84201220:	1b 54       	r1 = r1 LSHIFT 1;
84201222:	9b 12       	r1 = r1 OR r0;
    ps_entry_read((void*)op_data,key,PERSIST_ANY,ups_params_vc);
84201224:	42 f0 05 f0 	r3 = Null + 69212053;
84201228:	95 6b 
8420122a:	04 00       	r2 = Null + Null;
8420122c:	4a 08       	r0 = r7 + Null;
8420122e:	ff fd 42 f0 	call (m) 0x963a;
84201232:	2d e0 

    return retval;
84201234:	3a 00       	r0 = r5 + Null;

84201236 <Lc_vol_ctlr_opmsg_set_ucid_2>:
}
84201236:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84201238:	d8 4c       	rts;

8420123a <$_vol_ctlr_opmsg_get_ps_id>:

bool vol_ctlr_opmsg_get_ps_id(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420123a:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
8420123c:	16 00       	r4 = r0 + Null;
8420123e:	1a 09       	r8 = r1 + Null;
84201240:	20 09       	r6 = r2 + Null;
84201242:	2f 00       	r5 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
84201244:	ef fd f7 ff 	call (m) 0x1e2;
84201248:	3f ec 
8420124a:	11 09       	r7 = r0 + Null;

bool vol_ctlr_opmsg_get_ps_id(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);

    return cpsGetUcidMsgHandler(&op_extra_data->parms_def,base_op_get_cap_id(op_data),message_data,resp_length,resp_data);
8420124c:	32 00       	r0 = r4 + Null;
8420124e:	ef fd f7 ff 	call (m) 0x1e6;
84201252:	39 ec 
84201254:	13 00       	r1 = r0 + Null;
84201256:	39 1c       	pushm <r5>;
84201258:	92 f0 b4 22 	r0 = r7 + 692;
8420125c:	45 08       	r3 = r6 + Null;
8420125e:	54 08       	r2 = r8 + Null;
84201260:	ef fd fa ff 	call (m) 0x6f8;
84201264:	39 e4 
84201266:	7f 4c       	SP = SP + -4;

84201268 <Lc_vol_ctlr_opmsg_get_ps_id_2>:
}
84201268:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
8420126a:	d8 4c       	rts;

8420126c <$_vol_ctlr_opmsg_set_sample_rate>:

bool vol_ctlr_opmsg_set_sample_rate(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420126c:	f1 1c       	pushm <FP(=SP), r4, rLink>;
8420126e:	1e 00       	r4 = r1 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
84201270:	ef fd f7 ff 	call (m) 0x1e2;
84201274:	33 eb 
bool vol_ctlr_opmsg_set_sample_rate(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);

    /* We received client ID, length and then opmsgID and OBPM params */
    op_extra_data->sample_rate = 25 * (OPMSG_FIELD_GET(message_data, OPMSG_COMMON_MSG_SET_SAMPLE_RATE, SAMPLE_RATE));
84201276:	f1 88       	rMAC = M[r4 + 12];
84201278:	89 c6       	rMAC = rMAC AND 0xffff;
8420127a:	49 46       	rMAC = rMAC * 25 (int);
8420127c:	21 f0 3b 8e 	M[r0 + 236] = rMAC;

    return TRUE;
84201280:	42 20       	r0 = Null + 1;

84201282 <Lc_vol_ctlr_opmsg_set_sample_rate_2>:
}
84201282:	f1 48       	popm <FP, r4, rLink>;
84201284:	d8 4c       	rts;

84201286 <$_vol_ctlr_opmsg_data_stream_based>:

bool vol_ctlr_opmsg_data_stream_based(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84201286:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84201288:	1e 00       	r4 = r1 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
8420128a:	ef fd f7 ff 	call (m) 0x1e2;
8420128e:	39 ea 
bool vol_ctlr_opmsg_data_stream_based(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);

    /* We received client ID, length and then opmsgID and OBPM params */
    op_extra_data->stream_based = OPMSG_FIELD_GET(message_data, OPMSG_COMMON_MSG_SET_DATA_STREAM_BASED, IS_STREAM_BASED);
84201290:	f1 88       	rMAC = M[r4 + 12];
84201292:	89 c6       	rMAC = rMAC AND 0xffff;
84201294:	21 f0 c3 8e 	M[r0 + 780] = rMAC;

    return TRUE;
84201298:	42 20       	r0 = Null + 1;

8420129a <Lc_vol_ctlr_opmsg_data_stream_based_2>:
}
8420129a:	f1 48       	popm <FP, r4, rLink>;
8420129c:	d8 4c       	rts;

8420129e <$_vol_ctlr_opmsg_set_aux_time_to_play>:
#ifdef VOLUME_CONTROL_AUX_TTP_SUPPORT
bool vol_ctlr_opmsg_set_aux_time_to_play(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420129e:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
842012a0:	11 09       	r7 = r0 + Null;
842012a2:	1f 00       	r5 = r1 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
842012a4:	ef fd f7 ff 	call (m) 0x1e2;
842012a8:	3f e9 
842012aa:	16 00       	r4 = r0 + Null;


    /* get aux channel index */
    unsigned aux_channel_index = OPMSG_FIELD_GET(message_data,
                                                 OPMSG_VOL_CTRL_SET_AUX_TIME_TO_PLAY,
                                                 AUX_CHANNEL_INDEX);
842012ac:	f9 88       	rMAC = M[r5 + 12];
842012ae:	8b c6       	r1 = rMAC AND 0xffff;
        (TIME)OPMSG_FIELD_GET_FROM_OFFSET(message_data,
                                          OPMSG_VOL_CTRL_SET_AUX_TIME_TO_PLAY,
                                          AUX_TIME_TO_PLAY, 1) +
        ((TIME)OPMSG_FIELD_GET_FROM_OFFSET(message_data,
                                           OPMSG_VOL_CTRL_SET_AUX_TIME_TO_PLAY,
                                          AUX_TIME_TO_PLAY, 0) << 16);
842012b0:	39 89       	rMAC = M[r5 + 16];
842012b2:	8a c6       	r0 = rMAC AND 0xffff;
842012b4:	92 56       	r0 = r0 LSHIFT 16;
842012b6:	79 89       	rMAC = M[r5 + 20];
842012b8:	89 c6       	rMAC = rMAC AND 0xffff;
842012ba:	1f f2 08 c0 	r6 = r0 + rMAC;
    /* get drift rate */
    int aux_drift_rate = (int)(int16)OPMSG_FIELD_GET(message_data,
                                                     OPMSG_VOL_CTRL_SET_AUX_TIME_TO_PLAY,
                                                     AUX_DRIFT_RATE);
842012be:	b9 89       	rMAC = M[r5 + 24];
842012c0:	0f 0c       	r5 = SE16 rMAC;

    /* Only channel 0 is supported */
    if(aux_channel_index != 0)
842012c2:	18 04       	Null = r1 - Null;
842012c4:	0d 60       	if EQ jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_5;

842012c6 <Lc_vol_ctlr_opmsg_set_aux_time_to_play_2>:
    {
        L2_DBG_MSG1("Volume Control Aux Timed Playback, "
                    "only channel 0 supports this feature, channel=%d",
                    aux_channel_index);
842012c6:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
842012ca:	88 24       	Null = rMAC - 2;
842012cc:	07 68       	if LT jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_4;

842012ce <Lc_vol_ctlr_opmsg_set_aux_time_to_play_3>:
842012ce:	55 f1 02 f0 	r0 = Null + 357564774;
842012d2:	66 41 
842012d4:	ef fd fb ff 	call (m) 0x9de;
842012d8:	2b e8 

842012da <Lc_vol_ctlr_opmsg_set_aux_time_to_play_4>:
        return FALSE;
842012da:	02 00       	r0 = Null + Null;
842012dc:	6c 6e       	jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_17;

842012de <Lc_vol_ctlr_opmsg_set_aux_time_to_play_5>:
    }

    /* drift_rate is in 1/10 of ppm, so convert it to a
     * fractional number.
     */
    aux_drift_rate = aux_drift_rate * FRACTIONAL(0.0001);
842012de:	46 f3 dc f7 	r5 = r5 * 214748 (int);
842012e2:	97 d9 
    aux_drift_rate = frac_mult(aux_drift_rate, FRACTIONAL(0.001));
842012e4:	02 f0 62 f0 	r0 = Null + 2147483;
842012e8:	9b 48 
842012ea:	00 f2 77 c9 	r5 = r5 * r0 (frac);

    vol_ctrl_aux_channel_t  *aux_channel = &op_extra_data->aux_channel[aux_channel_index];
842012ee:	61 f0 6c 20 	rMAC = r4 + 108;
     * if sent after that we aren't be able to meet the deadline for timed
     * playback so just return FALSE.
     */
    if(aux_channel->buffer != NULL &&
       aux_channel->state != AUX_STATE_NO_AUX &&
       aux_channel->state != AUX_STATE_END_AUX)
842012f2:	0a e8       	r0 = M[rMAC + Null];
842012f4:	11 60       	if EQ jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_10;

842012f6 <Lc_vol_ctlr_opmsg_set_aux_time_to_play_6>:
842012f6:	09 81       	rMAC = MBS[rMAC + 4];
842012f8:	0f 60       	if EQ jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_10;

842012fa <Lc_vol_ctlr_opmsg_set_aux_time_to_play_7>:
842012fa:	c8 24       	Null = rMAC - 3;
842012fc:	0d 60       	if EQ jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_10;

842012fe <Lc_vol_ctlr_opmsg_set_aux_time_to_play_8>:
    {
        L2_DBG_MSG1("Volume Control Aux Timed Playback: "
                    "aux channel %d is already active",
                    aux_channel_index);
842012fe:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84201302:	88 24       	Null = rMAC - 2;
84201304:	eb 69       	if LT jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_4;

84201306 <Lc_vol_ctlr_opmsg_set_aux_time_to_play_9>:
84201306:	55 f1 02 f0 	r0 = Null + 357564858;
8420130a:	ba 41 
8420130c:	03 00       	r1 = Null + Null;
8420130e:	ef fd fb ff 	call (m) 0x9de;
84201312:	31 e6 
84201314:	e3 6f       	jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_4;

84201316 <Lc_vol_ctlr_opmsg_set_aux_time_to_play_10>:
        return FALSE;
    }

    /* Sanity check on time to play time */
    TIME current_time = time_get_time();
84201316:	ff fd 36 f0 	call (m) 0x7f4e;
8420131a:	39 e1 
8420131c:	13 00       	r1 = r0 + Null;
    TIME_INTERVAL ttp_in_future = time_sub(aux_time_to_play, current_time);
8420131e:	3f f8 01 c2 	rMAC = r6 - r1;
    if(ttp_in_future < (VOL_CTRL_AUX_MIN_TTP_IN_FUTURE_MS*MILLISECOND) ||
       ttp_in_future > (VOL_CTRL_AUX_MAX_TTP_IN_FUTURE_MS*MILLISECOND))
84201322:	01 f0 10 f3 	Null = rMAC - 30000;
84201326:	30 2d 
84201328:	05 68       	if LT jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_12;

8420132a <Lc_vol_ctlr_opmsg_set_aux_time_to_play_11>:
8420132a:	c4 f4 10 f2 	Null = rMAC - 20000000;
8420132e:	00 3d 
84201330:	0d 6c       	if LE jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_14;

84201332 <Lc_vol_ctlr_opmsg_set_aux_time_to_play_12>:
    {
        L2_DBG_MSG2("Volume Control Aux Timed Playback: "
                    "Requested time to play is too early or too late,"
                    "current time=%d, time to play=%d",
                    current_time, aux_time_to_play);
84201332:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84201336:	88 24       	Null = rMAC - 2;
84201338:	d1 69       	if LT jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_4;

8420133a <Lc_vol_ctlr_opmsg_set_aux_time_to_play_13>:
8420133a:	55 f1 02 f0 	r0 = Null + 357564926;
8420133e:	fe 41 
84201340:	44 08       	r2 = r6 + Null;
84201342:	ef fd fb ff 	call (m) 0x9f2;
84201346:	31 e5 
84201348:	c9 6f       	jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_4;

8420134a <Lc_vol_ctlr_opmsg_set_aux_time_to_play_14>:
     * aux_time_to_play will be for first sample of aux,
     * we have a ramping down time for main channel before
     * actual mixing happens.
     * */
    vol_ctrl_aux_params_t *aux_param = (vol_ctrl_aux_params_t *)
        (&op_extra_data->parameters.OFFSET_AUX1_SCALE);
8420134a:	61 f0 94 21 	rMAC = r4 + 404;
    unsigned atk_tc = aux_param[aux_channel_index].atk_tc;
8420134e:	4b 88       	r1 = M[rMAC + 4];
    TIME_INTERVAL start_period = (TIME_INTERVAL) ((1<<(DAWTH-1))/atk_tc)*10;
84201350:	00 f8 02 f0 	r0 = Null + -2147483648;
84201354:	00 40 
84201356:	ff fd be f0 	call (m) 0x1902c;
8420135a:	37 e6 
8420135c:	91 42       	rMAC = r0 * 10 (int);
    TIME ttp_gate_time = time_sub(aux_time_to_play, start_period);
8420135e:	1f f8 0b c2 	r9 = r6 - rMAC;
    /* aux timed playback message in only for one tone/prompt,
     * if we don't receive the actual aux data within reasonable
     * time, timed playback will expire and later received aux data
     * will be mixed in normal non-ttp mode */
    TIME ttp_expiry_time = time_add(aux_time_to_play,
                                    VOL_CTRL_AUX_TTP_EXPIRY_PERIOD_MS*MILLISECOND);
84201362:	06 f0 8a f0 	r8 = r6 + 100000;
84201366:	a0 2a 

    L2_DBG_MSG4("Volume Control, setting auxiliary playback time:"
                " time=%d, channel=%d, ttp=%d, drift=%d",
                time_get_time(), aux_channel_index, aux_time_to_play, aux_drift_rate);
84201368:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
8420136c:	88 24       	Null = rMAC - 2;
8420136e:	0f 68       	if LT jump (m) Lc_vol_ctlr_opmsg_set_aux_time_to_play_16;

84201370 <Lc_vol_ctlr_opmsg_set_aux_time_to_play_15>:
84201370:	ff fd 35 f0 	call (m) 0x7f4e;
84201374:	3f ee 
84201376:	13 00       	r1 = r0 + Null;
84201378:	39 1c       	pushm <r5>;
8420137a:	55 f1 02 f0 	r0 = Null + 357565042;
8420137e:	72 42 
84201380:	04 00       	r2 = Null + Null;
84201382:	45 08       	r3 = r6 + Null;
84201384:	ef fd fb ff 	call (m) 0xa20;
84201388:	3d e4 
8420138a:	7f 4c       	SP = SP + -4;

8420138c <Lc_vol_ctlr_opmsg_set_aux_time_to_play_16>:
    /* blocking interrupts just in case this update is preempted
     * by the operator's process. Normally user is expected to send
     * this message before auxiliary path starts sending audio data,
     * so practically perhaps not required.
     */
    opmgr_op_suspend_processing(op_data);
8420138c:	4a 08       	r0 = r7 + Null;
8420138e:	ff fd 31 f0 	call (m) 0x7592;
84201392:	25 e0 
    op_extra_data->aux0_ttp.time_to_play = aux_time_to_play;
84201394:	68 f0 c5 8e 	M[r4 + 788] = r6;
    op_extra_data->aux0_ttp.expiry_time = ttp_expiry_time;
84201398:	6a f0 c6 8e 	M[r4 + 792] = r8;
    op_extra_data->aux0_ttp.gate_time = ttp_gate_time;
8420139c:	6b f0 c7 8e 	M[r4 + 796] = r9;
    op_extra_data->aux0_ttp.drift_rate = aux_drift_rate;
842013a0:	67 f0 c9 8e 	M[r4 + 804] = r5;
    op_extra_data->aux0_ttp.enabled = TRUE;
842013a4:	41 20       	rMAC = Null + 1;
842013a6:	61 f0 c4 8e 	M[r4 + 784] = rMAC;
    opmgr_op_resume_processing(op_data);
842013aa:	4a 08       	r0 = r7 + Null;
842013ac:	ff fd 31 f0 	call (m) 0x75c0;
842013b0:	35 e0 
    return TRUE;
842013b2:	42 20       	r0 = Null + 1;

842013b4 <Lc_vol_ctlr_opmsg_set_aux_time_to_play_17>:
}
842013b4:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
842013b6:	d8 4c       	rts;

842013b8 <$_vol_ctlr_opmsg_set_downstream_latency_est>:

bool vol_ctlr_opmsg_set_downstream_latency_est(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842013b8:	f1 1c       	pushm <FP(=SP), r4, rLink>;
842013ba:	1e 00       	r4 = r1 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
842013bc:	ef fd f7 ff 	call (m) 0x1e2;
842013c0:	27 e1 
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data(op_data);

    /* get downstream latency field */
    unsigned latency_est_ms = OPMSG_FIELD_GET(message_data,
                                              OPMSG_VOL_CTRL_SET_DOWNSTREAM_LATENCY_EST,
                                              LATENCY_EST_MS);
842013c2:	f1 88       	rMAC = M[r4 + 12];
842013c4:	89 c6       	rMAC = rMAC AND 0xffff;
    /* check maximum value */
    if(latency_est_ms > VOL_CTRL_MAX_DOWNSTREAM_LATENCY_MS)
842013c6:	10 f0 c8 24 	Null = rMAC - 200;
842013ca:	09 f0 89 e0 	if LS jump (m) Lc_vol_ctlr_opmsg_set_downstream_latency_est_3;

842013ce <Lc_vol_ctlr_opmsg_set_downstream_latency_est_2>:
    {
        return FALSE;
842013ce:	02 00       	r0 = Null + Null;
842013d0:	04 6e       	jump (m) Lc_vol_ctlr_opmsg_set_downstream_latency_est_4;

842013d2 <Lc_vol_ctlr_opmsg_set_downstream_latency_est_3>:

    /* set downstream latency config, change while
	   the operator is running is ok, but the value
	   will be used from next auxiliary burst.
	 */
    VOL_CTRL_DOWNSTREAM_LATENCY_EST(op_extra_data) = latency_est_ms;
842013d2:	21 f0 d2 8e 	M[r0 + 840] = rMAC;
    return TRUE;
842013d6:	42 20       	r0 = Null + 1;

842013d8 <Lc_vol_ctlr_opmsg_set_downstream_latency_est_4>:
}
842013d8:	f1 48       	popm <FP, r4, rLink>;
842013da:	d8 4c       	rts;

842013dc <Lc_vol_ctrl_fixup_buffer_details_1>:
 */
static bool vol_ctrl_fixup_buffer_details(VOL_CTRL_DATA_T *op_extra_data, unsigned terminal_id, OP_BUF_DETAILS_RSP *resp)
{
    patch_fn_shared(volume_control_wrapper);

    return TRUE;
842013dc:	42 20       	r0 = Null + 1;

842013de <Lc_vol_ctrl_fixup_buffer_details_2>:
842013de:	d8 4c       	rts;

842013e0 <Lc_vol_ctrl_recalc_main_buffer_size_1>:
842013e0:	d8 4c       	rts;

842013e2 <Lc_vol_ctrl_recalc_aux_buffer_size_1>:

/**
 * \brief Update aux_buffer_size with the minimum of connected aux buffers' sizes
 */
static void vol_ctrl_recalc_aux_buffer_size(VOL_CTRL_DATA_T *op_extra_data)
{
842013e2:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
842013e4:	16 00       	r4 = r0 + Null;
    unsigned ch;
    unsigned aux_buffer_min_size = MAXINT;
842013e6:	ff f7 f8 f7 	r6 = Null + 2147483647;
842013ea:	ff 7b 

    patch_fn_shared(volume_control_wrapper);

    for (ch = 0; ch < VOL_CTRL_CONSTANT_NUM_CHANNELS; ch += 1)
842013ec:	07 00       	r5 = Null + Null;
842013ee:	69 f0 6c 20 	r7 = r4 + 108;

842013f2 <Lc_vol_ctrl_recalc_aux_buffer_size_2>:
    {
        tCbuffer* aux_buffer = op_extra_data->aux_channel[ch].buffer;
        if (aux_buffer != NULL)
842013f2:	92 f0 00 e8 	r0 = M[r7 + Null];
842013f6:	08 60       	if EQ jump (m) Lc_vol_ctrl_recalc_aux_buffer_size_5;

842013f8 <Lc_vol_ctrl_recalc_aux_buffer_size_3>:
        {
            unsigned size = cbuffer_get_size_in_words(aux_buffer);
842013f8:	ef fd fc ff 	call (m) 0xc80;
842013fc:	29 e4 
            aux_buffer_min_size = MIN(aux_buffer_min_size, size);
842013fe:	2f f8 00 c2 	Null = r6 - r0;
84201402:	02 64       	if NC jump (m) Lc_vol_ctrl_recalc_aux_buffer_size_5;

84201404 <Lc_vol_ctrl_recalc_aux_buffer_size_4>:
84201404:	10 09       	r6 = r0 + Null;

84201406 <Lc_vol_ctrl_recalc_aux_buffer_size_5>:
    unsigned ch;
    unsigned aux_buffer_min_size = MAXINT;

    patch_fn_shared(volume_control_wrapper);

    for (ch = 0; ch < VOL_CTRL_CONSTANT_NUM_CHANNELS; ch += 1)
84201406:	7f 20       	r5 = r5 + 1;
84201408:	81 75       	r7 = r7 + 16;
8420140a:	38 26       	Null = r5 - 8;
8420140c:	f3 65       	if NC jump (m) Lc_vol_ctrl_recalc_aux_buffer_size_2;

8420140e <Lc_vol_ctrl_recalc_aux_buffer_size_6>:
        {
            unsigned size = cbuffer_get_size_in_words(aux_buffer);
            aux_buffer_min_size = MIN(aux_buffer_min_size, size);
        }
    }
    op_extra_data->aux_buff_size = aux_buffer_min_size;
8420140e:	68 f0 bb 8e 	M[r4 + 748] = r6;

84201412 <Lc_vol_ctrl_recalc_aux_buffer_size_7>:
}
84201412:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84201414:	d8 4c       	rts;

84201416 <Lc_vol_ctrl_kick_waiting_1>:
84201416:	d8 4c       	rts;

84201418 <Lc_vol_ctrl_handle_aux_metadata_1>:
 *          delete all other aux metadata
 * \param op_extra_data     volume control operator specific data
 * \returns                 EOF tag, if found
 */
static metadata_tag* vol_ctrl_handle_aux_metadata(VOL_CTRL_DATA_T *op_extra_data)
{
84201418:	f3 1d       	pushm <FP(=SP), r4, r5, r6, rLink>, SP = SP + 0x10;
8420141a:	17 00       	r5 = r0 + Null;
    metadata_tag* aux_tag_head = NULL;
8420141c:	02 00       	r0 = Null + Null;
    metadata_tag* eoftag = NULL;
8420141e:	06 00       	r4 = Null + Null;
    metadata_tag* tmp_tag = NULL;
    metadata_tag* prev_tag = NULL;
84201420:	00 09       	r6 = Null + Null;
    unsigned b4idx, afteridx;

    /* get aux metadata, if applicable */
    if (op_extra_data->metadata_aux_channel != NULL)
84201422:	39 a9       	rMAC = M[r5 + 80];
84201424:	09 60       	if EQ jump (m) Lc_vol_ctrl_handle_aux_metadata_3;

84201426 <Lc_vol_ctrl_handle_aux_metadata_2>:
    {
        aux_tag_head = buff_metadata_remove(op_extra_data->metadata_aux_channel->buffer,
                                            op_extra_data->metadata_aux_channel->advance_buffer * OCTETS_PER_SAMPLE,
                                            &b4idx, &afteridx);
84201426:	85 11       	r3 = FP + 24;
84201428:	44 11       	r2 = FP + 20;
8420142a:	ca 88       	r0 = M[rMAC + 12];
8420142c:	53 54       	r1 = r0 LSHIFT 2;
8420142e:	0a e8       	r0 = M[rMAC + Null];
84201430:	ef fd fe ff 	call (m) 0x1218;
84201434:	29 ef 

84201436 <Lc_vol_ctrl_handle_aux_metadata_3>:
    }

    /* only look for EOF if we could output it */
    if (op_extra_data->metadata_op_buffer != NULL)
84201436:	f9 a8       	rMAC = M[r5 + 76];
84201438:	14 60       	if EQ jump (m) Lc_vol_ctrl_handle_aux_metadata_12;

8420143a <Lc_vol_ctrl_handle_aux_metadata_4>:
    {
        /* search for eof tag in aux metadata */
        tmp_tag = aux_tag_head;
8420143a:	11 00       	rMAC = r0 + Null;

8420143c <Lc_vol_ctrl_handle_aux_metadata_5>:
        while (tmp_tag != NULL && !METADATA_STREAM_END(tmp_tag))
8420143c:	08 04       	Null = rMAC - Null;
8420143e:	11 60       	if EQ jump (m) Lc_vol_ctrl_handle_aux_metadata_12;

84201440 <Lc_vol_ctrl_handle_aux_metadata_6>:
84201440:	4b 88       	r1 = M[rMAC + 4];
84201442:	5b c0       	r1 = r1 AND 0x2;
84201444:	04 62       	if NE jump (m) Lc_vol_ctrl_handle_aux_metadata_8;

84201446 <Lc_vol_ctrl_handle_aux_metadata_7>:
        {
            prev_tag = tmp_tag;
84201446:	08 09       	r6 = rMAC + Null;
            tmp_tag = tmp_tag->next;
84201448:	09 e8       	rMAC = M[rMAC + Null];
    /* only look for EOF if we could output it */
    if (op_extra_data->metadata_op_buffer != NULL)
    {
        /* search for eof tag in aux metadata */
        tmp_tag = aux_tag_head;
        while (tmp_tag != NULL && !METADATA_STREAM_END(tmp_tag))
8420144a:	f9 6f       	jump (m) Lc_vol_ctrl_handle_aux_metadata_5;

8420144c <Lc_vol_ctrl_handle_aux_metadata_8>:
            tmp_tag = tmp_tag->next;
        }
        if (tmp_tag != NULL)
        {
            /* EOF tag was found in aux metadata*/
            eoftag = tmp_tag;
8420144c:	0e 00       	r4 = rMAC + Null;
            /* remove it from the list */
            if (prev_tag != NULL)
8420144e:	0f f8 00 c2 	Null = r6 - Null;
84201452:	05 60       	if EQ jump (m) Lc_vol_ctrl_handle_aux_metadata_10;

84201454 <Lc_vol_ctrl_handle_aux_metadata_9>:
            {
                prev_tag->next = eoftag->next;
84201454:	0b e8       	r1 = M[rMAC + Null];
84201456:	83 f0 00 ee 	M[r6 + Null] = r1;
8420145a:	02 6e       	jump (m) Lc_vol_ctrl_handle_aux_metadata_11;

8420145c <Lc_vol_ctrl_handle_aux_metadata_10>:
            }
            else
            {
                aux_tag_head = eoftag->next;
8420145c:	0a e8       	r0 = M[rMAC + Null];

8420145e <Lc_vol_ctrl_handle_aux_metadata_11>:
            }
            eoftag->next = NULL;
8420145e:	08 ee       	M[rMAC + Null] = Null;

84201460 <Lc_vol_ctrl_handle_aux_metadata_12>:
        }
    }
    /* delete aux metadata anyways */
    buff_metadata_tag_list_delete(aux_tag_head);
84201460:	ef fd fc ff 	call (m) 0xe3a;
84201464:	3b ee 

    return eoftag;
84201466:	32 00       	r0 = r4 + Null;

84201468 <Lc_vol_ctrl_handle_aux_metadata_13>:
}
84201468:	f3 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, rLink>;
8420146a:	d8 4c       	rts;

8420146c <Lc_vol_ctrl_handle_input_metadata_1>:
 * \brief Transport metadata from input to output and handle aux EOF.
 * \param op_extra_data     volume control operator specific data
 * \param eoftag            EOF tag, if found in aux metadata
 */
static void vol_ctrl_handle_input_metadata(VOL_CTRL_DATA_T *op_extra_data, metadata_tag* eoftag)
{
8420146c:	f4 1d       	pushm <FP(=SP), r4, r5, r6, r7, rLink>, SP = SP + 0x10;
8420146e:	16 00       	r4 = r0 + Null;
84201470:	18 09       	r6 = r1 + Null;
    metadata_tag *ret_mtag;
    metadata_tag* tmp_tag = NULL;
    metadata_tag* prev_tag = NULL;
    unsigned b4idx, afteridx;
    unsigned input_amount = op_extra_data->tc.num_words * OCTETS_PER_SAMPLE;
84201472:	62 f0 b2 88 	r0 = M[r4 + 712];
84201476:	01 f2 d9 c8 	r7 = r0 LSHIFT 2;

    /* get input metadata, if applicable*/
    if (op_extra_data->metadata_ip_buffer != NULL)
8420147a:	b2 a8       	r0 = M[r4 + 72];
8420147c:	09 60       	if EQ jump (m) Lc_vol_ctrl_handle_input_metadata_3;

8420147e <Lc_vol_ctrl_handle_input_metadata_2>:
    {
        ret_mtag = buff_metadata_remove(op_extra_data->metadata_ip_buffer,
                                        input_amount, &b4idx, &afteridx);
8420147e:	c5 11       	r3 = FP + 28;
84201480:	84 11       	r2 = FP + 24;
84201482:	4b 08       	r1 = r7 + Null;
84201484:	ef fd fe ff 	call (m) 0x1218;
84201488:	35 ec 
8420148a:	17 00       	r5 = r0 + Null;
8420148c:	05 6e       	jump (m) Lc_vol_ctrl_handle_input_metadata_4;

8420148e <Lc_vol_ctrl_handle_input_metadata_3>:
    }
    else
    {
        b4idx = 0;
8420148e:	30 de       	M[FP + 24] = Null;
        afteridx = input_amount;
84201490:	e9 f0 07 8e 	M[FP + 28] = r7;
        ret_mtag = NULL;
84201494:	07 00       	r5 = Null + Null;

84201496 <Lc_vol_ctrl_handle_input_metadata_4>:
    }

    if (op_extra_data->metadata_op_buffer != NULL)
84201496:	f1 a8       	rMAC = M[r4 + 76];
84201498:	78 60       	if EQ jump (m) Lc_vol_ctrl_handle_input_metadata_36;

8420149a <Lc_vol_ctrl_handle_input_metadata_5>:
    {
#ifdef VOLUME_CONTROL_AUX_TTP_SUPPORT
        if(op_extra_data->aux0_ttp.generate_ttp)
8420149a:	60 f0 c8 88 	Null = M[r4 + 800];
8420149e:	06 60       	if EQ jump (m) Lc_vol_ctrl_handle_input_metadata_7;

842014a0 <Lc_vol_ctrl_handle_input_metadata_6>:
        {
            /* Operator shall generate timestamp itself, this
             * is done by time-stamping VOID tags.
             */
            vol_ctrl_timestamp_void_tags(op_extra_data, ret_mtag, b4idx);
842014a0:	34 d8       	r2 = M[FP + 24];
842014a2:	3b 00       	r1 = r5 + Null;
842014a4:	32 00       	r0 = r4 + Null;
842014a6:	01 f0 21 e2 	call (m) Lc_vol_ctrl_timestamp_void_tags_1;

842014aa <Lc_vol_ctrl_handle_input_metadata_7>:
        }
#endif
        if (ret_mtag == NULL)
842014aa:	38 04       	Null = r5 - Null;
842014ac:	31 62       	if NE jump (m) Lc_vol_ctrl_handle_input_metadata_19;

842014ae <Lc_vol_ctrl_handle_input_metadata_8>:
            /* No metadata in input: we cannot append EOF tags!
             * In this case we need to save the EOF tag until
             * a new input tag comes in.
             * If none does, we need to recognise the data closing
             * the last received tag and append the EOF there. */
            if (eoftag != NULL)
842014ae:	0f f8 00 c2 	Null = r6 - Null;
842014b2:	12 60       	if EQ jump (m) Lc_vol_ctrl_handle_input_metadata_13;

842014b4 <Lc_vol_ctrl_handle_input_metadata_9>:
            {
                /* Save it for next run. */
                if (op_extra_data->last_eoftag != NULL)
842014b4:	72 a9       	r0 = M[r4 + 84];
842014b6:	04 60       	if EQ jump (m) Lc_vol_ctrl_handle_input_metadata_11;

842014b8 <Lc_vol_ctrl_handle_input_metadata_10>:
                {
                    /* We already had a pending EOF tag. Delete it. */
                    buff_metadata_tag_list_delete(op_extra_data->last_eoftag);
842014b8:	ef fd fc ff 	call (m) 0xe3a;
842014bc:	23 ec 

842014be <Lc_vol_ctrl_handle_input_metadata_11>:
                }
                op_extra_data->last_eoftag = eoftag;
842014be:	68 f0 15 8e 	M[r4 + 84] = r6;
                L2_DBG_MSG("volume_control: aux EOF saved for next run");
842014c2:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
842014c6:	88 24       	Null = rMAC - 2;
842014c8:	07 68       	if LT jump (m) Lc_vol_ctrl_handle_input_metadata_13;

842014ca <Lc_vol_ctrl_handle_input_metadata_12>:
842014ca:	55 f1 02 f0 	r0 = Null + 357564416;
842014ce:	00 40 
842014d0:	ef fd fa ff 	call (m) 0x9cc;
842014d4:	3d e7 

842014d6 <Lc_vol_ctrl_handle_input_metadata_13>:
            }
            if (op_extra_data->last_tag_data_remaining <= input_amount)
842014d6:	b1 a9       	rMAC = M[r4 + 88];
842014d8:	9f f1 00 c2 	Null = rMAC - r7;
842014dc:	08 f0 ab e0 	if HI jump (m) Lc_vol_ctrl_handle_input_metadata_18;

842014e0 <Lc_vol_ctrl_handle_input_metadata_14>:
            {
                /* The last received tag is closed now and no other tags
                 * came through. If we had a pending EOF tag,
                 * we need to output it now */
                if (op_extra_data->last_eoftag != NULL)
842014e0:	71 a9       	rMAC = M[r4 + 84];
842014e2:	10 60       	if EQ jump (m) Lc_vol_ctrl_handle_input_metadata_17;

842014e4 <Lc_vol_ctrl_handle_input_metadata_15>:
                {
                    ret_mtag = op_extra_data->last_eoftag;
842014e4:	0f 00       	r5 = rMAC + Null;
                    /* clear backup ptr */
                    op_extra_data->last_eoftag = NULL;
842014e6:	70 af       	M[r4 + 84] = Null;
                    b4idx = input_amount;
842014e8:	e9 f0 06 8e 	M[FP + 24] = r7;
                    afteridx = 0;
842014ec:	38 de       	M[FP + 28] = Null;
                    L2_DBG_MSG("volume_control: ORPHAN aux EOF moved to output");
842014ee:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
842014f2:	88 24       	Null = rMAC - 2;
842014f4:	07 68       	if LT jump (m) Lc_vol_ctrl_handle_input_metadata_17;

842014f6 <Lc_vol_ctrl_handle_input_metadata_16>:
842014f6:	55 f1 02 f0 	r0 = Null + 357564459;
842014fa:	2b 40 
842014fc:	ef fd fa ff 	call (m) 0x9cc;
84201500:	31 e6 

84201502 <Lc_vol_ctrl_handle_input_metadata_17>:
                }
                op_extra_data->last_tag_data_remaining = 0;
84201502:	b0 af       	M[r4 + 88] = Null;
84201504:	3a 6e       	jump (m) Lc_vol_ctrl_handle_input_metadata_35;

84201506 <Lc_vol_ctrl_handle_input_metadata_18>:
            }
            else
            {
                /* update the number of octets to come to complete the last tag */
                op_extra_data->last_tag_data_remaining -= input_amount;
84201506:	00 f9 31 c2 	rMAC = rMAC - r7;
8420150a:	b1 af       	M[r4 + 88] = rMAC;
8420150c:	36 6e       	jump (m) Lc_vol_ctrl_handle_input_metadata_35;

8420150e <Lc_vol_ctrl_handle_input_metadata_19>:
        }
        else
        {
            /* Check if we found an EOF on a previous run where input had no
             * metadata and we could not append it on the output. */
            if (op_extra_data->last_eoftag != NULL && ret_mtag != NULL)
8420150e:	71 a9       	rMAC = M[r4 + 84];
84201510:	0e 60       	if EQ jump (m) Lc_vol_ctrl_handle_input_metadata_22;

84201512 <Lc_vol_ctrl_handle_input_metadata_20>:
            {
                /* Transport now at the beginning of the output*/
                op_extra_data->last_eoftag->next = ret_mtag;
84201512:	0f ee       	M[rMAC + Null] = r5;
                ret_mtag = op_extra_data->last_eoftag;
84201514:	77 a9       	r5 = M[r4 + 84];
                /* clear backup ptr */
                op_extra_data->last_eoftag = NULL;
84201516:	70 af       	M[r4 + 84] = Null;
                L2_DBG_MSG("volume_control: previous aux EOF moved to output");
84201518:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
8420151c:	88 24       	Null = rMAC - 2;
8420151e:	07 68       	if LT jump (m) Lc_vol_ctrl_handle_input_metadata_22;

84201520 <Lc_vol_ctrl_handle_input_metadata_21>:
84201520:	55 f1 02 f0 	r0 = Null + 357564506;
84201524:	5a 40 
84201526:	ef fd fa ff 	call (m) 0x9cc;
8420152a:	27 e5 

8420152c <Lc_vol_ctrl_handle_input_metadata_22>:
            }

            /* find the last tag of input metadata */
            tmp_tag = ret_mtag;
8420152c:	3a 00       	r0 = r5 + Null;
            prev_tag = NULL;
8420152e:	01 00       	rMAC = Null + Null;

84201530 <Lc_vol_ctrl_handle_input_metadata_23>:
            while (tmp_tag->next != NULL)
84201530:	13 e8       	r1 = M[r0 + Null];
84201532:	04 60       	if EQ jump (m) Lc_vol_ctrl_handle_input_metadata_25;

84201534 <Lc_vol_ctrl_handle_input_metadata_24>:
            {
                prev_tag = tmp_tag;
84201534:	11 00       	rMAC = r0 + Null;
                tmp_tag = tmp_tag->next;
84201536:	1a 00       	r0 = r1 + Null;
84201538:	fc 6f       	jump (m) Lc_vol_ctrl_handle_input_metadata_23;

8420153a <Lc_vol_ctrl_handle_input_metadata_25>:
            }

            /* save the number of octets to come to complete the last tag*/
            if (afteridx > 0 && afteridx <= tmp_tag->length)
8420153a:	3b d8       	r1 = M[FP + 28];
8420153c:	08 60       	if EQ jump (m) Lc_vol_ctrl_handle_input_metadata_28;

8420153e <Lc_vol_ctrl_handle_input_metadata_26>:
8420153e:	d4 88       	r2 = M[r0 + 12];
84201540:	18 05       	Null = r1 - r2;
84201542:	08 f0 8b e0 	if HI jump (m) Lc_vol_ctrl_handle_input_metadata_28;

84201546 <Lc_vol_ctrl_handle_input_metadata_27>:
            {
                op_extra_data->last_tag_data_remaining = tmp_tag->length - afteridx;
84201546:	e3 04       	r1 = r2 - r1;
84201548:	b3 af       	M[r4 + 88] = r1;
8420154a:	02 6e       	jump (m) Lc_vol_ctrl_handle_input_metadata_29;

8420154c <Lc_vol_ctrl_handle_input_metadata_28>:
            }
            else
            {
                op_extra_data->last_tag_data_remaining = 0;
8420154c:	b0 af       	M[r4 + 88] = Null;

8420154e <Lc_vol_ctrl_handle_input_metadata_29>:
            }

            if (eoftag != NULL)
8420154e:	0f f8 00 c2 	Null = r6 - Null;
84201552:	13 60       	if EQ jump (m) Lc_vol_ctrl_handle_input_metadata_35;

84201554 <Lc_vol_ctrl_handle_input_metadata_30>:
            {
                /* We found an EOF on the aux channel on this run
                 * bring it on the output in second to last position:
                 * aux_tag is the last tag, place eof tag in front of it. */
                eoftag->next = tmp_tag;
84201554:	82 f0 00 ee 	M[r6 + Null] = r0;
                if (prev_tag == NULL)
84201558:	08 04       	Null = rMAC - Null;
8420155a:	03 62       	if NE jump (m) Lc_vol_ctrl_handle_input_metadata_32;

8420155c <Lc_vol_ctrl_handle_input_metadata_31>:
                {
                    ret_mtag = eoftag;
8420155c:	47 08       	r5 = r6 + Null;
8420155e:	03 6e       	jump (m) Lc_vol_ctrl_handle_input_metadata_33;

84201560 <Lc_vol_ctrl_handle_input_metadata_32>:
                }
                else
                {
                    prev_tag->next = eoftag;
84201560:	18 f0 00 ee 	M[rMAC + Null] = r6;

84201564 <Lc_vol_ctrl_handle_input_metadata_33>:
                }
                L2_DBG_MSG("volume_control: aux EOF moved to output");
84201564:	01 f0 3c 91 	rMAC = MBS[Null + 0x33c];
84201568:	88 24       	Null = rMAC - 2;
8420156a:	07 68       	if LT jump (m) Lc_vol_ctrl_handle_input_metadata_35;

8420156c <Lc_vol_ctrl_handle_input_metadata_34>:
8420156c:	55 f1 02 f0 	r0 = Null + 357564555;
84201570:	8b 40 
84201572:	ef fd fa ff 	call (m) 0x9cc;
84201576:	3b e2 

84201578 <Lc_vol_ctrl_handle_input_metadata_35>:
            }
        }
        /* write metadata to output */
        buff_metadata_append(op_extra_data->metadata_op_buffer, ret_mtag, b4idx, afteridx);
84201578:	3d d8       	r3 = M[FP + 28];
8420157a:	34 d8       	r2 = M[FP + 24];
8420157c:	f2 a8       	r0 = M[r4 + 76];
8420157e:	3b 00       	r1 = r5 + Null;
84201580:	ef fd fd ff 	call (m) 0x1004;
84201584:	25 e4 
84201586:	05 6e       	jump (m) Lc_vol_ctrl_handle_input_metadata_37;

84201588 <Lc_vol_ctrl_handle_input_metadata_36>:
    }
    else
    {
        /* we cannot output metadata, delete input metadata */
        buff_metadata_tag_list_delete(ret_mtag);
84201588:	3a 00       	r0 = r5 + Null;
8420158a:	ef fd fc ff 	call (m) 0xe3a;
8420158e:	31 e5 

84201590 <Lc_vol_ctrl_handle_input_metadata_37>:
    }
}
84201590:	f4 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, rLink>;
84201592:	d8 4c       	rts;

84201594 <Lc_vol_ctrl_update_current_timestamp_1>:
 *        playback of aux inputs.
 * \param op_extra_data volume control operator specific data
 * \param amount_consumed amount of input consumed since last update
 */
static void vol_ctrl_update_current_timestamp(VOL_CTRL_DATA_T *op_extra_data)
{
84201594:	f4 1d       	pushm <FP(=SP), r4, r5, r6, r7, rLink>, SP = SP + 0x10;
84201596:	10 09       	r6 = r0 + Null;
    unsigned amount_consumed = op_extra_data->prev_consumed_samples;
84201598:	87 f0 cf 88 	r5 = M[r6 + 828];
    /* This will be set again when op consumes samples from input */
    op_extra_data->prev_consumed_samples = 0;
8420159c:	80 f0 cf 8e 	M[r6 + 828] = Null;
#endif

    /* 1. See if we see timestamp in input buffer, if we do then that will
     *    be used for timed mixing of aux input.
     */
    unsigned b4idx = 0;
842015a0:	30 de       	M[FP + 24] = Null;
    metadata_tag *mtag = buff_metadata_peek_ex(op_extra_data->metadata_ip_buffer, &b4idx);
842015a2:	83 11       	r1 = FP + 24;
842015a4:	82 f0 12 88 	r0 = M[r6 + 72];
842015a8:	ef fd fd ff 	call (m) 0x117e;
842015ac:	37 ee 
842015ae:	16 00       	r4 = r0 + Null;
842015b0:	06 6e       	jump (m) Lc_vol_ctrl_update_current_timestamp_3;

842015b2 <Lc_vol_ctrl_update_current_timestamp_2>:

            /* Op isn't generating ttp itself */
            op_extra_data->aux0_ttp.generate_ttp = FALSE;
            return;
        }
        b4idx += mtag->length;
842015b2:	f1 88       	rMAC = M[r4 + 12];
842015b4:	32 d8       	r0 = M[FP + 24];
842015b6:	51 00       	rMAC = r0 + rMAC;
842015b8:	31 de       	M[FP + 24] = rMAC;
        mtag = mtag->next;
842015ba:	36 e8       	r4 = M[r4 + Null];

842015bc <Lc_vol_ctrl_update_current_timestamp_3>:
    /* 1. See if we see timestamp in input buffer, if we do then that will
     *    be used for timed mixing of aux input.
     */
    unsigned b4idx = 0;
    metadata_tag *mtag = buff_metadata_peek_ex(op_extra_data->metadata_ip_buffer, &b4idx);
    while(mtag != NULL)
842015bc:	30 04       	Null = r4 - Null;
842015be:	36 60       	if EQ jump (m) Lc_vol_ctrl_update_current_timestamp_10;

842015c0 <Lc_vol_ctrl_update_current_timestamp_4>:
    {
        /* Search the input buffer metadata, if we see a TTP tag, then we use input time
         * stamps for the purpose of mixing time of auxiliary inputs to main inputs.
         */
        if(IS_TIMESTAMPED_TAG(mtag))
842015c0:	71 88       	rMAC = M[r4 + 4];
842015c2:	12 f0 30 00 	r0 = rMAC AND 0x30;
842015c6:	f6 61       	if EQ jump (m) Lc_vol_ctrl_update_current_timestamp_2;

842015c8 <Lc_vol_ctrl_update_current_timestamp_5>:
842015c8:	c9 c2       	rMAC = rMAC AND 0x40;
842015ca:	f4 63       	if NE jump (m) Lc_vol_ctrl_update_current_timestamp_2;

842015cc <Lc_vol_ctrl_update_current_timestamp_6>:
        {
            unsigned *err_offset_id;
            unsigned out_length;
            /* go back to first input sample */
            TIME_INTERVAL time_back = convert_samples_to_time(b4idx / OCTETS_PER_SAMPLE,
                                                              op_extra_data->sample_rate);
842015cc:	83 f0 3b 88 	r1 = M[r6 + 236];
842015d0:	32 d8       	r0 = M[FP + 24];
842015d2:	52 50       	r0 = r0 LSHIFT -2;
842015d4:	ff fd ae f0 	call (m) 0x17230;
842015d8:	3d e2 
            op_extra_data->current_timestamp = time_sub(mtag->timestamp, time_back);
842015da:	31 89       	rMAC = M[r4 + 16];
842015dc:	89 04       	rMAC = rMAC - r0;
842015de:	81 f0 cc 8e 	M[r6 + 816] = rMAC;
            if (buff_metadata_find_private_data(mtag, META_PRIV_KEY_TTP_OFFSET, &out_length,
                                                (void **)&err_offset_id))
842015e2:	c5 11       	r3 = FP + 28;
842015e4:	04 12       	r2 = FP + 32;
842015e6:	43 20       	r1 = Null + 1;
842015e8:	32 00       	r0 = r4 + Null;
842015ea:	ef fd fc ff 	call (m) 0xfae;
842015ee:	25 ee 
842015f0:	10 04       	Null = r0 - Null;
842015f2:	0e 60       	if EQ jump (m) Lc_vol_ctrl_update_current_timestamp_9;

842015f4 <Lc_vol_ctrl_update_current_timestamp_7>:
            {
                int *err_offset_ptr = ttp_info_get(*err_offset_id);
842015f4:	39 d8       	rMAC = M[FP + 28];
842015f6:	0a e8       	r0 = M[rMAC + Null];
842015f8:	ff fd b9 f0 	call (m) 0x189e2;
842015fc:	2b ef 
                if (err_offset_ptr != NULL)
842015fe:	10 04       	Null = r0 - Null;
84201600:	07 60       	if EQ jump (m) Lc_vol_ctrl_update_current_timestamp_9;

84201602 <Lc_vol_ctrl_update_current_timestamp_8>:
                {
                    /* subtract the offset */
                    op_extra_data->current_timestamp =
                        time_sub(op_extra_data->current_timestamp, *err_offset_ptr);
84201602:	81 f0 cc 88 	rMAC = M[r6 + 816];
84201606:	12 e8       	r0 = M[r0 + Null];
84201608:	89 04       	rMAC = rMAC - r0;
8420160a:	81 f0 cc 8e 	M[r6 + 816] = rMAC;

8420160e <Lc_vol_ctrl_update_current_timestamp_9>:
            /* current_timestamp: time stamp associated with first sample of input
             * main_timestamp_valid: whether main input has valid timestamp
             * last_main_real_timestamp: last valid timestamp we received from main input
             */
            op_extra_data->last_main_real_timestamp =
                op_extra_data->current_timestamp;
8420160e:	81 f0 cc 88 	rMAC = M[r6 + 816];
84201612:	81 f0 cb 8e 	M[r6 + 812] = rMAC;
            op_extra_data->main_timestamp_valid = TRUE;
84201616:	41 20       	rMAC = Null + 1;
84201618:	81 f0 ca 8e 	M[r6 + 808] = rMAC;
            op_extra_data->current_timestamp_valid = TRUE;
8420161c:	81 f0 cd 8e 	M[r6 + 820] = rMAC;

            /* real timestamp from input update, no accumulated remainder*/
            op_extra_data->current_timestamp_update_remainder = 0;
84201620:	80 f0 ce 8e 	M[r6 + 824] = Null;

            /* Op isn't generating ttp itself */
            op_extra_data->aux0_ttp.generate_ttp = FALSE;
84201624:	80 f0 c8 8e 	M[r6 + 800] = Null;
84201628:	5d 6e       	jump (m) Lc_vol_ctrl_update_current_timestamp_24;

8420162a <Lc_vol_ctrl_update_current_timestamp_10>:
     *    we can build based on last received timestamp from main
     *    buffer. We stop relying on main timestamp if we
     *    haven't received any timestamp from input in last
     *    MAX_REBUILD_TIMESTAMP_PERIOD milliseconds.
     */
    if(op_extra_data->main_timestamp_valid)
8420162a:	80 f0 ca 88 	Null = M[r6 + 808];
8420162e:	13 60       	if EQ jump (m) Lc_vol_ctrl_update_current_timestamp_14;

84201630 <Lc_vol_ctrl_update_current_timestamp_11>:
    {
        TIME_INTERVAL time_passed_since_last_real_timestamp =
            time_sub(op_extra_data->current_timestamp,
                     op_extra_data->last_main_real_timestamp);
84201630:	81 f0 cc 88 	rMAC = M[r6 + 816];
84201634:	82 f0 cb 88 	r0 = M[r6 + 812];
84201638:	89 04       	rMAC = rMAC - r0;
        if(time_passed_since_last_real_timestamp >
           (int)(VOL_CTRL_AUX_USE_MAIN_TIMESTAMP_PERIOD_MS*MILLISECOND))
8420163a:	0c f0 10 f0 	Null = rMAC - 200000;
8420163e:	40 3d 
84201640:	07 6c       	if LE jump (m) Lc_vol_ctrl_update_current_timestamp_13;

84201642 <Lc_vol_ctrl_update_current_timestamp_12>:
        {
            /* stop using main timestamp */
            op_extra_data->main_timestamp_valid = FALSE;
84201642:	80 f0 ca 8e 	M[r6 + 808] = Null;
            op_extra_data->current_timestamp_valid = FALSE;
84201646:	80 f0 cd 8e 	M[r6 + 820] = Null;
            op_extra_data->current_timestamp_update_remainder = 0;
8420164a:	80 f0 ce 8e 	M[r6 + 824] = Null;

8420164e <Lc_vol_ctrl_update_current_timestamp_13>:
     * to process actual aux data.
     */
    if(!op_extra_data->main_timestamp_valid &&
       op_extra_data->aux0_ttp.enabled &&
       !op_extra_data->aux0_ttp.generate_ttp &&
       !op_extra_data->aux_active)
8420164e:	80 f0 ca 88 	Null = M[r6 + 808];
84201652:	1b 62       	if NE jump (m) Lc_vol_ctrl_update_current_timestamp_19;

84201654 <Lc_vol_ctrl_update_current_timestamp_14>:
84201654:	80 f0 c4 88 	Null = M[r6 + 784];
84201658:	15 60       	if EQ jump (m) Lc_vol_ctrl_update_current_timestamp_18;

8420165a <Lc_vol_ctrl_update_current_timestamp_15>:
8420165a:	80 f0 c8 88 	Null = M[r6 + 800];
8420165e:	15 62       	if NE jump (m) Lc_vol_ctrl_update_current_timestamp_19;

84201660 <Lc_vol_ctrl_update_current_timestamp_16>:
84201660:	80 f0 b8 88 	Null = M[r6 + 736];
84201664:	0f 62       	if NE jump (m) Lc_vol_ctrl_update_current_timestamp_18;

84201666 <Lc_vol_ctrl_update_current_timestamp_17>:
    {
        /* Start self ttp generating, with an estimated
         * target latency from current time.
         */
        TIME cur_time = time_get_time();
84201666:	ff fd 34 f0 	call (m) 0x7f4e;
8420166a:	29 e7 
        op_extra_data->current_timestamp_valid = TRUE;
8420166c:	41 20       	rMAC = Null + 1;
8420166e:	81 f0 cd 8e 	M[r6 + 820] = rMAC;
        op_extra_data->current_timestamp =
            time_add(cur_time, op_extra_data->downstream_latency_estimate);
84201672:	83 f0 d0 88 	r1 = M[r6 + 832];
84201676:	9a 00       	r0 = r1 + r0;
84201678:	82 f0 cc 8e 	M[r6 + 816] = r0;
        op_extra_data->aux0_ttp.generate_ttp = TRUE;
8420167c:	81 f0 c8 8e 	M[r6 + 800] = rMAC;
84201680:	31 6e       	jump (m) Lc_vol_ctrl_update_current_timestamp_24;

84201682 <Lc_vol_ctrl_update_current_timestamp_18>:
     * if input has valid timestamp op will not
     * generate ttp itself.
     * */
    op_extra_data->current_timestamp_valid =
        op_extra_data->main_timestamp_valid ||
        op_extra_data->aux0_ttp.generate_ttp;
84201682:	80 f0 ca 88 	Null = M[r6 + 808];
84201686:	03 60       	if EQ jump (m) Lc_vol_ctrl_update_current_timestamp_20;

84201688 <Lc_vol_ctrl_update_current_timestamp_19>:
84201688:	41 20       	rMAC = Null + 1;
8420168a:	06 6e       	jump (m) Lc_vol_ctrl_update_current_timestamp_21;

8420168c <Lc_vol_ctrl_update_current_timestamp_20>:
8420168c:	41 20       	rMAC = Null + 1;
8420168e:	80 f0 c8 88 	Null = M[r6 + 800];
84201692:	00 f0 01 c0 	if EQ rMAC = Null + Null;

84201696 <Lc_vol_ctrl_update_current_timestamp_21>:

    /* Build timestamp from previous one considering number of samples
     * consumed since
     */
    if(op_extra_data->current_timestamp_valid && amount_consumed != 0)
84201696:	81 f0 cd 8e 	M[r6 + 820] = rMAC;
8420169a:	24 60       	if EQ jump (m) Lc_vol_ctrl_update_current_timestamp_24;

8420169c <Lc_vol_ctrl_update_current_timestamp_22>:
8420169c:	38 04       	Null = r5 - Null;
8420169e:	22 60       	if EQ jump (m) Lc_vol_ctrl_update_current_timestamp_24;

842016a0 <Lc_vol_ctrl_update_current_timestamp_23>:
    {
        /* new_time_stamp = previous_time_stamp + amount_consumed/sample_rate
         * we keep a remainder to avoid the effect of truncation.
         */
        uint64 tm_mul = (uint64)amount_consumed * 1000000 +
            op_extra_data->current_timestamp_update_remainder;
842016a0:	82 f0 ce 88 	r0 = M[r6 + 824];
842016a4:	00 f0 42 ff 	rMAC = r5 * 0.00023283064365386962890625 (UU);
842016a8:	40 f7 11 cc 
842016ac:	09 50       	rMAC = rMAC LSHIFT -1 (56bit);
842016ae:	00 f1 d5 c8 	r3 = rMAC LSHIFT 0;
842016b2:	cc 57       	r2 = rMAC LSHIFT 32;
842016b4:	16 01       	r4 = r0 + r2;
842016b6:	47 03       	r5 = Null + r3 + Carry;
        TIME_INTERVAL time_passed = (TIME_INTERVAL) (tm_mul/op_extra_data->sample_rate);
842016b8:	89 f0 3b 88 	r7 = M[r6 + 236];
842016bc:	4c 08       	r2 = r7 + Null;
842016be:	05 00       	r3 = Null + Null;
842016c0:	3b 00       	r1 = r5 + Null;
842016c2:	32 00       	r0 = r4 + Null;
842016c4:	ff fd bc f0 	call (m) 0x18fa4;
842016c8:	21 e7 
842016ca:	11 00       	rMAC = r0 + Null;
        op_extra_data->current_timestamp_update_remainder =
            (unsigned)(tm_mul - ((uint64)time_passed*op_extra_data->sample_rate));
842016cc:	32 00       	r0 = r4 + Null;
842016ce:	9f f1 83 c9 	r1 = rMAC * r7 (int);
842016d2:	d2 04       	r0 = r0 - r1;
842016d4:	82 f0 ce 8e 	M[r6 + 824] = r0;
        op_extra_data->current_timestamp =
            time_add(op_extra_data->current_timestamp, time_passed);
842016d8:	82 f0 cc 88 	r0 = M[r6 + 816];
842016dc:	51 00       	rMAC = r0 + rMAC;
842016de:	81 f0 cc 8e 	M[r6 + 816] = rMAC;

842016e2 <Lc_vol_ctrl_update_current_timestamp_24>:
    }
}
842016e2:	f4 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, rLink>;
842016e4:	d8 4c       	rts;

842016e6 <Lc_vol_ctrl_timestamp_void_tags_1>:
 * \octets_before_tag octets before mtag first octet
 */
static void vol_ctrl_timestamp_void_tags(VOL_CTRL_DATA_T *op_extra_data,
                                         metadata_tag *mtag,
                                         unsigned octets_before_tag)
{
842016e6:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
842016e8:	16 00       	r4 = r0 + Null;
842016ea:	1f 00       	r5 = r1 + Null;
842016ec:	20 09       	r6 = r2 + Null;

842016ee <Lc_vol_ctrl_timestamp_void_tags_2>:
    while(NULL != mtag)
842016ee:	38 04       	Null = r5 - Null;
842016f0:	1d 60       	if EQ jump (m) Lc_vol_ctrl_timestamp_void_tags_7;

842016f2 <Lc_vol_ctrl_timestamp_void_tags_3>:
    {
        /* traverse through all tags in the list*/
        if(IS_VOID_TTP_TAG(mtag))
842016f2:	79 88       	rMAC = M[r5 + 4];
842016f4:	11 f0 70 00 	rMAC = rMAC AND 0x70;
842016f8:	10 f0 50 24 	Null = rMAC - 80;
842016fc:	13 62       	if NE jump (m) Lc_vol_ctrl_timestamp_void_tags_6;

842016fe <Lc_vol_ctrl_timestamp_void_tags_4>:
842016fe:	38 89       	Null = M[r5 + 16];
84201700:	11 62       	if NE jump (m) Lc_vol_ctrl_timestamp_void_tags_6;

84201702 <Lc_vol_ctrl_timestamp_void_tags_5>:
            /* tags is a VOID tag, turn it to a TIMESTAMP tags.
             * Note: current_timestamp field holds ttp for octet 0
             */
            TIME_INTERVAL time_passed =
                convert_samples_to_time(octets_before_tag/ADDR_PER_WORD,
                                        op_extra_data->sample_rate);
84201702:	63 f0 3b 88 	r1 = M[r4 + 236];
84201706:	7f f8 d2 c8 	r0 = r6 LSHIFT -2;
8420170a:	ff fd ad f0 	call (m) 0x17230;
8420170e:	27 e9 
            METADATA_TIME_OF_ARRIVAL_UNSET(mtag);
84201710:	79 88       	rMAC = M[r5 + 4];
84201712:	11 ff bf 1f 	rMAC = rMAC AND 0xffffffbf;
            METADATA_TIMESTAMP_SET(mtag,
                                   time_add(op_extra_data->current_timestamp, time_passed),
                                   METADATA_TIMESTAMP_LOCAL);
84201716:	c9 c9       	rMAC = rMAC OR 0x10;
84201718:	79 8e       	M[r5 + 4] = rMAC;
8420171a:	61 f0 cc 88 	rMAC = M[r4 + 816];
8420171e:	51 00       	rMAC = r0 + rMAC;
84201720:	39 8f       	M[r5 + 16] = rMAC;

84201722 <Lc_vol_ctrl_timestamp_void_tags_6>:
        }
        octets_before_tag += mtag->length;
84201722:	f9 88       	rMAC = M[r5 + 12];
84201724:	08 0d       	r6 = rMAC + r6;
        mtag = mtag->next;
84201726:	3f e8       	r5 = M[r5 + Null];
 */
static void vol_ctrl_timestamp_void_tags(VOL_CTRL_DATA_T *op_extra_data,
                                         metadata_tag *mtag,
                                         unsigned octets_before_tag)
{
    while(NULL != mtag)
84201728:	e3 6f       	jump (m) Lc_vol_ctrl_timestamp_void_tags_2;

8420172a <Lc_vol_ctrl_timestamp_void_tags_7>:
                                   METADATA_TIMESTAMP_LOCAL);
        }
        octets_before_tag += mtag->length;
        mtag = mtag->next;
    }
}
8420172a:	f3 48       	popm <FP, r4, r5, r6, rLink>;
8420172c:	d8 4c       	rts;

8420172e <Lc_vol_ctrl_setup_mute_1>:
    op_extra_data->channels = NULL;
}


static void vol_ctrl_setup_mute(VOL_CTRL_DATA_T *op_extra_data,unsigned bMute)
{
8420172e:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84201730:	16 00       	r4 = r0 + Null;
84201732:	1f 00       	r5 = r1 + Null;

    /*  cur_mute_gain = 0 at start, and default mute=FALSE
        To immediately unmute set mute_period=0
    */

    if((op_extra_data->sample_rate<1) || (op_extra_data->mute_period<1) )
84201734:	63 f0 3b 88 	r1 = M[r4 + 236];
84201738:	04 60       	if EQ jump (m) Lc_vol_ctrl_setup_mute_3;

8420173a <Lc_vol_ctrl_setup_mute_2>:
8420173a:	62 f0 c0 88 	r0 = M[r4 + 768];
8420173e:	0b 62       	if NE jump (m) Lc_vol_ctrl_setup_mute_4;

84201740 <Lc_vol_ctrl_setup_mute_3>:
    {
        /* Immediately set mute gain */
        op_extra_data->cur_mute_gain  = bMute ? 0 : FRACTIONAL(1.0);
84201740:	ff f7 f1 f7 	rMAC = Null + 2147483647;
84201744:	ff 7b 
84201746:	38 04       	Null = r5 - Null;
84201748:	01 f0 01 c0 	if NE rMAC = Null + Null;
8420174c:	61 f0 c1 8e 	M[r4 + 772] = rMAC;
        mute_increment=1;
84201750:	42 20       	r0 = Null + 1;
84201752:	17 6e       	jump (m) Lc_vol_ctrl_setup_mute_7;

84201754 <Lc_vol_ctrl_setup_mute_4>:
    }
    else
    {

        if(op_extra_data->mute_period<1000)
84201754:	20 f0 e8 27 	Null = r0 - 1000;
84201758:	02 f0 a1 e0 	if C jump (m) Lc_vol_ctrl_setup_mute_6;

8420175c <Lc_vol_ctrl_setup_mute_5>:
        {
            mute_increment = pl_fractional_divide(op_extra_data->mute_period,1000);
8420175c:	03 f0 e8 43 	r1 = Null + 1000;
84201760:	ff fd b7 f1 	call (m) 0x386a4;
84201764:	25 ea 
            mute_increment = pl_fractional_divide(1,frac_mult(mute_increment,op_extra_data->sample_rate));
84201766:	63 f0 3b 88 	r1 = M[r4 + 236];
8420176a:	3f f2 43 c9 	r1 = r0 * r1 (frac);
8420176e:	42 20       	r0 = Null + 1;
84201770:	ff fd b7 f1 	call (m) 0x386a4;
84201774:	35 e9 
84201776:	05 6e       	jump (m) Lc_vol_ctrl_setup_mute_7;

84201778 <Lc_vol_ctrl_setup_mute_6>:
        }
        else
        {
            mute_increment = pl_fractional_divide(1,op_extra_data->sample_rate);
84201778:	42 20       	r0 = Null + 1;
8420177a:	ff fd b7 f1 	call (m) 0x386a4;
8420177e:	2b e9 

84201780 <Lc_vol_ctrl_setup_mute_7>:
        }
    }

    /* Set direction of transition */
    op_extra_data->mute_increment = (bMute) ? -mute_increment : mute_increment;
84201780:	38 04       	Null = r5 - Null;
84201782:	05 60       	if EQ jump (m) Lc_vol_ctrl_setup_mute_9;

84201784 <Lc_vol_ctrl_setup_mute_8>:
84201784:	81 04       	rMAC = Null - r0;
84201786:	61 f0 c2 8e 	M[r4 + 776] = rMAC;
8420178a:	03 6e       	jump (m) Lc_vol_ctrl_setup_mute_10;

8420178c <Lc_vol_ctrl_setup_mute_9>:
8420178c:	62 f0 c2 8e 	M[r4 + 776] = r0;

84201790 <Lc_vol_ctrl_setup_mute_10>:

}
84201790:	f2 48       	popm <FP, r4, r5, rLink>;
84201792:	d8 4c       	rts;

84201794 <Lc_ups_params_vc_1>:



static bool ups_params_vc(void* instance_data,PS_KEY_TYPE key,PERSISTENCE_RANK rank,
                          uint16 length, unsigned* data, STATUS_KYMERA status,uint16 extra_status_info)
{
84201794:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84201796:	2f 00       	r5 = r3 + Null;
/****************************************************************************
Private Function Definitions
*/
static inline VOL_CTRL_DATA_T *get_instance_data(OPERATOR_DATA *op_data)
{
    return (VOL_CTRL_DATA_T *) base_op_get_instance_data(op_data);
84201798:	ef fd f5 ff 	call (m) 0x1e2;
8420179c:	2b e2 
8420179e:	16 00       	r4 = r0 + Null;
static bool ups_params_vc(void* instance_data,PS_KEY_TYPE key,PERSISTENCE_RANK rank,
                          uint16 length, unsigned* data, STATUS_KYMERA status,uint16 extra_status_info)
{
    VOL_CTRL_DATA_T *op_extra_data = get_instance_data((OPERATOR_DATA*)instance_data);

    cpsSetParameterFromPsStore(&op_extra_data->parms_def,length,data,status);
842017a0:	e5 d5       	r3 = MHS[FP + -8];
842017a2:	fc d9       	r2 = M[FP + -4];
842017a4:	62 f0 b4 22 	r0 = r4 + 692;
842017a8:	3b 00       	r1 = r5 + Null;
842017aa:	ef fd f7 ff 	call (m) 0x73a;
842017ae:	31 ec 

    /* Set the Reinit flag after setting the parameters */
    op_extra_data->ReInitFlag = 1;
842017b0:	41 20       	rMAC = Null + 1;
842017b2:	61 f0 ac 8e 	M[r4 + 688] = rMAC;

    return TRUE;
842017b6:	0a 00       	r0 = rMAC + Null;

842017b8 <Lc_ups_params_vc_2>:
}
842017b8:	f2 48       	popm <FP, r4, r5, rLink>;
842017ba:	d8 4c       	rts;

842017bc <$_VOL_CTRL_GetDefaults>:
   0x7999999Au,			// LIMIT_ADAPTATION_RATIO
   0xFFD57A44u			// LIMIT_THRESHOLD_LOG
};

unsigned *VOL_CTRL_GetDefaults(unsigned capid){
	switch(capid){
842017bc:	20 f0 48 24 	Null = r0 - 72;
842017c0:	05 60       	if EQ jump (m) Lc_VOL_CTRL_GetDefaults_3;

842017c2 <Lc_VOL_CTRL_GetDefaults_2>:
842017c2:	01 f0 20 f0 	Null = r0 - 16468;
842017c6:	54 24 
842017c8:	05 62       	if NE jump (m) Lc_VOL_CTRL_GetDefaults_4;

842017ca <Lc_VOL_CTRL_GetDefaults_3>:
		case 0x0048: return defaults_vol_ctrlVOL_V2PLUS;
842017ca:	f8 ff 02 f0 	r0 = Null + -8388604;
842017ce:	04 40 
842017d0:	02 6e       	jump (m) Lc_VOL_CTRL_GetDefaults_5;

842017d2 <Lc_VOL_CTRL_GetDefaults_4>:
		case 0x4054: return defaults_vol_ctrlVOL_V2PLUS;
	}
	return((unsigned *)0);
842017d2:	02 00       	r0 = Null + Null;

842017d4 <Lc_VOL_CTRL_GetDefaults_5>:
842017d4:	d8 4c       	rts;

842017d6 <$kdc_start>:
.MODULE $M.kdc_start;
.CODESEGMENT PM;
.DATASEGMENT DM;

$kdc_start:
r0 = $_vol_ctlr_cap_data;
842017d6:	07 f0 02 f0 	r0 = Null + 7340176;
842017da:	90 40 
    /* Force this symbol to be exported in ELF */
    Null = $___kymera_debug_map_addr;
842017dc:	20 f0 bc 42 	Null = Null + 17084;

842017e0 <$_vol_ctrl_update_aux_state>:
.CONST $vol_ctrl.axfp.period        4*ADDR_PER_WORD;  // r3
.MODULE $M.vol_ctrl_update_aux_state;
    .CODESEGMENT PM;

$_vol_ctrl_update_aux_state:
    pushm <r5,r7>;
842017e0:	28 f0 40 e0 	pushm <r5, r7>;

    LIBS_PUSH_R0_SLOW_SW_ROM_PATCH_POINT($vol_ctrl_update_aux_state.PATCH_ID_0, r7)

    // Check if any AUX to monitor
    r7 = r1;
842017e4:	19 09       	r7 = r1 + Null;
    if Z jump update_aux_state_abort;
842017e6:	b7 60       	if EQ jump (m) $M.vol_ctrl_update_aux_state.update_aux_state_abort;

    r5 = r0;
842017e8:	17 00       	r5 = r0 + Null;

    /* Setup Parameters Pointer */
    r1 = r0 + ($volume_control_cap._vol_ctrl_data_struct.PARAMETERS_FIELD +
               $volume_control_cap._tag_VOL_CTRL_PARAMETERS_struct.OFFSET_AUX1_SCALE_FIELD);
842017ea:	23 f0 94 21 	r1 = r0 + 404;
    /* Setup Aux Pointer */
    r0 = r5 + $volume_control_cap._vol_ctrl_data_struct.AUX_CHANNEL_FIELD;
842017ee:	72 f0 6c 20 	r0 = r5 + 108;
    /* setup period */
    r3 = M[r2 + $volume_control_cap.vol_time_constants_struct.PERIOD_FIELD];
842017f2:	25 89       	r3 = M[r2 + 16];
    /* Get number of words to process */
    r2 = M[r2 + $volume_control_cap.vol_time_constants_struct.NUM_WORDS_FIELD];
842017f4:	24 88       	r2 = M[r2 + 0];

    pushm <FP(=SP),r0,r1,r2,r3,r4,r6,r8,rLink>;
842017f6:	57 f2 4d e0 	pushm <FP(=SP), r0, r1, r2, r3, r4, r6, r8, rLink>;

    r8 = NULL;
842017fa:	02 09       	r8 = Null + Null;
    r6 = 1;
842017fc:	08 71       	r6 = Null + 1;

842017fe <$M.vol_ctrl_update_aux_state.vol_ctrl_update_aux_state_next>:

    // r0: vol_ctrl_aux_channel_t *aux
    // r1: vol_ctrl_aux_params_t *aux_params

    // Get aux->state
    r4 = M[r0 + $volume_control_cap.vol_ctrl_aux_channel_struct.STATE_FIELD];
842017fe:	56 88       	r4 = M[r0 + 4];
    // In aux timed playback mode we don't allow aux data
    // to be consumed until the right time.

    // Auxiliary timed playback is only for channel 0, skip ttp handling
    // if this isn't first aux channel.
    r1 = r5 + $volume_control_cap._vol_ctrl_data_struct.AUX_CHANNEL_FIELD;
84201800:	73 f0 6c 20 	r1 = r5 + 108;
    NULL = r1 - r0;
84201804:	98 04       	Null = r1 - r0;
    if NZ jump aux_ttp_gate_control_done;
84201806:	22 62       	if NE jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_gate_control_done;
    // timed playback requires that aux ttp to have been enabled by the user and
    // also we have valid timestamp to honour the ttp request, check both below,
    // if any fails then no gate control.

    // see if TTP is enabled for this aux channel
    NULL = M[r5 + VOL_CTRL_AUX0_TTP_FIELD(ENABLED)];
84201808:	70 f0 c4 88 	Null = M[r5 + 784];
    if Z jump aux_ttp_gate_control_done;
8420180c:	1f 60       	if EQ jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_gate_control_done;
    // also see if we have a valid timestamp to handle aux timed playback
    // if not as if aux ttp isn't enabled
    NULL = M[r5 + $volume_control_cap._vol_ctrl_data_struct.CURRENT_TIMESTAMP_VALID_FIELD];
8420180e:	70 f0 cd 88 	Null = M[r5 + 820];
    if Z jump aux_ttp_gate_control_done;
84201812:	1c 60       	if EQ jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_gate_control_done;
    // time to open the gate. We open the gate when time passes TTP_GATE_TIME,
    // this is a bit before AUX_TTP time (default 10ms but user configurable) it will
    // give time to main channel for fading.
    // r1 = time stamp for first sample
    // r3 = ttp gate time
    r1 = M[r5 + $volume_control_cap._vol_ctrl_data_struct.CURRENT_TIMESTAMP_FIELD];
84201814:	73 f0 cc 88 	r1 = M[r5 + 816];
    r3 = M[r5 + VOL_CTRL_AUX0_TTP_FIELD(GATE_TIME)];
84201818:	75 f0 c7 88 	r3 = M[r5 + 796];
    r3 = r1 - r3;
8420181c:	5d 05       	r3 = r1 - r3;
    if POS jump check_aux_ttp_expiry;
8420181e:	05 f0 97 e0 	if POS jump (m) $M.vol_ctrl_update_aux_state.check_aux_ttp_expiry;

    // gate time hasn't passed yet, AUX is expected to be
    // inactive, if for any reason it is in an active state
    // then we can't meet TTP deadline, just disable TTP playback.
    NULL = r4 - $volume_control_cap.AUX_STATE_NO_AUX;
84201822:	30 24       	Null = r4 - 0;
    if NZ jump disable_aux_ttp;
84201824:	0f 62       	if NE jump (m) $M.vol_ctrl_update_aux_state.disable_aux_ttp;
    // see if it is the time to open the gate
    // we open the gate if the gate time lies in
    // a sample within this chunk, i.e between
    // current timestamp and and next timestamp
    // timestamp ----gate_time --- (timestamp+period)
    rMAC = M[FP + $vol_ctrl.axfp.period]; // rMAC = period in 10us
84201826:	21 d8       	rMAC = M[FP + 16];
    rMAC = rMAC * 10 (int);               // rMAC = period in us
84201828:	89 42       	rMAC = rMAC * 10 (int);
    NULL = r3 + rMAC;                     // rMAC > time left to gate?
8420182a:	68 00       	Null = r3 + rMAC;
    if POS jump aux_ttp_gate_control_done;// if yes then open the gate
8420182c:	05 f0 9f e0 	if POS jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_gate_control_done;
    // keep the gate closed
    // it's not time to open the aux gate
    // don't allow anything to be consumed from aux
    M[r0 + $volume_control_cap.vol_ctrl_aux_channel_struct.ADVANCE_BUFFER_FIELD] = 0;
84201830:	d0 8e       	M[r0 + 12] = Null;
    jump aux_ttp_gate_control_done;
84201832:	0c 6e       	jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_gate_control_done;

84201834 <$M.vol_ctrl_update_aux_state.check_aux_ttp_expiry>:

check_aux_ttp_expiry:
    // if expiry time has reached and we haven't yet started
    // playing the aux then no longer need to honour the timed
    // playback request, we can't meet the deadline.
    NULL = r4 - $volume_control_cap.AUX_STATE_NO_AUX;
84201834:	30 24       	Null = r4 - 0;
    if NZ jump aux_ttp_gate_control_done;
84201836:	0a 62       	if NE jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_gate_control_done;

    r3 = M[r5 + VOL_CTRL_AUX0_TTP_FIELD(EXPIRY_TIME)];
84201838:	75 f0 c6 88 	r3 = M[r5 + 792];
    NULL = r1 - r3;
8420183c:	58 05       	Null = r1 - r3;
    if NEG jump aux_ttp_gate_control_done;
8420183e:	04 f0 8d e0 	if NEG jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_gate_control_done;

84201842 <$M.vol_ctrl_update_aux_state.disable_aux_ttp>:
    // Aux ttp has expired
disable_aux_ttp:
    // disabling aux timed playback
    M[r5 + VOL_CTRL_AUX0_TTP_FIELD(ENABLED)] = NULL;
84201842:	70 f0 c4 8e 	M[r5 + 784] = Null;
    M[r5 + VOL_CTRL_AUX0_TTP_FIELD(GENERATE_TTP)] = 0;
84201846:	70 f0 c8 8e 	M[r5 + 800] = Null;

8420184a <$M.vol_ctrl_update_aux_state.aux_ttp_gate_control_done>:
aux_ttp_gate_control_done:
#endif // VOLUME_CONTROL_AUX_TTP_SUPPORT
    // amount = aux_ptr->advance_buffer
    //        = aux_ptr->buffer ? cbuffer_calc_amount_data_in_words(aux_ptr->buffer) : 0
    r0 = M[r0 + $volume_control_cap.vol_ctrl_aux_channel_struct.ADVANCE_BUFFER_FIELD];
8420184a:	d2 88       	r0 = M[r0 + 12];


    // Is Aux Data Present in sufficient quantity to mix?
    r1 = M[FP + $vol_ctrl.axfp.num_words];
8420184c:	1b d8       	r1 = M[FP + 12];
    NULL = r1 - r0;
8420184e:	98 04       	Null = r1 - r0;
    if GT jump update_aux_state_insufficient_data;
84201850:	50 6a       	if GT jump (m) $M.vol_ctrl_update_aux_state.update_aux_state_insufficient_data;

84201852 <$M.vol_ctrl_update_aux_state.update_aux_state_sufficient_data>:

    update_aux_state_sufficient_data:
        r3 = M[FP + $vol_ctrl.axfp.aux_ptr];
84201852:	0d d8       	r3 = M[FP + 4];
        // aux_ptr->advance_buffer = volume_tc.num_words;
        M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.ADVANCE_BUFFER_FIELD]=r1;
84201854:	eb 8e       	M[r3 + 12] = r1;

        NULL = r4 - $volume_control_cap.AUX_STATE_IN_AUX;
84201856:	b0 24       	Null = r4 - 2;
        if Z jump update_aux_state_done;
84201858:	6c 60       	if EQ jump (m) $M.vol_ctrl_update_aux_state.update_aux_state_done;
        /* Not in IN_AUX state */
        NULL = r4 - $volume_control_cap.AUX_STATE_START_AUX;
8420185a:	70 24       	Null = r4 - 1;
        if Z jump update_aux_state_in_AUX_START;
8420185c:	04 60       	if EQ jump (m) $M.vol_ctrl_update_aux_state.update_aux_state_in_AUX_START;
            /* Not in START_AUX state, enter START_AUX state
               Start count down.  Don't use data until in IN_AUX state */
            r1 = $volume_control_cap.AUX_STATE_START_AUX;
8420185e:	43 20       	r1 = Null + 1;
            M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.STATE_FIELD] = r1;
84201860:	6b 8e       	M[r3 + 4] = r1;
            M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.TRANSITION_FIELD] = NULL;
84201862:	a8 8e       	M[r3 + 8] = Null;

84201864 <$M.vol_ctrl_update_aux_state.update_aux_state_in_AUX_START>:
           // jump update_aux_do_not_use_data;
        update_aux_state_in_AUX_START:
            /* Continue count down */
            r0 = M[FP + $vol_ctrl.axfp.period];
84201864:	22 d8       	r0 = M[FP + 16];
            r1 = M[FP + $vol_ctrl.axfp.aparm_ptr];
84201866:	13 d8       	r1 = M[FP + 8];
            r1 = M[r1 + $volume_control_cap.vol_ctrl_aux_params_struct.ATK_TC_FIELD];
84201868:	5b 88       	r1 = M[r1 + 4];
            rMAC = r0 * r1;
8420186a:	3f f2 c1 cc 	rMAC = r0 * r1 (SS);
            rMAC = rMAC ASHIFT (DAWTH-1) (56bit);
8420186e:	89 5f       	rMAC = rMAC ASHIFT 31 (56bit);
            r0 = M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.TRANSITION_FIELD];
84201870:	aa 88       	r0 = M[r3 + 8];
            r2 = 1.0;
84201872:	ff f7 f4 f7 	r2 = Null + 2147483647;
84201876:	ff 7b 
            rMAC = rMAC + r0;
84201878:	51 00       	rMAC = r0 + rMAC;
            if V rMAC = r2;
8420187a:	06 f4 01 c0 	if V rMAC = r2 + Null;
            M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.TRANSITION_FIELD] = rMAC;
8420187e:	a9 8e       	M[r3 + 8] = rMAC;
            NULL = rMAC - r2;
84201880:	08 05       	Null = rMAC - r2;
            if NZ jump update_aux_do_not_use_data;
84201882:	56 62       	if NE jump (m) $M.vol_ctrl_update_aux_state.update_aux_do_not_use_data;

#ifdef VOLUME_CONTROL_AUX_TTP_SUPPORT
            /* auxiliary timed playback is only for channel 0, skip ttp handling
             * if this isn't first aux channel.
             */
            r1 = r5 + $volume_control_cap._vol_ctrl_data_struct.AUX_CHANNEL_FIELD;
84201884:	73 f0 6c 20 	r1 = r5 + 108;
            NULL = r1 - r3;
84201888:	58 05       	Null = r1 - r3;
            if NZ jump aux_ttp_start_done;
8420188a:	2d 62       	if NE jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_start_done;
            // time we start mixing aux into main channel. In ttp mode we
            // might need to delay it to make sure aux starts mixing at a time
            // as close as to requested playback time.

            // see if TTP is enabled at all for aux channel
            NULL = M[r5 + VOL_CTRL_AUX0_TTP_FIELD(ENABLED)];
8420188c:	70 f0 c4 88 	Null = M[r5 + 784];
            if Z jump aux_ttp_start_done;
84201890:	2a 60       	if EQ jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_start_done;
            // and we have valid timestamp
            NULL = M[r5 + $volume_control_cap._vol_ctrl_data_struct.CURRENT_TIMESTAMP_VALID_FIELD];
84201892:	70 f0 cd 88 	Null = M[r5 + 820];
            if Z jump aux_ttp_start_done;
84201896:	27 60       	if EQ jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_start_done;

            // r1 = aux requested ttp, this is the timestamp we want the aux to be mixed with main
            // r2 = timestamp, this is the timestamp for first sample of main
            r1 = M[r5 + VOL_CTRL_AUX0_TTP_FIELD(TIME_TO_PLAY)];
84201898:	73 f0 c5 88 	r1 = M[r5 + 788];
            r2 = M[r5 + $volume_control_cap._vol_ctrl_data_struct.CURRENT_TIMESTAMP_FIELD];
8420189c:	74 f0 cc 88 	r2 = M[r5 + 816];
            r1 = r1 - r2;
842018a0:	1b 05       	r1 = r1 - r2;

            // because of the gate we expect to be very close to TTP time. If that
            // not the case, i.e. it's unexpectedly far in the future then something
            // should have gone wrong, to avoid stalling of mixing for long time ignore
            // TTP and let it go ahead with mixing.
            NULL = r1 - $vol_ctrl.MAX_EXTENDING_START_TRANSIENT_TIME_US;
842018a2:	01 f0 30 f3 	Null = r1 - 30000;
842018a6:	30 2d 
            if POS jump aux_ttp_start_done_without_ttp;
842018a8:	05 f0 b9 e0 	if POS jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_start_done_without_ttp;
            // Good news, we are very close to TTP time, lets work out how
            // many sample we are to TTP time
            // samples = time * fs
            // r1 = time*1000000, so we calculate it this way:
            // samples = (r1 / 2000) * (fs/500)
            r2 = M[r5 + $volume_control_cap._vol_ctrl_data_struct.SAMPLE_RATE_FIELD];
842018ac:	74 f0 3b 88 	r2 = M[r5 + 236];
            r2 = r2 * (1/500.0)(frac);
842018b0:	04 f0 89 f1 	r2 = r2 * 0.0019999998621642589569091796875 (frac);
842018b4:	37 f4 54 c9 
            r2 = r2 * r1 (int)(sat);
842018b8:	00 f3 f4 c9 	r2 = r2 * r1 (int) (sat);
            r2 = r2 * (1.0/2000.0)(frac); // r2 = samples to ttp time
842018bc:	01 f0 62 f0 	r2 = r2 * 0.000500000081956386566162109375 (frac);
842018c0:	4e f4 54 c9 
            // negative r2 means that ttp was in a sample in the past
            // i.e. already exited the operator, this shall not happen
            // since we open the gate at right time, however in case that
            // happened continue without ttp.
            if NEG jump aux_ttp_start_done_without_ttp;
842018c4:	04 f0 9d e0 	if NEG jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_start_done_without_ttp;

            // r2 = 0, means TTP is exactly at first sample,
            // lucky, go to IN_AUX state now and start mixing
            if Z jump aux_ttp_start_done;
842018c8:	0e 60       	if EQ jump (m) $M.vol_ctrl_update_aux_state.aux_ttp_start_done;

            // if TTP is for later than whole of this chunk then extend transient time
            rMAC = M[FP + $vol_ctrl.axfp.num_words];
842018ca:	19 d8       	rMAC = M[FP + 12];
            NULL = r2 - rMAC;
842018cc:	60 04       	Null = r2 - rMAC;
            if POS jump update_aux_do_not_use_data;
842018ce:	05 f0 e1 e0 	if POS jump (m) $M.vol_ctrl_update_aux_state.update_aux_do_not_use_data;

            // TTP lies somewhere within current chunk, we split the
            // current chunk, so only samples before TTP are consumed
            // from the main channel, so next time will be start of TTP
            rMAC = r5 + $volume_control_cap._vol_ctrl_data_struct.TC_FIELD;
842018d2:	71 f0 c8 22 	rMAC = r5 + 712;
            M[rMAC + $volume_control_cap.vol_time_constants_struct.NUM_WORDS_FIELD] = r2;
842018d6:	0c 8e       	M[rMAC + 0] = r2;
            M[FP + $vol_ctrl.axfp.num_words] = r2;
842018d8:	1c de       	M[FP + 12] = r2;
            r1 = r1 * 10 (int);
842018da:	9b 42       	r1 = r1 * 10 (int);
            M[FP + $vol_ctrl.axfp.period] = r1;
842018dc:	23 de       	M[FP + 16] = r1;
            jump update_aux_do_not_use_data;
842018de:	28 6e       	jump (m) $M.vol_ctrl_update_aux_state.update_aux_do_not_use_data;

842018e0 <$M.vol_ctrl_update_aux_state.aux_ttp_start_done_without_ttp>:
            // We are here since either ttp time passed or is quite into the future.
            // We aren't expected to come to this point if gate opened at right time.
            // We go to IN_AUX now and timed playback won't be honoured.
            // clearing TTP_ENABLED field but not stopping TTP generation if active,
            // this is to avoid unnecessary disturbance it timed playback.
            M[r5 + VOL_CTRL_AUX0_TTP_FIELD(ENABLED)] = 0;
842018e0:	70 f0 c4 8e 	M[r5 + 784] = Null;

842018e4 <$M.vol_ctrl_update_aux_state.aux_ttp_start_done>:
aux_ttp_start_done:
            // debug var only, just shows that started to mix aux, the flag shall be
            // cleared by the caller.
            r1 = 1;
842018e4:	43 20       	r1 = Null + 1;
            M[r5 + $volume_control_cap._vol_ctrl_data_struct.DBG_AUX_MIXING_STARTED_FIELD] = r1;
842018e6:	73 f0 d1 8e 	M[r5 + 836] = r1;
#endif // VOLUME_CONTROL_AUX_TTP_SUPPORT
            /* Entering IN_AUX state */
            r1 = $volume_control_cap.AUX_STATE_IN_AUX;
842018ea:	83 20       	r1 = Null + 2;
            M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.STATE_FIELD] = r1;
842018ec:	6b 8e       	M[r3 + 4] = r1;
            jump update_aux_state_done;
842018ee:	21 6e       	jump (m) $M.vol_ctrl_update_aux_state.update_aux_state_done;

842018f0 <$M.vol_ctrl_update_aux_state.update_aux_state_insufficient_data>:

     update_aux_state_insufficient_data:
        r3 = M[FP + $vol_ctrl.axfp.aux_ptr];
842018f0:	0d d8       	r3 = M[FP + 4];
        // aux_ptr->advance_buffer = amount;

        NULL = r4 - $volume_control_cap.AUX_STATE_NO_AUX;
842018f2:	30 24       	Null = r4 - 0;
        if Z jump update_aux_do_not_use_data;
842018f4:	1d 60       	if EQ jump (m) $M.vol_ctrl_update_aux_state.update_aux_do_not_use_data;
        /* Not in NO_AUX state */
        NULL = r4 - $volume_control_cap.AUX_STATE_END_AUX;
842018f6:	f0 24       	Null = r4 - 3;
        if Z jump update_aux_state_in_AUX_END;
842018f8:	07 60       	if EQ jump (m) $M.vol_ctrl_update_aux_state.update_aux_state_in_AUX_END;
            /* Not in END_AUX state, enter END_AUX state
               Start count down.  Don't purge data until in NO_AUX state */
            r1 = $volume_control_cap.AUX_STATE_END_AUX;
842018fa:	c3 20       	r1 = Null + 3;
            M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.STATE_FIELD] = r1;
842018fc:	6b 8e       	M[r3 + 4] = r1;
            r1 = 1.0;
842018fe:	ff f7 f3 f7 	r1 = Null + 2147483647;
84201902:	ff 7b 
            M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.TRANSITION_FIELD] = r1;
84201904:	ab 8e       	M[r3 + 8] = r1;

84201906 <$M.vol_ctrl_update_aux_state.update_aux_state_in_AUX_END>:
           // jump update_aux_do_not_use_data;
       update_aux_state_in_AUX_END:
            /* Continue count down */
            r0 = M[FP + $vol_ctrl.axfp.period];
84201906:	22 d8       	r0 = M[FP + 16];
            r1 = M[FP + $vol_ctrl.axfp.aparm_ptr];
84201908:	13 d8       	r1 = M[FP + 8];
            r1 = M[r1 + $volume_control_cap.vol_ctrl_aux_params_struct.DEC_TC_FIELD];
8420190a:	9b 88       	r1 = M[r1 + 8];
            rMAC = r0 * r1;
8420190c:	3f f2 c1 cc 	rMAC = r0 * r1 (SS);
            rMAC = rMAC ASHIFT (DAWTH-1) (56bit);
84201910:	89 5f       	rMAC = rMAC ASHIFT 31 (56bit);
            r2 = M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.TRANSITION_FIELD];
84201912:	ac 88       	r2 = M[r3 + 8];
            rMAC = r2 - rMAC;
84201914:	61 04       	rMAC = r2 - rMAC;
            if NEG rMAC=NULL;
84201916:	04 f0 01 c0 	if NEG rMAC = Null + Null;
            M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.TRANSITION_FIELD] = rMAC;
8420191a:	a9 8e       	M[r3 + 8] = rMAC;
            if GT jump update_aux_do_not_use_data;
8420191c:	09 6a       	if GT jump (m) $M.vol_ctrl_update_aux_state.update_aux_do_not_use_data;
#ifdef VOLUME_CONTROL_AUX_TTP_SUPPORT
            // timed playback is only for one tone/prompt, once
            // finished disable aux timed playback
            M[r5 + VOL_CTRL_AUX0_TTP_FIELD(GENERATE_TTP)] = 0;
8420191e:	70 f0 c8 8e 	M[r5 + 800] = Null;
            M[r5 + VOL_CTRL_AUX0_TTP_FIELD(ENABLED)] = 0;
84201922:	70 f0 c4 8e 	M[r5 + 784] = Null;
#endif
            /* Entering NO_AUX state */
            r1 = $volume_control_cap.AUX_STATE_NO_AUX;
84201926:	03 00       	r1 = Null + Null;
            M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.STATE_FIELD] = r1;
84201928:	6b 8e       	M[r3 + 4] = r1;
            M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.TRANSITION_FIELD] = NULL;
8420192a:	a8 8e       	M[r3 + 8] = Null;
            jump update_aux_state_done;
8420192c:	02 6e       	jump (m) $M.vol_ctrl_update_aux_state.update_aux_state_done;

8420192e <$M.vol_ctrl_update_aux_state.update_aux_do_not_use_data>:

update_aux_do_not_use_data:
    M[r3 + $volume_control_cap.vol_ctrl_aux_channel_struct.ADVANCE_BUFFER_FIELD] = NULL;
8420192e:	e8 8e       	M[r3 + 12] = Null;

84201930 <$M.vol_ctrl_update_aux_state.update_aux_state_done>:
update_aux_state_done:

    // Next aux channel
    r0 = M[FP + $vol_ctrl.axfp.aux_ptr];
84201930:	0a d8       	r0 = M[FP + 4];

    /* Is NO_AUX */
    NULL = M[r0 + $volume_control_cap.vol_ctrl_aux_channel_struct.STATE_FIELD];
84201932:	50 88       	Null = M[r0 + 4];
    if NZ r8 = r8 OR r6;
84201934:	81 fa 4a c8 	if NE r8 = r8 OR r6;
    r0 = r0 + ($volume_control_cap.vol_ctrl_aux_channel_struct.STRUC_SIZE*ADDR_PER_WORD);
84201938:	12 28       	r0 = r0 + 16;
    M[FP + $vol_ctrl.axfp.aux_ptr]=r0;
8420193a:	0a de       	M[FP + 4] = r0;

    r1 = M[FP + $vol_ctrl.axfp.aparm_ptr];
8420193c:	13 d8       	r1 = M[FP + 8];
    r1 = r1 + ($volume_control_cap.vol_ctrl_aux_params_struct.STRUC_SIZE*ADDR_PER_WORD);
8420193e:	1b 23       	r1 = r1 + 12;
    M[FP + $vol_ctrl.axfp.aparm_ptr]=r1;
84201940:	13 de       	M[FP + 8] = r1;

    r6 = r6 LSHIFT 1;
84201942:	00 f8 d8 d8 	r6 = r6 LSHIFT 1;
    r7 = r7 LSHIFT -1;
84201946:	7f f9 d9 d8 	r7 = r7 LSHIFT -1;
    if NZ jump vol_ctrl_update_aux_state_next;
8420194a:	5a 63       	if NE jump (m) $M.vol_ctrl_update_aux_state.vol_ctrl_update_aux_state_next;

    /* Save overall state */
    M[r5 + $volume_control_cap._vol_ctrl_data_struct.AUX_ACTIVE_FIELD] = r8;
8420194c:	7a f0 b8 8e 	M[r5 + 736] = r8;

    popm <FP,r0,r1,r2,r3,r4,r6,r8,rLink>;
84201950:	57 f2 6d e0 	popm <FP, r0, r1, r2, r3, r4, r6, r8, rLink>;

84201954 <$M.vol_ctrl_update_aux_state.update_aux_state_abort>:

update_aux_state_abort:
    popm <r5,r7>;
84201954:	28 f0 60 e0 	popm <r5, r7>;
    rts;
84201958:	d8 4c       	rts;

8420195a <$_vol_ctrl_compute_time_constants>:
    .CODESEGMENT PM;

    .CONST POS_ONE_Q16_N   (1<<(DAWTH-16));  // 1.0 in Q16.8 (arch4: Q16.16)

$_vol_ctrl_compute_time_constants:
    pushm <r4,r5,r6,r7,rlink>;
8420195a:	b4 1c       	pushm <r4, r5, r6, r7, rLink>;
// r0:  unsigned sample_rate
// r1:  unsigned vol_tc  (r-1)
// r2:  vol_time_constants_t *lpvcs

    r3 = r1;
8420195c:	1d 00       	r3 = r1 + Null;
    r1 = M[r2+$volume_control_cap.vol_time_constants_struct.NUM_WORDS_FIELD];
8420195e:	23 88       	r1 = M[r2 + 0];

    // compute period in 100th of msec  (samples/sample_rate)*100,000
    rMAC = r1 * 3125 (int);
84201960:	0c f0 35 f3 	rMAC = r1 * 3125 (int);
84201964:	91 d9 
    rMAC = rMAC LSHIFT (5-DAWTH) (56bit);
84201966:	72 f1 d1 d8 	rMAC = rMAC LSHIFT -27 (56bit);
    Div  = rMAC / r0;
8420196a:	91 4c       	Div = rMAC / r0;
    r4 = DivResult;
8420196c:	c6 4c       	r4 = DivResult;
    M[r2 + $volume_control_cap.vol_time_constants_struct.PERIOD_FIELD] = r4;
8420196e:	26 8f       	M[r2 + 16] = r4;

    r4 = r4 ASHIFT (DAWTH-14);
84201970:	09 f6 16 c9 	r4 = r4 ASHIFT 18;
    // compute volume update coeff: 11.5*n/fs (roughly 0.1dB/ms)
    r5 = r4 * 0.942071589546666;      // update coef in Q1.23 (arch4: Q1.31)
84201974:	89 f7 cd f5 	r5 = r4 * 0.942071589641273021697998046875 (SS);
84201978:	46 f6 d7 cc 
    // positive VOL_TC will increase the rate.
    // modified_coef ~= coef*r*(1+(r-1)*coef) (r = ramp factor)
    r1 = r3 + POS_ONE_Q16_N;
8420197c:	04 f0 53 f0 	r1 = r3 + 65536;
84201980:	00 20 
    if NEG r1 = 0;          // safeguard
84201982:	04 f0 03 c0 	if NEG r1 = Null + Null;
    rMAC = r1 * r5;
84201986:	7f f3 c1 cc 	rMAC = r1 * r5 (SS);
    r1 = rMAC ASHIFT 15;    // coef*r                in Q1.23 (arch4: Q1.31)
8420198a:	07 f1 13 d9 	r1 = rMAC ASHIFT 15;
    rMAC = POS_ONE_Q16_N;
8420198e:	81 f0 00 40 	rMAC = Null + 65536;
    rMAC = rMAC + r5 * r3;  // (1+(r-1)*coef)        in Q16.8 (arch4: Q16.16)
84201992:	5f f7 c1 ca 	rMAC = rMAC + r5 * r3 (SS);
    rMAC = rMAC ASHIFT 8 (56bit);
84201996:	c9 5d       	rMAC = rMAC ASHIFT 8 (56bit);
    rMAC = rMAC * r1;       // coef*r*(1+(r-1)*coef) in Q8.16 (arch4: Q8.24)
84201998:	3f f1 c1 cc 	rMAC = rMAC * r1 (SS);
    r1 = rMAC ASHIFT 7;     // convert modified_coef to Q1.23 (arch4: Q1.31)
8420199c:	8b 5d       	r1 = rMAC ASHIFT 7;
    M[r2 + $volume_control_cap.vol_time_constants_struct.VOL_TC_FIELD] = r1;
8420199e:	63 8e       	M[r2 + 4] = r1;


   // calculate release coeff(reaches 99% in 50ms)
   r0 = r4 * 0.6553593446;
842019a0:	3e f5 d0 f2 	r0 = r4 * 0.65535934455692768096923828125 (SS);
842019a4:	a4 f6 d2 cc 
   r0 = r0 * (log(0.01)/0.05/log(2.0)/128.0/100.0)(frac);
842019a8:	ea ff d5 fb 	r0 = r0 * -0.010381025262176990509033203125 (frac);
842019ac:	a6 f2 52 c9 
   call $math.pow2_table;
842019b0:	ff fd 1d f3 	call 0x65408;
842019b4:	38 e2 
   M[r2 + $volume_control_cap.vol_time_constants_struct.SAT_TC_FIELD] = r0;
842019b6:	a2 8e       	M[r2 + 8] = r0;

   // attack coeff, 5 times faster
   r1 = r0 * r0 (frac);
842019b8:	2f f2 43 c9 	r1 = r0 * r0 (frac);
   r1 = r1 * r1 (frac);
842019bc:	00 f3 73 c9 	r1 = r1 * r1 (frac);
   r1 = r0 * r1 (frac);
842019c0:	3f f2 43 c9 	r1 = r0 * r1 (frac);
   M[r2 + $volume_control_cap.vol_time_constants_struct.SAT_TCP5_FIELD] = r1;
842019c4:	e3 8e       	M[r2 + 12] = r1;

   popm <r4,r5,r6,r7,rlink>;
842019c6:	b4 48       	popm <r4, r5, r6, r7, rLink>;
   rts;
842019c8:	d8 4c       	rts;
