
/home/svc-audio-dspsw/kymera_builds/builds/2020/kymera_2006121714/kalimba/kymera/tools/KCSMaker/out/4786/stre_rom_v02_release/download/debugbin/download_aec_reference.elf:     file format elf32-littlekalimba

Disassembly of section .text_maxim:

84200000 <$_set_rate_monitor_new_amount_ptr>:
// *****************************************************************************
.MODULE $cbops.rate_monitor_op.set_rate_monitor_new_amount_ptr;
.CODESEGMENT PM;
.MAXIM;
$_set_rate_monitor_new_amount_ptr:
   NULL = r0;
84200000:	0f 00 02 00 	Null = r0 + Null;
   if Z rts;
84200004:	00 00 0d dc 	if EQ rts;
   push r3;
84200008:	00 00 50 f3 	push r3;
   r3 = M[r0 +   ($cbops_c.cbops_op_struct.PARAMETER_AREA_START_FIELD+$cbops.param_hdr.OPERATOR_DATA_PTR_FIELD)];
8420000c:	0c 00 52 d1 	r3 = M[r0 + 12];
   M[r3 + $cbops_rate_monitor_op.rate_monitor_op_struct.NEW_AMOUNT_PTR_FIELD] = r1;
84200010:	34 00 35 d5 	M[r3 + 52] = r1;
   pop r3;
84200014:	00 00 54 f3 	pop r3;
   rts;
84200018:	0f 00 0d dc 	rts;

8420001c <$_rate_monitor_op_initialise>:
// *****************************************************************************
.MODULE $cbops.rate_monitor_op.rate_monitor_op_initialise;
.CODESEGMENT PM;
.MAXIM;
$_rate_monitor_op_initialise:
   push rLink;
8420001c:	00 00 d0 f3 	push rLink;
   // run init function from ROM
   call $_rate_monitor_op_initiatlize;
84200020:	06 00 00 fd 	call 0x6bb84;
84200024:	84 bb f0 e1 
   // then do the extra init
   M[r0 + $cbops_rate_monitor_op.rate_monitor_op_struct.ACC_DRIFT_FIELD] = Null;
84200028:	3c 00 02 d5 	M[r0 + 60] = Null;
   M[r0 + $cbops_rate_monitor_op.rate_monitor_op_struct.EXPECTED_ACC_SUM_FIELD] = Null;
8420002c:	38 00 02 d5 	M[r0 + 56] = Null;
   M[r0 + $cbops_rate_monitor_op.rate_monitor_op_struct.STALL_FIELD] = NULL;
84200030:	20 00 02 d5 	M[r0 + 32] = Null;
   pop rLink;
84200034:	00 00 d4 f3 	pop rLink;
   rts;
84200038:	0f 00 0d dc 	rts;
Disassembly of section .text_minim:

8420003c <$_aec_reference_create>:
int32 mpy_add_32(int32 a, int32 b, int32 c);
int32 mpy_32(int32 a, int32 b);


bool aec_reference_create(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
8420003c:	f4 1d       	pushm <FP(=SP), r4, r5, r6, r7, rLink>, SP = SP + 0x10;
8420003e:	17 00       	r5 = r0 + Null;
84200040:	21 09       	r7 = r2 + Null;
84200042:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84200044:	3e 99       	r4 = M[r5 + 48];

    patch_fn_shared(aec_reference);

#ifdef CAPABILITY_DOWNLOAD_BUILD
    /* let the patches know it's not running from ROM */
    set_aec_reference_not_running_from_rom();
84200046:	1b f0 21 ef 	call (m) $_set_aec_reference_not_running_from_rom;
#endif

    /* Setup Response to Creation Request.   Assume Failure*/
    *response_id = OPCMD_CREATE;
8420004a:	90 f0 00 ee 	M[r7 + Null] = Null;
    if(!base_op_build_std_response(STATUS_CMD_FAILED,op_data->id,response_data))
8420004e:	7b 88       	r1 = M[r5 + 4];
84200050:	02 f0 00 60 	r0 = Null + 4096;
84200054:	44 08       	r2 = r6 + Null;
84200056:	ff fd 00 f0 	call (m) 0x204;
8420005a:	2f ed 
8420005c:	10 04       	Null = r0 - Null;
8420005e:	03 62       	if NE jump (m) Lc_aec_reference_create_3;

84200060 <Lc_aec_reference_create_2>:
    {
        return(FALSE);
84200060:	02 00       	r0 = Null + Null;
84200062:	6d 6e       	jump (m) Lc_aec_reference_create_14;

84200064 <Lc_aec_reference_create_3>:

    /* AEC REFERENCE runs on periodic timer task and doesn't
     * need to receive usual operator kicks, neither from source
     * side nor from sink side.
     */
     op_data->stop_chain_kicks = BOTH_SIDES;
84200064:	c1 20       	rMAC = Null + 3;
84200066:	79 ba       	MB[r5 + 25] = rMAC;

    /* Initialize extended data for operator.  Assume intialized to zero*/
    op_extra_data->cap_id = op_data->cap_data->id;
84200068:	79 89       	rMAC = M[r5 + 20];
8420006a:	09 e8       	rMAC = M[rMAC + Null];
8420006c:	61 f0 59 8e 	M[r4 + 356] = rMAC;
    op_extra_data->ReInitFlag = TRUE;
84200070:	41 20       	rMAC = Null + 1;
84200072:	61 f0 5c 8e 	M[r4 + 368] = rMAC;
    op_extra_data->Cur_mode = AEC_REFERENCE_SYSMODE_FULL;
84200076:	61 f0 5a 8e 	M[r4 + 360] = rMAC;
    op_extra_data->kick_id = TIMER_ID_INVALID;
8420007a:	60 f0 5d 8e 	M[r4 + 372] = Null;
                         (AEC_REFERENCE_DEFAULT_TASK_PERIOD >= AEC_REFERENCE_MIN_TASK_PERIOD) &&
                         ((SECOND%AEC_REFERENCE_DEFAULT_TASK_PERIOD)==0)),
                        AEC_REFERENCE_DEFAULT_TASK_PERIOD_Not_Accepted);

    /* set default task period */
    if(!aec_reference_set_task_period(op_extra_data, AEC_REFERENCE_DEFAULT_TASK_PERIOD, 1))
8420007e:	03 f0 e8 43 	r1 = Null + 1000;
84200082:	0c 00       	r2 = rMAC + Null;
84200084:	32 00       	r0 = r4 + Null;
84200086:	07 f0 39 ea 	call (m) $_aec_reference_set_task_period;
8420008a:	10 04       	Null = r0 - Null;
8420008c:	42 60       	if EQ jump (m) Lc_aec_reference_create_8;

8420008e <Lc_aec_reference_create_4>:
    }


#ifdef AEC_REFERENCE_GENERATE_MIC_TIMESTAMP
    /* set minimum tag length for mic output metadata tags */
    op_extra_data->mic_metadata_min_tag_len = AEC_REFERENCE_MIC_METADATA_MIN_TAG_LEN;
8420008e:	01 3b       	rMAC = Null + 60;
84200090:	61 f0 cc 8e 	M[r4 + 816] = rMAC;

    /* create time to play with default params */
    op_extra_data->mic_time_to_play = ttp_init();
84200094:	ff fd b3 f0 	call (m) 0x16698;
84200098:	25 e0 
8420009a:	62 f0 cf 8e 	M[r4 + 828] = r0;
    if (op_extra_data->mic_time_to_play != NULL)
8420009e:	61 f0 cf 88 	rMAC = M[r4 + 828];
842000a2:	37 60       	if EQ jump (m) Lc_aec_reference_create_8;

842000a4 <Lc_aec_reference_create_5>:
    {
        ttp_params params;
        ttp_get_default_params(&params, TTP_TYPE_PCM);
842000a4:	43 20       	r1 = Null + 1;
842000a6:	82 11       	r0 = FP + 24;
842000a8:	ff fd b3 f0 	call (m) 0x166de;
842000ac:	37 e1 
        ttp_configure_params(op_extra_data->mic_time_to_play, &params);
842000ae:	83 11       	r1 = FP + 24;
842000b0:	62 f0 cf 88 	r0 = M[r4 + 828];
842000b4:	ff fd b3 f0 	call (m) 0x16822;
842000b8:	2f eb 
       but is not declared as such because we may want it to be configurable in the future */

    /* For Atlas this must be less than for equal to the ping/pong period.
       Also set AEC_REFERENCE_TIME_PERIOD
    */
    op_extra_data->mic_rate_ability  = RATEMATCHING_SUPPORT_NONE;
842000ba:	60 f0 67 8e 	M[r4 + 412] = Null;
    op_extra_data->spkr_rate_ability = RATEMATCHING_SUPPORT_NONE;
842000be:	60 f0 6f 8e 	M[r4 + 444] = Null;
    op_extra_data->mic_shift  = AEC_REFERENCE_DEFAULT_EP_SHIFT;
842000c2:	60 f0 6d 8e 	M[r4 + 436] = Null;
    op_extra_data->spkr_shift = -AEC_REFERENCE_DEFAULT_EP_SHIFT;
842000c6:	60 f0 74 8e 	M[r4 + 464] = Null;

    /* Note:  sample rate config must be sent before the operator's terminals may be connected
       input_rate and output_rate are initialized to zero and checked in the connect operation */

    /*allocate the volume control shared memory */
    op_extra_data->shared_volume_ptr = allocate_shared_volume_cntrl();
842000ca:	ff fd 8b f0 	call (m) 0x1181c;
842000ce:	33 ea 
842000d0:	62 f0 58 8e 	M[r4 + 352] = r0;
    if(!op_extra_data->shared_volume_ptr)
842000d4:	61 f0 58 88 	rMAC = M[r4 + 352];
842000d8:	24 60       	if EQ jump (m) Lc_aec_reference_create_10;

842000da <Lc_aec_reference_create_6>:
    {
        goto aFailed;
    }

    if(!cpsInitParameters(&op_extra_data->parms_def,(unsigned*)AEC_REFERENCE_GetDefaults(op_extra_data->cap_id),(unsigned*)&op_extra_data->params,sizeof(AEC_REFERENCE_PARAMETERS)))
842000da:	62 f0 59 88 	r0 = M[r4 + 356];
842000de:	16 f0 37 ee 	call (m) $_AEC_REFERENCE_GetDefaults;
842000e2:	13 00       	r1 = r0 + Null;
842000e4:	05 f0 ac 40 	r3 = Null + 172;
842000e8:	64 f0 b4 20 	r2 = r4 + 180;
842000ec:	62 f0 78 21 	r0 = r4 + 376;
842000f0:	ff fd 01 f0 	call (m) 0x424;
842000f4:	35 e9 
842000f6:	10 04       	Null = r0 - Null;
842000f8:	0c 60       	if EQ jump (m) Lc_aec_reference_create_8;

842000fa <Lc_aec_reference_create_7>:
    {
        goto aFailed;
    }

#if defined(IO_DEBUG)
    aec_latency_ptr = &op_extra_data->sync_block;
842000fa:	61 f0 14 22 	rMAC = r4 + 532;
842000fe:	e0 f0 01 f0 	M[Null + $_aec_latency_ptr] = rMAC;
84200102:	5b 8e 
#endif

    /* operator state variable set to not running state. based on base_op.c */
    op_data->state = OP_NOT_RUNNING;
84200104:	41 20       	rMAC = Null + 1;
84200106:	39 ba       	MB[r5 + 24] = rMAC;
 * \param  response_data Pointer to the pointer to message that is allocated in the function.
 * \param  new_status  A status ID that is to be sent in the message.
 */
inline static void base_op_change_response_status(void **response_data, STATUS_KYMERA new_status)
{
    (((OP_STD_RSP *)(*response_data))->status = new_status);
84200108:	81 f0 00 e8 	rMAC = M[r6 + Null];
8420010c:	48 8e       	M[rMAC + 4] = Null;
8420010e:	16 6e       	jump (m) Lc_aec_reference_create_13;

84200110 <Lc_aec_reference_create_8>:
    patch_fn_shared(aec_reference);

    base_op_change_response_status(response_data,STATUS_OK);
    return TRUE;
  aFailed:
    if(op_extra_data->shared_volume_ptr)
84200110:	62 f0 58 88 	r0 = M[r4 + 352];
84200114:	06 60       	if EQ jump (m) Lc_aec_reference_create_10;

84200116 <Lc_aec_reference_create_9>:
    {
        release_shared_volume_cntrl(op_extra_data->shared_volume_ptr);
84200116:	ff fd 8b f0 	call (m) 0x11840;
8420011a:	2b e9 
        op_extra_data->shared_volume_ptr = NULL;
8420011c:	60 f0 58 8e 	M[r4 + 352] = Null;

84200120 <Lc_aec_reference_create_10>:
    }

#ifdef AEC_REFERENCE_GENERATE_MIC_TIMESTAMP
    /* free it if we created time to play context for mic */
    if (op_extra_data->mic_time_to_play != NULL)
84200120:	62 f0 cf 88 	r0 = M[r4 + 828];
84200124:	06 60       	if EQ jump (m) Lc_aec_reference_create_12;

84200126 <Lc_aec_reference_create_11>:
    {
        ttp_free(op_extra_data->mic_time_to_play);
84200126:	ff fd b4 f0 	call (m) 0x16af4;
8420012a:	2f ee 
        op_extra_data->mic_time_to_play = NULL;
8420012c:	60 f0 cf 8e 	M[r4 + 828] = Null;

84200130 <Lc_aec_reference_create_12>:
84200130:	01 f0 00 60 	rMAC = Null + 4096;
84200134:	82 f0 00 e8 	r0 = M[r6 + Null];
84200138:	51 8e       	M[r0 + 4] = rMAC;

8420013a <Lc_aec_reference_create_13>:

    /* chance to fix up */
    patch_fn_shared(aec_reference);

    base_op_change_response_status(response_data,STATUS_OK);
    return TRUE;
8420013a:	42 20       	r0 = Null + 1;

8420013c <Lc_aec_reference_create_14>:
    hl_limiter_init(op_extra_data);
#endif /* INSTALL_AEC_REFERENCE_HOWL_LIMITER */

    base_op_change_response_status(response_data, STATUS_CMD_FAILED);
    return TRUE;
}
8420013c:	f4 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, rLink>;
8420013e:	d8 4c       	rts;

84200140 <$_aec_reference_destroy>:
     */
    op_extra_data->channel_status = 0;
}

bool aec_reference_destroy(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200140:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84200142:	17 00       	r5 = r0 + Null;
84200144:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84200146:	3e 99       	r4 = M[r5 + 48];
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);

    patch_fn_shared(aec_reference);

    /* Setup Response to Destroy Request.*/
    if(!base_op_destroy(op_data, message_data, response_id, response_data))
84200148:	ef fd ff ff 	call (m) 0xac;
8420014c:	25 eb 
8420014e:	10 04       	Null = r0 - Null;
84200150:	03 62       	if NE jump (m) Lc_aec_reference_destroy_3;

84200152 <Lc_aec_reference_destroy_2>:
    {
        return(FALSE);
84200152:	02 00       	r0 = Null + Null;
84200154:	17 6e       	jump (m) Lc_aec_reference_destroy_6;

84200156 <Lc_aec_reference_destroy_3>:
    }

    /* Make sure everything is cleared */
    aec_reference_cleanup(op_data);
84200156:	3a 00       	r0 = r5 + Null;
84200158:	09 f0 2f e5 	call (m) $_aec_reference_cleanup;

    /* calling the "destroy" assembly function - this frees up all the capability-internal memory */
    /*free volume control shared memory*/
    release_shared_volume_cntrl(op_extra_data->shared_volume_ptr);
8420015c:	62 f0 58 88 	r0 = M[r4 + 352];
84200160:	ff fd 8b f0 	call (m) 0x11840;
84200164:	21 e7 
    op_extra_data->shared_volume_ptr = NULL;
84200166:	60 f0 58 8e 	M[r4 + 352] = Null;


#ifdef AEC_REFERENCE_GENERATE_MIC_TIMESTAMP
    /* delete mic time-to-play object */
    if(op_extra_data->mic_time_to_play != NULL)
8420016a:	62 f0 cf 88 	r0 = M[r4 + 828];
8420016e:	06 60       	if EQ jump (m) Lc_aec_reference_destroy_5;

84200170 <Lc_aec_reference_destroy_4>:
    {
        ttp_free(op_extra_data->mic_time_to_play);
84200170:	ff fd b4 f0 	call (m) 0x16af4;
84200174:	25 ec 
        op_extra_data->mic_time_to_play = NULL;
84200176:	60 f0 cf 8e 	M[r4 + 828] = Null;

8420017a <Lc_aec_reference_destroy_5>:
8420017a:	81 f0 00 e8 	rMAC = M[r6 + Null];
8420017e:	48 8e       	M[rMAC + 4] = Null;
    }
#endif

    base_op_change_response_status(response_data,STATUS_OK);
    return(TRUE);
84200180:	42 20       	r0 = Null + 1;

84200182 <Lc_aec_reference_destroy_6>:
}
84200182:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84200184:	d8 4c       	rts;

84200186 <$_aec_reference_reset>:
    *response_id = OPCMD_STOP;
    return(aec_reference_stop_reset(op_data,response_data));
}

bool aec_reference_reset(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200186:	c8 1c       	pushm <FP(=SP), rLink>;
84200188:	2b 00       	r1 = r3 + Null;
    /* Setup Response to Reset Request.   Assume Failure*/
    *response_id = OPCMD_RESET;
8420018a:	01 21       	rMAC = Null + 4;
8420018c:	21 ee       	M[r2 + Null] = rMAC;
    return(aec_reference_stop_reset(op_data,response_data));
8420018e:	11 f0 3d e4 	call (m) $_aec_reference_stop_reset;

84200192 <Lc_aec_reference_reset_2>:
}
84200192:	c8 48       	popm <FP, rLink>;
84200194:	d8 4c       	rts;

84200196 <$_aec_reference_connect>:


bool aec_reference_connect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200196:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
84200198:	13 09       	r9 = r0 + Null;
8420019a:	20 09       	r6 = r2 + Null;
8420019c:	45 de       	M[FP + 32] = r3;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
8420019e:	b7 f0 0c 88 	r5 = M[r9 + 48];

bool aec_reference_connect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    tCbuffer **bufp = NULL;
    unsigned terminal_id    = ((unsigned*)message_data)[0];    /* extract the terminal_id */
842001a2:	1e e8       	r4 = M[r1 + Null];
    tCbuffer* pterminal_buf = (tCbuffer*)(uintptr_t)(((unsigned *)message_data)[1]);
842001a4:	3a f0 01 88 	r8 = M[r1 + 4];
    INT_OP_ID int_id = op_data->id;
842001a8:	b9 f0 01 88 	r7 = M[r9 + 4];

    patch_fn_shared(aec_reference);

    L3_DBG_MSG1("AEC REFERENCE --- connect TID = %x", terminal_id);
842001ac:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
842001b0:	c8 24       	Null = rMAC - 3;
842001b2:	08 68       	if LT jump (m) Lc_aec_reference_connect_3;

842001b4 <Lc_aec_reference_connect_2>:
842001b4:	55 f1 02 f0 	r0 = Null + 357564416;
842001b8:	00 40 
842001ba:	33 00       	r1 = r4 + Null;
842001bc:	ff fd 03 f0 	call (m) 0x9b4;
842001c0:	39 ef 

842001c2 <Lc_aec_reference_connect_3>:


    /* Setup Response to Connection Request.   Assume Failure*/
    *response_id = OPCMD_CONNECT;
842001c2:	41 21       	rMAC = Null + 5;
842001c4:	81 f0 00 ee 	M[r6 + Null] = rMAC;
    if(!base_op_build_std_response(STATUS_CMD_FAILED,op_data->id,response_data))
842001c8:	b3 f0 01 88 	r1 = M[r9 + 4];
842001cc:	02 f0 00 60 	r0 = Null + 4096;
842001d0:	44 d8       	r2 = M[FP + 32];
842001d2:	ff fd 00 f0 	call (m) 0x204;
842001d6:	33 e1 
842001d8:	10 04       	Null = r0 - Null;
842001da:	03 62       	if NE jump (m) Lc_aec_reference_connect_5;

842001dc <Lc_aec_reference_connect_4>:
    {
        return(FALSE);
842001dc:	02 00       	r0 = Null + Null;
842001de:	d4 6e       	jump (m) Lc_aec_reference_connect_44;

842001e0 <Lc_aec_reference_connect_5>:
    }

    /* Only allow connection if operator has been configured */
    if((op_extra_data->input_rate==0) || (op_extra_data->output_rate==0) )
842001e0:	70 f0 64 88 	Null = M[r5 + 400];
842001e4:	13 60       	if EQ jump (m) Lc_aec_reference_connect_10;

842001e6 <Lc_aec_reference_connect_6>:
842001e6:	70 f0 65 88 	Null = M[r5 + 404];
842001ea:	10 60       	if EQ jump (m) Lc_aec_reference_connect_10;

842001ec <Lc_aec_reference_connect_7>:
        return(TRUE);
    }

    /* (i)  check if the terminal ID is valid . The number has to be less than the maximum number of sinks or sources .  */
    /* (ii) check if we are connecting to the right type . It has to be a buffer pointer and not endpoint connection */
    if( !base_op_is_terminal_valid(op_data, terminal_id) || !pterminal_buf)
842001ec:	33 00       	r1 = r4 + Null;
842001ee:	5a 08       	r0 = r9 + Null;
842001f0:	ef fd ff ff 	call (m) 0x1de;
842001f4:	2f ef 
842001f6:	10 04       	Null = r0 - Null;
842001f8:	04 60       	if EQ jump (m) Lc_aec_reference_connect_9;

842001fa <Lc_aec_reference_connect_8>:
842001fa:	0f fa 00 c2 	Null = r8 - Null;
842001fe:	08 62       	if NE jump (m) Lc_aec_reference_connect_11;

84200200 <Lc_aec_reference_connect_9>:
84200200:	01 f0 03 60 	rMAC = Null + 4099;
84200204:	42 d8       	r0 = M[FP + 32];
84200206:	12 e8       	r0 = M[r0 + Null];
84200208:	51 8e       	M[r0 + 4] = rMAC;

8420020a <Lc_aec_reference_connect_10>:
    }

    /* Only allow connection if operator has been configured */
    if((op_extra_data->input_rate==0) || (op_extra_data->output_rate==0) )
    {
        return(TRUE);
8420020a:	42 20       	r0 = Null + 1;
8420020c:	bd 6e       	jump (m) Lc_aec_reference_connect_44;

8420020e <Lc_aec_reference_connect_11>:
        base_op_change_response_status(response_data,STATUS_INVALID_CMD_PARAMS);
        return TRUE;
    }

    /* check if the terminal is already connected and if not , connect the terminal */
    if(terminal_id & TERMINAL_SINK_MASK)
8420020e:	40 f0 61 f0 	rMAC = r4 AND 0x800000;
84200212:	00 00 
84200214:	5b 60       	if EQ jump (m) Lc_aec_reference_connect_27;

84200216 <Lc_aec_reference_connect_12>:
    {
        terminal_id &= ~ TERMINAL_SINK_MASK;
84200216:	bf ff 66 ff 	r4 = r4 AND 0xff7fffff;
8420021a:	ff 1f 

        if(terminal_id==AEC_REF_MIC_TERMINAL1)
8420021c:	b0 24       	Null = r4 - 2;
8420021e:	34 62       	if NE jump (m) Lc_aec_reference_connect_19;

84200220 <Lc_aec_reference_connect_13>:
        {
            uint32 config_value;

            /* get info about overridden endpoints */
            op_extra_data->mic_endpoint = get_overriden_endpoint(int_id,
                                                                 AEC_REF_MIC_TERMINAL1 | TERMINAL_SINK_MASK);
84200220:	08 f0 03 f0 	r1 = Null + 8388610;
84200224:	02 40 
84200226:	4a 08       	r0 = r7 + Null;
84200228:	ff fd 24 f0 	call (m) 0x4ab0;
8420022c:	29 e4 
8420022e:	72 f0 7f 8e 	M[r5 + 508] = r0;

            if(!get_override_ep_ratematch_ability(op_extra_data->mic_endpoint,&config_value))
84200232:	43 12       	r1 = FP + 36;
84200234:	72 f0 7f 88 	r0 = M[r5 + 508];
84200238:	ff fd 24 f0 	call (m) 0x4a4e;
8420023c:	37 e0 
8420023e:	10 04       	Null = r0 - Null;
84200240:	e0 61       	if EQ jump (m) Lc_aec_reference_connect_9;

84200242 <Lc_aec_reference_connect_14>:
            /* Save rate matching ability HW or SW*/
            op_extra_data->mic_rate_ability   = RATEMATCHING_SUPPORT_SW;
            op_extra_data->mic_rate_enactment = RATEMATCHING_SUPPORT_SW;
#else
            /* Save rate matching ability HW or SW*/
            op_extra_data->mic_rate_ability   = (unsigned)config_value;
84200242:	49 d8       	rMAC = M[FP + 36];
84200244:	71 f0 67 8e 	M[r5 + 412] = rMAC;
            op_extra_data->mic_rate_enactment = RATEMATCHING_SUPPORT_NONE;
84200248:	70 f0 68 8e 	M[r5 + 416] = Null;
#endif
            if(op_extra_data->mic_sync_enable)
8420024c:	70 f0 d4 88 	Null = M[r5 + 848];
84200250:	0b 60       	if EQ jump (m) Lc_aec_reference_connect_17;

84200252 <Lc_aec_reference_connect_15>:
            {
                /* Mic output will be synchronised to speaker input, SW or HW depends on
                 * it's ability.
                 */
                op_extra_data->mic_rate_enactment = op_extra_data->mic_rate_ability;
84200252:	71 f0 68 8e 	M[r5 + 416] = rMAC;
                if(op_extra_data->mic_rate_enactment == RATEMATCHING_SUPPORT_HW)
84200256:	88 24       	Null = rMAC - 2;
84200258:	07 62       	if NE jump (m) Lc_aec_reference_connect_17;

8420025a <Lc_aec_reference_connect_16>:
                {
                    set_override_ep_ratematch_enacting(op_extra_data->mic_endpoint, TRUE);
8420025a:	43 20       	r1 = Null + 1;
8420025c:	72 f0 7f 88 	r0 = M[r5 + 508];
84200260:	ff fd 23 f0 	call (m) 0x4a3e;
84200264:	3f ee 

84200266 <Lc_aec_reference_connect_17>:
                }
            }

#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
            /* see if mic graph wants to use an external rate adjust operator */
            aec_reference_mic_check_external_rate_adjust_op(op_extra_data);
84200266:	3a 00       	r0 = r5 + Null;
84200268:	07 f0 27 ec 	call (m) $_aec_reference_mic_check_external_rate_adjust_op;
#endif /* INSTALL_DELEGATE_RATE_ADJUST_SUPPORT */

            if(!get_override_ep_sample_rate(op_extra_data->mic_endpoint,&config_value))
8420026c:	43 12       	r1 = FP + 36;
8420026e:	72 f0 7f 88 	r0 = M[r5 + 508];
84200272:	ff fd 23 f0 	call (m) 0x4a02;
84200276:	31 ec 
84200278:	10 04       	Null = r0 - Null;
8420027a:	c3 61       	if EQ jump (m) Lc_aec_reference_connect_9;

8420027c <Lc_aec_reference_connect_18>:
            {
                /* Should never fail */
                base_op_change_response_status(response_data,STATUS_INVALID_CMD_PARAMS);
                return TRUE;
            }
            op_extra_data->mic_rate = (unsigned)config_value;
8420027c:	49 d8       	rMAC = M[FP + 36];
8420027e:	71 f0 66 8e 	M[r5 + 408] = rMAC;
        else if(terminal_id==AEC_REF_INPUT_TERMINAL1)
        {
            op_extra_data->spkr_in_endpoint = get_overriden_endpoint(int_id,
                                                                     AEC_REF_INPUT_TERMINAL1 | TERMINAL_SINK_MASK);
        }
        bufp = &op_extra_data->input_stream[terminal_id];
84200282:	3b 22       	r1 = r5 + 8;
84200284:	60 6e       	jump (m) Lc_aec_reference_connect_36;

84200286 <Lc_aec_reference_connect_19>:
                return TRUE;
            }
            op_extra_data->mic_rate = (unsigned)config_value;

        }
        else if(terminal_id==AEC_REF_INPUT_TERMINAL1)
84200286:	30 04       	Null = r4 - Null;
84200288:	15 62       	if NE jump (m) Lc_aec_reference_connect_24;

8420028a <Lc_aec_reference_connect_20>:
        {
            op_extra_data->spkr_in_endpoint = get_overriden_endpoint(int_id,
                                                                     AEC_REF_INPUT_TERMINAL1 | TERMINAL_SINK_MASK);
8420028a:	08 f0 03 f0 	r1 = Null + 8388608;
8420028e:	00 40 
84200290:	4a 08       	r0 = r7 + Null;
84200292:	ff fd 24 f0 	call (m) 0x4ab0;
84200296:	3f e0 
84200298:	72 f0 82 8e 	M[r5 + 520] = r0;
        }
        bufp = &op_extra_data->input_stream[terminal_id];
8420029c:	3b 00       	r1 = r5 + Null;

8420029e <Lc_aec_reference_connect_21>:
 *
 * \return TRUE if the buffer supports metadata. FALSE if it doesn't.
 */
static inline bool buff_has_metadata(tCbuffer *buff)
{
    if (BUFF_METADATA(buff))
8420029e:	a1 f0 05 88 	rMAC = M[r8 + 20];
842002a2:	49 c6       	rMAC = rMAC AND 0x8000;
842002a4:	50 60       	if EQ jump (m) Lc_aec_reference_connect_36;

842002a6 <Lc_aec_reference_connect_22>:
         */
        if(IsSpeakerInputTerminal(terminal_id) &&
           buff_has_metadata(pterminal_buf))
        {
            /* set metadata buffer if it hasn't been set already */
            if(NULL == op_extra_data->spkr_input_metadata_buffer)
842002a6:	71 f0 c9 88 	rMAC = M[r5 + 804];
842002aa:	4d 62       	if NE jump (m) Lc_aec_reference_connect_36;

842002ac <Lc_aec_reference_connect_23>:
            {
                op_extra_data->spkr_input_metadata_buffer = pterminal_buf;
842002ac:	7a f0 c9 8e 	M[r5 + 804] = r8;
842002b0:	4a 6e       	jump (m) Lc_aec_reference_connect_36;

842002b2 <Lc_aec_reference_connect_24>:
        else if(terminal_id==AEC_REF_INPUT_TERMINAL1)
        {
            op_extra_data->spkr_in_endpoint = get_overriden_endpoint(int_id,
                                                                     AEC_REF_INPUT_TERMINAL1 | TERMINAL_SINK_MASK);
        }
        bufp = &op_extra_data->input_stream[terminal_id];
842002b2:	72 54       	r0 = r4 LSHIFT 2;
842002b4:	39 00       	rMAC = r5 + Null;
842002b6:	51 00       	rMAC = r0 + rMAC;
842002b8:	0b 00       	r1 = rMAC + Null;
inline static bool IsSpeakerInputTerminal(unsigned term_idx)
{
    return ( (term_idx==AEC_REF_INPUT_TERMINAL1)
          || (term_idx==AEC_REF_INPUT_TERMINAL2)
          || ( (term_idx>=AEC_REF_INPUT_TERMINAL3)
              && (term_idx<=AEC_REF_INPUT_TERMINAL8) ) );
842002ba:	70 24       	Null = r4 - 1;
842002bc:	f1 61       	if EQ jump (m) Lc_aec_reference_connect_21;

842002be <Lc_aec_reference_connect_25>:
842002be:	b0 25       	Null = r4 - 6;
842002c0:	42 64       	if NC jump (m) Lc_aec_reference_connect_36;

842002c2 <Lc_aec_reference_connect_26>:
842002c2:	f0 26       	Null = r4 - 11;
842002c4:	f9 ff db ef 	if LS jump (m) Lc_aec_reference_connect_21;

842002c8 <Lc_14>:
842002c8:	3e 6e       	jump (m) Lc_aec_reference_connect_36;

842002ca <Lc_aec_reference_connect_27>:
        }
#endif /* AEC_REFERENCE_SUPPORT_METADATA */
    }
    else
    {
        if(terminal_id==AEC_REF_SPKR_TERMINAL1)
842002ca:	70 24       	Null = r4 - 1;
842002cc:	26 62       	if NE jump (m) Lc_aec_reference_connect_31;

842002ce <Lc_aec_reference_connect_28>:
        {
            uint32 config_value;

            op_extra_data->spkr_endpoint = get_overriden_endpoint(int_id,
                                                                  AEC_REF_SPKR_TERMINAL1);
842002ce:	43 20       	r1 = Null + 1;
842002d0:	4a 08       	r0 = r7 + Null;
842002d2:	ff fd 23 f0 	call (m) 0x4ab0;
842002d6:	3f ee 
842002d8:	72 f0 80 8e 	M[r5 + 512] = r0;

            if(!get_override_ep_ratematch_ability(op_extra_data->spkr_endpoint,&config_value))
842002dc:	83 12       	r1 = FP + 40;
842002de:	72 f0 80 88 	r0 = M[r5 + 512];
842002e2:	ff fd 23 f0 	call (m) 0x4a4e;
842002e6:	2d eb 
842002e8:	10 04       	Null = r0 - Null;
842002ea:	8b 61       	if EQ jump (m) Lc_aec_reference_connect_9;

842002ec <Lc_aec_reference_connect_29>:

#if defined(ENABLE_FORCE_SW_RATEMATCH)
            op_extra_data->spkr_rate_ability   = RATEMATCHING_SUPPORT_SW;
            op_extra_data->spkr_rate_enactment = RATEMATCHING_SUPPORT_SW;
#else
            op_extra_data->spkr_rate_ability   = (unsigned)config_value;
842002ec:	51 d8       	rMAC = M[FP + 40];
842002ee:	71 f0 6f 8e 	M[r5 + 444] = rMAC;
            op_extra_data->spkr_rate_enactment = RATEMATCHING_SUPPORT_NONE;
842002f2:	70 f0 71 8e 	M[r5 + 452] = Null;
#endif

#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
            /* see if speaker graph wants to use an external rate adjust operator */
            aec_reference_spkr_check_external_rate_adjust_op(op_extra_data);
842002f6:	3a 00       	r0 = r5 + Null;
842002f8:	07 f0 39 e5 	call (m) $_aec_reference_spkr_check_external_rate_adjust_op;
#endif
            if(!get_override_ep_sample_rate(op_extra_data->spkr_endpoint,&config_value))
842002fc:	83 12       	r1 = FP + 40;
842002fe:	72 f0 80 88 	r0 = M[r5 + 512];
84200302:	ff fd 23 f0 	call (m) 0x4a02;
84200306:	21 e8 
84200308:	10 04       	Null = r0 - Null;
8420030a:	7b 61       	if EQ jump (m) Lc_aec_reference_connect_9;

8420030c <Lc_aec_reference_connect_30>:
            {
                /* Should never fail */
                base_op_change_response_status(response_data,STATUS_INVALID_CMD_PARAMS);
                return TRUE;
            }
            op_extra_data->spkr_rate = (unsigned)config_value;
8420030c:	51 d8       	rMAC = M[FP + 40];
8420030e:	71 f0 6e 8e 	M[r5 + 440] = rMAC;
        }
        else if(terminal_id==AEC_REF_REFERENCE_TERMINAL)
        {
            op_extra_data->sync_block.speaker_data = 0;
        }
        bufp = &op_extra_data->output_stream[terminal_id];
84200312:	73 f0 44 20 	r1 = r5 + 68;
84200316:	17 6e       	jump (m) Lc_aec_reference_connect_36;

84200318 <Lc_aec_reference_connect_31>:
                return TRUE;
            }
            op_extra_data->spkr_rate = (unsigned)config_value;

        }
        else if (terminal_id==AEC_REF_OUTPUT_TERMINAL1)
84200318:	f0 24       	Null = r4 - 3;
8420031a:	1f 62       	if NE jump (m) Lc_aec_reference_connect_38;

8420031c <Lc_aec_reference_connect_32>:
        {
            op_extra_data->mic_out_endpoint = get_overriden_endpoint(int_id,
                                                                     AEC_REF_OUTPUT_TERMINAL1);
8420031c:	c3 20       	r1 = Null + 3;
8420031e:	4a 08       	r0 = r7 + Null;
84200320:	ff fd 23 f0 	call (m) 0x4ab0;
84200324:	31 ec 
84200326:	72 f0 81 8e 	M[r5 + 516] = r0;
            op_extra_data->sync_block.mic_data = 0;
8420032a:	70 f0 88 8e 	M[r5 + 544] = Null;
        }
        else if(terminal_id==AEC_REF_REFERENCE_TERMINAL)
        {
            op_extra_data->sync_block.speaker_data = 0;
        }
        bufp = &op_extra_data->output_stream[terminal_id];
8420032e:	73 f0 4c 20 	r1 = r5 + 76;

84200332 <Lc_aec_reference_connect_33>:
84200332:	a1 f0 05 88 	rMAC = M[r8 + 20];
84200336:	49 c6       	rMAC = rMAC AND 0x8000;
84200338:	06 60       	if EQ jump (m) Lc_aec_reference_connect_36;

8420033a <Lc_aec_reference_connect_34>:
#ifdef AEC_REFERENCE_GENERATE_MIC_TIMESTAMP
       /* set metadata buffer for mic outputs */
       if(IsMicrophoneOutputTerminal(terminal_id) &&
          buff_has_metadata(pterminal_buf))
       {
           if(NULL == op_extra_data->mic_metadata_buffer)
8420033a:	71 f0 ca 88 	rMAC = M[r5 + 808];
8420033e:	03 62       	if NE jump (m) Lc_aec_reference_connect_36;

84200340 <Lc_aec_reference_connect_35>:
           {   /* first connected mic output buffer with metadata */
               op_extra_data->mic_metadata_buffer = pterminal_buf;
84200340:	7a f0 ca 8e 	M[r5 + 808] = r8;

84200344 <Lc_aec_reference_connect_36>:
#endif /* AEC_REFERENCE_GENERATE_MIC_TIMESTAMP */

    }

    /* set the stream buffer for this terminal and rebuild the graphs if needed */
    if(aec_reference_update_stream_and_validate_channels(op_data, bufp, pterminal_buf))
84200344:	54 08       	r2 = r8 + Null;
84200346:	5a 08       	r0 = r9 + Null;
84200348:	11 f0 3d e3 	call (m) $_aec_reference_update_stream_and_validate_channels;
8420034c:	10 04       	Null = r0 - Null;
8420034e:	5e 61       	if EQ jump (m) Lc_aec_reference_connect_10;

84200350 <Lc_aec_reference_connect_37>:
84200350:	41 d8       	rMAC = M[FP + 32];
84200352:	09 e8       	rMAC = M[rMAC + Null];
84200354:	48 8e       	M[rMAC + 4] = Null;
84200356:	5a 6f       	jump (m) Lc_aec_reference_connect_10;

84200358 <Lc_aec_reference_connect_38>:
        {
            op_extra_data->mic_out_endpoint = get_overriden_endpoint(int_id,
                                                                     AEC_REF_OUTPUT_TERMINAL1);
            op_extra_data->sync_block.mic_data = 0;
        }
        else if(terminal_id==AEC_REF_REFERENCE_TERMINAL)
84200358:	30 04       	Null = r4 - Null;
8420035a:	06 62       	if NE jump (m) Lc_aec_reference_connect_40;

8420035c <Lc_aec_reference_connect_39>:
        {
            op_extra_data->sync_block.speaker_data = 0;
8420035c:	70 f0 89 8e 	M[r5 + 548] = Null;
        }
        bufp = &op_extra_data->output_stream[terminal_id];
84200360:	73 f0 40 20 	r1 = r5 + 64;
84200364:	f0 6f       	jump (m) Lc_aec_reference_connect_36;

84200366 <Lc_aec_reference_connect_40>:
84200366:	72 54       	r0 = r4 LSHIFT 2;
84200368:	39 00       	rMAC = r5 + Null;
8420036a:	51 00       	rMAC = r0 + rMAC;
8420036c:	13 f0 40 20 	r1 = rMAC + 64;
{
    return ((AEC_REF_OUTPUT_TERMINAL1 <= term_idx &&
            AEC_REF_OUTPUT_TERMINAL4 >= term_idx) ||
            (AEC_REF_OUTPUT_TERMINAL5 <= term_idx &&
                         AEC_REF_OUTPUT_TERMINAL8 >= term_idx)
            );
84200370:	f0 24       	Null = r4 - 3;
84200372:	e9 65       	if NC jump (m) Lc_aec_reference_connect_36;

84200374 <Lc_aec_reference_connect_41>:
84200374:	b0 25       	Null = r4 - 6;
84200376:	f9 ff bd ef 	if LS jump (m) Lc_aec_reference_connect_33;

8420037a <Lc_aec_reference_connect_42>:
8420037a:	70 27       	Null = r4 - 13;
8420037c:	e4 65       	if NC jump (m) Lc_aec_reference_connect_36;

8420037e <Lc_aec_reference_connect_43>:
8420037e:	30 2c       	Null = r4 - 16;
84200380:	f9 ff b3 ef 	if LS jump (m) Lc_aec_reference_connect_33;

84200384 <Lc_15>:
84200384:	e0 6f       	jump (m) Lc_aec_reference_connect_36;

84200386 <Lc_aec_reference_connect_44>:
    if(aec_reference_update_stream_and_validate_channels(op_data, bufp, pterminal_buf))
    {
        base_op_change_response_status(response_data,STATUS_OK);
    }
    return TRUE;
}
84200386:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200388:	d8 4c       	rts;

8420038a <$_aec_reference_disconnect>:

bool aec_reference_disconnect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
8420038a:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
8420038c:	11 09       	r7 = r0 + Null;
8420038e:	20 09       	r6 = r2 + Null;
84200390:	2a 09       	r8 = r3 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84200392:	96 f0 0c 88 	r4 = M[r7 + 48];

bool aec_reference_disconnect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    tCbuffer **bufp = NULL;
    unsigned terminal_id = *((unsigned*)message_data);
84200396:	1f e8       	r5 = M[r1 + Null];

    patch_fn_shared(aec_reference);

    L3_DBG_MSG1("AEC REFERENCE --- disconnect TID = %x", terminal_id);
84200398:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
8420039c:	c8 24       	Null = rMAC - 3;
8420039e:	08 68       	if LT jump (m) Lc_aec_reference_disconnect_3;

842003a0 <Lc_aec_reference_disconnect_2>:
842003a0:	55 f1 02 f0 	r0 = Null + 357564451;
842003a4:	23 40 
842003a6:	3b 00       	r1 = r5 + Null;
842003a8:	ff fd 03 f0 	call (m) 0x9b4;
842003ac:	2d e0 

842003ae <Lc_aec_reference_disconnect_3>:

    /* Setup Response to Disconnection Request. Assume Failure*/
    *response_id = OPCMD_DISCONNECT;
842003ae:	81 21       	rMAC = Null + 6;
842003b0:	81 f0 00 ee 	M[r6 + Null] = rMAC;
    if(!base_op_build_std_response(STATUS_CMD_FAILED,op_data->id,response_data))
842003b4:	93 f0 01 88 	r1 = M[r7 + 4];
842003b8:	02 f0 00 60 	r0 = Null + 4096;
842003bc:	54 08       	r2 = r8 + Null;
842003be:	ef fd ff ff 	call (m) 0x204;
842003c2:	27 e2 
842003c4:	10 04       	Null = r0 - Null;
842003c6:	03 62       	if NE jump (m) Lc_aec_reference_disconnect_5;

842003c8 <Lc_aec_reference_disconnect_4>:
    {
        return(FALSE);
842003c8:	02 00       	r0 = Null + Null;
842003ca:	9a 6e       	jump (m) Lc_aec_reference_disconnect_53;

842003cc <Lc_aec_reference_disconnect_5>:
    }

    /* check if the terminal ID is valid . The number has to be less than the maximum number of sinks or sources.  */
    if(!base_op_is_terminal_valid(op_data, terminal_id))
842003cc:	3b 00       	r1 = r5 + Null;
842003ce:	4a 08       	r0 = r7 + Null;
842003d0:	ef fd ff ff 	call (m) 0x1de;
842003d4:	2f e0 
842003d6:	10 04       	Null = r0 - Null;
842003d8:	07 62       	if NE jump (m) Lc_aec_reference_disconnect_7;

842003da <Lc_aec_reference_disconnect_6>:
842003da:	01 f0 03 60 	rMAC = Null + 4099;
842003de:	a2 f0 00 e8 	r0 = M[r8 + Null];
842003e2:	51 8e       	M[r0 + 4] = rMAC;
842003e4:	7a 6e       	jump (m) Lc_aec_reference_disconnect_47;

842003e6 <Lc_aec_reference_disconnect_7>:
        base_op_change_response_status(response_data,STATUS_INVALID_CMD_PARAMS);
        return TRUE;
    }

    /* check if the terminal is connected and if so , disconnect the terminal */
    if(terminal_id & TERMINAL_SINK_MASK)
842003e6:	40 f0 71 f0 	rMAC = r5 AND 0x800000;
842003ea:	00 00 
842003ec:	3c 60       	if EQ jump (m) Lc_aec_reference_disconnect_28;

842003ee <Lc_aec_reference_disconnect_8>:
inline static bool IsSpeakerInputTerminal(unsigned term_idx)
{
    return ( (term_idx==AEC_REF_INPUT_TERMINAL1)
          || (term_idx==AEC_REF_INPUT_TERMINAL2)
          || ( (term_idx>=AEC_REF_INPUT_TERMINAL3)
              && (term_idx<=AEC_REF_INPUT_TERMINAL8) ) );
842003ee:	bf ff 77 ff 	r5 = r5 AND 0xff7fffff;
842003f2:	ff 1f 
842003f4:	08 60       	if EQ jump (m) Lc_aec_reference_disconnect_12;

842003f6 <Lc_aec_reference_disconnect_9>:
842003f6:	78 24       	Null = r5 - 1;
842003f8:	06 60       	if EQ jump (m) Lc_aec_reference_disconnect_12;

842003fa <Lc_aec_reference_disconnect_10>:
842003fa:	b8 25       	Null = r5 - 6;
842003fc:	27 64       	if NC jump (m) Lc_aec_reference_disconnect_25;

842003fe <Lc_aec_reference_disconnect_11>:
842003fe:	f8 26       	Null = r5 - 11;
84200400:	08 f0 c3 e0 	if HI jump (m) Lc_aec_reference_disconnect_24;

84200404 <Lc_aec_reference_disconnect_12>:
        terminal_id &= ~ TERMINAL_SINK_MASK;

#ifdef AEC_REFERENCE_SUPPORT_METADATA
        if(IsSpeakerInputTerminal(terminal_id))
        {
            tCbuffer *this_buf = op_extra_data->input_stream[terminal_id];
84200404:	7a 54       	r0 = r5 LSHIFT 2;
84200406:	b1 e8       	rMAC = M[r4 + r0];
            if(this_buf == op_extra_data->spkr_input_metadata_buffer)
84200408:	62 f0 c9 88 	r0 = M[r4 + 804];
8420040c:	88 04       	Null = rMAC - r0;
8420040e:	16 62       	if NE jump (m) Lc_aec_reference_disconnect_22;

84200410 <Lc_aec_reference_disconnect_13>:
            {
                /* disconnecting buffer is the metadata buffer,
                 * change the metadata buffer to another connected
                 * buffer with metadata, if there is any.
                 */
                tCbuffer *new_metadata_buf = NULL;
84200410:	02 00       	r0 = Null + Null;
                int idx;
                for(idx=0; idx < MAX_NUMBER_SPEAKERS; idx++)
84200412:	03 00       	r1 = Null + Null;
84200414:	03 6e       	jump (m) Lc_aec_reference_disconnect_15;

84200416 <Lc_aec_reference_disconnect_14>:
                {
                    tCbuffer *inp_buf = op_extra_data->input_stream[SpeakerInputTerminalByIndex(idx)];
84200416:	98 24       	Null = r1 - 2;
84200418:	03 66       	if GE jump (m) Lc_aec_reference_disconnect_16;

8420041a <Lc_aec_reference_disconnect_15>:
8420041a:	1c 00       	r2 = r1 + Null;
8420041c:	02 6e       	jump (m) Lc_aec_reference_disconnect_17;

8420041e <Lc_aec_reference_disconnect_16>:
8420041e:	1c 21       	r2 = r1 + 4;

84200420 <Lc_aec_reference_disconnect_17>:
84200420:	64 54       	r2 = r2 LSHIFT 2;
                    if(inp_buf != NULL &&
                       inp_buf != this_buf &&
                       buff_has_metadata(inp_buf))
84200422:	34 e9       	r2 = M[r4 + r2];
84200424:	06 60       	if EQ jump (m) Lc_aec_reference_disconnect_20;

84200426 <Lc_aec_reference_disconnect_18>:
84200426:	60 04       	Null = r2 - rMAC;
84200428:	04 60       	if EQ jump (m) Lc_aec_reference_disconnect_20;

8420042a <Lc_aec_reference_disconnect_19>:
8420042a:	65 89       	r3 = M[r2 + 20];
8420042c:	6d c6       	r3 = r3 AND 0x8000;
8420042e:	64 62       	if NE jump (m) Lc_aec_reference_disconnect_51;

84200430 <Lc_aec_reference_disconnect_20>:
                 * change the metadata buffer to another connected
                 * buffer with metadata, if there is any.
                 */
                tCbuffer *new_metadata_buf = NULL;
                int idx;
                for(idx=0; idx < MAX_NUMBER_SPEAKERS; idx++)
84200430:	5b 20       	r1 = r1 + 1;
84200432:	18 26       	Null = r1 - 8;
84200434:	f1 69       	if LT jump (m) Lc_aec_reference_disconnect_14;

84200436 <Lc_aec_reference_disconnect_21>:
                    {
                        new_metadata_buf = inp_buf;
                        break;
                    }
                }
                op_extra_data->spkr_input_metadata_buffer = new_metadata_buf;
84200436:	62 f0 c9 8e 	M[r4 + 804] = r0;

8420043a <Lc_aec_reference_disconnect_22>:
                op_extra_data->mic_ext_rate_adjust_op = 0;
            }
#endif /* INSTALL_DELEGATE_RATE_ADJUST_SUPPORT */

        }
        else if(terminal_id==AEC_REF_INPUT_TERMINAL1)
8420043a:	38 04       	Null = r5 - Null;
8420043c:	03 62       	if NE jump (m) Lc_aec_reference_disconnect_24;

8420043e <Lc_aec_reference_disconnect_23>:
        {
            op_extra_data->spkr_in_endpoint=NULL;
8420043e:	60 f0 82 8e 	M[r4 + 520] = Null;

84200442 <Lc_aec_reference_disconnect_24>:
        }
        bufp = &op_extra_data->input_stream[terminal_id];
84200442:	7a 54       	r0 = r5 LSHIFT 2;
84200444:	33 00       	r1 = r4 + Null;
84200446:	d3 00       	r1 = r0 + r1;
84200448:	3f 6e       	jump (m) Lc_aec_reference_disconnect_45;

8420044a <Lc_aec_reference_disconnect_25>:
                op_extra_data->spkr_input_metadata_buffer = new_metadata_buf;
            }
        }
#endif /* AEC_REFERENCE_SUPPORT_METADATA */

        if(terminal_id==AEC_REF_MIC_TERMINAL1)
8420044a:	b8 24       	Null = r5 - 2;
8420044c:	fb 63       	if NE jump (m) Lc_aec_reference_disconnect_24;

8420044e <Lc_aec_reference_disconnect_26>:
        {
            op_extra_data->mic_endpoint=NULL;
8420044e:	60 f0 7f 8e 	M[r4 + 508] = Null;
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
            if(op_extra_data->mic_ext_rate_adjust_op != 0)
84200452:	62 f0 ad 88 	r0 = M[r4 + 692];
84200456:	f6 61       	if EQ jump (m) Lc_aec_reference_disconnect_24;

84200458 <Lc_aec_reference_disconnect_27>:
            {
                /* set external op to passthrough mode */
                stream_delegate_rate_adjust_set_passthrough_mode(op_extra_data->mic_ext_rate_adjust_op, TRUE);
84200458:	43 20       	r1 = Null + 1;
8420045a:	16 f0 35 ee 	call (m) $_stream_delegate_rate_adjust_set_passthrough_mode;
                op_extra_data->mic_ext_rate_adjust_op = 0;
8420045e:	60 f0 ad 8e 	M[r4 + 692] = Null;
84200462:	f0 6f       	jump (m) Lc_aec_reference_disconnect_24;

84200464 <Lc_aec_reference_disconnect_28>:
{
    return ((AEC_REF_OUTPUT_TERMINAL1 <= term_idx &&
            AEC_REF_OUTPUT_TERMINAL4 >= term_idx) ||
            (AEC_REF_OUTPUT_TERMINAL5 <= term_idx &&
                         AEC_REF_OUTPUT_TERMINAL8 >= term_idx)
            );
84200464:	f8 24       	Null = r5 - 3;
84200466:	3b 64       	if NC jump (m) Lc_aec_reference_disconnect_48;

84200468 <Lc_aec_reference_disconnect_29>:
84200468:	b8 25       	Null = r5 - 6;
8420046a:	09 f0 8f e0 	if LS jump (m) Lc_aec_reference_disconnect_32;

8420046e <Lc_aec_reference_disconnect_30>:
8420046e:	78 27       	Null = r5 - 13;
84200470:	27 64       	if NC jump (m) Lc_aec_reference_disconnect_44;

84200472 <Lc_aec_reference_disconnect_31>:
84200472:	38 2c       	Null = r5 - 16;
84200474:	08 f0 cb e0 	if HI jump (m) Lc_aec_reference_disconnect_44;

84200478 <Lc_aec_reference_disconnect_32>:
    else
    {
#ifdef AEC_REFERENCE_GENERATE_MIC_TIMESTAMP
        if(IsMicrophoneOutputTerminal(terminal_id))
        {
            tCbuffer *this_buf = op_extra_data->output_stream[terminal_id];
84200478:	7a 54       	r0 = r5 LSHIFT 2;
8420047a:	31 00       	rMAC = r4 + Null;
8420047c:	51 00       	rMAC = r0 + rMAC;
8420047e:	09 a8       	rMAC = M[rMAC + 64];
            if(this_buf == op_extra_data->mic_metadata_buffer)
84200480:	62 f0 ca 88 	r0 = M[r4 + 808];
84200484:	88 04       	Null = rMAC - r0;
84200486:	18 62       	if NE jump (m) Lc_aec_reference_disconnect_42;

84200488 <Lc_aec_reference_disconnect_33>:
            {
                /* disconnecting buffer is the mic metadata buffer,
                 * change the metadata buffer to another connected
                 * buffer with metadata, if there is any.
                 */
                tCbuffer *new_metadata_buf = NULL;
84200488:	02 00       	r0 = Null + Null;
                int idx;
                for(idx=0; idx < MAX_NUMBER_MICS; idx++)
8420048a:	03 00       	r1 = Null + Null;
8420048c:	03 6e       	jump (m) Lc_aec_reference_disconnect_35;

8420048e <Lc_aec_reference_disconnect_34>:
                {
                    tCbuffer *out_buf = op_extra_data->output_stream[MicrophoneOutputTerminalByIndex(idx)];
8420048e:	98 24       	Null = r1 - 2;
84200490:	03 66       	if GE jump (m) Lc_aec_reference_disconnect_36;

84200492 <Lc_aec_reference_disconnect_35>:
84200492:	dc 20       	r2 = r1 + 3;
84200494:	02 6e       	jump (m) Lc_aec_reference_disconnect_37;

84200496 <Lc_aec_reference_disconnect_36>:
84200496:	5c 22       	r2 = r1 + 9;

84200498 <Lc_aec_reference_disconnect_37>:
84200498:	65 f0 40 20 	r3 = r4 + 64;
8420049c:	64 54       	r2 = r2 LSHIFT 2;
                    if(out_buf != NULL &&
                       out_buf != this_buf &&
                       buff_has_metadata(out_buf))
8420049e:	2c e9       	r2 = M[r3 + r2];
842004a0:	06 60       	if EQ jump (m) Lc_aec_reference_disconnect_40;

842004a2 <Lc_aec_reference_disconnect_38>:
842004a2:	60 04       	Null = r2 - rMAC;
842004a4:	04 60       	if EQ jump (m) Lc_aec_reference_disconnect_40;

842004a6 <Lc_aec_reference_disconnect_39>:
842004a6:	65 89       	r3 = M[r2 + 20];
842004a8:	6d c6       	r3 = r3 AND 0x8000;
842004aa:	28 62       	if NE jump (m) Lc_aec_reference_disconnect_52;

842004ac <Lc_aec_reference_disconnect_40>:
                 * change the metadata buffer to another connected
                 * buffer with metadata, if there is any.
                 */
                tCbuffer *new_metadata_buf = NULL;
                int idx;
                for(idx=0; idx < MAX_NUMBER_MICS; idx++)
842004ac:	5b 20       	r1 = r1 + 1;
842004ae:	18 26       	Null = r1 - 8;
842004b0:	ef 69       	if LT jump (m) Lc_aec_reference_disconnect_34;

842004b2 <Lc_aec_reference_disconnect_41>:
                    {
                        new_metadata_buf = out_buf;
                        break;
                    }
                }
                op_extra_data->mic_metadata_buffer = new_metadata_buf;
842004b2:	62 f0 ca 8e 	M[r4 + 808] = r0;

842004b6 <Lc_aec_reference_disconnect_42>:
                op_extra_data->spkr_ext_rate_adjust_op = 0;
            }
#endif /* INSTALL_DELEGATE_RATE_ADJUST_SUPPORT */

        }
        else if(terminal_id==AEC_REF_OUTPUT_TERMINAL1)
842004b6:	f8 24       	Null = r5 - 3;
842004b8:	03 62       	if NE jump (m) Lc_aec_reference_disconnect_44;

842004ba <Lc_aec_reference_disconnect_43>:
        {
            op_extra_data->mic_out_endpoint=NULL;
842004ba:	60 f0 81 8e 	M[r4 + 516] = Null;

842004be <Lc_aec_reference_disconnect_44>:
        }
        bufp = &op_extra_data->output_stream[terminal_id];
842004be:	7a 54       	r0 = r5 LSHIFT 2;
842004c0:	96 01       	r4 = r0 + r4;
842004c2:	63 f0 40 20 	r1 = r4 + 64;

842004c6 <Lc_aec_reference_disconnect_45>:
    }

    /* clear the stream buffer for this terminal and rebuild the graphs if needed */
    if(aec_reference_update_stream_and_validate_channels(op_data, bufp, NULL))
842004c6:	04 00       	r2 = Null + Null;
842004c8:	4a 08       	r0 = r7 + Null;
842004ca:	10 f0 3b e7 	call (m) $_aec_reference_update_stream_and_validate_channels;
842004ce:	10 04       	Null = r0 - Null;
842004d0:	04 60       	if EQ jump (m) Lc_aec_reference_disconnect_47;

842004d2 <Lc_aec_reference_disconnect_46>:
842004d2:	a1 f0 00 e8 	rMAC = M[r8 + Null];
842004d6:	48 8e       	M[rMAC + 4] = Null;

842004d8 <Lc_aec_reference_disconnect_47>:

    /* check if the terminal ID is valid . The number has to be less than the maximum number of sinks or sources.  */
    if(!base_op_is_terminal_valid(op_data, terminal_id))
    {
        base_op_change_response_status(response_data,STATUS_INVALID_CMD_PARAMS);
        return TRUE;
842004d8:	42 20       	r0 = Null + 1;
842004da:	12 6e       	jump (m) Lc_aec_reference_disconnect_53;

842004dc <Lc_aec_reference_disconnect_48>:
                op_extra_data->mic_metadata_buffer = new_metadata_buf;
            }
        }
#endif /* AEC_REFERENCE_GENERATE_MIC_TIMESTAMP */

        if(terminal_id==AEC_REF_SPKR_TERMINAL1)
842004dc:	78 24       	Null = r5 - 1;
842004de:	f0 63       	if NE jump (m) Lc_aec_reference_disconnect_44;

842004e0 <Lc_aec_reference_disconnect_49>:
        {
            op_extra_data->spkr_endpoint=NULL;
842004e0:	60 f0 80 8e 	M[r4 + 512] = Null;
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
            if(op_extra_data->spkr_ext_rate_adjust_op != 0)
842004e4:	62 f0 ae 88 	r0 = M[r4 + 696];
842004e8:	eb 61       	if EQ jump (m) Lc_aec_reference_disconnect_44;

842004ea <Lc_aec_reference_disconnect_50>:
            {
                /* set external op to passthrough mode */
                stream_delegate_rate_adjust_set_passthrough_mode(op_extra_data->spkr_ext_rate_adjust_op, TRUE);
842004ea:	43 20       	r1 = Null + 1;
842004ec:	16 f0 23 ea 	call (m) $_stream_delegate_rate_adjust_set_passthrough_mode;
                op_extra_data->spkr_ext_rate_adjust_op = 0;
842004f0:	60 f0 ae 8e 	M[r4 + 696] = Null;
842004f4:	e5 6f       	jump (m) Lc_aec_reference_disconnect_44;

842004f6 <Lc_aec_reference_disconnect_51>:
                    tCbuffer *inp_buf = op_extra_data->input_stream[SpeakerInputTerminalByIndex(idx)];
                    if(inp_buf != NULL &&
                       inp_buf != this_buf &&
                       buff_has_metadata(inp_buf))
                    {
                        new_metadata_buf = inp_buf;
842004f6:	22 00       	r0 = r2 + Null;
                        break;
842004f8:	9f 6f       	jump (m) Lc_aec_reference_disconnect_21;

842004fa <Lc_aec_reference_disconnect_52>:
                    tCbuffer *out_buf = op_extra_data->output_stream[MicrophoneOutputTerminalByIndex(idx)];
                    if(out_buf != NULL &&
                       out_buf != this_buf &&
                       buff_has_metadata(out_buf))
                    {
                        new_metadata_buf = out_buf;
842004fa:	22 00       	r0 = r2 + Null;
                        break;
842004fc:	db 6f       	jump (m) Lc_aec_reference_disconnect_41;

842004fe <Lc_aec_reference_disconnect_53>:
    {
        base_op_change_response_status(response_data,STATUS_OK);
    }

    return TRUE;
}
842004fe:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84200500:	d8 4c       	rts;

84200502 <$_aec_reference_start>:

    return TRUE;
}

bool aec_reference_start(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200502:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84200504:	16 00       	r4 = r0 + Null;
84200506:	2f 00       	r5 = r3 + Null;
    patch_fn_shared(aec_reference);

    /* Setup Response to Start Request.   Assume Failure*/
    *response_id = OPCMD_START;
84200508:	81 20       	rMAC = Null + 2;
8420050a:	21 ee       	M[r2 + Null] = rMAC;
    if(!base_op_build_std_response(STATUS_CMD_FAILED,op_data->id,response_data))
8420050c:	73 88       	r1 = M[r4 + 4];
8420050e:	02 f0 00 60 	r0 = Null + 4096;
84200512:	3c 00       	r2 = r5 + Null;
84200514:	ef fd fe ff 	call (m) 0x204;
84200518:	31 e7 
8420051a:	10 04       	Null = r0 - Null;
8420051c:	03 62       	if NE jump (m) Lc_aec_reference_start_3;

8420051e <Lc_aec_reference_start_2>:
    {
        return(FALSE);
8420051e:	02 00       	r0 = Null + Null;
84200520:	0f 6e       	jump (m) Lc_aec_reference_start_8;

84200522 <Lc_aec_reference_start_3>:
    }
    /* do something only if the current state is "connected" */
    if(op_data->state == OP_RUNNING)
84200522:	31 b0       	rMAC = MBS[r4 + 24];
84200524:	0a 60       	if EQ jump (m) Lc_aec_reference_start_6;

84200526 <Lc_aec_reference_start_4>:
        base_op_change_response_status(response_data,STATUS_OK);
        return(TRUE);
    }

    /* Validate channel configuration */
    if(!validate_channels_and_build(op_data))
84200526:	32 00       	r0 = r4 + Null;
84200528:	0a f0 29 ef 	call (m) $_validate_channels_and_build;
8420052c:	10 04       	Null = r0 - Null;
8420052e:	07 60       	if EQ jump (m) Lc_aec_reference_start_7;

84200530 <Lc_aec_reference_start_5>:
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84200530:	32 99       	r0 = M[r4 + 48];
    }
#ifdef AEC_REFERENCE_SPKR_TTP
    {
        AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
        /* initialisation for timed playback in speaker path */
        aec_reference_spkr_ttp_init(op_extra_data);
84200532:	13 f0 23 e1 	call (m) $_aec_reference_spkr_ttp_init;
    }
#endif /* AEC_REFERENCE_SPKR_TTP */
    /* set internal capability state variable to "running" */
    /* operator state variable set to not running state. based on base_op.c */
    op_data->state = OP_RUNNING;
84200536:	30 ba       	MB[r4 + 24] = Null;

84200538 <Lc_aec_reference_start_6>:
84200538:	39 e8       	rMAC = M[r5 + Null];
8420053a:	48 8e       	M[rMAC + 4] = Null;

8420053c <Lc_aec_reference_start_7>:
    }
    /* do something only if the current state is "connected" */
    if(op_data->state == OP_RUNNING)
    {
        base_op_change_response_status(response_data,STATUS_OK);
        return(TRUE);
8420053c:	42 20       	r0 = Null + 1;

8420053e <Lc_aec_reference_start_8>:
        hl_limiter_init(op_extra_data);
    }
#endif /* INSTALL_AEC_REFERENCE_HOWL_LIMITER */

    return TRUE;
}
8420053e:	f2 48       	popm <FP, r4, r5, rLink>;
84200540:	d8 4c       	rts;

84200542 <$_aec_reference_stop>:

    return retval;
}

bool aec_reference_stop(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200542:	c8 1c       	pushm <FP(=SP), rLink>;
84200544:	2b 00       	r1 = r3 + Null;
    /* Setup Response to Stop Request.   Assume Failure*/
    *response_id = OPCMD_STOP;
84200546:	c1 20       	rMAC = Null + 3;
84200548:	21 ee       	M[r2 + Null] = rMAC;
    return(aec_reference_stop_reset(op_data,response_data));
8420054a:	0f f0 21 e7 	call (m) $_aec_reference_stop_reset;

8420054e <Lc_aec_reference_stop_2>:
}
8420054e:	c8 48       	popm <FP, rLink>;
84200550:	d8 4c       	rts;

84200552 <$_aec_reference_buffer_details>:

    return TRUE;
}

bool aec_reference_buffer_details(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200552:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84200554:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84200556:	16 99       	r4 = M[r0 + 48];
}

bool aec_reference_buffer_details(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    unsigned term_id =  *((unsigned *)message_data);
84200558:	1f e8       	r5 = M[r1 + Null];
    OP_BUF_DETAILS_RSP *resp;

    patch_fn_shared(aec_reference);

    if(!base_op_buffer_details(op_data, message_data, response_id, response_data))
8420055a:	ef fd fd ff 	call (m) 0xbe;
8420055e:	25 eb 
84200560:	10 04       	Null = r0 - Null;
84200562:	03 62       	if NE jump (m) Lc_aec_reference_buffer_details_3;

84200564 <Lc_aec_reference_buffer_details_2>:
    {
        return FALSE;
84200564:	02 00       	r0 = Null + Null;
84200566:	8e 6e       	jump (m) Lc_aec_reference_buffer_details_30;

84200568 <Lc_aec_reference_buffer_details_3>:
    }
    resp = (OP_BUF_DETAILS_RSP*)*response_data;
84200568:	88 f0 00 e8 	r6 = M[r6 + Null];

    if ( term_id & TERMINAL_SINK_MASK)
8420056c:	40 f0 71 f0 	rMAC = r5 AND 0x800000;
84200570:	00 00 
84200572:	0d 60       	if EQ jump (m) Lc_aec_reference_buffer_details_7;

84200574 <Lc_aec_reference_buffer_details_4>:
          || ( (term_idx>=AEC_REF_INPUT_TERMINAL3)
              && (term_idx<=AEC_REF_INPUT_TERMINAL8) ) );
}
inline static bool IsMicrophoneTerminal(unsigned term_idx)
{
    term_idx &= ~TERMINAL_SINK_MASK;
84200574:	bf ff 71 ff 	rMAC = r5 AND 0xff7fffff;
84200578:	ff 1f 

    if(term_idx < AEC_REF_MIC_TERMINAL1)
8420057a:	88 24       	Null = rMAC - 2;
8420057c:	02 f0 f3 e1 	if C jump (m) Lc_aec_reference_buffer_details_28;

84200580 <Lc_aec_reference_buffer_details_5>:
            resp->needs_override = TRUE;
            resp->b.buffer_size  = 0;
        }
        else
        {
            if(op_extra_data->input_buffer_size != 0)
84200580:	61 f0 d6 88 	rMAC = M[r4 + 856];
84200584:	10 60       	if EQ jump (m) Lc_aec_reference_buffer_details_9;

84200586 <Lc_aec_reference_buffer_details_6>:
            {
                /* buffer size based on user configuration */
                resp->b.buffer_size = op_extra_data->input_buffer_size;
84200586:	81 f0 04 8e 	M[r6 + 16] = rMAC;
8420058a:	18 6e       	jump (m) Lc_aec_reference_buffer_details_10;

8420058c <Lc_aec_reference_buffer_details_7>:
inline static bool IsSpeakerTerminal(unsigned term_idx)
{
    return ( (term_idx==AEC_REF_SPKR_TERMINAL1)
          || (term_idx==AEC_REF_SPKR_TERMINAL2)
          || ( (term_idx>=AEC_REF_SPKR_TERMINAL3)
              && (term_idx<=AEC_REF_SPKR_TERMINAL8) ) );
8420058c:	78 24       	Null = r5 - 1;
8420058e:	2d 62       	if NE jump (m) Lc_aec_reference_buffer_details_15;

84200590 <Lc_aec_reference_buffer_details_8>:
    if ( term_id & TERMINAL_SINK_MASK)
    {
        if(IsMicrophoneTerminal(term_id))
        {
            /* override MIC endpoints */
            resp->needs_override = TRUE;
84200590:	81 f0 08 82 	rMAC = MBU[r6 + 8];
84200594:	11 ff fb 1f 	rMAC = rMAC AND 0xfffffffb;
84200598:	c9 c8       	rMAC = rMAC OR 0x4;
8420059a:	81 f0 08 8a 	MB[r6 + 8] = rMAC;
            resp->b.buffer_size  = 0;
8420059e:	80 f0 04 8e 	M[r6 + 16] = Null;
842005a2:	21 6e       	jump (m) Lc_aec_reference_buffer_details_14;

842005a4 <Lc_aec_reference_buffer_details_9>:
                /* buffer size based on sample rate. task period + 2ms for safety,
                 * 2ms extra should be enough as assumption is that scheduling jitter
                 * assumed will not be too high.
                 */
                resp->b.buffer_size  =
                    frac_mult(op_extra_data->input_rate,FRACTIONAL(0.002)+op_extra_data->task_period_frac);
842005a4:	62 f0 64 88 	r0 = M[r4 + 400];
842005a8:	61 f0 93 88 	rMAC = M[r4 + 588];
842005ac:	06 f1 13 f0 	r1 = rMAC + 4294967;
842005b0:	37 31 
842005b2:	00 f3 72 c9 	r0 = r0 * r1 (frac);
842005b6:	82 f0 04 8e 	M[r6 + 16] = r0;

842005ba <Lc_aec_reference_buffer_details_10>:

#ifdef AEC_REFERENCE_SUPPORT_METADATA
            /* currently metadata is supported only for
             * speaker input channels.
             */
            L3_DBG_MSG("AEC_REFERENCE: metadata is supported for speaker inputs");
842005ba:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
842005be:	c8 24       	Null = rMAC - 3;
842005c0:	07 68       	if LT jump (m) Lc_aec_reference_buffer_details_12;

842005c2 <Lc_aec_reference_buffer_details_11>:
842005c2:	55 f1 02 f0 	r0 = Null + 357564489;
842005c6:	49 40 
842005c8:	ff fd 01 f0 	call (m) 0x9a2;
842005cc:	3b ee 

842005ce <Lc_aec_reference_buffer_details_12>:
            resp->metadata_buffer = op_extra_data->spkr_input_metadata_buffer;
842005ce:	61 f0 c9 88 	rMAC = M[r4 + 804];
842005d2:	81 f0 03 8e 	M[r6 + 12] = rMAC;

842005d6 <Lc_aec_reference_buffer_details_13>:
             */
            if(op_extra_data->mic_metadata_enable &&
               IsMicrophoneOutputTerminal(term_id))
            {
                resp->metadata_buffer = op_extra_data->mic_metadata_buffer;
                resp->supports_metadata = TRUE;
842005d6:	81 f0 08 82 	rMAC = MBU[r6 + 8];
842005da:	11 ff ef 1f 	rMAC = rMAC AND 0xffffffef;
842005de:	c9 c9       	rMAC = rMAC OR 0x10;
842005e0:	81 f0 08 8a 	MB[r6 + 8] = rMAC;

842005e4 <Lc_aec_reference_buffer_details_14>:
            }
#endif /* AEC_REFERENCE_GENERATE_MIC_TIMESTAMP */
        }
    }

    return TRUE;
842005e4:	42 20       	r0 = Null + 1;
842005e6:	4e 6e       	jump (m) Lc_aec_reference_buffer_details_30;

842005e8 <Lc_aec_reference_buffer_details_15>:
842005e8:	b8 24       	Null = r5 - 2;
842005ea:	d3 61       	if EQ jump (m) Lc_aec_reference_buffer_details_8;

842005ec <Lc_aec_reference_buffer_details_16>:
842005ec:	f8 25       	Null = r5 - 7;
842005ee:	04 64       	if NC jump (m) Lc_aec_reference_buffer_details_18;

842005f0 <Lc_aec_reference_buffer_details_17>:
842005f0:	38 27       	Null = r5 - 12;
842005f2:	f9 ff 9f ef 	if LS jump (m) Lc_aec_reference_buffer_details_8;

842005f6 <Lc_aec_reference_buffer_details_18>:
            resp->needs_override = TRUE;
            resp->b.buffer_size  = 0;
        }
        else
        {
            if(op_extra_data->output_buffer_size != 0)
842005f6:	61 f0 d5 88 	rMAC = M[r4 + 852];
842005fa:	14 60       	if EQ jump (m) Lc_aec_reference_buffer_details_21;

842005fc <Lc_aec_reference_buffer_details_19>:
            {
                /* buffer size based on user configuration */
                resp->b.buffer_size = op_extra_data->output_buffer_size;
842005fc:	81 f0 04 8e 	M[r6 + 16] = rMAC;

                if(AEC_REF_REFERENCE_TERMINAL == term_id)
84200600:	38 04       	Null = r5 - Null;
84200602:	26 62       	if NE jump (m) Lc_aec_reference_buffer_details_23;

84200604 <Lc_aec_reference_buffer_details_20>:
                     * within [ref_delay, ref_delay+jitter] range. For that reason we add an extra
                     * for ref buffer so mic output can use full output_buffer_size
                     */
                    unsigned ref_extra =
                        frac_mult(op_extra_data->output_rate,
                                  op_extra_data->task_period_frac + FRACTIONAL(0.001));
84200604:	62 f0 65 88 	r0 = M[r4 + 404];
84200608:	61 f0 93 88 	rMAC = M[r4 + 588];
8420060c:	83 f0 13 f0 	r1 = rMAC + 2147483;
84200610:	9b 28 
84200612:	00 f3 72 c9 	r0 = r0 * r1 (frac);

                    resp->b.buffer_size += ref_extra;
84200616:	81 f0 04 88 	rMAC = M[r6 + 16];
8420061a:	51 00       	rMAC = r0 + rMAC;
8420061c:	81 f0 04 8e 	M[r6 + 16] = rMAC;
84200620:	17 6e       	jump (m) Lc_aec_reference_buffer_details_23;

84200622 <Lc_aec_reference_buffer_details_21>:
                }
            }
            else
            {
                unsigned two_task_period_size = frac_mult(op_extra_data->output_rate,
                                                          2*op_extra_data->task_period_frac) + 1;
84200622:	62 f0 65 88 	r0 = M[r4 + 404];
84200626:	63 f0 93 88 	r1 = M[r4 + 588];
8420062a:	1b 54       	r1 = r1 LSHIFT 1;
8420062c:	00 f3 72 c9 	r0 = r0 * r1 (frac);
84200630:	51 20       	rMAC = r0 + 1;
                /* buffer size based on sample rate */
                resp->b.buffer_size  = frac_mult(op_extra_data->output_rate,FRACTIONAL(0.0087));
84200632:	62 f0 65 88 	r0 = M[r4 + 404];
84200636:	11 f0 83 f6 	r1 = Null + 18683107;
8420063a:	e3 68 
8420063c:	00 f3 72 c9 	r0 = r0 * r1 (frac);
84200640:	82 f0 04 8e 	M[r6 + 16] = r0;
                /* given that this is for cvc-like operators and limited task periods that the
                 * operator supports, 8.7ms would be adequate for all use cases. In case of very
                 * high task period is used make sure output has space for at least two task period.
                 */
                resp->b.buffer_size = MAX(resp->b.buffer_size,
                                          two_task_period_size);
84200644:	50 04       	Null = r0 - rMAC;
84200646:	02 f0 89 e0 	if C jump (m) Lc_aec_reference_buffer_details_23;

8420064a <Lc_aec_reference_buffer_details_22>:
8420064a:	81 f0 04 8e 	M[r6 + 16] = rMAC;

8420064e <Lc_aec_reference_buffer_details_23>:
#ifdef AEC_REFERENCE_GENERATE_MIC_TIMESTAMP
            /* Support metadta for microphone output channels (reference channel not included)
             * if enabled by the user.
             */
            if(op_extra_data->mic_metadata_enable &&
               IsMicrophoneOutputTerminal(term_id))
8420064e:	60 f0 cd 88 	Null = M[r4 + 820];
84200652:	c9 61       	if EQ jump (m) Lc_aec_reference_buffer_details_14;

84200654 <Lc_aec_reference_buffer_details_24>:
{
    return ((AEC_REF_OUTPUT_TERMINAL1 <= term_idx &&
            AEC_REF_OUTPUT_TERMINAL4 >= term_idx) ||
            (AEC_REF_OUTPUT_TERMINAL5 <= term_idx &&
                         AEC_REF_OUTPUT_TERMINAL8 >= term_idx)
            );
84200654:	f8 24       	Null = r5 - 3;
84200656:	c7 65       	if NC jump (m) Lc_aec_reference_buffer_details_14;

84200658 <Lc_aec_reference_buffer_details_25>:
84200658:	b8 25       	Null = r5 - 6;
8420065a:	09 f0 8b e0 	if LS jump (m) Lc_aec_reference_buffer_details_27;

8420065e <Lc_aec_reference_buffer_details_26>:
8420065e:	38 2c       	Null = r5 - 16;
84200660:	f8 ff 85 ef 	if HI jump (m) Lc_aec_reference_buffer_details_14;

84200664 <Lc_aec_reference_buffer_details_27>:
            {
                resp->metadata_buffer = op_extra_data->mic_metadata_buffer;
84200664:	61 f0 ca 88 	rMAC = M[r4 + 808];
84200668:	81 f0 03 8e 	M[r6 + 12] = rMAC;
8420066c:	b5 6f       	jump (m) Lc_aec_reference_buffer_details_13;

8420066e <Lc_aec_reference_buffer_details_28>:

    if(term_idx < AEC_REF_MIC_TERMINAL1)
    {
        return FALSE;
    }
    if(term_idx <= AEC_REF_MIC_TERMINAL4)
8420066e:	48 25       	Null = rMAC - 5;
84200670:	f9 ff a1 ee 	if LS jump (m) Lc_aec_reference_buffer_details_8;

84200674 <Lc_aec_reference_buffer_details_29>:
    {
        return TRUE;
    }
    return (term_idx >= AEC_REF_MIC_TERMINAL5);
84200674:	02 00       	r0 = Null + Null;
84200676:	08 27       	Null = rMAC - 12;
84200678:	22 f0 42 ce 	if C r0 = Null + 1;
    }
    resp = (OP_BUF_DETAILS_RSP*)*response_data;

    if ( term_id & TERMINAL_SINK_MASK)
    {
        if(IsMicrophoneTerminal(term_id))
8420067c:	10 04       	Null = r0 - Null;
8420067e:	89 63       	if NE jump (m) Lc_aec_reference_buffer_details_8;

84200680 <Lc_16>:
84200680:	80 6f       	jump (m) Lc_aec_reference_buffer_details_5;

84200682 <Lc_aec_reference_buffer_details_30>:
#endif /* AEC_REFERENCE_GENERATE_MIC_TIMESTAMP */
        }
    }

    return TRUE;
}
84200682:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84200684:	d8 4c       	rts;

84200686 <$_aec_reference_timer_task>:
        op_extra_data->sync_block.frm_count = 0;
    }
}

void aec_reference_timer_task(void *kick_object)
{
84200686:	f6 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x20;
84200688:	13 09       	r9 = r0 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
8420068a:	b6 f0 0c 88 	r4 = M[r9 + 48];
void aec_reference_timer_task(void *kick_object)
{
    OPERATOR_DATA         *op_data = (OPERATOR_DATA*) kick_object;
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    TIME next_fire_time;
    unsigned                 sink_kicks=0,source_kicks=0;
8420068e:	40 de       	M[FP + 32] = Null;
84200690:	48 de       	M[FP + 36] = Null;
#ifdef PROFILER_ON
    if (op_data->profiler != NULL)
84200692:	b2 f0 08 88 	r0 = M[r9 + 32];
84200696:	04 60       	if EQ jump (m) Lc_aec_reference_timer_task_3;

84200698 <Lc_aec_reference_timer_task_2>:
    {
        PROFILER_START(op_data->profiler);
84200698:	ff fd 64 f1 	call (m) 0x2d006;
8420069c:	2f eb 

8420069e <Lc_aec_reference_timer_task_3>:
    }
#endif

    patch_fn_shared(aec_reference_run);

    if(op_extra_data->ReInitFlag==TRUE)
8420069e:	61 f0 5c 88 	rMAC = M[r4 + 368];
842006a2:	48 24       	Null = rMAC - 1;
842006a4:	0c 62       	if NE jump (m) Lc_aec_reference_timer_task_7;

842006a6 <Lc_aec_reference_timer_task_4>:
    {
        op_extra_data->ReInitFlag=FALSE;
842006a6:	60 f0 5c 8e 	M[r4 + 368] = Null;

        /* Handle Reinitialize */
        if(op_extra_data->mic_sidetone_op)
842006aa:	62 f0 6c 88 	r0 = M[r4 + 432];
842006ae:	04 60       	if EQ jump (m) Lc_aec_reference_timer_task_6;

842006b0 <Lc_aec_reference_timer_task_5>:
        {
            initialize_sidetone_filter_op(op_extra_data->mic_sidetone_op);
842006b0:	ff fd 58 f3 	call 0x6b82c;
842006b4:	3c eb 

842006b6 <Lc_aec_reference_timer_task_6>:
        }

        aec_reference_set_mic_gains(op_data);
842006b6:	5a 08       	r0 = r9 + Null;
842006b8:	06 f0 33 e7 	call (m) $_aec_reference_set_mic_gains;

842006bc <Lc_aec_reference_timer_task_7>:
#ifdef INSTALL_AEC_REFERENCE_HOWL_LIMITER
        hl_limiter_param_config(op_extra_data);
#endif /* INSTALL_AEC_REFERENCE_HOWL_LIMITER */
    }

    if(op_extra_data->mic_sidetone_op)
842006bc:	62 f0 6c 88 	r0 = M[r4 + 432];
842006c0:	0a 60       	if EQ jump (m) Lc_aec_reference_timer_task_9;

842006c2 <Lc_aec_reference_timer_task_8>:
    {
        update_sidetone_filter_op(op_extra_data->mic_sidetone_op,
                                  op_extra_data->params.OFFSET_CONFIG & AEC_REFERENCE_CONFIG_SIDETONEENA,
                                  op_extra_data->shared_volume_ptr->ndvc_filter_sum_lpdnz);
842006c2:	61 f0 58 88 	rMAC = M[r4 + 352];
842006c6:	4c 88       	r2 = M[rMAC + 4];
842006c8:	61 f0 2d 88 	rMAC = M[r4 + 180];
842006cc:	cb c1       	r1 = rMAC AND 0x10;
842006ce:	ff fd 58 f3 	call 0x6b7d4;
842006d2:	26 e8 

842006d4 <Lc_aec_reference_timer_task_9>:
        */
       && (0 != (op_extra_data->params.OFFSET_CONFIG & AEC_REFERENCE_CONFIG_SIDETONEENA))
       /* Also check that both speaker and mic still connected */
       && (NULL != op_extra_data->output_stream[AEC_REF_SPKR_TERMINAL1])
       && (NULL != op_extra_data->input_stream[AEC_REF_MIC_TERMINAL1])
       )
842006d4:	62 f0 99 88 	r0 = M[r4 + 612];
842006d8:	0e 60       	if EQ jump (m) Lc_aec_reference_timer_task_14;

842006da <Lc_aec_reference_timer_task_10>:
842006da:	61 f0 2d 88 	rMAC = M[r4 + 180];
842006de:	c9 c1       	rMAC = rMAC AND 0x10;
842006e0:	0a 60       	if EQ jump (m) Lc_aec_reference_timer_task_14;

842006e2 <Lc_aec_reference_timer_task_11>:
842006e2:	71 a8       	rMAC = M[r4 + 68];
842006e4:	08 60       	if EQ jump (m) Lc_aec_reference_timer_task_14;

842006e6 <Lc_aec_reference_timer_task_12>:
842006e6:	b1 88       	rMAC = M[r4 + 8];
842006e8:	06 60       	if EQ jump (m) Lc_aec_reference_timer_task_14;

842006ea <Lc_aec_reference_timer_task_13>:
    {
        /* Run sidetone graph */
        cbops_process_data(op_extra_data->sidetone_graph, CBOPS_MAX_COPY_SIZE-1);
842006ea:	03 f0 ff 41 	r1 = Null + 511;
842006ee:	ff fd d9 f2 	call 0x5b9a4;
842006f2:	36 e5 

842006f4 <Lc_aec_reference_timer_task_14>:
    }

    op_extra_data->task_decim_counter++;
842006f4:	61 f0 98 88 	rMAC = M[r4 + 608];
842006f8:	49 20       	rMAC = rMAC + 1;
842006fa:	61 f0 98 8e 	M[r4 + 608] = rMAC;
    if(op_extra_data->task_decim_counter >= op_extra_data->task_decim_factor)
842006fe:	62 f0 97 88 	r0 = M[r4 + 604];
84200702:	88 04       	Null = rMAC - r0;
84200704:	03 64       	if NC jump (m) Lc_aec_reference_timer_task_16;

84200706 <Lc_aec_reference_timer_task_15>:
    {
        op_extra_data->task_decim_counter = 0;
84200706:	60 f0 98 8e 	M[r4 + 608] = Null;

8420070a <Lc_aec_reference_timer_task_16>:
    }
    if(op_extra_data->task_decim_counter == 0)
8420070a:	60 f0 98 88 	Null = M[r4 + 608];
8420070e:	01 f0 91 e5 	if NE jump (m) Lc_aec_reference_timer_task_80;

84200712 <Lc_aec_reference_timer_task_17>:
    {
        /* Process the speaker path if we have speaker graph and
         * speaker is still connected
         */
        bool spkr_graph_active = (NULL != op_extra_data->spkr_graph) &&
            (NULL != op_extra_data->output_stream[AEC_REF_SPKR_TERMINAL1]);
84200712:	61 f0 72 88 	rMAC = M[r4 + 456];
84200716:	07 60       	if EQ jump (m) Lc_aec_reference_timer_task_19;

84200718 <Lc_aec_reference_timer_task_18>:
84200718:	72 a8       	r0 = M[r4 + 68];
8420071a:	01 00       	rMAC = Null + Null;
8420071c:	80 04       	Null = Null - r0;
8420071e:	21 f0 41 ce 	if NE rMAC = Null + 1;
84200722:	02 6e       	jump (m) Lc_aec_reference_timer_task_20;

84200724 <Lc_aec_reference_timer_task_19>:
84200724:	01 00       	rMAC = Null + Null;

84200726 <Lc_aec_reference_timer_task_20>:
84200726:	51 de       	M[FP + 40] = rMAC;

        /* Process the mic path if we have mic graph and
         * mic is still connected
         */
        bool mic_graph_active = (NULL != op_extra_data->mic_graph) &&
            (NULL != op_extra_data->input_stream[AEC_REF_MIC_TERMINAL1]);
84200728:	61 f0 6a 88 	rMAC = M[r4 + 424];
8420072c:	07 60       	if EQ jump (m) Lc_aec_reference_timer_task_22;

8420072e <Lc_aec_reference_timer_task_21>:
8420072e:	b1 88       	rMAC = M[r4 + 8];
84200730:	07 00       	r5 = Null + Null;
84200732:	40 04       	Null = Null - rMAC;
84200734:	21 f0 47 ce 	if NE r5 = Null + 1;
84200738:	02 6e       	jump (m) Lc_aec_reference_timer_task_23;

8420073a <Lc_aec_reference_timer_task_22>:
8420073a:	07 00       	r5 = Null + Null;

8420073c <Lc_aec_reference_timer_task_23>:
         * 1- we have a rate monitor op for speaker, and/or
         * 2- speaker hasn't started consuming (to detect start of flow)
         */
        if(spkr_graph_active &&
           (op_extra_data->spkr_rate_monitor_op != NULL ||
            !op_extra_data->spkr_flow_started))
8420073c:	51 d8       	rMAC = M[FP + 40];
8420073e:	2f 60       	if EQ jump (m) Lc_aec_reference_timer_task_31;

84200740 <Lc_aec_reference_timer_task_24>:
84200740:	61 f0 73 88 	rMAC = M[r4 + 460];
84200744:	04 62       	if NE jump (m) Lc_aec_reference_timer_task_26;

84200746 <Lc_aec_reference_timer_task_25>:
84200746:	60 f0 d3 88 	Null = M[r4 + 844];
8420074a:	29 62       	if NE jump (m) Lc_aec_reference_timer_task_31;

8420074c <Lc_aec_reference_timer_task_26>:
             * since previous run and pass it to the rate monitor cbops op. The
             * op can use its transfer amount, however since speaker graph runs after mic
             * graph, the new amount will have bigger jitter which might affect
             * reference synchronisation.
             */
            tCbuffer *monbuf = op_extra_data->output_stream[AEC_REF_SPKR_TERMINAL1];
8420074c:	69 f0 11 88 	r7 = M[r4 + 68];
            unsigned new_offset = cbuffer_get_read_mmu_offset(monbuf);
84200750:	4a 08       	r0 = r7 + Null;
84200752:	ff fd 91 f0 	call (m) 0x12a28;
84200756:	37 e6 
84200758:	10 09       	r6 = r0 + Null;
            if(new_offset >= op_extra_data->spkr_last_offset)
8420075a:	61 f0 d1 88 	rMAC = M[r4 + 836];
8420075e:	1f f8 00 c2 	Null = r6 - rMAC;
84200762:	06 64       	if NC jump (m) Lc_aec_reference_timer_task_28;

84200764 <Lc_aec_reference_timer_task_27>:
            {
                op_extra_data->spkr_new_amount = new_offset - op_extra_data->spkr_last_offset;
84200764:	1f f8 01 c2 	rMAC = r6 - rMAC;
84200768:	61 f0 d2 8e 	M[r4 + 840] = rMAC;
8420076c:	0c 6e       	jump (m) Lc_aec_reference_timer_task_29;

8420076e <Lc_aec_reference_timer_task_28>:
            }
            else
            {
                op_extra_data->spkr_new_amount = new_offset + cbuffer_get_size_in_words(monbuf) - op_extra_data->spkr_last_offset;
8420076e:	4a 08       	r0 = r7 + Null;
84200770:	ff fd 90 f0 	call (m) 0x12858;
84200774:	29 e7 
84200776:	8f f2 01 c0 	rMAC = r0 + r6;
8420077a:	62 f0 d1 88 	r0 = M[r4 + 836];
8420077e:	89 04       	rMAC = rMAC - r0;
84200780:	61 f0 d2 8e 	M[r4 + 840] = rMAC;

84200784 <Lc_aec_reference_timer_task_29>:
            }
            op_extra_data->spkr_last_offset = new_offset;
84200784:	68 f0 d1 8e 	M[r4 + 836] = r6;

            /* Set a flag showing that speaker output has started consuming samples. */
            if(!op_extra_data->spkr_flow_started)
84200788:	60 f0 d3 88 	Null = M[r4 + 844];
8420078c:	08 62       	if NE jump (m) Lc_aec_reference_timer_task_31;

8420078e <Lc_aec_reference_timer_task_30>:
            {
                op_extra_data->spkr_flow_started = op_extra_data->spkr_new_amount != 0;
8420078e:	01 00       	rMAC = Null + Null;
84200790:	60 f0 d2 88 	Null = M[r4 + 840];
84200794:	21 f0 41 ce 	if NE rMAC = Null + 1;
84200798:	61 f0 d3 8e 	M[r4 + 844] = rMAC;

8420079c <Lc_aec_reference_timer_task_31>:
            }
        }
#endif /* AEC_REF_CALC_SPKR_RATE_MONITOR_AMOUNT */

        /*  - Run MIC cbops */
        if(mic_graph_active)
8420079c:	38 04       	Null = r5 - Null;
8420079e:	8a 60       	if EQ jump (m) Lc_aec_reference_timer_task_59;

842007a0 <Lc_aec_reference_timer_task_32>:
        {
            if(op_extra_data->spkr_ref_active
               || op_extra_data->mic_sync_enable)
842007a0:	60 f0 a0 88 	Null = M[r4 + 640];
842007a4:	04 62       	if NE jump (m) Lc_aec_reference_timer_task_34;

842007a6 <Lc_aec_reference_timer_task_33>:
842007a6:	60 f0 d4 88 	Null = M[r4 + 848];
842007aa:	04 60       	if EQ jump (m) Lc_aec_reference_timer_task_35;

842007ac <Lc_aec_reference_timer_task_34>:
            {
                /* keep REFERENCE path and MIC output synchronised */
                aec_reference_update_mic_reference_sync(op_extra_data);
842007ac:	32 00       	r0 = r4 + Null;
842007ae:	0e f0 31 e5 	call (m) $_aec_reference_update_mic_reference_sync;

842007b2 <Lc_aec_reference_timer_task_35>:
            }

            if(!op_extra_data->mic_graph_no_output)
842007b2:	60 f0 dd 88 	Null = M[r4 + 884];
842007b6:	77 62       	if NE jump (m) Lc_aec_reference_timer_task_58;

842007b8 <Lc_aec_reference_timer_task_36>:
            {
                /* Mic graph with output */
                unsigned b4_space = 0;
                unsigned after_space;
                unsigned amount_produced;
                tCbuffer *mic_buf = op_extra_data->output_stream[AEC_REF_OUTPUT_TERMINAL1];
842007b8:	68 f0 13 88 	r6 = M[r4 + 76];
                b4_space = cbuffer_calc_amount_space_in_words(mic_buf);
842007bc:	42 08       	r0 = r6 + Null;
842007be:	ff fd 5c f1 	call (m) 0x2c1b6;
842007c2:	39 ef 
842007c4:	17 00       	r5 = r0 + Null;
                cbops_process_data(op_extra_data->mic_graph, CBOPS_MAX_COPY_SIZE-1);
842007c6:	03 f0 ff 41 	r1 = Null + 511;
842007ca:	62 f0 6a 88 	r0 = M[r4 + 424];
842007ce:	ff fd d8 f2 	call 0x5b9a4;
842007d2:	36 ee 
                after_space = cbuffer_calc_amount_space_in_words(mic_buf);
842007d4:	42 08       	r0 = r6 + Null;
842007d6:	ff fd 5c f1 	call (m) 0x2c1b6;
842007da:	21 ef 

                /* Don't tolerate cbops writing more than available space */
                PL_ASSERT(b4_space >= after_space);
842007dc:	b8 04       	Null = r5 - r0;
842007de:	02 f0 95 e0 	if C jump (m) Lc_aec_reference_timer_task_38;

842007e2 <Lc_aec_reference_timer_task_37>:
842007e2:	03 f0 48 60 	r1 = Null + 4168;
842007e6:	02 f0 13 60 	r0 = Null + 4115;
842007ea:	ff fd 9b f0 	call (m) 0x13f12;
842007ee:	29 e9 
842007f0:	f4 6e       	jump (m) Lc_aec_reference_timer_task_83;

842007f2 <Lc_aec_reference_timer_task_38>:
                amount_produced = b4_space - after_space;
842007f2:	2f f7 0a c2 	r8 = r5 - r0;

#ifdef AEC_REFERENCE_GENERATE_MIC_TIMESTAMP
                if(op_extra_data->mic_metadata_buffer!= NULL
                   && buff_has_metadata(op_extra_data->mic_metadata_buffer))
842007f6:	61 f0 ca 88 	rMAC = M[r4 + 808];
842007fa:	08 60       	if EQ jump (m) Lc_aec_reference_timer_task_41;

842007fc <Lc_aec_reference_timer_task_39>:
842007fc:	49 89       	rMAC = M[rMAC + 20];
842007fe:	49 c6       	rMAC = rMAC AND 0x8000;
84200800:	05 60       	if EQ jump (m) Lc_aec_reference_timer_task_41;

84200802 <Lc_aec_reference_timer_task_40>:
                {
                    aec_reference_mic_generate_metadata_with_ttp(op_extra_data, b4_space - after_space);
84200802:	53 08       	r1 = r8 + Null;
84200804:	32 00       	r0 = r4 + Null;
84200806:	05 f0 21 e6 	call (m) $_aec_reference_mic_generate_metadata_with_ttp;

8420080a <Lc_aec_reference_timer_task_41>:
                   !op_extra_data->spkr_flow_started
#else
                   /* insert silence until speaker graph hasn't started */
                   !op_extra_data->spkr_ref_active
#endif
                   )
8420080a:	31 a8       	rMAC = M[r4 + 64];
8420080c:	53 60       	if EQ jump (m) Lc_aec_reference_timer_task_59;

8420080e <Lc_aec_reference_timer_task_42>:
8420080e:	60 f0 d3 88 	Null = M[r4 + 844];
84200812:	50 62       	if NE jump (m) Lc_aec_reference_timer_task_59;

84200814 <Lc_aec_reference_timer_task_43>:
                     * Note: The synchronisation is normally done by the speaker latency operator
                     * however we don't have a running speaker graph at this situation, so is done
                     * manually here.
                     */

                    unsigned mic_out_data = cbuffer_calc_amount_data_in_words(mic_buf);
84200814:	42 08       	r0 = r6 + Null;
84200816:	ff fd 5c f1 	call (m) 0x2c208;
8420081a:	33 ef 
8420081c:	17 00       	r5 = r0 + Null;
                    /* if we have more than one mic, get max amount amnong all */
                    unsigned idx;
                    for(idx = 1; idx < op_extra_data->num_mic_channels; ++idx)
8420081e:	08 71       	r6 = Null + 1;
84200820:	0f 6e       	jump (m) Lc_aec_reference_timer_task_49;

84200822 <Lc_aec_reference_timer_task_44>:
                    {
                        tCbuffer *out_buf = op_extra_data->output_stream[MicrophoneOutputTerminalByIndex(idx)];
84200822:	82 f0 09 20 	r0 = r6 + 9;

84200826 <Lc_aec_reference_timer_task_45>:
84200826:	61 f0 40 20 	rMAC = r4 + 64;
8420082a:	52 54       	r0 = r0 LSHIFT 2;
                        if(NULL != out_buf)
8420082c:	8a e8       	r0 = M[rMAC + r0];
8420082e:	07 60       	if EQ jump (m) Lc_aec_reference_timer_task_48;

84200830 <Lc_aec_reference_timer_task_46>:
                        {
                            unsigned out_data = cbuffer_calc_amount_data_in_words(out_buf);
84200830:	ff fd 5c f1 	call (m) 0x2c208;
84200834:	39 ee 
                            mic_out_data = MAX(out_data, mic_out_data);
84200836:	d0 05       	Null = r0 - r5;
84200838:	02 64       	if NC jump (m) Lc_aec_reference_timer_task_48;

8420083a <Lc_aec_reference_timer_task_47>:
8420083a:	17 00       	r5 = r0 + Null;

8420083c <Lc_aec_reference_timer_task_48>:
                     */

                    unsigned mic_out_data = cbuffer_calc_amount_data_in_words(mic_buf);
                    /* if we have more than one mic, get max amount amnong all */
                    unsigned idx;
                    for(idx = 1; idx < op_extra_data->num_mic_channels; ++idx)
8420083c:	08 75       	r6 = r6 + 1;

8420083e <Lc_aec_reference_timer_task_49>:
8420083e:	61 f0 78 88 	rMAC = M[r4 + 480];
84200842:	1f f8 00 c2 	Null = r6 - rMAC;
84200846:	02 f0 91 e0 	if C jump (m) Lc_aec_reference_timer_task_52;

8420084a <Lc_aec_reference_timer_task_50>:
                    {
                        tCbuffer *out_buf = op_extra_data->output_stream[MicrophoneOutputTerminalByIndex(idx)];
8420084a:	80 f0 02 24 	Null = r6 - 2;
8420084e:	f2 ff d5 ef 	if C jump (m) Lc_aec_reference_timer_task_44;

84200852 <Lc_aec_reference_timer_task_51>:
84200852:	02 21       	r0 = Null + 4;
84200854:	e9 6f       	jump (m) Lc_aec_reference_timer_task_45;

84200856 <Lc_aec_reference_timer_task_52>:
                        {
                            unsigned out_data = cbuffer_calc_amount_data_in_words(out_buf);
                            mic_out_data = MAX(out_data, mic_out_data);
                        }
                    }
                    tCbuffer *ref_buf = op_extra_data->output_stream[AEC_REF_REFERENCE_TERMINAL];
84200856:	68 f0 10 88 	r6 = M[r4 + 64];
                    unsigned ref_data = cbuffer_calc_amount_data_in_words(ref_buf);
8420085a:	42 08       	r0 = r6 + Null;
8420085c:	ff fd 5c f1 	call (m) 0x2c208;
84200860:	2d ed 
84200862:	11 09       	r7 = r0 + Null;
                    unsigned ideal_amount = mic_out_data +
                        op_extra_data->sync_block.ref_delay +
                        (op_extra_data->sync_block.jitter/2);
84200864:	62 f0 85 88 	r0 = M[r4 + 532];
84200868:	61 f0 8a 88 	rMAC = M[r4 + 552];
8420086c:	12 50       	r0 = r0 LSHIFT -1;
8420086e:	51 00       	rMAC = r0 + rMAC;
84200870:	cf 01       	r5 = rMAC + r5;
                    /* We only insert, dropping is done via waiting for mic buffer to fill up */
                    unsigned amount_to_insert = 0;
                    if(ideal_amount > ref_data)
84200872:	9f f7 00 c2 	Null = r5 - r7;
84200876:	09 f0 bd e0 	if LS jump (m) Lc_aec_reference_timer_task_59;

8420087a <Lc_aec_reference_timer_task_53>:
                    {
                        unsigned ref_space = cbuffer_calc_amount_space_in_words(ref_buf);
8420087a:	42 08       	r0 = r6 + Null;
8420087c:	ff fd 5c f1 	call (m) 0x2c1b6;
84200880:	3b e9 
                        amount_to_insert = ideal_amount - ref_data;
84200882:	9f f7 03 c2 	r1 = r5 - r7;
                         * Note: limit to amount_produced*3/2, since we own only the write
                         * side of the buffer, although the read sides are syncronised by
                         * consumer but there is a chance the this operator preempt the consumer
                         * right at the middle of read pointer update. For that reason we apply this limit
                         */
                        amount_to_insert = MIN(amount_to_insert, amount_produced*3/2);
84200886:	01 fa 94 d9 	r2 = r8 * 3 (int);
8420088a:	24 50       	r2 = r2 LSHIFT -1;
8420088c:	18 05       	Null = r1 - r2;
8420088e:	02 64       	if NC jump (m) Lc_aec_reference_timer_task_55;

84200890 <Lc_aec_reference_timer_task_54>:
84200890:	23 00       	r1 = r2 + Null;

84200892 <Lc_aec_reference_timer_task_55>:
                        amount_to_insert = MIN(amount_to_insert, ref_space);
84200892:	98 04       	Null = r1 - r0;
84200894:	02 64       	if NC jump (m) Lc_aec_reference_timer_task_57;

84200896 <Lc_aec_reference_timer_task_56>:
84200896:	13 00       	r1 = r0 + Null;

84200898 <Lc_aec_reference_timer_task_57>:

                        /* insert silence */
                        cbuffer_block_fill(ref_buf, amount_to_insert, 0);
84200898:	04 00       	r2 = Null + Null;
8420089a:	42 08       	r0 = r6 + Null;
8420089c:	ff fd 5d f1 	call (m) 0x2c2e8;
842008a0:	2d e2 
842008a2:	08 6e       	jump (m) Lc_aec_reference_timer_task_59;

842008a4 <Lc_aec_reference_timer_task_58>:
                }
            }
            else /* if(!op_extra_data->mic_graph_no_output) */
            {
                /* run cbops process for mic graph without output */
                cbops_process_data(op_extra_data->mic_graph, CBOPS_MAX_COPY_SIZE-1);
842008a4:	03 f0 ff 41 	r1 = Null + 511;
842008a8:	62 f0 6a 88 	r0 = M[r4 + 424];
842008ac:	ff fd d8 f2 	call 0x5b9a4;
842008b0:	38 e7 

842008b2 <Lc_aec_reference_timer_task_59>:
#endif
        }
#endif /* INSTALL_AEC_REFERENCE_HOWL_LIMITER */

        /*  - Run SPKR cbops */
        if(spkr_graph_active)
842008b2:	51 d8       	rMAC = M[FP + 40];
842008b4:	57 60       	if EQ jump (m) Lc_aec_reference_timer_task_73;

842008b6 <Lc_aec_reference_timer_task_60>:
        {
#ifdef AEC_REFERENCE_SUPPORT_METADATA
            unsigned max_to_process = CBOPS_MAX_COPY_SIZE-1;
842008b6:	01 f0 ff 41 	rMAC = Null + 511;
842008ba:	59 de       	M[FP + 44] = rMAC;
            tCbuffer *met_buf = op_extra_data->spkr_input_metadata_buffer;
            unsigned before_amount = 0;
842008bc:	00 09       	r6 = Null + Null;
            if(met_buf!= NULL && buff_has_metadata(met_buf))
842008be:	67 f0 c9 88 	r5 = M[r4 + 804];
842008c2:	19 60       	if EQ jump (m) Lc_aec_reference_timer_task_65;

842008c4 <Lc_aec_reference_timer_task_61>:
842008c4:	79 89       	rMAC = M[r5 + 20];
842008c6:	49 c6       	rMAC = rMAC AND 0x8000;
842008c8:	1f 60       	if EQ jump (m) Lc_aec_reference_timer_task_66;

842008ca <Lc_aec_reference_timer_task_62>:
            {
                /* amount of metadata available */
                unsigned meta_data_available = buff_metadata_available_octets(met_buf)/OCTETS_PER_SAMPLE;
842008ca:	3a 00       	r0 = r5 + Null;
842008cc:	ff fd 8a f0 	call (m) 0x11d04;
842008d0:	39 e1 
842008d2:	7f f2 d9 c8 	r7 = r0 LSHIFT -2;

                /* get amount in the buffer before running cbops */
                before_amount = cbuffer_calc_amount_data_in_words(met_buf);
842008d6:	3a 00       	r0 = r5 + Null;
842008d8:	ff fd 5c f1 	call (m) 0x2c208;
842008dc:	31 e9 
842008de:	10 09       	r6 = r0 + Null;

                /* if we have metadata enabled then limit the amount to
                 * process to the amount of available metadata
                 */
                max_to_process = MIN(max_to_process, meta_data_available);
842008e0:	59 d8       	rMAC = M[FP + 44];
842008e2:	9f f1 00 c2 	Null = rMAC - r7;
842008e6:	03 64       	if NC jump (m) Lc_aec_reference_timer_task_64;

842008e8 <Lc_aec_reference_timer_task_63>:
842008e8:	e9 f0 0b 8e 	M[FP + 44] = r7;

842008ec <Lc_aec_reference_timer_task_64>:
#ifdef AEC_REFERENCE_SPKR_TTP
                /* Run TTP error control for speaker graph */
                aec_reference_spkr_ttp_run(op_extra_data, &max_to_process);
842008ec:	c3 12       	r1 = FP + 44;
842008ee:	32 00       	r0 = r4 + Null;
842008f0:	10 f0 27 ea 	call (m) $_aec_reference_spkr_ttp_run;

842008f4 <Lc_aec_reference_timer_task_65>:
#endif
            }

            /* run cbops process */
            cbops_process_data(op_extra_data->spkr_graph, max_to_process);
842008f4:	5b d8       	r1 = M[FP + 44];
842008f6:	62 f0 72 88 	r0 = M[r4 + 456];
842008fa:	ff fd d8 f2 	call 0x5b9a4;
842008fe:	2a e5 

            if(met_buf!= NULL && buff_has_metadata(met_buf))
84200900:	38 04       	Null = r5 - Null;
84200902:	09 62       	if NE jump (m) Lc_aec_reference_timer_task_67;

84200904 <Lc_17>:
84200904:	27 6e       	jump (m) Lc_aec_reference_timer_task_71;

84200906 <Lc_aec_reference_timer_task_66>:
                aec_reference_spkr_ttp_run(op_extra_data, &max_to_process);
#endif
            }

            /* run cbops process */
            cbops_process_data(op_extra_data->spkr_graph, max_to_process);
84200906:	03 f0 ff 41 	r1 = Null + 511;
8420090a:	62 f0 72 88 	r0 = M[r4 + 456];
8420090e:	ff fd d8 f2 	call 0x5b9a4;
84200912:	36 e4 

84200914 <Lc_aec_reference_timer_task_67>:
84200914:	79 89       	rMAC = M[r5 + 20];
84200916:	49 c6       	rMAC = rMAC AND 0x8000;
84200918:	1d 60       	if EQ jump (m) Lc_aec_reference_timer_task_71;

8420091a <Lc_aec_reference_timer_task_68>:
                 * The assumption is that the write pointer of
                 * input buffer isn't changed during cbops
                 * process.
                 */
                unsigned amount_processed;
                unsigned after_amount = cbuffer_calc_amount_data_in_words(met_buf);
8420091a:	3a 00       	r0 = r5 + Null;
8420091c:	ff fd 5c f1 	call (m) 0x2c208;
84200920:	2d e7 
#ifdef TODO_AEC_REFERENCE_TTP
                /* for the moment don't tolerate cbops doing anything wrong */
                PL_ASSERT(after_amount <= before_amount);
84200922:	8f f2 00 c2 	Null = r0 - r6;
84200926:	08 f0 a5 e1 	if HI jump (m) Lc_aec_reference_timer_task_82;

8420092a <Lc_aec_reference_timer_task_69>:
                amount_processed = before_amount - after_amount;
8420092a:	00 f2 38 c2 	r6 = r6 - r0;
                     */
                    unsigned buff_size = cbuffer_get_size_in_words(met_buf);
                    amount_processed = buff_size + before_amount - after_amount;
                }
#endif /* TODO_AEC_REFERENCE_TTP */
                if(amount_processed > 0)
8420092e:	0f f8 00 c2 	Null = r6 - Null;
84200932:	10 60       	if EQ jump (m) Lc_aec_reference_timer_task_71;

84200934 <Lc_aec_reference_timer_task_70>:
                {
                    /* delete metadata tags for consumed input */
                    unsigned b4idx, afteridx;
                    buff_metadata_tag_list_delete(
                        buff_metadata_remove(met_buf, OCTETS_PER_SAMPLE * amount_processed, &b4idx, &afteridx));
84200934:	45 13       	r3 = FP + 52;
84200936:	04 13       	r2 = FP + 48;
84200938:	01 f8 d3 c8 	r1 = r6 LSHIFT 2;
8420093c:	3a 00       	r0 = r5 + Null;
8420093e:	ff fd 8a f0 	call (m) 0x11d7a;
84200942:	3d e1 
84200944:	ff fd 87 f0 	call (m) 0x11906;
84200948:	23 ee 
                    /* update timestamp */
                    aec_reference_spkr_ttp_update_last_timestamp(op_extra_data, amount_processed);
8420094a:	43 08       	r1 = r6 + Null;
8420094c:	32 00       	r0 = r4 + Null;
8420094e:	11 f0 29 e0 	call (m) $_aec_reference_spkr_ttp_update_last_timestamp;

84200952 <Lc_aec_reference_timer_task_71>:
            }
#else /* AEC_REFERENCE_SUPPORT_METADATA */
            cbops_process_data(op_extra_data->spkr_graph, CBOPS_MAX_COPY_SIZE-1);
#endif /* AEC_REFERENCE_SUPPORT_METADATA*/
#ifdef PROFILER_ON
            if (op_data->profiler != NULL)
84200952:	b1 f0 08 88 	rMAC = M[r9 + 32];
84200956:	06 60       	if EQ jump (m) Lc_aec_reference_timer_task_73;

84200958 <Lc_aec_reference_timer_task_72>:
            {
                op_data->profiler->kick_inc++;
84200958:	12 f0 2a 88 	r0 = M[rMAC + 168];
8420095c:	52 20       	r0 = r0 + 1;
8420095e:	12 f0 2a 8e 	M[rMAC + 168] = r0;

84200962 <Lc_aec_reference_timer_task_73>:
            }
#endif
        }

        /* Check for Kicks (outputs).   Use Output 1 available data*/
        if(op_extra_data->sync_block.block_sync)
84200962:	60 f0 87 88 	Null = M[r4 + 540];
84200966:	06 60       	if EQ jump (m) Lc_aec_reference_timer_task_75;

84200968 <Lc_aec_reference_timer_task_74>:
        {
            source_kicks = op_extra_data->source_kicks;
84200968:	61 f0 7b 88 	rMAC = M[r4 + 492];
8420096c:	49 de       	M[FP + 36] = rMAC;
            op_extra_data->sync_block.block_sync = 0;
8420096e:	60 f0 87 8e 	M[r4 + 540] = Null;

84200972 <Lc_aec_reference_timer_task_75>:
        }

        /* Check for Kick (inputs).   Use Input 1 available space */
        if(op_extra_data->input_stream[AEC_REF_INPUT_TERMINAL1])
84200972:	32 e8       	r0 = M[r4 + Null];
84200974:	0d 60       	if EQ jump (m) Lc_aec_reference_timer_task_78;

84200976 <Lc_aec_reference_timer_task_76>:
        {
            int available_space = cbuffer_calc_amount_space_in_words(op_extra_data->input_stream[AEC_REF_INPUT_TERMINAL1]);
84200976:	ff fd 5c f1 	call (m) 0x2c1b6;
8420097a:	21 e2 

            if(available_space >= op_extra_data->spkr_kick_size)
8420097c:	61 f0 75 88 	rMAC = M[r4 + 468];
84200980:	50 04       	Null = r0 - rMAC;
84200982:	06 64       	if NC jump (m) Lc_aec_reference_timer_task_78;

84200984 <Lc_aec_reference_timer_task_77>:
            {
                sink_kicks = op_extra_data->sink_kicks;
84200984:	61 f0 7c 88 	rMAC = M[r4 + 496];
84200988:	41 de       	M[FP + 32] = rMAC;
            }
        }


        if(sink_kicks || source_kicks)
8420098a:	08 04       	Null = rMAC - Null;
8420098c:	03 62       	if NE jump (m) Lc_aec_reference_timer_task_79;

8420098e <Lc_aec_reference_timer_task_78>:
8420098e:	49 d8       	rMAC = M[FP + 36];
84200990:	07 60       	if EQ jump (m) Lc_aec_reference_timer_task_80;

84200992 <Lc_aec_reference_timer_task_79>:
        {
            opmgr_kick_from_operator(op_data,source_kicks,sink_kicks);
84200992:	5a 08       	r0 = r9 + Null;
84200994:	44 d8       	r2 = M[FP + 32];
84200996:	4b d8       	r1 = M[FP + 36];
84200998:	ff fd 11 f0 	call (m) 0x2d10;
8420099c:	39 eb 

8420099e <Lc_aec_reference_timer_task_80>:
        }
    }

/* Next Timer Event */
    next_fire_time = time_add(get_last_fire_time(), op_extra_data->kick_period);
8420099e:	ff fd 9c f0 	call (m) 0x14334;
842009a2:	37 ec 
842009a4:	61 f0 94 88 	rMAC = M[r4 + 592];
842009a8:	8a 00       	r0 = rMAC + r0;
    op_extra_data->kick_id = timer_schedule_event_at(next_fire_time,
                                                     aec_reference_timer_task, (void*)op_data);
842009aa:	42 f0 03 f0 	r1 = Null + 69207687;
842009ae:	87 4a 
INLINE_SECTION static inline tTimerId timer_schedule_event_at(
       TIME event_time,
       tTimerEventFunction TimerEventFunction,
       void *data_pointer)
{
    return create_add_strict_event(event_time, TimerEventFunction, data_pointer);
842009b0:	5c 08       	r2 = r9 + Null;
842009b2:	ff fd 9b f0 	call (m) 0x1402a;
842009b6:	39 e3 
}
842009b8:	62 f0 5d 8e 	M[r4 + 372] = r0;
#ifdef PROFILER_ON
    if (op_data->profiler != NULL)
842009bc:	b2 f0 08 88 	r0 = M[r9 + 32];
842009c0:	0c 60       	if EQ jump (m) Lc_aec_reference_timer_task_83;

842009c2 <Lc_aec_reference_timer_task_81>:
    {
        PROFILER_STOP(op_data->profiler);
842009c2:	ff fd 63 f1 	call (m) 0x2d0d0;
842009c6:	2f e8 
842009c8:	08 6e       	jump (m) Lc_aec_reference_timer_task_83;

842009ca <Lc_aec_reference_timer_task_82>:
                 */
                unsigned amount_processed;
                unsigned after_amount = cbuffer_calc_amount_data_in_words(met_buf);
#ifdef TODO_AEC_REFERENCE_TTP
                /* for the moment don't tolerate cbops doing anything wrong */
                PL_ASSERT(after_amount <= before_amount);
842009ca:	03 f0 d1 60 	r1 = Null + 4305;
842009ce:	02 f0 13 60 	r0 = Null + 4115;
842009d2:	ff fd 9a f0 	call (m) 0x13f12;
842009d6:	21 ea 

842009d8 <Lc_aec_reference_timer_task_83>:
    if (op_data->profiler != NULL)
    {
        PROFILER_STOP(op_data->profiler);
    }
#endif
}
842009d8:	f6 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
842009da:	d8 4c       	rts;

842009dc <$_aec_reference_opmsg_obpm_get_status>:
unsigned ref_last_inserts_insert=0;
unsigned ref_last_inserts_wrap=0;
#endif

bool aec_reference_opmsg_obpm_get_status(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842009dc:	f4 1e       	pushm <FP(=SP), r4, r5, r6, r7, rLink>, SP = SP + 0x20;
842009de:	19 00       	rMAC = r1 + Null;
842009e0:	23 00       	r1 = r2 + Null;
842009e2:	2c 00       	r2 = r3 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
842009e4:	28 f0 0c 88 	r6 = M[r0 + 48];
#if defined(IO_DEBUG)
    unsigned num_inserts_total  = 0;
    unsigned num_inserts_insert = 0;
    unsigned num_inserts_wrap   = 0;

    unsigned last_acc_mic = 0;
842009e8:	38 de       	M[FP + 28] = Null;
    unsigned last_acc_spkr = 0;
842009ea:	40 de       	M[FP + 32] = Null;
#endif

    patch_fn_shared(aec_reference);

    if(!common_obpm_status_helper(message_data,resp_length,resp_data,sizeof(AEC_REFERENCE_STATISTICS) ,&resp))
842009ec:	82 11       	r0 = FP + 24;
842009ee:	11 1c       	pushm <r0>;
842009f0:	05 f0 54 40 	r3 = Null + 84;
842009f4:	0a 00       	r0 = rMAC + Null;
842009f6:	ef fd ff ff 	call (m) 0x868;
842009fa:	33 e3 
842009fc:	7f 4c       	SP = SP + -4;
842009fe:	10 04       	Null = r0 - Null;
84200a00:	03 62       	if NE jump (m) Lc_aec_reference_opmsg_obpm_get_status_3;

84200a02 <Lc_aec_reference_opmsg_obpm_get_status_2>:
    {
        return FALSE;
84200a02:	02 00       	r0 = Null + Null;
84200a04:	be 6e       	jump (m) Lc_aec_reference_opmsg_obpm_get_status_15;

84200a06 <Lc_aec_reference_opmsg_obpm_get_status_3>:
    }

    if(resp)
84200a06:	34 d8       	r2 = M[FP + 24];
84200a08:	bb 60       	if EQ jump (m) Lc_aec_reference_opmsg_obpm_get_status_14;

84200a0a <Lc_aec_reference_opmsg_obpm_get_status_4>:
    {
        unsigned config_flag = 0;
84200a0a:	48 de       	M[FP + 36] = Null;
        unsigned volume=op_extra_data->shared_volume_ptr->current_volume_level;
84200a0c:	81 f0 58 88 	rMAC = M[r6 + 352];
84200a10:	89 88       	rMAC = M[rMAC + 8];
84200a12:	51 de       	M[FP + 40] = rMAC;

        if(op_extra_data->using_sidetone==USE_SIDETONE_FLAG)
84200a14:	81 f0 7a 88 	rMAC = M[r6 + 488];
84200a18:	c8 24       	Null = rMAC - 3;
84200a1a:	04 62       	if NE jump (m) Lc_aec_reference_opmsg_obpm_get_status_6;

84200a1c <Lc_aec_reference_opmsg_obpm_get_status_5>:
        {
            config_flag = flag_uses_SIDETONE;
84200a1c:	41 f0 00 40 	rMAC = Null + 32768;
84200a20:	49 de       	M[FP + 36] = rMAC;

84200a22 <Lc_aec_reference_opmsg_obpm_get_status_6>:
        }
        if(op_extra_data->channel_status&AEC_REFERENCE_CONSTANT_CONN_TYPE_REF)
84200a22:	81 f0 76 88 	rMAC = M[r6 + 472];
84200a26:	11 f2 00 00 	rMAC = rMAC AND 0x4000;
84200a2a:	05 60       	if EQ jump (m) Lc_aec_reference_opmsg_obpm_get_status_8;

84200a2c <Lc_aec_reference_opmsg_obpm_get_status_7>:
        {
            config_flag += flag_uses_AEC_REFERENCE;
84200a2c:	49 d8       	rMAC = M[FP + 36];
84200a2e:	81 f0 00 44 	rMAC = rMAC + 65536;
84200a32:	49 de       	M[FP + 36] = rMAC;

84200a34 <Lc_aec_reference_opmsg_obpm_get_status_8>:
        }

        resp = cpsPackWords(&op_extra_data->Cur_mode,&op_extra_data->Ovr_Control, resp);
84200a34:	83 f0 6c 21 	r1 = r6 + 364;
84200a38:	82 f0 68 21 	r0 = r6 + 360;
84200a3c:	ff fd 5b f1 	call (m) 0x2c056;
84200a40:	3b e0 
84200a42:	32 de       	M[FP + 24] = r0;
        resp = cpsPackWords(&config_flag, &volume, resp);
84200a44:	34 d8       	r2 = M[FP + 24];
84200a46:	83 12       	r1 = FP + 40;
84200a48:	42 12       	r0 = FP + 36;
84200a4a:	ff fd 5b f1 	call (m) 0x2c056;
84200a4e:	2d e0 
84200a50:	32 de       	M[FP + 24] = r0;
        resp = cpsPackWords(&op_extra_data->channel_status, &op_extra_data->mic_rate, resp);
84200a52:	34 d8       	r2 = M[FP + 24];
84200a54:	83 f0 98 21 	r1 = r6 + 408;
84200a58:	82 f0 d8 21 	r0 = r6 + 472;
84200a5c:	ff fd 5a f1 	call (m) 0x2c056;
84200a60:	3b ef 
84200a62:	32 de       	M[FP + 24] = r0;
        resp = cpsPackWords(&op_extra_data->output_rate, &op_extra_data->input_rate, resp);
84200a64:	34 d8       	r2 = M[FP + 24];
84200a66:	83 f0 90 21 	r1 = r6 + 400;
84200a6a:	82 f0 94 21 	r0 = r6 + 404;
84200a6e:	ff fd 5a f1 	call (m) 0x2c056;
84200a72:	29 ef 
84200a74:	32 de       	M[FP + 24] = r0;
        resp = cpsPackWords(&op_extra_data->spkr_rate,NULL, resp);
84200a76:	34 d8       	r2 = M[FP + 24];
84200a78:	82 f0 b8 21 	r0 = r6 + 440;
84200a7c:	03 00       	r1 = Null + Null;
84200a7e:	ff fd 5a f1 	call (m) 0x2c056;
84200a82:	39 ee 
84200a84:	32 de       	M[FP + 24] = r0;

        /* Rate Matching statistics */
        /* TODO: Make these on demand instead of always ON */

#if defined(IO_DEBUG)
        if(st_disgard_op)
84200a86:	e0 f0 02 f0 	r0 = M[Null + $_st_disgard_op];
84200a8a:	5d 88 
84200a8c:	07 60       	if EQ jump (m) Lc_aec_reference_opmsg_obpm_get_status_10;

84200a8e <Lc_aec_reference_opmsg_obpm_get_status_9>:
        {
            ref_st_drop = get_sink_overflow_disgard_drops(st_disgard_op);
84200a8e:	ff fd 58 f3 	call 0x6bc74;
84200a92:	26 ef 
84200a94:	e0 f0 02 f0 	M[Null + $_ref_st_drop] = r0;
84200a98:	60 8e 

84200a9a <Lc_aec_reference_opmsg_obpm_get_status_10>:
        }

        ref_spkr_refdrop = op_extra_data->sync_block.speaker_drops + op_extra_data->sync_block.speaker_inserts;
84200a9a:	81 f0 8e 88 	rMAC = M[r6 + 568];
84200a9e:	82 f0 8d 88 	r0 = M[r6 + 564];
84200aa2:	07 f0 01 f0 	M[$_ref_spkr_refdrop] = rMAC + r0;
84200aa6:	78 f2 91 c1 
        ref_micref_delay = op_extra_data->sync_block.speaker_delay;
84200aaa:	81 f0 8f 88 	rMAC = M[r6 + 572];
84200aae:	e0 f0 01 f0 	M[Null + $_ref_micref_delay] = rMAC;
84200ab2:	5f 8e 

        if(insert_op)
84200ab4:	07 f0 07 f0 	r5 = Null + 7340400;
84200ab8:	70 41 
84200aba:	3a e8       	r0 = M[r5 + Null];
84200abc:	1e 60       	if EQ jump (m) Lc_aec_reference_opmsg_obpm_get_status_13;

84200abe <Lc_aec_reference_opmsg_obpm_get_status_11>:
        {
            num_inserts_total  = get_aec_ref_cbops_inserts_total(insert_op);
84200abe:	14 f0 3d e9 	call (m) $_get_aec_ref_cbops_inserts_total;
84200ac2:	16 00       	r4 = r0 + Null;
            num_inserts_insert = get_aec_ref_cbops_insert_op_insert_total(insert_op);
84200ac4:	3a e8       	r0 = M[r5 + Null];
84200ac6:	14 f0 3f e9 	call (m) $_get_aec_ref_cbops_insert_op_insert_total;
84200aca:	11 09       	r7 = r0 + Null;
            num_inserts_wrap   = get_aec_ref_cbops_wrap_op_insert_total(insert_op);
84200acc:	3a e8       	r0 = M[r5 + Null];
84200ace:	14 f0 3d e9 	call (m) $_get_aec_ref_cbops_wrap_op_insert_total;

            if(num_inserts_total!=ref_last_inserts_total)
84200ad2:	07 f0 01 f0 	rMAC = Null + 7340424;
84200ad6:	88 41 
84200ad8:	1f f6 80 c2 	Null = r4 - M[rMAC];
84200adc:	0e 60       	if EQ jump (m) Lc_aec_reference_opmsg_obpm_get_status_13;

84200ade <Lc_aec_reference_opmsg_obpm_get_status_12>:
            {
                ref_last_inserts_total=num_inserts_total;
84200ade:	0e ee       	M[rMAC + Null] = r4;
                ref_last_inserts_insert=num_inserts_insert;
84200ae0:	e0 f0 09 f0 	M[Null + $_ref_last_inserts_insert] = r7;
84200ae4:	63 8e 
                ref_last_inserts_wrap=num_inserts_wrap;
84200ae6:	e0 f0 02 f0 	M[Null + $_ref_last_inserts_wrap] = r0;
84200aea:	64 8e 
                ref_inserts++;
84200aec:	07 f0 01 f0 	rMAC = Null + 7340420;
84200af0:	84 41 
84200af2:	00 f1 12 d1 	r0 = M[rMAC] + 1;
84200af6:	0a ee       	M[rMAC + Null] = r0;

84200af8 <Lc_aec_reference_opmsg_obpm_get_status_13>:
            }
        }

        /* get last acc for mic and speaker,
         * Note: it's fine if rate_monitor_op not existing, it will return 0 */
        last_acc_mic = get_rate_monitor_last_acc(op_extra_data->mic_rate_monitor_op);
84200af8:	82 f0 6b 88 	r0 = M[r6 + 428];
84200afc:	ff fd 58 f3 	call 0x6bc3c;
84200b00:	20 ea 
84200b02:	3a de       	M[FP + 28] = r0;
        last_acc_spkr = get_rate_monitor_last_acc(op_extra_data->spkr_rate_monitor_op);
84200b04:	82 f0 73 88 	r0 = M[r6 + 460];
84200b08:	ff fd 58 f3 	call 0x6bc3c;
84200b0c:	34 e9 
84200b0e:	42 de       	M[FP + 32] = r0;

        resp = cpsPackWords(&op_extra_data->mic_rate_enactment,&op_extra_data->spkr_rate_enactment, resp);
84200b10:	34 d8       	r2 = M[FP + 24];
84200b12:	83 f0 c4 21 	r1 = r6 + 452;
84200b16:	82 f0 a0 21 	r0 = r6 + 416;
84200b1a:	ff fd 5a f1 	call (m) 0x2c056;
84200b1e:	3d e9 
84200b20:	32 de       	M[FP + 24] = r0;
        resp = cpsPackWords((unsigned*)&last_acc_mic,(unsigned*)&last_acc_spkr, resp);
84200b22:	34 d8       	r2 = M[FP + 24];
84200b24:	03 12       	r1 = FP + 32;
84200b26:	c2 11       	r0 = FP + 28;
84200b28:	ff fd 5a f1 	call (m) 0x2c056;
84200b2c:	2f e9 
84200b2e:	32 de       	M[FP + 24] = r0;
        resp = cpsPackWords(&op_extra_data->mic_rate_adjustment,&op_extra_data->spkr_rate_adjustment, resp);
84200b30:	34 d8       	r2 = M[FP + 24];
84200b32:	83 f0 c0 21 	r1 = r6 + 448;
84200b36:	82 f0 a4 21 	r0 = r6 + 420;
84200b3a:	ff fd 5a f1 	call (m) 0x2c056;
84200b3e:	3d e8 
84200b40:	32 de       	M[FP + 24] = r0;
        resp = cpsPackWords(&op_extra_data->sync_block.rm_adjustment,(unsigned*)&ref_last_inserts_total, resp);
84200b42:	34 d8       	r2 = M[FP + 24];
84200b44:	07 f0 03 f0 	r1 = Null + 7340424;
84200b48:	88 41 
84200b4a:	82 f0 30 22 	r0 = r6 + 560;
84200b4e:	ff fd 5a f1 	call (m) 0x2c056;
84200b52:	29 e8 
84200b54:	32 de       	M[FP + 24] = r0;
        resp = cpsPackWords((unsigned*)&ref_spkr_refdrop,(unsigned*)&ref_st_drop, resp);
84200b56:	34 d8       	r2 = M[FP + 24];
84200b58:	07 f0 03 f0 	r1 = Null + 7340416;
84200b5c:	80 41 
84200b5e:	07 f0 02 f0 	r0 = Null + 7340408;
84200b62:	78 41 
84200b64:	ff fd 5a f1 	call (m) 0x2c056;
84200b68:	33 e7 
84200b6a:	32 de       	M[FP + 24] = r0;
        resp = cpsPackWords((unsigned*)&ref_micref_delay, NULL, resp);
84200b6c:	34 d8       	r2 = M[FP + 24];
84200b6e:	07 f0 02 f0 	r0 = Null + 7340412;
84200b72:	7c 41 
84200b74:	03 00       	r1 = Null + Null;
84200b76:	ff fd 5a f1 	call (m) 0x2c056;
84200b7a:	21 e7 
84200b7c:	32 de       	M[FP + 24] = r0;

84200b7e <Lc_aec_reference_opmsg_obpm_get_status_14>:
#ifdef INSTALL_AEC_REFERENCE_HOWL_LIMITER
        resp = cpsPackWords((unsigned*)&op_extra_data->hl_data.hl_detect_cnt, NULL, resp);
#endif /* INSTALL_AEC_REFERENCE_HOWL_LIMITER */
    }

    return TRUE;
84200b7e:	42 20       	r0 = Null + 1;

84200b80 <Lc_aec_reference_opmsg_obpm_get_status_15>:
}
84200b80:	f4 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, rLink>;
84200b82:	d8 4c       	rts;

84200b84 <$_aec_reference_opmsg_ep_get_config>:
    return;
}
#endif /* INSTALL_DELEGATE_RATE_ADJUST_SUPPORT */

bool aec_reference_opmsg_ep_get_config(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200b84:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84200b86:	17 99       	r5 = M[r0 + 48];

bool aec_reference_opmsg_ep_get_config(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    OPMSG_GET_CONFIG *msg = message_data;
    OPMSG_GET_CONFIG_RESULT *result = msg->result;
84200b88:	1e 89       	r4 = M[r1 + 16];
    unsigned term_idx = msg->header.cmd_header.client_id;
84200b8a:	19 e8       	rMAC = M[r1 + Null];

    /* msg->value - Pointer which will be populated with the asked configuration value
       msg->cmd_header.client_id - Terminal ID (includes TERMINAL_SINK_MASK for sinks)
       msg->key - Parameter Key to return value for */

    switch(msg->key)
84200b8c:	da 88       	r0 = M[r1 + 12];
84200b8e:	d0 24       	Null = r0 - 3;
84200b90:	62 64       	if NC jump (m) Lc_aec_reference_opmsg_ep_get_config_28;

84200b92 <Lc_aec_reference_opmsg_ep_get_config_2>:
84200b92:	d0 26       	Null = r0 - 11;
84200b94:	08 f0 c1 e1 	if HI jump (m) Lc_aec_reference_opmsg_ep_get_config_28;

84200b98 <Lc_aec_reference_opmsg_ep_get_config_3>:
84200b98:	ea 7c       	r0 = r0 + -3;
84200b9a:	52 54       	r0 = r0 LSHIFT 2;
84200b9c:	e0 f0 22 f0 	r0 = M[r0 + 7340280];
84200ba0:	3e 88 
84200ba2:	da 4c       	jump r0;

84200ba4 <Lc_aec_reference_opmsg_ep_get_config_4>:
    {
        case OPMSG_OP_TERMINAL_DETAILS:
            /* Return a uint32 - Is Terminal emulating a real endpoint. Called at operator endpoint creation.
             */
            if(term_idx & TERMINAL_SINK_MASK)
84200ba4:	40 f0 12 f0 	r0 = rMAC AND 0x800000;
84200ba8:	00 00 
84200baa:	0e 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_get_config_8;

84200bac <Lc_aec_reference_opmsg_ep_get_config_5>:
          || ( (term_idx>=AEC_REF_INPUT_TERMINAL3)
              && (term_idx<=AEC_REF_INPUT_TERMINAL8) ) );
}
inline static bool IsMicrophoneTerminal(unsigned term_idx)
{
    term_idx &= ~TERMINAL_SINK_MASK;
84200bac:	bf ff 11 ff 	rMAC = rMAC AND 0xff7fffff;
84200bb0:	ff 1f 

    if(term_idx < AEC_REF_MIC_TERMINAL1)
84200bb2:	88 24       	Null = rMAC - 2;
84200bb4:	02 f0 a5 e1 	if C jump (m) Lc_aec_reference_opmsg_ep_get_config_29;

84200bb8 <Lc_aec_reference_opmsg_ep_get_config_6>:
    {
        return FALSE;
84200bb8:	02 00       	r0 = Null + Null;

84200bba <Lc_aec_reference_opmsg_ep_get_config_7>:
            {
                result->value = (uint32)(IsMicrophoneTerminal(term_idx)?
                                         OPMSG_GET_CONFIG_TERMINAL_DETAILS_NONE:
                                         OPMSG_GET_CONFIG_TERMINAL_DETAILS_REAL);
84200bba:	01 00       	rMAC = Null + Null;
84200bbc:	10 04       	Null = r0 - Null;
84200bbe:	20 f0 41 ce 	if EQ rMAC = Null + 1;
84200bc2:	31 ee       	M[r4 + Null] = rMAC;
84200bc4:	21 6e       	jump (m) Lc_aec_reference_opmsg_ep_get_config_20;

84200bc6 <Lc_aec_reference_opmsg_ep_get_config_8>:
inline static bool IsSpeakerTerminal(unsigned term_idx)
{
    return ( (term_idx==AEC_REF_SPKR_TERMINAL1)
          || (term_idx==AEC_REF_SPKR_TERMINAL2)
          || ( (term_idx>=AEC_REF_SPKR_TERMINAL3)
              && (term_idx<=AEC_REF_SPKR_TERMINAL8) ) );
84200bc6:	48 24       	Null = rMAC - 1;
84200bc8:	08 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_get_config_12;

84200bca <Lc_aec_reference_opmsg_ep_get_config_9>:
84200bca:	88 24       	Null = rMAC - 2;
84200bcc:	06 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_get_config_12;

84200bce <Lc_aec_reference_opmsg_ep_get_config_10>:
84200bce:	c8 25       	Null = rMAC - 7;
84200bd0:	4e 64       	if NC jump (m) Lc_aec_reference_opmsg_ep_get_config_32;

84200bd2 <Lc_aec_reference_opmsg_ep_get_config_11>:
84200bd2:	08 27       	Null = rMAC - 12;
84200bd4:	08 f0 99 e1 	if HI jump (m) Lc_aec_reference_opmsg_ep_get_config_32;

84200bd8 <Lc_aec_reference_opmsg_ep_get_config_12>:
84200bd8:	41 20       	rMAC = Null + 1;
84200bda:	4a 6e       	jump (m) Lc_aec_reference_opmsg_ep_get_config_33;

84200bdc <Lc_aec_reference_opmsg_ep_get_config_13>:
                                         OPMSG_GET_CONFIG_TERMINAL_DETAILS_NONE:
                                         OPMSG_GET_CONFIG_TERMINAL_DETAILS_REAL);
            }
            break;
        case OPMSG_OP_TERMINAL_RATEMATCH_ABILITY: /* uint32 */
            if(term_idx == (AEC_REF_INPUT_TERMINAL1|TERMINAL_SINK_MASK) )
84200bdc:	00 f2 10 f0 	Null = rMAC - 8388608;
84200be0:	00 24 
84200be2:	05 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_get_config_15;

84200be4 <Lc_aec_reference_opmsg_ep_get_config_14>:
            {
                result->value = (uint32)op_extra_data->spkr_rate_ability;
84200be4:	71 f0 6f 88 	rMAC = M[r5 + 444];
84200be8:	31 ee       	M[r4 + Null] = rMAC;
84200bea:	09 6e       	jump (m) Lc_aec_reference_opmsg_ep_get_config_18;

84200bec <Lc_aec_reference_opmsg_ep_get_config_15>:
                     */
                    result->value = RATEMATCHING_SUPPORT_HW;
                }
#endif
            }
            else if (term_idx == AEC_REF_OUTPUT_TERMINAL1)
84200bec:	c8 24       	Null = rMAC - 3;
84200bee:	0e 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_get_config_21;

84200bf0 <Lc_aec_reference_opmsg_ep_get_config_16>:
            {

                if(op_extra_data->mic_sync_enable)
84200bf0:	70 f0 d4 88 	Null = M[r5 + 848];
84200bf4:	0b 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_get_config_21;

84200bf6 <Lc_aec_reference_opmsg_ep_get_config_17>:
                    result->value = (uint32)RATEMATCHING_SUPPORT_AUTO;
                }
                else
                {

                    result->value = (uint32)op_extra_data->mic_rate_ability;
84200bf6:	71 f0 67 88 	rMAC = M[r5 + 412];
84200bfa:	31 ee       	M[r4 + Null] = rMAC;

84200bfc <Lc_aec_reference_opmsg_ep_get_config_18>:
        case OPMSG_OP_TERMINAL_RATEMATCH_ABILITY: /* uint32 */
            if(term_idx == (AEC_REF_INPUT_TERMINAL1|TERMINAL_SINK_MASK) )
            {
                result->value = (uint32)op_extra_data->spkr_rate_ability;
#ifdef ENABLE_FORCE_ENACTING_BY_AEC_REFERENCE
                if(RATEMATCHING_SUPPORT_SW == result->value)
84200bfc:	31 e8       	rMAC = M[r4 + Null];
84200bfe:	48 24       	Null = rMAC - 1;
84200c00:	03 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_get_config_20;

84200c02 <Lc_aec_reference_opmsg_ep_get_config_19>:
                {
                    /* Advertise HW despite planning to do it in SW
                     * this will make sure that enacting will be granted
                     * to this end.
                     */
                    result->value = RATEMATCHING_SUPPORT_HW;
84200c02:	81 20       	rMAC = Null + 2;
84200c04:	31 ee       	M[r4 + Null] = rMAC;

84200c06 <Lc_aec_reference_opmsg_ep_get_config_20>:
        case OPMSG_OP_TERMINAL_PROC_TIME:         /* uint32 */
        default:
            return FALSE;
    }

    return TRUE;
84200c06:	42 20       	r0 = Null + 1;
84200c08:	39 6e       	jump (m) Lc_aec_reference_opmsg_ep_get_config_34;

84200c0a <Lc_aec_reference_opmsg_ep_get_config_21>:
                }

            }
            else
            {
                result->value = (uint32)RATEMATCHING_SUPPORT_AUTO;
84200c0a:	c1 20       	rMAC = Null + 3;
84200c0c:	31 ee       	M[r4 + Null] = rMAC;
84200c0e:	fc 6f       	jump (m) Lc_aec_reference_opmsg_ep_get_config_20;

84200c10 <Lc_aec_reference_opmsg_ep_get_config_22>:
            break;
        case OPMSG_OP_TERMINAL_KICK_PERIOD:       /* uint32 */
            break;
        case OPMSG_OP_TERMINAL_RATEMATCH_RATE:    /* uint32 */

            if(term_idx == (AEC_REF_INPUT_TERMINAL1|TERMINAL_SINK_MASK) )
84200c10:	00 f2 10 f0 	Null = rMAC - 8388608;
84200c14:	00 24 
84200c16:	0b 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_get_config_24;

84200c18 <Lc_aec_reference_opmsg_ep_get_config_23>:
            {
                result->value = rate_monitor_op_get_rate(op_extra_data->spkr_rate_monitor_op,0);
84200c18:	72 f0 73 88 	r0 = M[r5 + 460];
84200c1c:	03 00       	r1 = Null + Null;
84200c1e:	ff fd 57 f3 	call 0x6bbf0;
84200c22:	32 ee 
84200c24:	32 ee       	M[r4 + Null] = r0;
                patch_fn_shared(aec_reference);

                op_extra_data->spkr_rate_meas = (unsigned)(result->value);
84200c26:	72 f0 83 8e 	M[r5 + 524] = r0;
84200c2a:	ee 6f       	jump (m) Lc_aec_reference_opmsg_ep_get_config_20;

84200c2c <Lc_aec_reference_opmsg_ep_get_config_24>:

            }
            else if (term_idx == AEC_REF_OUTPUT_TERMINAL1)
84200c2c:	c8 24       	Null = rMAC - 3;
84200c2e:	0b 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_get_config_26;

84200c30 <Lc_aec_reference_opmsg_ep_get_config_25>:
            {
                result->value = rate_monitor_op_get_rate(op_extra_data->mic_rate_monitor_op,0);
84200c30:	72 f0 6b 88 	r0 = M[r5 + 428];
84200c34:	03 00       	r1 = Null + Null;
84200c36:	ff fd 57 f3 	call 0x6bbf0;
84200c3a:	3a ed 
84200c3c:	32 ee       	M[r4 + Null] = r0;
                patch_fn_shared(aec_reference);

                op_extra_data->mic_rate_meas = (unsigned)(result->value);
84200c3e:	72 f0 84 8e 	M[r5 + 528] = r0;
84200c42:	e2 6f       	jump (m) Lc_aec_reference_opmsg_ep_get_config_20;

84200c44 <Lc_aec_reference_opmsg_ep_get_config_26>:
            }
            else
            {
                /* 1.0 in Qx.22 independent of word width */
                result->value = 1<<STREAM_RATEMATCHING_FIX_POINT_SHIFT;
84200c44:	04 f0 01 f0 	rMAC = Null + 4194304;
84200c48:	00 40 
84200c4a:	31 ee       	M[r4 + Null] = rMAC;
84200c4c:	dd 6f       	jump (m) Lc_aec_reference_opmsg_ep_get_config_20;

84200c4e <Lc_aec_reference_opmsg_ep_get_config_27>:
            }

            break;
        case OPMSG_OP_TERMINAL_RATEMATCH_MEASUREMENT:
            /* TODO */
            result->rm_measurement.sp_deviation = 0;
84200c4e:	30 ee       	M[r4 + Null] = Null;
            result->rm_measurement.measurement.valid = FALSE;
84200c50:	30 8b       	MB[r4 + 4] = Null;
            break;
84200c52:	da 6f       	jump (m) Lc_aec_reference_opmsg_ep_get_config_20;

84200c54 <Lc_aec_reference_opmsg_ep_get_config_28>:
        case OPMSG_OP_TERMINAL_BLOCK_SIZE:        /* uint32 */
        case OPMSG_OP_TERMINAL_PROC_TIME:         /* uint32 */
        default:
            return FALSE;
84200c54:	02 00       	r0 = Null + Null;
84200c56:	12 6e       	jump (m) Lc_aec_reference_opmsg_ep_get_config_34;

84200c58 <Lc_aec_reference_opmsg_ep_get_config_29>:

    if(term_idx < AEC_REF_MIC_TERMINAL1)
    {
        return FALSE;
    }
    if(term_idx <= AEC_REF_MIC_TERMINAL4)
84200c58:	48 25       	Null = rMAC - 5;
84200c5a:	08 f0 89 e0 	if HI jump (m) Lc_aec_reference_opmsg_ep_get_config_31;

84200c5e <Lc_aec_reference_opmsg_ep_get_config_30>:
    {
        return TRUE;
84200c5e:	42 20       	r0 = Null + 1;
84200c60:	ad 6f       	jump (m) Lc_aec_reference_opmsg_ep_get_config_7;

84200c62 <Lc_aec_reference_opmsg_ep_get_config_31>:
    }
    return (term_idx >= AEC_REF_MIC_TERMINAL5);
84200c62:	02 00       	r0 = Null + Null;
84200c64:	08 27       	Null = rMAC - 12;
84200c66:	22 f0 42 ce 	if C r0 = Null + 1;
84200c6a:	a8 6f       	jump (m) Lc_aec_reference_opmsg_ep_get_config_7;

84200c6c <Lc_aec_reference_opmsg_ep_get_config_32>:
inline static bool IsSpeakerTerminal(unsigned term_idx)
{
    return ( (term_idx==AEC_REF_SPKR_TERMINAL1)
          || (term_idx==AEC_REF_SPKR_TERMINAL2)
          || ( (term_idx>=AEC_REF_SPKR_TERMINAL3)
              && (term_idx<=AEC_REF_SPKR_TERMINAL8) ) );
84200c6c:	01 00       	rMAC = Null + Null;

84200c6e <Lc_aec_reference_opmsg_ep_get_config_33>:
            }
            else
            {
                result->value = (uint32)(IsSpeakerTerminal(term_idx)?
                                         OPMSG_GET_CONFIG_TERMINAL_DETAILS_NONE:
                                         OPMSG_GET_CONFIG_TERMINAL_DETAILS_REAL);
84200c6e:	02 00       	r0 = Null + Null;
84200c70:	08 04       	Null = rMAC - Null;
84200c72:	20 f0 42 ce 	if EQ r0 = Null + 1;
84200c76:	32 ee       	M[r4 + Null] = r0;
84200c78:	c7 6f       	jump (m) Lc_aec_reference_opmsg_ep_get_config_20;

84200c7a <Lc_aec_reference_opmsg_ep_get_config_34>:
        default:
            return FALSE;
    }

    return TRUE;
}
84200c7a:	f2 48       	popm <FP, r4, r5, rLink>;
84200c7c:	d8 4c       	rts;

84200c7e <$_aec_reference_opmsg_ep_configure>:


bool aec_reference_opmsg_ep_configure(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200c7e:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84200c80:	16 99       	r4 = M[r0 + 48];

bool aec_reference_opmsg_ep_configure(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    OPMSG_CONFIGURE  *msg = message_data;
    unsigned terminal_id = msg->header.cmd_header.client_id;
84200c82:	19 e8       	rMAC = M[r1 + Null];
    uint32      value = msg->value;
84200c84:	1f 89       	r5 = M[r1 + 16];

    /* msg->value - Pointer or Value for Key
       msg->cmd_header.client_id - Terminal ID (includes TERMINAL_SINK_MASK for sinks)
       msg->key - Parameter Key to return value for */

    switch(msg->key)
84200c86:	da 88       	r0 = M[r1 + 12];
84200c88:	0c 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_5;

84200c8a <Lc_aec_reference_opmsg_ep_configure_2>:
84200c8a:	90 26       	Null = r0 - 10;
84200c8c:	08 f0 95 e0 	if HI jump (m) Lc_aec_reference_opmsg_ep_configure_5;

84200c90 <Lc_aec_reference_opmsg_ep_configure_3>:
84200c90:	52 24       	r0 = r0 - 1;
84200c92:	52 54       	r0 = r0 LSHIFT 2;
84200c94:	e0 f0 22 f0 	r0 = M[r0 + 7340316];
84200c98:	47 88 
84200c9a:	da 4c       	jump r0;

84200c9c <Lc_aec_reference_opmsg_ep_configure_4>:
    {
        case OPMSG_OP_TERMINAL_DATA_FORMAT:
            /* value is data type */
            if( ((AUDIO_DATA_FORMAT)msg->value)!=AUDIO_DATA_FORMAT_FIXP )
84200c9c:	78 24       	Null = r5 - 1;
84200c9e:	e7 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200ca0 <Lc_aec_reference_opmsg_ep_configure_5>:
            {
                return(FALSE);
84200ca0:	02 00       	r0 = Null + Null;
84200ca2:	e6 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_56;

84200ca4 <Lc_aec_reference_opmsg_ep_configure_6>:
               TODO - Really need to know type of endpoint: ADC/DAC, I2S, Digital MIC

               CBOPS_DC_REMOVE | CBOPS_SHIFT (set data format --> AUDIO_DATA_FORMAT_FIXP)
               CBOPS_RATEADJUST (EP_RATEMATCH_ENACTING) */

            if(terminal_id == (AEC_REF_MIC_TERMINAL1|TERMINAL_SINK_MASK) )
84200ca4:	00 f2 10 f0 	Null = rMAC - 8388610;
84200ca8:	02 24 
84200caa:	08 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_8;

84200cac <Lc_aec_reference_opmsg_ep_configure_7>:
            {
                op_extra_data->mic_shift = get_shift_from_cbops_parameters((CBOPS_PARAMETERS *)(uintptr_t)value);
84200cac:	3a 00       	r0 = r5 + Null;
84200cae:	ff fd 1e f0 	call (m) 0x49da;
84200cb2:	2d e9 
84200cb4:	62 f0 6d 8e 	M[r4 + 436] = r0;
84200cb8:	da 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200cba <Lc_aec_reference_opmsg_ep_configure_8>:
            }
            else if (terminal_id == AEC_REF_SPKR_TERMINAL1)
84200cba:	48 24       	Null = rMAC - 1;
84200cbc:	d8 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200cbe <Lc_aec_reference_opmsg_ep_configure_9>:
            {
                op_extra_data->spkr_shift = get_shift_from_cbops_parameters((CBOPS_PARAMETERS *)(uintptr_t)value);
84200cbe:	3a 00       	r0 = r5 + Null;
84200cc0:	ff fd 1e f0 	call (m) 0x49da;
84200cc4:	3b e8 
84200cc6:	62 f0 74 8e 	M[r4 + 464] = r0;
84200cca:	d1 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200ccc <Lc_aec_reference_opmsg_ep_configure_10>:
            /* uint32 expected block size per period

               endpoint->state.audio.block_size = (unsigned int)value;
               endpoint->state.audio.kick_period =  (unsigned int)(value * (unsigned long)STREAM_KICK_PERIOD_FROM_USECS(1000000UL) /
               endpoint->state.audio.sample_rate); */
            if(terminal_id == (AEC_REF_INPUT_TERMINAL1|TERMINAL_SINK_MASK) )
84200ccc:	00 f2 10 f0 	Null = rMAC - 8388608;
84200cd0:	00 24 
84200cd2:	04 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_12;

84200cd4 <Lc_aec_reference_opmsg_ep_configure_11>:
            {
                op_extra_data->spkr_kick_size = (unsigned)value;
84200cd4:	67 f0 75 8e 	M[r4 + 468] = r5;
84200cd8:	ca 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200cda <Lc_aec_reference_opmsg_ep_configure_12>:
            }
            else if (terminal_id == AEC_REF_OUTPUT_TERMINAL1)
84200cda:	c8 24       	Null = rMAC - 3;
84200cdc:	c8 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200cde <Lc_aec_reference_opmsg_ep_configure_13>:

                /* mic-ref block_size latency control only works for larger block sizes, it will fail
                 * if requested block size is small, so we apply a minimum block size, below
                 * that mic-ref latency control logic will be turned off.
                 */
                unsigned min_block_size = frac_mult(op_extra_data->output_rate, FRACTIONAL(0.006));
84200cde:	62 f0 65 88 	r0 = M[r4 + 404];
84200ce2:	0c f0 43 f2 	r1 = Null + 12884901;
84200ce6:	a5 73 
84200ce8:	00 f3 72 c9 	r0 = r0 * r1 (frac);

                /* Validate block size for sync logic.   Output buffers size will be at least 8.7 msec of data */
                if(block_size && (block_size < min_block_size) )
84200cec:	39 00       	rMAC = r5 + Null;
84200cee:	05 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_16;

84200cf0 <Lc_aec_reference_opmsg_ep_configure_14>:
84200cf0:	b8 04       	Null = r5 - r0;
84200cf2:	02 f0 87 e0 	if C jump (m) Lc_aec_reference_opmsg_ep_configure_16;

84200cf6 <Lc_aec_reference_opmsg_ep_configure_15>:
                {
                    /* Disable sync logic if block_size is to small */
                    block_size = 0;
84200cf6:	01 00       	rMAC = Null + Null;

84200cf8 <Lc_aec_reference_opmsg_ep_configure_16>:
                }
                op_extra_data->sync_block.block_size = block_size;
84200cf8:	61 f0 86 8e 	M[r4 + 536] = rMAC;
#ifdef AEC_REFERENCE_GENERATE_MIC_TIMESTAMP
                {
                    /* update minimum len metadata tags for mic output */
                    op_extra_data->mic_metadata_min_tag_len =
                        MAX(op_extra_data->mic_metadata_min_tag_len,
                            op_extra_data->sync_block.block_size);
84200cfc:	62 f0 cc 88 	r0 = M[r4 + 816];
84200d00:	50 04       	Null = r0 - rMAC;
84200d02:	02 f0 eb e2 	if C jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200d06 <Lc_aec_reference_opmsg_ep_configure_17>:
84200d06:	61 f0 cc 8e 	M[r4 + 816] = rMAC;
84200d0a:	b1 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200d0c <Lc_aec_reference_opmsg_ep_configure_18>:
            }
            break;
        case OPMSG_OP_TERMINAL_RATEMATCH_ENACTING:
            /* uint32 TRUE or FALSE.   Operator should perform rate matching if TRUE  */

            if(terminal_id == (AEC_REF_INPUT_TERMINAL1|TERMINAL_SINK_MASK) )
84200d0c:	00 f2 10 f0 	Null = rMAC - 8388608;
84200d10:	00 24 
84200d12:	2a 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_27;

84200d14 <Lc_aec_reference_opmsg_ep_configure_19>:
            {
                set_override_ep_ratematch_enacting(op_extra_data->spkr_endpoint,value);
84200d14:	62 f0 80 88 	r0 = M[r4 + 512];
84200d18:	3b 00       	r1 = r5 + Null;
84200d1a:	ff fd 1e f0 	call (m) 0x4a3e;
84200d1e:	25 e9 
                if(value==(uint32)FALSE)
84200d20:	38 04       	Null = r5 - Null;
84200d22:	04 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_21;

84200d24 <Lc_aec_reference_opmsg_ep_configure_20>:
                {
                    op_extra_data->spkr_rate_enactment = RATEMATCHING_SUPPORT_NONE;
84200d24:	60 f0 71 8e 	M[r4 + 452] = Null;
84200d28:	05 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_22;

84200d2a <Lc_aec_reference_opmsg_ep_configure_21>:
                }
                else
                {
                    op_extra_data->spkr_rate_enactment = op_extra_data->spkr_rate_ability;
84200d2a:	61 f0 6f 88 	rMAC = M[r4 + 444];
84200d2e:	61 f0 71 8e 	M[r4 + 452] = rMAC;

84200d32 <Lc_aec_reference_opmsg_ep_configure_22>:
                }

                if((op_extra_data->spkr_rate_enactment==RATEMATCHING_SUPPORT_HW) && (op_extra_data->spkr_rate_monitor_op))
84200d32:	61 f0 71 88 	rMAC = M[r4 + 452];
84200d36:	88 24       	Null = rMAC - 2;
84200d38:	0b 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_25;

84200d3a <Lc_aec_reference_opmsg_ep_configure_23>:
84200d3a:	62 f0 73 88 	r0 = M[r4 + 460];
84200d3e:	08 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_25;

84200d40 <Lc_aec_reference_opmsg_ep_configure_24>:
                {
                    rate_monitor_op_initialise(op_extra_data->spkr_rate_monitor_op,op_extra_data->spkr_rate,TRUE,3*MS_PER_SEC);
84200d40:	05 f0 b8 53 	r3 = Null + 3000;
84200d44:	44 20       	r2 = Null + 1;
84200d46:	63 f0 6e 88 	r1 = M[r4 + 440];
84200d4a:	f9 ff 32 e6 	call $_rate_monitor_op_initialise;

84200d4e <Lc_aec_reference_opmsg_ep_configure_25>:
                }

                if(op_extra_data->spkr_sw_rateadj_op)
84200d4e:	62 f0 7e 88 	r0 = M[r4 + 504];
84200d52:	8d 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200d54 <Lc_aec_reference_opmsg_ep_configure_26>:
                {
                    cbops_rateadjust_passthrough_mode(op_extra_data->spkr_sw_rateadj_op,(op_extra_data->spkr_rate_enactment==RATEMATCHING_SUPPORT_NONE)?TRUE:FALSE);
84200d54:	03 00       	r1 = Null + Null;
84200d56:	60 f0 71 88 	Null = M[r4 + 452];
84200d5a:	20 f0 43 ce 	if EQ r1 = Null + 1;
84200d5e:	ff fd af f0 	call (m) 0x16c96;
84200d62:	39 e9 
84200d64:	84 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200d66 <Lc_aec_reference_opmsg_ep_configure_27>:

                }
            }
            else if (terminal_id == AEC_REF_OUTPUT_TERMINAL1
                     && !op_extra_data->mic_sync_enable)
84200d66:	c8 24       	Null = rMAC - 3;
84200d68:	82 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200d6a <Lc_aec_reference_opmsg_ep_configure_28>:
84200d6a:	60 f0 d4 88 	Null = M[r4 + 848];
84200d6e:	7f 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200d70 <Lc_aec_reference_opmsg_ep_configure_29>:
            {
                set_override_ep_ratematch_enacting(op_extra_data->mic_endpoint,value);
84200d70:	62 f0 7f 88 	r0 = M[r4 + 508];
84200d74:	3b 00       	r1 = r5 + Null;
84200d76:	ff fd 1e f0 	call (m) 0x4a3e;
84200d7a:	29 e6 
                if(value==(uint32)FALSE)
84200d7c:	38 04       	Null = r5 - Null;
84200d7e:	04 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_31;

84200d80 <Lc_aec_reference_opmsg_ep_configure_30>:
                {
                    op_extra_data->mic_rate_enactment = RATEMATCHING_SUPPORT_NONE;
84200d80:	60 f0 68 8e 	M[r4 + 416] = Null;
84200d84:	05 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_32;

84200d86 <Lc_aec_reference_opmsg_ep_configure_31>:
                }
                else
                {
                    op_extra_data->mic_rate_enactment = op_extra_data->mic_rate_ability;
84200d86:	61 f0 67 88 	rMAC = M[r4 + 412];
84200d8a:	61 f0 68 8e 	M[r4 + 416] = rMAC;

84200d8e <Lc_aec_reference_opmsg_ep_configure_32>:
                }

                if((op_extra_data->mic_rate_enactment==RATEMATCHING_SUPPORT_HW) && (op_extra_data->mic_rate_monitor_op))
84200d8e:	61 f0 68 88 	rMAC = M[r4 + 416];
84200d92:	88 24       	Null = rMAC - 2;
84200d94:	0b 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_35;

84200d96 <Lc_aec_reference_opmsg_ep_configure_33>:
84200d96:	62 f0 6b 88 	r0 = M[r4 + 428];
84200d9a:	08 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_35;

84200d9c <Lc_aec_reference_opmsg_ep_configure_34>:
                {
                    rate_monitor_op_initialise(op_extra_data->mic_rate_monitor_op,op_extra_data->mic_rate,TRUE,3*MS_PER_SEC);
84200d9c:	05 f0 b8 53 	r3 = Null + 3000;
84200da0:	44 20       	r2 = Null + 1;
84200da2:	63 f0 66 88 	r1 = M[r4 + 408];
84200da6:	f9 ff 36 e3 	call $_rate_monitor_op_initialise;

84200daa <Lc_aec_reference_opmsg_ep_configure_35>:
                }

                if(op_extra_data->mic_sw_rateadj_op)
84200daa:	62 f0 7d 88 	r0 = M[r4 + 500];
84200dae:	5f 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200db0 <Lc_aec_reference_opmsg_ep_configure_36>:
                {
                    cbops_rateadjust_passthrough_mode(op_extra_data->mic_sw_rateadj_op,(op_extra_data->mic_rate_enactment==RATEMATCHING_SUPPORT_NONE)?TRUE:FALSE);
84200db0:	03 00       	r1 = Null + Null;
84200db2:	60 f0 68 88 	Null = M[r4 + 416];
84200db6:	20 f0 43 ce 	if EQ r1 = Null + 1;
84200dba:	ff fd af f0 	call (m) 0x16c96;
84200dbe:	3d e6 
84200dc0:	56 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200dc2 <Lc_aec_reference_opmsg_ep_configure_37>:
            break;
        case OPMSG_OP_TERMINAL_RATEMATCH_ADJUSTMENT:
        {
            int svalue = (int)value;
            /*  See BlueCore audio real endpoint function "adjust_audio_rate" for details */
            if(terminal_id == (AEC_REF_INPUT_TERMINAL1|TERMINAL_SINK_MASK) )
84200dc2:	00 f2 10 f0 	Null = rMAC - 8388608;
84200dc6:	00 24 
84200dc8:	29 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_46;

84200dca <Lc_aec_reference_opmsg_ep_configure_38>:
            {
#ifdef AEC_REFERENCE_SPKR_TTP
                if(op_extra_data->spkr_timed_playback_mode)
84200dca:	60 f0 b2 88 	Null = M[r4 + 712];
84200dce:	4f 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200dd0 <Lc_aec_reference_opmsg_ep_configure_39>:
                     * rate adjustment is managed by speaker ttp */
                    break;
                }
#endif /* AEC_REFERENCE_SPKR_TTP */
                /* Send Rate Adjustment to hardware */
                if(op_extra_data->spkr_rate_enactment==RATEMATCHING_SUPPORT_HW)
84200dd0:	61 f0 71 88 	rMAC = M[r4 + 452];
84200dd4:	88 24       	Null = rMAC - 2;
84200dd6:	19 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_44;

84200dd8 <Lc_aec_reference_opmsg_ep_configure_40>:
                {
                    if(op_extra_data->output_stream[AEC_REF_SPKR_TERMINAL1])
84200dd8:	71 a8       	rMAC = M[r4 + 68];
84200dda:	49 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200ddc <Lc_aec_reference_opmsg_ep_configure_41>:
                    {
                        if((op_extra_data->spkr_rate_monitor_op) && (rate_monitor_op_is_complete(op_extra_data->spkr_rate_monitor_op)))
84200ddc:	62 f0 73 88 	r0 = M[r4 + 460];
84200de0:	46 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200de2 <Lc_aec_reference_opmsg_ep_configure_42>:
84200de2:	ff fd 57 f3 	call 0x6bc28;
84200de6:	26 e2 
84200de8:	10 04       	Null = r0 - Null;
84200dea:	41 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200dec <Lc_aec_reference_opmsg_ep_configure_43>:
                        {
                            op_extra_data->spkr_rate_adjustment = svalue;
84200dec:	3b 00       	r1 = r5 + Null;
84200dee:	63 f0 70 8e 	M[r4 + 448] = r1;
                            value = op_extra_data->spkr_rate_adjustment;
                            set_override_ep_ratematch_adjustment(op_extra_data->spkr_endpoint,value);
84200df2:	62 f0 80 88 	r0 = M[r4 + 512];
84200df6:	ff fd 1e f0 	call (m) 0x4aa0;
84200dfa:	2b e5 
                            rate_monitor_op_restart(op_extra_data->spkr_rate_monitor_op);
84200dfc:	62 f0 73 88 	r0 = M[r4 + 460];
84200e00:	ff fd 57 f3 	call 0x6bc14;
84200e04:	34 e0 
84200e06:	33 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200e08 <Lc_aec_reference_opmsg_ep_configure_44>:
                        }
                    }
                }
                else
                {
                    op_extra_data->spkr_rate_adjustment = svalue;
84200e08:	3b 00       	r1 = r5 + Null;
84200e0a:	63 f0 70 8e 	M[r4 + 448] = r1;
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
                    if(0 != op_extra_data->spkr_ext_rate_adjust_op)
84200e0e:	62 f0 ae 88 	r0 = M[r4 + 696];
84200e12:	2d 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200e14 <Lc_aec_reference_opmsg_ep_configure_45>:
                    {

                        /* set the target rate value, this will be ignored if speaker path is doing TTP. */
                        stream_delegate_rate_adjust_set_target_rate(op_extra_data->spkr_ext_rate_adjust_op,
                                                                    op_extra_data->spkr_rate_adjustment);
84200e14:	11 f0 2f ef 	call (m) $_stream_delegate_rate_adjust_set_target_rate;
84200e18:	2a 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200e1a <Lc_aec_reference_opmsg_ep_configure_46>:
            }
            else if (terminal_id == AEC_REF_OUTPUT_TERMINAL1
                     /* if we are syncing mic to speaker input we shouldn't
                      * receive this message, but ignore it if we received.
                      */
                     && !op_extra_data->mic_sync_enable)
84200e1a:	c8 24       	Null = rMAC - 3;
84200e1c:	28 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200e1e <Lc_aec_reference_opmsg_ep_configure_47>:
84200e1e:	60 f0 d4 88 	Null = M[r4 + 848];
84200e22:	25 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200e24 <Lc_aec_reference_opmsg_ep_configure_48>:
            {
                /* Send Rate Adjustment to hardware */
                if(op_extra_data->mic_rate_enactment == RATEMATCHING_SUPPORT_HW)
84200e24:	61 f0 68 88 	rMAC = M[r4 + 416];
84200e28:	88 24       	Null = rMAC - 2;
84200e2a:	19 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_53;

84200e2c <Lc_aec_reference_opmsg_ep_configure_49>:
                {
                    if(op_extra_data->input_stream[AEC_REF_MIC_TERMINAL1])
84200e2c:	b1 88       	rMAC = M[r4 + 8];
84200e2e:	1f 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200e30 <Lc_aec_reference_opmsg_ep_configure_50>:
                    {
                        if((op_extra_data->mic_rate_monitor_op) && (rate_monitor_op_is_complete(op_extra_data->mic_rate_monitor_op)))
84200e30:	62 f0 6b 88 	r0 = M[r4 + 428];
84200e34:	1c 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200e36 <Lc_aec_reference_opmsg_ep_configure_51>:
84200e36:	ff fd 56 f3 	call 0x6bc28;
84200e3a:	32 ef 
84200e3c:	10 04       	Null = r0 - Null;
84200e3e:	17 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200e40 <Lc_aec_reference_opmsg_ep_configure_52>:
                        {
                            op_extra_data->mic_rate_adjustment = svalue;
84200e40:	3b 00       	r1 = r5 + Null;
84200e42:	63 f0 69 8e 	M[r4 + 420] = r1;
                            value = op_extra_data->mic_rate_adjustment;
                            set_override_ep_ratematch_adjustment(op_extra_data->mic_endpoint,value);
84200e46:	62 f0 7f 88 	r0 = M[r4 + 508];
84200e4a:	ff fd 1e f0 	call (m) 0x4aa0;
84200e4e:	37 e2 
                            rate_monitor_op_restart(op_extra_data->mic_rate_monitor_op);
84200e50:	62 f0 6b 88 	r0 = M[r4 + 428];
84200e54:	ff fd 56 f3 	call 0x6bc14;
84200e58:	20 ee 
84200e5a:	09 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200e5c <Lc_aec_reference_opmsg_ep_configure_53>:
                        }
                    }
                }
                else
                {
                    op_extra_data->mic_rate_adjustment = svalue;
84200e5c:	3b 00       	r1 = r5 + Null;
84200e5e:	63 f0 69 8e 	M[r4 + 420] = r1;
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
                    if(0 != op_extra_data->mic_ext_rate_adjust_op)
84200e62:	62 f0 ad 88 	r0 = M[r4 + 692];
84200e66:	03 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200e68 <Lc_aec_reference_opmsg_ep_configure_54>:
                    {

                        /* set the target rate */
                        stream_delegate_rate_adjust_set_target_rate(op_extra_data->mic_ext_rate_adjust_op,
                                                                    op_extra_data->mic_rate_adjustment);
84200e68:	11 f0 3b ec 	call (m) $_stream_delegate_rate_adjust_set_target_rate;

84200e6c <Lc_aec_reference_opmsg_ep_configure_55>:
            /* break; */
        default:
            return(FALSE);
    }

    return(TRUE);
84200e6c:	42 20       	r0 = Null + 1;

84200e6e <Lc_aec_reference_opmsg_ep_configure_56>:
}
84200e6e:	f2 48       	popm <FP, r4, r5, rLink>;
84200e70:	d8 4c       	rts;

84200e72 <$_aec_reference_opmsg_ep_clock_id>:

   TODO.  Remove OPMSG_COMMON_GET_CLOCK_ID from table and delete this function
*/

bool aec_reference_opmsg_ep_clock_id(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200e72:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
84200e74:	16 00       	r4 = r0 + Null;
84200e76:	23 09       	r9 = r2 + Null;
84200e78:	2f 00       	r5 = r3 + Null;
    unsigned *resp;
    OP_MSG_REQ *msg = message_data;
    unsigned terminal_id = msg->header.cmd_header.client_id;
84200e7a:	3a f0 00 e8 	r8 = M[r1 + Null];
    INT_OP_ID int_id = op_data->id;
84200e7e:	69 f0 01 88 	r7 = M[r4 + 4];
     * If the Mic and Spkr share the same clock source then all real terminals
     * share the same rate.
     */

    /* Payload is a single word containing the clock ID */
    resp = xpmalloc(sizeof(unsigned));
84200e82:	c3 20       	r1 = Null + 3;
84200e84:	02 21       	r0 = Null + 4;
84200e86:	ff fd 1f f0 	call (m) 0x4e2e;
84200e8a:	29 ed 
84200e8c:	10 09       	r6 = r0 + Null;
    if (!resp)
84200e8e:	03 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_clock_id_3;

84200e90 <Lc_aec_reference_opmsg_ep_clock_id_2>:
    {
        return FALSE;
84200e90:	02 00       	r0 = Null + Null;
84200e92:	20 6e       	jump (m) Lc_aec_reference_opmsg_ep_clock_id_10;

84200e94 <Lc_aec_reference_opmsg_ep_clock_id_3>:
    }
    *resp_data = (OP_OPMSG_RSP_PAYLOAD*)resp;
84200e94:	78 f0 00 ee 	M[r5 + Null] = r6;
    *resp_length = 1;
84200e98:	41 20       	rMAC = Null + 1;
84200e9a:	b1 f0 00 ee 	M[r9 + Null] = rMAC;
      clock ID will be reported as zero before this operation is called.

      If MIC and SPKR real endpoints are not connected then we report the same clock source.
    */

    if (terminal_id & TERMINAL_SINK_MASK)
84200e9e:	40 f0 a1 f0 	rMAC = r8 AND 0x800000;
84200ea2:	00 00 
84200ea4:	14 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_clock_id_8;

84200ea6 <Lc_aec_reference_opmsg_ep_clock_id_4>:
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84200ea6:	31 99       	rMAC = M[r4 + 48];
         * same clock source as the mic then report the same clock source of
         * the op id. If they differ then report op_id and 1 << 7 as the op id
         * is 7 bits long.
         */
        if (!op_extra_data->input_stream[AEC_REF_MIC_TERMINAL1] ||
            !op_extra_data->output_stream[AEC_REF_SPKR_TERMINAL1])
84200ea8:	8a 88       	r0 = M[rMAC + 8];
84200eaa:	11 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_clock_id_8;

84200eac <Lc_aec_reference_opmsg_ep_clock_id_5>:
84200eac:	4a a8       	r0 = M[rMAC + 68];
84200eae:	0f 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_clock_id_8;

84200eb0 <Lc_aec_reference_opmsg_ep_clock_id_6>:
        {
            *resp = int_id;
        }
        else if (override_endpoints_have_same_clock_source(op_extra_data->spkr_endpoint,
                                                           op_extra_data->mic_endpoint))
84200eb0:	13 f0 7f 88 	r1 = M[rMAC + 508];
84200eb4:	12 f0 80 88 	r0 = M[rMAC + 512];
84200eb8:	ff fd 1d f0 	call (m) 0x4a96;
84200ebc:	3f ee 
84200ebe:	10 04       	Null = r0 - Null;
84200ec0:	06 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_clock_id_8;

84200ec2 <Lc_aec_reference_opmsg_ep_clock_id_7>:
        {
            *resp = int_id;
        }
        else
        {
            *resp = int_id | (1 << 7);
84200ec2:	40 f9 51 c8 	rMAC = r7 OR 0x80;
84200ec6:	81 f0 00 ee 	M[r6 + Null] = rMAC;
84200eca:	03 6e       	jump (m) Lc_aec_reference_opmsg_ep_clock_id_9;

84200ecc <Lc_aec_reference_opmsg_ep_clock_id_8>:
    {
        /* The sources that this is relevant to is Outputs and Reference. These
         * all have the same clock source. Report default clock source as the
         * op id.
         */
        *resp = int_id;
84200ecc:	89 f0 00 ee 	M[r6 + Null] = r7;

84200ed0 <Lc_aec_reference_opmsg_ep_clock_id_9>:
    }

    return TRUE;
84200ed0:	42 20       	r0 = Null + 1;

84200ed2 <Lc_aec_reference_opmsg_ep_clock_id_10>:
}
84200ed2:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200ed4:	d8 4c       	rts;

84200ed6 <$_aec_reference_set_rates>:

    return cpsGetUcidMsgHandler(&op_extra_data->parms_def,op_extra_data->cap_id,message_data,resp_length,resp_data);
}

bool aec_reference_set_rates(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200ed6:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84200ed8:	17 00       	r5 = r0 + Null;
    AEC_REFERENCE_OP_DATA   *op_extra_data = (AEC_REFERENCE_OP_DATA*)op_data->extra_op_data;
84200eda:	3e 99       	r4 = M[r5 + 48];
    unsigned irate,orate;
    bool rebuild = FALSE;
84200edc:	02 09       	r8 = Null + Null;

    patch_fn_shared(aec_reference);

    /* Rates needed for creating cbops and for "aec_reference_buffer_details" */
    irate  = OPMSG_FIELD_GET(message_data, OPMSG_AEC_SET_SAMPLE_RATES, INPUT_RATE);
84200ede:	d9 88       	rMAC = M[r1 + 12];
84200ee0:	19 f7 ff 1f 	r7 = rMAC AND 0xffff;
    orate  = OPMSG_FIELD_GET(message_data, OPMSG_AEC_SET_SAMPLE_RATES, OUTPUT_RATE);
84200ee4:	19 89       	rMAC = M[r1 + 16];
84200ee6:	18 f7 ff 1f 	r6 = rMAC AND 0xffff;

    L2_DBG_MSG2("AEC REFERENCE: set rates = %d %d", irate, orate);
84200eea:	55 f1 02 f0 	r0 = Null + 357564799;
84200eee:	7f 41 
84200ef0:	44 08       	r2 = r6 + Null;
84200ef2:	4b 08       	r1 = r7 + Null;
84200ef4:	ef fd fd ff 	call (m) 0x9c8;
84200ef8:	35 e6 

    if(op_extra_data->input_rate!=irate)
84200efa:	61 f0 64 88 	rMAC = M[r4 + 400];
84200efe:	9f f1 00 c2 	Null = rMAC - r7;
84200f02:	0c 60       	if EQ jump (m) Lc_aec_reference_set_rates_4;

84200f04 <Lc_aec_reference_set_rates_2>:
    {
        op_extra_data->input_rate = irate;
84200f04:	69 f0 64 8e 	M[r4 + 400] = r7;
        if(op_data->state == OP_RUNNING)
84200f08:	39 b0       	rMAC = MBS[r5 + 24];
84200f0a:	08 62       	if NE jump (m) Lc_aec_reference_set_rates_4;

84200f0c <Lc_aec_reference_set_rates_3>:
        {
            /* if the operator is running, any change in input
             * rate should trigger a rebuild of speaker graph
             */
            SetSpkrChannelStatus(op_extra_data, 0);
84200f0c:	61 f0 76 88 	rMAC = M[r4 + 472];
84200f10:	11 fe 0f 00 	rMAC = rMAC AND 0xffffc00f;
84200f14:	61 f0 76 8e 	M[r4 + 472] = rMAC;
            rebuild = TRUE;
84200f18:	0a 71       	r8 = Null + 1;

84200f1a <Lc_aec_reference_set_rates_4>:
        }
    }

#ifdef AEC_REFERENCE_GENERATE_MIC_TIMESTAMP
    /* configure sample rate for MIC ttp */
    ttp_configure_rate(op_extra_data->mic_time_to_play, orate);
84200f1a:	62 f0 cf 88 	r0 = M[r4 + 828];
84200f1e:	43 08       	r1 = r6 + Null;
84200f20:	ff fd ac f0 	call (m) 0x1684c;
84200f24:	2d e9 
#endif

    if(op_extra_data->output_rate!=orate)
84200f26:	61 f0 65 88 	rMAC = M[r4 + 404];
84200f2a:	8f f1 00 c2 	Null = rMAC - r6;
84200f2e:	17 60       	if EQ jump (m) Lc_aec_reference_set_rates_8;

84200f30 <Lc_aec_reference_set_rates_5>:
    {
        op_extra_data->output_rate = orate;
84200f30:	68 f0 65 8e 	M[r4 + 404] = r6;
        if(op_data->state == OP_RUNNING)
84200f34:	39 b0       	rMAC = MBS[r5 + 24];
84200f36:	13 62       	if NE jump (m) Lc_aec_reference_set_rates_8;

84200f38 <Lc_aec_reference_set_rates_6>:
        {
            /* if the operator is running, any change in output
             * rate should trigger a rebuild of microphone graph
             */
            SetMicChannelStatus(op_extra_data, 0);
84200f38:	61 f0 76 88 	rMAC = M[r4 + 472];
84200f3c:	f0 ff 11 f7 	rMAC = rMAC AND 0xffe0fff0;
84200f40:	f0 1f 
84200f42:	61 f0 76 8e 	M[r4 + 472] = rMAC;

84200f46 <Lc_aec_reference_set_rates_7>:
        /* At least one of input or output rate has changed while the operator
         * is running. This will require fresh rebuild of the affected cbops graphs.
         * No need to do this when operator isn't running since this will be done
         * at start point.
         */
        if(!aec_reference_update_stream_and_validate_channels(op_data, NULL, NULL))
84200f46:	04 00       	r2 = Null + Null;
84200f48:	03 00       	r1 = Null + Null;
84200f4a:	3a 00       	r0 = r5 + Null;
84200f4c:	0b f0 39 e3 	call (m) $_aec_reference_update_stream_and_validate_channels;
        {
            /* Not the best way to indicate failure, but best we can do */
            return FALSE;
84200f50:	11 00       	rMAC = r0 + Null;
84200f52:	02 00       	r0 = Null + Null;
84200f54:	08 04       	Null = rMAC - Null;
84200f56:	21 f0 42 ce 	if NE r0 = Null + 1;
84200f5a:	05 6e       	jump (m) Lc_aec_reference_set_rates_10;

84200f5c <Lc_aec_reference_set_rates_8>:
            SetMicChannelStatus(op_extra_data, 0);
            rebuild = TRUE;
        }
    }

    if(rebuild)
84200f5c:	0f fa 00 c2 	Null = r8 - Null;
84200f60:	f3 63       	if NE jump (m) Lc_aec_reference_set_rates_7;

84200f62 <Lc_aec_reference_set_rates_9>:
            /* Not the best way to indicate failure, but best we can do */
            return FALSE;
        }
    }

    return TRUE;
84200f62:	42 20       	r0 = Null + 1;

84200f64 <Lc_aec_reference_set_rates_10>:
}
84200f64:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84200f66:	d8 4c       	rts;

84200f68 <$_aec_reference_opmsg_get_ps_id>:

    return TRUE;
}

bool aec_reference_opmsg_get_ps_id(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200f68:	c8 1c       	pushm <FP(=SP), rLink>;
84200f6a:	19 00       	rMAC = r1 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84200f6c:	12 99       	r0 = M[r0 + 48];
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);

    patch_fn_shared(aec_reference);

    return cpsGetUcidMsgHandler(&op_extra_data->parms_def,op_extra_data->cap_id,message_data,resp_length,resp_data);
84200f6e:	29 1c       	pushm <r3>;
84200f70:	23 f0 59 88 	r1 = M[r0 + 356];
84200f74:	25 00       	r3 = r2 + Null;
84200f76:	02 f0 78 45 	r0 = r0 + 376;
84200f7a:	0c 00       	r2 = rMAC + Null;
84200f7c:	ef fd fb ff 	call (m) 0x6d2;
84200f80:	37 ea 
84200f82:	7f 4c       	SP = SP + -4;

84200f84 <Lc_aec_reference_opmsg_get_ps_id_2>:
}
84200f84:	c8 48       	popm <FP, rLink>;
84200f86:	d8 4c       	rts;

84200f88 <$_aec_reference_opmsg_mute_mic_output>:

    return TRUE;
}

bool aec_reference_opmsg_mute_mic_output(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200f88:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84200f8a:	16 99       	r4 = M[r0 + 48];
    bool mute_enable;

    patch_fn_shared(aec_reference);

    /* read the enable field */
    mute_enable  = (OPMSG_FIELD_GET(message_data, OPMSG_AEC_MUTE_MIC_OUTPUT, ENABLE)) != 0;
84200f8c:	d9 88       	rMAC = M[r1 + 12];
84200f8e:	07 00       	r5 = Null + Null;
84200f90:	89 c6       	rMAC = rMAC AND 0xffff;
84200f92:	21 f0 47 ce 	if NE r5 = Null + 1;
    L2_DBG_MSG1("ACE REFERENCE muting mic, mute=%d", mute_enable);
84200f96:	55 f1 02 f0 	r0 = Null + 357564765;
84200f9a:	5d 41 
84200f9c:	3b 00       	r1 = r5 + Null;
84200f9e:	ef fd fd ff 	call (m) 0x9b4;
84200fa2:	37 e0 

    if(NULL != op_extra_data->mic_mute_op)
84200fa4:	62 f0 9d 88 	r0 = M[r4 + 628];
84200fa8:	05 60       	if EQ jump (m) Lc_aec_reference_opmsg_mute_mic_output_3;

84200faa <Lc_aec_reference_opmsg_mute_mic_output_2>:
    {
        /* configure already running mute operator with simple ramping */
        cbops_mute_enable(op_extra_data->mic_mute_op, mute_enable, FALSE);
84200faa:	04 00       	r2 = Null + Null;
84200fac:	3b 00       	r1 = r5 + Null;
84200fae:	10 f0 25 e4 	call (m) $_cbops_mute_enable;

84200fb2 <Lc_aec_reference_opmsg_mute_mic_output_3>:
    }

    /* store the last mute config */
    op_extra_data->mic_mute_enable_config = mute_enable;
84200fb2:	67 f0 de 8e 	M[r4 + 888] = r5;

    return TRUE;
84200fb6:	42 20       	r0 = Null + 1;

84200fb8 <Lc_aec_reference_opmsg_mute_mic_output_4>:
}
84200fb8:	f2 48       	popm <FP, r4, r5, rLink>;
84200fba:	d8 4c       	rts;

84200fbc <$_aec_reference_opmsg_set_task_period>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool aec_reference_opmsg_set_task_period(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200fbc:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84200fbe:	1e 00       	r4 = r1 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84200fc0:	17 99       	r5 = M[r0 + 48];
bool aec_reference_opmsg_set_task_period(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);

    /* We cant change this setting while running */
    if (opmgr_op_is_running(op_data))
84200fc2:	10 f0 27 ef 	call (m) $_opmgr_op_is_running;
84200fc6:	10 04       	Null = r0 - Null;
84200fc8:	03 60       	if EQ jump (m) Lc_aec_reference_opmsg_set_task_period_3;

84200fca <Lc_aec_reference_opmsg_set_task_period_2>:
    {
        return FALSE;
84200fca:	02 00       	r0 = Null + Null;
84200fcc:	07 6e       	jump (m) Lc_aec_reference_opmsg_set_task_period_4;

84200fce <Lc_aec_reference_opmsg_set_task_period_3>:
    }

    /* get the task period */
    unsigned task_period = OPMSG_FIELD_GET(message_data, OPMSG_AEC_SET_TASK_PERIOD, TASK_PERIOD);
84200fce:	f1 88       	rMAC = M[r4 + 12];
84200fd0:	8b c6       	r1 = rMAC AND 0xffff;

    /* get decimation factor */
    unsigned decim_factor = OPMSG_FIELD_GET(message_data, OPMSG_AEC_SET_TASK_PERIOD, DECIM_FACTOR);
84200fd2:	31 89       	rMAC = M[r4 + 16];
84200fd4:	8c c6       	r2 = rMAC AND 0xffff;

    return aec_reference_set_task_period(op_extra_data, task_period, decim_factor);
84200fd6:	3a 00       	r0 = r5 + Null;
84200fd8:	03 4e       	call (m) $_aec_reference_set_task_period;

84200fda <Lc_aec_reference_opmsg_set_task_period_4>:
}
84200fda:	f2 48       	popm <FP, r4, r5, rLink>;
84200fdc:	d8 4c       	rts;

84200fde <$_aec_reference_set_task_period>:
 * \param decim_factor decimation factor for sidetone mixing task
 *
 * \return whether the task period update successfully
 */
bool aec_reference_set_task_period(AEC_REFERENCE_OP_DATA *op_extra_data, unsigned task_period, unsigned decim_factor)
{
84200fde:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84200fe0:	17 00       	r5 = r0 + Null;
84200fe2:	1e 00       	r4 = r1 + Null;
84200fe4:	20 09       	r6 = r2 + Null;
    /* check the limits */
    if(task_period > AEC_REFERENCE_MAX_TASK_PERIOD ||
       task_period < AEC_REFERENCE_MIN_TASK_PERIOD)
84200fe6:	60 f1 88 27 	Null = r4 - 5000;
84200fea:	08 f0 8d e0 	if HI jump (m) Lc_aec_reference_set_task_period_3;

84200fee <Lc_aec_reference_set_task_period_2>:
84200fee:	60 f0 e8 27 	Null = r4 - 1000;
84200ff2:	02 f0 89 e0 	if C jump (m) Lc_aec_reference_set_task_period_4;

84200ff6 <Lc_aec_reference_set_task_period_3>:
    {
        return FALSE;
84200ff6:	02 00       	r0 = Null + Null;
84200ff8:	5d 6e       	jump (m) Lc_aec_reference_set_task_period_12;

84200ffa <Lc_aec_reference_set_task_period_4>:
    }

    /* see if task period is an integer factor of a second */
    if(0 != (SECOND % task_period))
84200ffa:	00 f0 a2 f7 	r0 = Null + 1000000;
84200ffe:	40 42 
84201000:	ff fd b0 f0 	call (m) 0x171d6;
84201004:	37 ee 
84201006:	10 04       	Null = r0 - Null;
84201008:	f7 63       	if NE jump (m) Lc_aec_reference_set_task_period_3;

8420100a <Lc_aec_reference_set_task_period_5>:
    }

    /* Also we don't expect AEC_REFERENCE task period becoms
     * larger than system kick period
     */
    if(task_period > (unsigned)stream_if_get_system_kick_period())
8420100a:	ff fd 2e f0 	call (m) 0x6dc0;
8420100e:	37 ed 
84201010:	b0 04       	Null = r4 - r0;
84201012:	f8 ff e5 ef 	if HI jump (m) Lc_aec_reference_set_task_period_3;

84201016 <Lc_aec_reference_set_task_period_6>:

#ifdef AEC_REFERENCE_CAN_PERFORM_INPLACE_SIDETONE_MIXING
    /* if a decimation factor supplied it should be a factor of
     * task period
     */
    if(decim_factor > 1)
84201016:	80 f0 01 24 	Null = r6 - 1;
8420101a:	09 f0 95 e0 	if LS jump (m) Lc_aec_reference_set_task_period_8;

8420101e <Lc_aec_reference_set_task_period_7>:
    {
        if((task_period % decim_factor) != 0)
8420101e:	32 00       	r0 = r4 + Null;
84201020:	43 08       	r1 = r6 + Null;
84201022:	ff fd b0 f0 	call (m) 0x171d6;
84201026:	35 ed 
84201028:	10 04       	Null = r0 - Null;
8420102a:	e6 63       	if NE jump (m) Lc_aec_reference_set_task_period_3;

8420102c <Lc_18>:
8420102c:	02 6e       	jump (m) Lc_aec_reference_set_task_period_9;

8420102e <Lc_aec_reference_set_task_period_8>:
            return FALSE;
        }
    }
    else
    {
        decim_factor = 1;
8420102e:	08 71       	r6 = Null + 1;

84201030 <Lc_aec_reference_set_task_period_9>:
    }
    op_extra_data->task_decim_factor = decim_factor;
84201030:	78 f0 97 8e 	M[r5 + 604] = r6;
    op_extra_data->task_decim_counter = 0;
84201034:	70 f0 98 8e 	M[r5 + 608] = Null;
    op_extra_data->kick_period = task_period / decim_factor;
84201038:	32 00       	r0 = r4 + Null;
8420103a:	43 08       	r1 = r6 + Null;
8420103c:	ff fd b0 f0 	call (m) 0x171b8;
84201040:	3d eb 
84201042:	72 f0 94 8e 	M[r5 + 592] = r0;
    op_extra_data->kick_period_frac = frac_div(op_extra_data->kick_period, SECOND);
84201046:	00 f0 a1 f7 	rMAC = Null + 1000000;
8420104a:	40 42 
8420104c:	7f f2 1f d9 	rMACB = r0 ASHIFT -1 (56bit);
84201050:	00 f1 9f cd 	Div = rMACB / rMAC;
84201054:	c2 4c       	r0 = DivResult;
84201056:	72 f0 96 8e 	M[r5 + 600] = r0;
    op_extra_data->kick_period = task_period;
    decim_factor = 1;
#endif /* AEC_REFERENCE_CAN_PERFORM_INPLACE_SIDETONE_MIXING */

    /* All are fine, set the task period*/
    op_extra_data->task_period = task_period;
8420105a:	76 f0 63 8e 	M[r5 + 396] = r4;
    op_extra_data->task_frequency = (unsigned)SECOND/task_period;
8420105e:	33 00       	r1 = r4 + Null;
84201060:	0a 00       	r0 = rMAC + Null;
84201062:	ff fd b0 f0 	call (m) 0x171b8;
84201066:	37 ea 
84201068:	72 f0 92 8e 	M[r5 + 584] = r0;
    op_extra_data->task_period_frac = frac_div(task_period, SECOND);
8420106c:	00 f0 a1 f7 	rMAC = Null + 1000000;
84201070:	40 42 
84201072:	7f f6 1f d9 	rMACB = r4 ASHIFT -1 (56bit);
84201076:	00 f1 9f cd 	Div = rMACB / rMAC;
8420107a:	c2 4c       	r0 = DivResult;
8420107c:	72 f0 93 8e 	M[r5 + 588] = r0;
     * stage does an upsample by a factor of 2.1.
     * 48000.0 (fs in : 21/10) --> 100800.0 (fs internal : 7/16) --> 44100.0 (fs out)
     *
     * (2*task period) @100800
     */
    op_extra_data->resampler_temp_buffer_size = frac_mult(100800, 2*op_extra_data->task_period_frac) + 4;
84201080:	c3 f0 c0 51 	r1 = Null + 100800;
84201084:	12 54       	r0 = r0 LSHIFT 1;
84201086:	2f f3 42 c9 	r0 = r1 * r0 (frac);
8420108a:	11 21       	rMAC = r0 + 4;
8420108c:	71 f0 91 8e 	M[r5 + 580] = rMAC;
    op_extra_data->resampler_temp_buffer_size = MAX(op_extra_data->resampler_temp_buffer_size,
                                                        AEC_REF_RESAMPLER_TEMP_MIN_BUF_SIZE);
84201090:	10 f0 cc 24 	Null = rMAC - 204;
84201094:	02 f0 8d e0 	if C jump (m) Lc_aec_reference_set_task_period_11;

84201098 <Lc_aec_reference_set_task_period_10>:
84201098:	01 f0 cc 40 	rMAC = Null + 204;
8420109c:	71 f0 91 8e 	M[r5 + 580] = rMAC;

842010a0 <Lc_aec_reference_set_task_period_11>:

    L2_DBG_MSG2("AEC REFERENCE: task period set @%dus, decimation factor=%d", task_period, decim_factor);
842010a0:	55 f1 02 f0 	r0 = Null + 357564589;
842010a4:	ad 40 
842010a6:	44 08       	r2 = r6 + Null;
842010a8:	33 00       	r1 = r4 + Null;
842010aa:	ef fd fc ff 	call (m) 0x9c8;
842010ae:	3f e8 

    return TRUE;
842010b0:	42 20       	r0 = Null + 1;

842010b2 <Lc_aec_reference_set_task_period_12>:
}
842010b2:	f3 48       	popm <FP, r4, r5, r6, rLink>;
842010b4:	d8 4c       	rts;

842010b6 <$_aec_reference_opmsg_enable_mic_sync>:
 *             backend input and output are from same clock
 * Note: the msaage shall not be sent when any MIC/OUTPUT/REF
 *       terminal is connected.
 */
bool aec_reference_opmsg_enable_mic_sync(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842010b6:	c8 1c       	pushm <FP(=SP), rLink>;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
842010b8:	11 99       	rMAC = M[r0 + 48];
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    patch_fn_shared(aec_reference);

    if((NULL != op_extra_data->input_stream[AEC_REF_MIC_TERMINAL1]) ||
       (NULL != op_extra_data->output_stream[AEC_REF_REFERENCE_TERMINAL]) ||
       (NULL != op_extra_data->input_stream[AEC_REF_OUTPUT_TERMINAL1]))
842010ba:	8a 88       	r0 = M[rMAC + 8];
842010bc:	05 62       	if NE jump (m) Lc_aec_reference_opmsg_enable_mic_sync_4;

842010be <Lc_aec_reference_opmsg_enable_mic_sync_2>:
842010be:	0a a8       	r0 = M[rMAC + 64];
842010c0:	03 62       	if NE jump (m) Lc_aec_reference_opmsg_enable_mic_sync_4;

842010c2 <Lc_aec_reference_opmsg_enable_mic_sync_3>:
842010c2:	ca 88       	r0 = M[rMAC + 12];
842010c4:	03 60       	if EQ jump (m) Lc_aec_reference_opmsg_enable_mic_sync_5;

842010c6 <Lc_aec_reference_opmsg_enable_mic_sync_4>:
    {
        /* This message can be handled only if MIC and REF are disconnected */
        return FALSE;
842010c6:	02 00       	r0 = Null + Null;
842010c8:	0f 6e       	jump (m) Lc_aec_reference_opmsg_enable_mic_sync_6;

842010ca <Lc_aec_reference_opmsg_enable_mic_sync_5>:
    }

    /* read the enable field */
    op_extra_data->mic_sync_enable = (OPMSG_FIELD_GET(message_data, OPMSG_AEC_SAME_INPUT_OUTPUT_CLOCK_SOURCE, SAME_CLK_SRC)) != 0;
842010ca:	da 88       	r0 = M[r1 + 12];
842010cc:	03 00       	r1 = Null + Null;
842010ce:	92 c6       	r0 = r0 AND 0xffff;
842010d0:	21 f0 43 ce 	if NE r1 = Null + 1;
842010d4:	13 f0 d4 8e 	M[rMAC + 848] = r1;
    L2_DBG_MSG1("ACE REFERENCE input-output use same clock: ", op_extra_data->mic_sync_enable);
842010d8:	55 f1 02 f0 	r0 = Null + 357564545;
842010dc:	81 40 
842010de:	ef fd fc ff 	call (m) 0x9b4;
842010e2:	37 e6 

    return TRUE;
842010e4:	42 20       	r0 = Null + 1;

842010e6 <Lc_aec_reference_opmsg_enable_mic_sync_6>:
}
842010e6:	c8 48       	popm <FP, rLink>;
842010e8:	d8 4c       	rts;

842010ea <$_aec_reference_opmsg_set_buffer_size>:
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool aec_reference_opmsg_set_buffer_size(OPERATOR_DATA *op_data, void *message_data,
                                         unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842010ea:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
842010ec:	28 f0 0c 88 	r6 = M[r0 + 48];
                                         unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{

    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    /* get the required buffer size */
    unsigned buffer_size = OPMSG_FIELD_GET(message_data, OPMSG_COMMON_SET_TERMINAL_BUFFER_SIZE, BUFFER_SIZE);
842010f0:	d9 88       	rMAC = M[r1 + 12];
842010f2:	8e c6       	r4 = rMAC AND 0xffff;
    /* get the sink terminals that need configuration */
    unsigned sinks = OPMSG_FIELD_GET(message_data, OPMSG_COMMON_SET_TERMINAL_BUFFER_SIZE,
                                     SINKS);
842010f4:	19 89       	rMAC = M[r1 + 16];
    /* get the source terminals that need configuration */
    unsigned sources = OPMSG_FIELD_GET(message_data, OPMSG_COMMON_SET_TERMINAL_BUFFER_SIZE,
                                       SOURCES);
842010f6:	0f c0       	r5 = rMAC AND 0x1;
842010f8:	59 89       	rMAC = M[r1 + 20];

    /* Output buffer size is allowd to change if none of outputs are connected,
     * Note: We allow buffer size change while the operator is running, only the
     * relevant path must be not running.
     */
    if(sources != 0)
842010fa:	49 c1       	rMAC = rMAC AND 0x8;
842010fc:	16 60       	if EQ jump (m) Lc_aec_reference_opmsg_set_buffer_size_10;

842010fe <Lc_aec_reference_opmsg_set_buffer_size_2>:
    {
        unsigned idx;

        /* No output must be connected */
        for(idx = 0; idx<MAX_NUMBER_MICS; idx++)
842010fe:	02 00       	r0 = Null + Null;
84201100:	04 6e       	jump (m) Lc_aec_reference_opmsg_set_buffer_size_4;

84201102 <Lc_aec_reference_opmsg_set_buffer_size_3>:
    }
}

inline static unsigned OutputTerminalByIndex(unsigned i)
{
    if(i<4)
84201102:	10 25       	Null = r0 - 4;
84201104:	02 f0 89 e0 	if C jump (m) Lc_aec_reference_opmsg_set_buffer_size_5;

84201108 <Lc_aec_reference_opmsg_set_buffer_size_4>:
    {
        return (i + AEC_REF_OUTPUT_TERMINAL1);
84201108:	d3 20       	r1 = r0 + 3;
8420110a:	02 6e       	jump (m) Lc_aec_reference_opmsg_set_buffer_size_6;

8420110c <Lc_aec_reference_opmsg_set_buffer_size_5>:
    }
    else
    {
        return ((i-4) + AEC_REF_OUTPUT_TERMINAL5);
8420110c:	53 22       	r1 = r0 + 9;

8420110e <Lc_aec_reference_opmsg_set_buffer_size_6>:
        {
            if(NULL != op_extra_data->output_stream[OutputTerminalByIndex(idx)])
8420110e:	84 f0 40 20 	r2 = r6 + 64;
84201112:	5b 54       	r1 = r1 LSHIFT 2;
84201114:	e3 e8       	r1 = M[r2 + r1];
84201116:	03 60       	if EQ jump (m) Lc_aec_reference_opmsg_set_buffer_size_8;

84201118 <Lc_aec_reference_opmsg_set_buffer_size_7>:
            {
                return FALSE;
84201118:	02 00       	r0 = Null + Null;
8420111a:	2f 6e       	jump (m) Lc_aec_reference_opmsg_set_buffer_size_22;

8420111c <Lc_aec_reference_opmsg_set_buffer_size_8>:
    if(sources != 0)
    {
        unsigned idx;

        /* No output must be connected */
        for(idx = 0; idx<MAX_NUMBER_MICS; idx++)
8420111c:	52 20       	r0 = r0 + 1;
8420111e:	10 26       	Null = r0 - 8;
84201120:	f1 65       	if NC jump (m) Lc_aec_reference_opmsg_set_buffer_size_3;

84201122 <Lc_aec_reference_opmsg_set_buffer_size_9>:
            {
                return FALSE;
            }
        }
        /* Also REFERENCE must also be disconnected */
        if(NULL != op_extra_data->output_stream[AEC_REF_REFERENCE_TERMINAL])
84201122:	82 f0 10 88 	r0 = M[r6 + 64];
84201126:	f9 63       	if NE jump (m) Lc_aec_reference_opmsg_set_buffer_size_7;

84201128 <Lc_aec_reference_opmsg_set_buffer_size_10>:

    /* Input buffer size is allowd to change if none of inputs are connected,
     * Note: We allow buffer size change while the operator is running, only the
     * relevant path must be not running.
     */
    if(sinks != 0)
84201128:	38 04       	Null = r5 - Null;
8420112a:	10 60       	if EQ jump (m) Lc_aec_reference_opmsg_set_buffer_size_17;

8420112c <Lc_aec_reference_opmsg_set_buffer_size_11>:
    {
        unsigned idx;

        /* No input must be connected */
        for(idx = 0; idx < MAX_NUMBER_SPEAKERS; idx++)
8420112c:	02 00       	r0 = Null + Null;
8420112e:	04 6e       	jump (m) Lc_aec_reference_opmsg_set_buffer_size_13;

84201130 <Lc_aec_reference_opmsg_set_buffer_size_12>:
        {
            if(NULL != op_extra_data->input_stream[SpeakerInputTerminalByIndex(idx)])
84201130:	90 24       	Null = r0 - 2;
84201132:	02 f0 89 e0 	if C jump (m) Lc_aec_reference_opmsg_set_buffer_size_14;

84201136 <Lc_aec_reference_opmsg_set_buffer_size_13>:
84201136:	13 00       	r1 = r0 + Null;
84201138:	02 6e       	jump (m) Lc_aec_reference_opmsg_set_buffer_size_15;

8420113a <Lc_aec_reference_opmsg_set_buffer_size_14>:
8420113a:	13 21       	r1 = r0 + 4;

8420113c <Lc_aec_reference_opmsg_set_buffer_size_15>:
8420113c:	5b 54       	r1 = r1 LSHIFT 2;
8420113e:	83 f0 03 e8 	r1 = M[r6 + r1];
84201142:	eb 63       	if NE jump (m) Lc_aec_reference_opmsg_set_buffer_size_7;

84201144 <Lc_aec_reference_opmsg_set_buffer_size_16>:
    if(sinks != 0)
    {
        unsigned idx;

        /* No input must be connected */
        for(idx = 0; idx < MAX_NUMBER_SPEAKERS; idx++)
84201144:	52 20       	r0 = r0 + 1;
84201146:	10 26       	Null = r0 - 8;
84201148:	f4 65       	if NC jump (m) Lc_aec_reference_opmsg_set_buffer_size_12;

8420114a <Lc_aec_reference_opmsg_set_buffer_size_17>:
                return FALSE;
            }
        }
    }

    if(sources != 0)
8420114a:	08 04       	Null = rMAC - Null;
8420114c:	0a 60       	if EQ jump (m) Lc_aec_reference_opmsg_set_buffer_size_19;

8420114e <Lc_aec_reference_opmsg_set_buffer_size_18>:
    {
        /* set the output buffer size */
        op_extra_data->output_buffer_size = buffer_size;
8420114e:	86 f0 d5 8e 	M[r6 + 852] = r4;
        L2_DBG_MSG1("AEC_REFERENCE: minimum output buffer size set to %d words ", buffer_size);
84201152:	55 f1 02 f0 	r0 = Null + 357564648;
84201156:	e8 40 
84201158:	33 00       	r1 = r4 + Null;
8420115a:	ef fd fc ff 	call (m) 0x9b4;
8420115e:	3b e2 

84201160 <Lc_aec_reference_opmsg_set_buffer_size_19>:
    }

    if(sinks != 0)
84201160:	38 04       	Null = r5 - Null;
84201162:	0a 60       	if EQ jump (m) Lc_aec_reference_opmsg_set_buffer_size_21;

84201164 <Lc_aec_reference_opmsg_set_buffer_size_20>:
    {
        op_extra_data->input_buffer_size = buffer_size;
84201164:	86 f0 d6 8e 	M[r6 + 856] = r4;
        L2_DBG_MSG1("AEC_REFERENCE: minimum input buffer size set to %d words ", buffer_size);
84201168:	55 f1 02 f0 	r0 = Null + 357564707;
8420116c:	23 41 
8420116e:	33 00       	r1 = r4 + Null;
84201170:	ef fd fc ff 	call (m) 0x9b4;
84201174:	25 e2 

84201176 <Lc_aec_reference_opmsg_set_buffer_size_21>:
    }

    return TRUE;
84201176:	42 20       	r0 = Null + 1;

84201178 <Lc_aec_reference_opmsg_set_buffer_size_22>:
}
84201178:	f3 48       	popm <FP, r4, r5, r6, rLink>;
8420117a:	d8 4c       	rts;

8420117c <$_aec_reference_update_sidetone_status>:
    if((op_extra_data->params.OFFSET_CONFIG & AEC_REFERENCE_CONFIG_SIDETONE_DISABLE) == 0)
    {
        /* a sidetone path will be formed whenever
         * we have both speaker and mic paths
         */
        op_extra_data->using_sidetone = SIDETONE_ENABLE_FLAG;
8420117c:	21 f0 2d 88 	rMAC = M[r0 + 180];
84201180:	03 00       	r1 = Null + Null;
84201182:	49 c1       	rMAC = rMAC AND 0x8;
84201184:	a0 f0 43 ce 	if EQ r1 = Null + 2;
84201188:	23 f0 7a 8e 	M[r0 + 488] = r1;
        /* User doesn't want sidetone at all */
        op_extra_data->using_sidetone = 0;
    }

    /* see if we need sidetone */
    if((op_extra_data->num_mic_channels > 0) && (op_extra_data->num_spkr_channels > 0))
8420118c:	20 f0 78 88 	Null = M[r0 + 480];
84201190:	0a 60       	if EQ jump (m) Lc_aec_reference_update_sidetone_status_4;

84201192 <Lc_aec_reference_update_sidetone_status_2>:
84201192:	20 f0 77 88 	Null = M[r0 + 476];
84201196:	07 60       	if EQ jump (m) Lc_aec_reference_update_sidetone_status_4;

84201198 <Lc_aec_reference_update_sidetone_status_3>:
    {
        op_extra_data->using_sidetone |= SIDETONE_MIC_SPKR_FLAG;
84201198:	21 f0 7a 88 	rMAC = M[r0 + 488];
8420119c:	09 c8       	rMAC = rMAC OR 0x1;
8420119e:	21 f0 7a 8e 	M[r0 + 488] = rMAC;
842011a2:	06 6e       	jump (m) Lc_aec_reference_update_sidetone_status_5;

842011a4 <Lc_aec_reference_update_sidetone_status_4>:
    }
    else
    {
        op_extra_data->using_sidetone &= SIDETONE_ENABLE_FLAG;
842011a4:	21 f0 7a 88 	rMAC = M[r0 + 488];
842011a8:	49 c0       	rMAC = rMAC AND 0x2;
842011aa:	21 f0 7a 8e 	M[r0 + 488] = rMAC;

842011ae <Lc_aec_reference_update_sidetone_status_5>:
842011ae:	d8 4c       	rts;

842011b0 <$_aec_reference_spkr_check_external_rate_adjust_op>:
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 *
 */
void aec_reference_spkr_check_external_rate_adjust_op(AEC_REFERENCE_OP_DATA *op_extra_data)
{
842011b0:	f1 1d       	pushm <FP(=SP), r4, rLink>, SP = SP + 0x10;
842011b2:	16 00       	r4 = r0 + Null;
    uint32 val;
    if(get_override_ep_rate_adjust_op(op_extra_data->spkr_endpoint, &val) && val != 0)
842011b4:	c3 10       	r1 = FP + 12;
842011b6:	62 f0 80 88 	r0 = M[r4 + 512];
842011ba:	0f f0 3b ef 	call (m) $_get_override_ep_rate_adjust_op;
842011be:	10 04       	Null = r0 - Null;
842011c0:	13 60       	if EQ jump (m) Lc_aec_reference_spkr_check_external_rate_adjust_op_4;

842011c2 <Lc_aec_reference_spkr_check_external_rate_adjust_op_2>:
842011c2:	1a d8       	r0 = M[FP + 12];
842011c4:	11 60       	if EQ jump (m) Lc_aec_reference_spkr_check_external_rate_adjust_op_4;

842011c6 <Lc_aec_reference_spkr_check_external_rate_adjust_op_3>:
    {
        /* Speaker graph will use an external RATE_ADJUST operator for
         * performing rate adjustment.
         */
        op_extra_data->spkr_ext_rate_adjust_op = val;
842011c6:	62 f0 ae 8e 	M[r4 + 696] = r0;

        /* if we have standalone rate adjust, we will use it, even
         * if spkr is able to use HW warping */
        op_extra_data->spkr_rate_ability = RATEMATCHING_SUPPORT_SW;
842011ca:	41 20       	rMAC = Null + 1;
842011cc:	61 f0 6f 8e 	M[r4 + 444] = rMAC;

        /* Speaker path will use this, so not in pass-through mode */
        stream_delegate_rate_adjust_set_passthrough_mode(op_extra_data->spkr_ext_rate_adjust_op, FALSE);
842011d0:	03 00       	r1 = Null + Null;
842011d2:	10 f0 3d e2 	call (m) $_stream_delegate_rate_adjust_set_passthrough_mode;

        L2_DBG_MSG1("AEC_REFERENCE: Speaker path will use standalone rate adjust: opid=0x%x", val);
842011d6:	1b d8       	r1 = M[FP + 12];
842011d8:	55 f1 02 f0 	r0 = Null + 357564832;
842011dc:	a0 41 
842011de:	ef fd fb ff 	call (m) 0x9b4;
842011e2:	37 ee 
842011e4:	03 6e       	jump (m) Lc_aec_reference_spkr_check_external_rate_adjust_op_5;

842011e6 <Lc_aec_reference_spkr_check_external_rate_adjust_op_4>:

        return;
    }

    /* No external operator found or needed */
    op_extra_data->spkr_ext_rate_adjust_op = 0;
842011e6:	60 f0 ae 8e 	M[r4 + 696] = Null;

842011ea <Lc_aec_reference_spkr_check_external_rate_adjust_op_5>:

    return;
}
842011ea:	f1 49       	SP = SP - 0x10, popm <FP, r4, rLink>;
842011ec:	d8 4c       	rts;

842011ee <$_aec_reference_mic_check_external_rate_adjust_op>:
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 *
 * \return TRUE if there is a standalone rate adjust operator linked to the microphne path
 */
void aec_reference_mic_check_external_rate_adjust_op(AEC_REFERENCE_OP_DATA *op_extra_data)
{
842011ee:	f1 1d       	pushm <FP(=SP), r4, rLink>, SP = SP + 0x10;
842011f0:	16 00       	r4 = r0 + Null;
    uint32 val;
    if(get_override_ep_rate_adjust_op(op_extra_data->mic_endpoint, &val) && val != 0)
842011f2:	c3 10       	r1 = FP + 12;
842011f4:	62 f0 7f 88 	r0 = M[r4 + 508];
842011f8:	0f f0 3d ed 	call (m) $_get_override_ep_rate_adjust_op;
842011fc:	10 04       	Null = r0 - Null;
842011fe:	1e 60       	if EQ jump (m) Lc_aec_reference_mic_check_external_rate_adjust_op_6;

84201200 <Lc_aec_reference_mic_check_external_rate_adjust_op_2>:
84201200:	1a d8       	r0 = M[FP + 12];
84201202:	1c 60       	if EQ jump (m) Lc_aec_reference_mic_check_external_rate_adjust_op_6;

84201204 <Lc_aec_reference_mic_check_external_rate_adjust_op_3>:
    {
        /* If we have been told to synchronise mic to speaker input then
         * we shouldn't have been told to use standalone rate adjust.
         */
        PL_ASSERT(!op_extra_data->mic_sync_enable);
84201204:	60 f0 d4 88 	Null = M[r4 + 848];
84201208:	09 60       	if EQ jump (m) Lc_aec_reference_mic_check_external_rate_adjust_op_5;

8420120a <Lc_aec_reference_mic_check_external_rate_adjust_op_4>:
8420120a:	03 f0 56 61 	r1 = Null + 4438;
8420120e:	02 f0 13 60 	r0 = Null + 4115;
84201212:	ff fd 96 f0 	call (m) 0x13f12;
84201216:	21 e8 
84201218:	13 6e       	jump (m) Lc_aec_reference_mic_check_external_rate_adjust_op_7;

8420121a <Lc_aec_reference_mic_check_external_rate_adjust_op_5>:

        /* Microphone graph will use an external RATE_ADJUST operator for
         * performing rate adjustment.
         */
        op_extra_data->mic_ext_rate_adjust_op = val;
8420121a:	62 f0 ad 8e 	M[r4 + 692] = r0;

        /* if we have standalone rate adjust, we will use it, even
         * if mic is able to use HW warping */
        op_extra_data->mic_rate_ability = RATEMATCHING_SUPPORT_SW;
8420121e:	41 20       	rMAC = Null + 1;
84201220:	61 f0 67 8e 	M[r4 + 412] = rMAC;

        /* Microphone path will use this, so not in pass-through mode */
        stream_delegate_rate_adjust_set_passthrough_mode(op_extra_data->mic_ext_rate_adjust_op, FALSE);
84201224:	03 00       	r1 = Null + Null;
84201226:	10 f0 29 e0 	call (m) $_stream_delegate_rate_adjust_set_passthrough_mode;

        L2_DBG_MSG1("AEC_REFERENCE: Microphone path will use standalone rate adjust: opid=0x%x", val);
8420122a:	1b d8       	r1 = M[FP + 12];
8420122c:	55 f1 02 f0 	r0 = Null + 357564903;
84201230:	e7 41 
84201232:	ef fd fb ff 	call (m) 0x9b4;
84201236:	23 ec 
84201238:	03 6e       	jump (m) Lc_aec_reference_mic_check_external_rate_adjust_op_7;

8420123a <Lc_aec_reference_mic_check_external_rate_adjust_op_6>:

        return;
    }

    /* No external operator found or needed */
    op_extra_data->mic_ext_rate_adjust_op = 0;
8420123a:	60 f0 ad 8e 	M[r4 + 692] = Null;

8420123e <Lc_aec_reference_mic_check_external_rate_adjust_op_7>:

    return;
}
8420123e:	f1 49       	SP = SP - 0x10, popm <FP, r4, rLink>;
84201240:	d8 4c       	rts;

84201242 <$_aec_reference_opmsg_set_ttp_latency>:
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool aec_reference_opmsg_set_ttp_latency(OPERATOR_DATA *op_data, void *message_data,
                                     unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84201242:	f1 1c       	pushm <FP(=SP), r4, rLink>;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84201244:	16 99       	r4 = M[r0 + 48];
                                     unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);

    /* We cant change this setting while running */
    if(op_data->state == OP_RUNNING)
84201246:	11 b0       	rMAC = MBS[r0 + 24];
84201248:	03 62       	if NE jump (m) Lc_aec_reference_opmsg_set_ttp_latency_3;

8420124a <Lc_aec_reference_opmsg_set_ttp_latency_2>:

    {
        return FALSE;
8420124a:	02 00       	r0 = Null + Null;
8420124c:	15 6e       	jump (m) Lc_aec_reference_opmsg_set_ttp_latency_4;

8420124e <Lc_aec_reference_opmsg_set_ttp_latency_3>:
    }

    /* get the latency from payload */
    op_extra_data->mic_target_latency = ttp_get_msg_latency(message_data);
8420124e:	1a 00       	r0 = r1 + Null;
84201250:	ff fd aa f0 	call (m) 0x16706;
84201254:	37 e5 
84201256:	13 00       	r1 = r0 + Null;
84201258:	63 f0 ce 8e 	M[r4 + 824] = r1;

    /* configure latency */
    ttp_configure_latency(op_extra_data->mic_time_to_play, op_extra_data->mic_target_latency);
8420125c:	62 f0 cf 88 	r0 = M[r4 + 828];
84201260:	ff fd aa f0 	call (m) 0x167da;
84201264:	3b eb 

    /* receiving this message (with latenct != 0) will enable metadata generation */
    op_extra_data->mic_metadata_enable = op_extra_data->mic_target_latency != 0;
84201266:	01 00       	rMAC = Null + Null;
84201268:	60 f0 ce 88 	Null = M[r4 + 824];
8420126c:	21 f0 41 ce 	if NE rMAC = Null + 1;
84201270:	61 f0 cd 8e 	M[r4 + 820] = rMAC;

    return TRUE;
84201274:	42 20       	r0 = Null + 1;

84201276 <Lc_aec_reference_opmsg_set_ttp_latency_4>:
}
84201276:	f1 48       	popm <FP, r4, rLink>;
84201278:	d8 4c       	rts;

8420127a <$_aec_reference_opmsg_set_ttp_params>:
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool aec_reference_opmsg_set_ttp_params(OPERATOR_DATA *op_data, void *message_data,
                                    unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420127a:	f1 1d       	pushm <FP(=SP), r4, rLink>, SP = SP + 0x10;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
8420127c:	16 99       	r4 = M[r0 + 48];

    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    ttp_params params;

    /* We cant change this setting while running */
    if(op_data->state == OP_RUNNING)
8420127e:	11 b0       	rMAC = MBS[r0 + 24];
84201280:	03 62       	if NE jump (m) Lc_aec_reference_opmsg_set_ttp_params_3;

84201282 <Lc_aec_reference_opmsg_set_ttp_params_2>:
    {
        return FALSE;
84201282:	02 00       	r0 = Null + Null;
84201284:	0c 6e       	jump (m) Lc_aec_reference_opmsg_set_ttp_params_4;

84201286 <Lc_aec_reference_opmsg_set_ttp_params_3>:
    }

    /* configure ttp params */
    ttp_get_msg_params(&params, message_data);
84201286:	c2 10       	r0 = FP + 12;
84201288:	ff fd aa f0 	call (m) 0x16786;
8420128c:	3f e7 
    ttp_configure_params(op_extra_data->mic_time_to_play, &params);
8420128e:	c3 10       	r1 = FP + 12;
84201290:	62 f0 cf 88 	r0 = M[r4 + 828];
84201294:	ff fd aa f0 	call (m) 0x16822;
84201298:	2f ec 

    return TRUE;
8420129a:	42 20       	r0 = Null + 1;

8420129c <Lc_aec_reference_opmsg_set_ttp_params_4>:
}
8420129c:	f1 49       	SP = SP - 0x10, popm <FP, r4, rLink>;
8420129e:	d8 4c       	rts;

842012a0 <$_aec_reference_opmsg_set_latency_limits>:
 * aec_reference_opmsg_set_latency_limits
 * \brief message handler to set ttp latency limits for mic output channels
 */
bool aec_reference_opmsg_set_latency_limits(OPERATOR_DATA *op_data, void *message_data,
                                        unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842012a0:	f1 1d       	pushm <FP(=SP), r4, rLink>, SP = SP + 0x10;
842012a2:	19 00       	rMAC = r1 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
842012a4:	16 99       	r4 = M[r0 + 48];
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    TIME_INTERVAL min_latency, max_latency;

    /* get the limits from the message payload and configure the time to play limits */
    ttp_get_msg_latency_limits(message_data, &min_latency, &max_latency);
842012a6:	04 11       	r2 = FP + 16;
842012a8:	c3 10       	r1 = FP + 12;
842012aa:	0a 00       	r0 = rMAC + Null;
842012ac:	ff fd aa f0 	call (m) 0x1673c;
842012b0:	31 e4 
    ttp_configure_latency_limits(op_extra_data->mic_time_to_play, min_latency, max_latency);
842012b2:	24 d8       	r2 = M[FP + 16];
842012b4:	1b d8       	r1 = M[FP + 12];
842012b6:	62 f0 cf 88 	r0 = M[r4 + 828];
842012ba:	ff fd aa f0 	call (m) 0x167fa;
842012be:	21 ea 

    return TRUE;
842012c0:	42 20       	r0 = Null + 1;

842012c2 <Lc_aec_reference_opmsg_set_latency_limits_2>:
}
842012c2:	f1 49       	SP = SP - 0x10, popm <FP, r4, rLink>;
842012c4:	d8 4c       	rts;

842012c6 <$_aec_reference_mic_generate_metadata_with_ttp>:
 * \brief generates metadata for microphone output channels
 * \param op_extra_data Pointer to AEC_REFERENCE operator specific data
 * \param samples number of samples in the to-be-copied chunk
 */
void aec_reference_mic_generate_metadata_with_ttp(AEC_REFERENCE_OP_DATA *op_extra_data, unsigned samples)
{
842012c6:	f6 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x20;
842012c8:	10 09       	r6 = r0 + Null;
842012ca:	8b f0 ca 88 	r9 = M[r6 + 808];
842012ce:	1f 00       	r5 = r1 + Null;
    metadata_tag *mtag;
    unsigned b4idx, afteridx;
    tCbuffer *met_buf = op_extra_data->mic_metadata_buffer;

    /* no update needed if no new samples arrived */
    if(samples == 0)
842012d0:	6b 60       	if EQ jump (m) Lc_aec_reference_mic_generate_metadata_with_ttp_12;

842012d2 <Lc_aec_reference_mic_generate_metadata_with_ttp_2>:
    {
        return;
    }

    /* if previous tag was incomplete, we need first to complete the tag */
    if(op_extra_data->mic_metadata_tag_left_words > 0)
842012d2:	81 f0 cb 88 	rMAC = M[r6 + 812];
842012d6:	15 60       	if EQ jump (m) Lc_aec_reference_mic_generate_metadata_with_ttp_6;

842012d8 <Lc_aec_reference_mic_generate_metadata_with_ttp_3>:
    {
        /* last written tag was incomplete, we keep adding
         * Null tag until full length of incomplete tag is
         * covered.
         */
        unsigned null_tag_len = op_extra_data->mic_metadata_tag_left_words;
842012d8:	0e 00       	r4 = rMAC + Null;
        if(null_tag_len > samples)
842012da:	c8 05       	Null = rMAC - r5;
842012dc:	09 f0 87 e0 	if LS jump (m) Lc_aec_reference_mic_generate_metadata_with_ttp_5;

842012e0 <Lc_aec_reference_mic_generate_metadata_with_ttp_4>:
        {
            null_tag_len = samples;
842012e0:	3e 00       	r4 = r5 + Null;

842012e2 <Lc_aec_reference_mic_generate_metadata_with_ttp_5>:
        }

        /* append Null tag, with length = null_tag_len */
        b4idx = 0;
        afteridx = null_tag_len*OCTETS_PER_SAMPLE;
842012e2:	75 54       	r3 = r4 LSHIFT 2;
        buff_metadata_append(met_buf, NULL, b4idx, afteridx);
842012e4:	04 00       	r2 = Null + Null;
842012e6:	03 00       	r1 = Null + Null;
842012e8:	5a 08       	r0 = r9 + Null;
842012ea:	ff fd 83 f0 	call (m) 0x11adc;
842012ee:	33 ef 

        /* update amount left */
        op_extra_data->mic_metadata_tag_left_words -= null_tag_len;
842012f0:	81 f0 cb 88 	rMAC = M[r6 + 812];
842012f4:	89 05       	rMAC = rMAC - r4;
842012f6:	81 f0 cb 8e 	M[r6 + 812] = rMAC;
        samples -= null_tag_len;
842012fa:	bf 05       	r5 = r5 - r4;
        if(samples == 0)
842012fc:	38 04       	Null = r5 - Null;
842012fe:	54 60       	if EQ jump (m) Lc_aec_reference_mic_generate_metadata_with_ttp_12;

84201300 <Lc_aec_reference_mic_generate_metadata_with_ttp_6>:
        }
    }

    /* create a new tag to append */
    b4idx = 0;
    afteridx = samples*OCTETS_PER_SAMPLE;
84201300:	7a 54       	r0 = r5 LSHIFT 2;
84201302:	42 de       	M[FP + 32] = r0;
    mtag = buff_metadata_new_tag();
84201304:	ff fd 82 f0 	call (m) 0x11862;
84201308:	3f ea 
8420130a:	16 00       	r4 = r0 + Null;
    if (mtag != NULL)
8420130c:	46 60       	if EQ jump (m) Lc_aec_reference_mic_generate_metadata_with_ttp_11;

8420130e <Lc_aec_reference_mic_generate_metadata_with_ttp_7>:
    {
        /* calculating time of arrival for first sample of the tag,
         * we do that by looking how many samples are in the mic buffer,
         * this could be short by up to 1 sample as our reading isn't aligned.
         */
        TIME current_time = hal_get_time();
8420130e:	ff fd 82 f1 	call (m) 0x317e8;
84201312:	3b e6 
84201314:	12 09       	r8 = r0 + Null;

        /* amount of data in the mic buffer */
        unsigned amount_in_buffer =
            cbuffer_calc_amount_data_in_words(op_extra_data->input_stream[AEC_REF_MIC_TERMINAL1]);
84201316:	82 f0 02 88 	r0 = M[r6 + 8];
8420131a:	ff fd 57 f1 	call (m) 0x2c208;
8420131e:	2f e7 

        /* convert samples to time,
         * Note: some inaccuracies because of rate adjustment, but jitter will be filtered by ttp filter */
        INTERVAL time_passed = (INTERVAL) (((uint48)(amount_in_buffer)*SECOND)/op_extra_data->mic_rate) +
            (INTERVAL) (((uint48)(samples)*SECOND)/op_extra_data->output_rate);
84201320:	00 f0 42 ff 	rMAC = r0 * 0.00023283064365386962890625 (UU);
84201324:	40 f2 11 cc 
84201328:	84 f0 66 88 	r2 = M[r6 + 408];
8420132c:	05 00       	r3 = Null + Null;
8420132e:	09 50       	rMAC = rMAC LSHIFT -1 (56bit);
84201330:	00 f1 d3 c8 	r1 = rMAC LSHIFT 0;
84201334:	ca 57       	r0 = rMAC LSHIFT 32;
84201336:	ff fd ae f0 	call (m) 0x17130;
8420133a:	3b ef 
8420133c:	11 09       	r7 = r0 + Null;
8420133e:	00 f0 42 ff 	rMAC = r5 * 0.00023283064365386962890625 (UU);
84201342:	40 f7 11 cc 
84201346:	84 f0 65 88 	r2 = M[r6 + 404];
8420134a:	05 00       	r3 = Null + Null;
8420134c:	09 50       	rMAC = rMAC LSHIFT -1 (56bit);
8420134e:	00 f1 d3 c8 	r1 = rMAC LSHIFT 0;
84201352:	ca 57       	r0 = rMAC LSHIFT 32;
84201354:	ff fd ae f0 	call (m) 0x17130;
84201358:	3d ee 
8420135a:	11 00       	rMAC = r0 + Null;
8420135c:	49 0c       	rMAC = r7 + rMAC;

        TIME time_of_arrival = time_sub(current_time, time_passed);
8420135e:	1f fa 03 c2 	r1 = r8 - rMAC;

        /* see if we have minimum amount for tag */
        if(samples >= op_extra_data->mic_metadata_min_tag_len)
84201362:	82 f0 cc 88 	r0 = M[r6 + 816];
84201366:	b8 04       	Null = r5 - r0;
84201368:	04 64       	if NC jump (m) Lc_aec_reference_mic_generate_metadata_with_ttp_9;

8420136a <Lc_aec_reference_mic_generate_metadata_with_ttp_8>:
        {
            /* we have enough new samples to append a complete tag */
            mtag->length = samples*OCTETS_PER_SAMPLE;
8420136a:	7a 54       	r0 = r5 LSHIFT 2;
8420136c:	f2 8e       	M[r4 + 12] = r0;
8420136e:	08 6e       	jump (m) Lc_aec_reference_mic_generate_metadata_with_ttp_10;

84201370 <Lc_aec_reference_mic_generate_metadata_with_ttp_9>:
             * new complete tag, we append a new tag with
             * minimum length, this tag is incomplete and
             * will be completed in next calls when we receive
             * new samples by appending Null tags.
             */
            mtag->length = op_extra_data->mic_metadata_min_tag_len*OCTETS_PER_SAMPLE;
84201370:	52 54       	r0 = r0 LSHIFT 2;
84201372:	f2 8e       	M[r4 + 12] = r0;
            op_extra_data->mic_metadata_tag_left_words = op_extra_data->mic_metadata_min_tag_len - samples;
84201374:	81 f0 cc 88 	rMAC = M[r6 + 816];
84201378:	c9 05       	rMAC = rMAC - r5;
8420137a:	81 f0 cb 8e 	M[r6 + 812] = rMAC;

8420137e <Lc_aec_reference_mic_generate_metadata_with_ttp_10>:
        }

        ttp_status status;
        ttp_update_ttp(op_extra_data->mic_time_to_play, time_of_arrival,
                       mtag->length/OCTETS_PER_SAMPLE, &status);
8420137e:	45 12       	r3 = FP + 36;
84201380:	f2 88       	r0 = M[r4 + 12];
84201382:	54 50       	r2 = r0 LSHIFT -2;
84201384:	82 f0 cf 88 	r0 = M[r6 + 828];
84201388:	ff fd aa f0 	call (m) 0x16860;
8420138c:	39 e6 
        /* Populate the metadata tag from the TTP status */
        ttp_utils_populate_tag(mtag, &status);
8420138e:	43 12       	r1 = FP + 36;
84201390:	32 00       	r0 = r4 + Null;
84201392:	ef fd fa ff 	call (m) 0x8d0;
84201396:	3f e9 

84201398 <Lc_aec_reference_mic_generate_metadata_with_ttp_11>:
    }
    /* append generated metadata to the output buffer */
    buff_metadata_append(met_buf, mtag, b4idx, afteridx);
84201398:	04 00       	r2 = Null + Null;
8420139a:	33 00       	r1 = r4 + Null;
8420139c:	5a 08       	r0 = r9 + Null;
8420139e:	45 d8       	r3 = M[FP + 32];
842013a0:	ff fd 83 f0 	call (m) 0x11adc;
842013a4:	3d e9 

842013a6 <Lc_aec_reference_mic_generate_metadata_with_ttp_12>:
}
842013a6:	f6 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
842013a8:	d8 4c       	rts;

842013aa <$_aec_reference_set_mic_gains>:
    return TRUE;
}


void aec_reference_set_mic_gains(OPERATOR_DATA *op_data)
{
842013aa:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
842013ac:	12 09       	r8 = r0 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
842013ae:	a9 f0 0c 88 	r7 = M[r8 + 48];


void aec_reference_set_mic_gains(OPERATOR_DATA *op_data)
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    unsigned i, *lpadcgains = (unsigned*)&op_extra_data->params.OFFSET_ADC_GAIN1;
842013b2:	97 f0 b8 20 	r5 = r7 + 184;

    patch_fn_shared(aec_reference);

    for(i=0;i<MAX_NUMBER_MICS;i++)
842013b6:	06 00       	r4 = Null + Null;
842013b8:	17 6e       	jump (m) Lc_aec_reference_set_mic_gains_6;

842013ba <Lc_aec_reference_set_mic_gains_2>:
    {
        return (i + AEC_REF_MIC_TERMINAL1);
    }
    else
    {
        return ((i-4)+ AEC_REF_MIC_TERMINAL5);
842013ba:	31 22       	rMAC = r4 + 8;

842013bc <Lc_aec_reference_set_mic_gains_3>:
        if(op_extra_data->input_stream[MicrophoneTerminalByIndex(i)])
        {
            uint32 config_value = (uint32)(lpadcgains[i]);
            set_override_ep_gain(get_overriden_endpoint(op_data->id,
                                 MicrophoneTerminalByIndex(i) | TERMINAL_SINK_MASK),
                                 config_value);
842013bc:	08 f0 00 f0 	r1 = rMAC OR 0x800000;
842013c0:	00 f1 53 c8 
842013c4:	a2 f0 01 88 	r0 = M[r8 + 4];
842013c8:	ff fd 1b f0 	call (m) 0x4ab0;
842013cc:	29 e7 
842013ce:	43 08       	r1 = r6 + Null;
842013d0:	ff fd 1b f0 	call (m) 0x4a1c;
842013d4:	2d e2 

842013d6 <Lc_aec_reference_set_mic_gains_4>:
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    unsigned i, *lpadcgains = (unsigned*)&op_extra_data->params.OFFSET_ADC_GAIN1;

    patch_fn_shared(aec_reference);

    for(i=0;i<MAX_NUMBER_MICS;i++)
842013d6:	76 20       	r4 = r4 + 1;
842013d8:	3f 21       	r5 = r5 + 4;
842013da:	30 26       	Null = r4 - 8;
842013dc:	02 f0 a7 e0 	if C jump (m) Lc_aec_reference_set_mic_gains_11;

842013e0 <Lc_aec_reference_set_mic_gains_5>:
}


inline static unsigned MicrophoneTerminalByIndex(unsigned i)
{
    if(i<4)
842013e0:	30 25       	Null = r4 - 4;
842013e2:	02 f0 89 e0 	if C jump (m) Lc_aec_reference_set_mic_gains_7;

842013e6 <Lc_aec_reference_set_mic_gains_6>:
    {
        return (i + AEC_REF_MIC_TERMINAL1);
842013e6:	b2 20       	r0 = r4 + 2;
842013e8:	02 6e       	jump (m) Lc_aec_reference_set_mic_gains_8;

842013ea <Lc_aec_reference_set_mic_gains_7>:
    }
    else
    {
        return ((i-4)+ AEC_REF_MIC_TERMINAL5);
842013ea:	32 22       	r0 = r4 + 8;

842013ec <Lc_aec_reference_set_mic_gains_8>:
    {
        if(op_extra_data->input_stream[MicrophoneTerminalByIndex(i)])
842013ec:	52 54       	r0 = r0 LSHIFT 2;
842013ee:	91 f0 02 e8 	rMAC = M[r7 + r0];
842013f2:	f2 61       	if EQ jump (m) Lc_aec_reference_set_mic_gains_4;

842013f4 <Lc_aec_reference_set_mic_gains_9>:
        {
            uint32 config_value = (uint32)(lpadcgains[i]);
842013f4:	78 f0 00 e8 	r6 = M[r5 + Null];
}


inline static unsigned MicrophoneTerminalByIndex(unsigned i)
{
    if(i<4)
842013f8:	30 25       	Null = r4 - 4;
842013fa:	f2 ff c1 ef 	if C jump (m) Lc_aec_reference_set_mic_gains_2;

842013fe <Lc_aec_reference_set_mic_gains_10>:
    {
        return (i + AEC_REF_MIC_TERMINAL1);
842013fe:	b1 20       	rMAC = r4 + 2;
84201400:	de 6f       	jump (m) Lc_aec_reference_set_mic_gains_3;

84201402 <Lc_aec_reference_set_mic_gains_11>:
            set_override_ep_gain(get_overriden_endpoint(op_data->id,
                                 MicrophoneTerminalByIndex(i) | TERMINAL_SINK_MASK),
                                 config_value);
        }
    }
}
84201402:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84201404:	d8 4c       	rts;

84201406 <$_aec_reference_cleanup>:
 * Note: This function is the same as aec_reference_cleanup_graphs
 *       except that it will reset the entire channel status so any new attempt
 *       to build the graphs will rebuild everything from scratch.
 */
void aec_reference_cleanup(OPERATOR_DATA *op_data)
{
84201406:	f1 1c       	pushm <FP(=SP), r4, rLink>;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84201408:	16 99       	r4 = M[r0 + 48];
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);

    patch_fn_shared(aec_reference);

    /* cleanup all the graphs */
    aec_reference_cleanup_graphs(op_extra_data);
8420140a:	32 00       	r0 = r4 + Null;
8420140c:	06 f0 31 ed 	call (m) $_aec_reference_cleanup_graphs;

    /* reset channel status, so any new trying
     * of building graphs will rebuild every thing
     * from scratch
     */
    op_extra_data->channel_status = 0;
84201410:	60 f0 76 8e 	M[r4 + 472] = Null;

84201414 <Lc_aec_reference_cleanup_2>:
}
84201414:	f1 48       	popm <FP, r4, rLink>;
84201416:	d8 4c       	rts;

84201418 <$_build_mic_graph>:
 *        whenever there is a change in microphone channel status.
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 */
bool build_mic_graph(AEC_REFERENCE_OP_DATA *op_extra_data)
{
84201418:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
8420141a:	10 09       	r6 = r0 + Null;
    cbops_graph *mic_graph;
    cbops_op *op_ptr;
    unsigned i, num_mics = op_extra_data->num_mic_channels,j,num_io;
8420141c:	8a f0 78 88 	r8 = M[r6 + 480];
    unsigned* idxs;
    unsigned  out_idx,intern_idx;
    bool sidetone_enabled = (op_extra_data->using_sidetone&SIDETONE_ENABLE_FLAG) != 0;
84201420:	81 f0 7a 88 	rMAC = M[r6 + 488];
84201424:	02 00       	r0 = Null + Null;
84201426:	49 c0       	rMAC = rMAC AND 0x2;
84201428:	21 f0 42 ce 	if NE r0 = Null + 1;
8420142c:	42 de       	M[FP + 32] = r0;
8420142e:	13 00       	r1 = r0 + Null;
       aec_reference_mic_spkr_include_sidetone.

    **********************************************************************/

    /* see if we need a MIC path */
    if(!build_mic_graph_is_required(op_extra_data, sidetone_enabled))
84201430:	42 08       	r0 = r6 + Null;
84201432:	0a f0 37 e1 	call (m) Lc_build_mic_graph_is_required_1;
84201436:	10 04       	Null = r0 - Null;
84201438:	7d 60       	if EQ jump (m) Lc_build_mic_graph_19;

8420143a <Lc_build_mic_graph_2>:
       MIC Internal
       SIDETONE OUT
    */

    out_idx    = num_mics;
    intern_idx = out_idx;
8420143a:	51 09       	r7 = r8 + Null;
    num_io     = 2*num_mics;
8420143c:	00 fa d6 d8 	r4 = r8 LSHIFT 1;

    /* if sidetone enabled reserve indexes for mic sidetone process,
     * the process will insert later if required.
     */
    if(sidetone_enabled)
84201440:	41 d8       	rMAC = M[FP + 32];
84201442:	7a 60       	if EQ jump (m) Lc_build_mic_graph_20;

84201444 <Lc_build_mic_graph_3>:
    {
        /* Need internal buffer between input and output */
        intern_idx = num_io;
84201444:	31 09       	r7 = r4 + Null;
        num_io    += num_mics;
84201446:	56 0c       	r4 = r8 + r4;

        /* sidetone path input */
        op_extra_data->mic_st_input_idx = intern_idx;
84201448:	89 f0 da 8e 	M[r6 + 872] = r7;

        /* sidetone output */
        op_extra_data->mic_st_idx = num_io;
8420144c:	86 f0 d8 8e 	M[r6 + 864] = r4;

        /* one extra io for sidetone, could be unused*/
        num_io++;
84201450:	76 20       	r4 = r4 + 1;
84201452:	86 6e       	jump (m) Lc_build_mic_graph_25;

84201454 <Lc_build_mic_graph_4>:
                goto aFailed;
            }
            rate_monitor_op_initialise(op_ptr,op_extra_data->mic_rate,TRUE,3*MS_PER_SEC);
        }
    }
    else if(!is_override_ep_locally_clocked(op_extra_data->mic_endpoint))
84201454:	82 f0 7f 88 	r0 = M[r6 + 508];
84201458:	ff fd 1b f0 	call (m) 0x4a8c;
8420145c:	35 e1 
8420145e:	10 04       	Null = r0 - Null;
84201460:	16 62       	if NE jump (m) Lc_build_mic_graph_8;

84201462 <Lc_build_mic_graph_5>:
    {
        /* With SW rate adjustment we need rate monitor if mic isn't locally clocked */
        op_ptr = create_rate_monitor_operator(op_extra_data->task_frequency, 0);
84201462:	82 f0 92 88 	r0 = M[r6 + 584];
84201466:	03 00       	r1 = Null + Null;
84201468:	0d f0 35 e7 	call (m) $_create_rate_monitor_operator;
8420146c:	16 00       	r4 = r0 + Null;
        if(!op_ptr)
8420146e:	9a 60       	if EQ jump (m) Lc_build_mic_graph_30;

84201470 <Lc_build_mic_graph_6>:
        {
            goto aFailed;
        }
        rate_monitor_op_initialise(op_ptr,op_extra_data->mic_rate, FALSE,
                                   100*MILLISECOND/MILLISECOND);
84201470:	05 f0 64 40 	r3 = Null + 100;
84201474:	83 f0 66 88 	r1 = M[r6 + 408];
84201478:	04 00       	r2 = Null + Null;
8420147a:	f5 ff 22 ed 	call $_rate_monitor_op_initialise;

8420147e <Lc_build_mic_graph_7>:
    }
    if(NULL != op_ptr)
    {
        /* insert rate monitor op into the graph */
        op_extra_data->mic_rate_monitor_op = op_ptr;
8420147e:	86 f0 6b 8e 	M[r6 + 428] = r4;
        cbops_append_operator_to_graph(mic_graph,op_ptr);
84201482:	33 00       	r1 = r4 + Null;
84201484:	5a 08       	r0 = r9 + Null;
84201486:	ff fd ad f0 	call (m) 0x16e96;
8420148a:	31 e0 

8420148c <Lc_build_mic_graph_8>:
    /* Handle input */
    if(op_extra_data->mic_rate_ability == RATEMATCHING_SUPPORT_SW
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
        && (0 == op_extra_data->mic_ext_rate_adjust_op)
#endif
        )
8420148c:	81 f0 67 88 	rMAC = M[r6 + 412];
84201490:	48 24       	Null = rMAC - 1;
84201492:	78 62       	if NE jump (m) Lc_build_mic_graph_28;

84201494 <Lc_build_mic_graph_9>:
84201494:	80 f0 ad 88 	Null = M[r6 + 692];
84201498:	75 62       	if NE jump (m) Lc_build_mic_graph_28;

8420149a <Lc_build_mic_graph_10>:
    {
        /* Apply Software Rate Adjustment */
        op_ptr = create_sw_rate_adj_op(num_mics, idxs, &idxs[intern_idx],
                                       CBOPS_RATEADJUST_COEFFS,
                                       &op_extra_data->mic_rate_adjustment, op_extra_data->mic_shift);
8420149a:	81 f0 6d 88 	rMAC = M[r6 + 436];
8420149e:	09 1c       	pushm <rMAC>;
842014a0:	01 f0 a4 ff 	push r6 + 420;
842014a4:	18 cf 
842014a6:	85 2a       	r3 = Null + 26;
842014a8:	01 f9 d2 c8 	r0 = r7 LSHIFT 2;
842014ac:	4c d8       	r2 = M[FP + 36];
842014ae:	23 00       	r1 = r2 + Null;
842014b0:	14 01       	r2 = r0 + r2;
842014b2:	52 08       	r0 = r8 + Null;
842014b4:	ff fd ab f0 	call (m) 0x16bea;
842014b8:	37 e9 
842014ba:	7e 4c       	SP = SP + -8;
842014bc:	16 00       	r4 = r0 + Null;
        if(!op_ptr)
842014be:	72 60       	if EQ jump (m) Lc_build_mic_graph_30;

842014c0 <Lc_build_mic_graph_11>:
        {
            goto aFailed;
        }

        op_extra_data->mic_sw_rateadj_op=op_ptr;
842014c0:	86 f0 7d 8e 	M[r6 + 500] = r4;
        cbops_rateadjust_passthrough_mode(op_ptr,(op_extra_data->mic_rate_enactment==RATEMATCHING_SUPPORT_NONE)?TRUE:FALSE);
842014c4:	03 00       	r1 = Null + Null;
842014c6:	80 f0 68 88 	Null = M[r6 + 416];
842014ca:	20 f0 43 ce 	if EQ r1 = Null + 1;
842014ce:	ff fd ab f0 	call (m) 0x16c96;
842014d2:	29 ee 

842014d4 <Lc_build_mic_graph_12>:

        cbops_append_operator_to_graph(mic_graph,op_ptr);
842014d4:	33 00       	r1 = r4 + Null;
842014d6:	5a 08       	r0 = r9 + Null;
842014d8:	ff fd ac f0 	call (m) 0x16e96;
842014dc:	3f ed 

        /* Early DC remove on mic path. Before Sidetone split so the signal split
           to the speaker doesn't have DC */
        op_ptr = create_dc_remove_op(num_mics, &idxs[intern_idx], &idxs[intern_idx]);
842014de:	01 f9 d2 c8 	r0 = r7 LSHIFT 2;
842014e2:	4b d8       	r1 = M[FP + 36];
842014e4:	d3 00       	r1 = r0 + r1;
842014e6:	1c 00       	r2 = r1 + Null;
842014e8:	52 08       	r0 = r8 + Null;
842014ea:	ff fd 24 f1 	call (m) 0x25e40;
842014ee:	37 ea 
842014f0:	16 00       	r4 = r0 + Null;
        if(!op_ptr)
842014f2:	58 60       	if EQ jump (m) Lc_build_mic_graph_30;

842014f4 <Lc_build_mic_graph_13>:
        {
            goto aFailed;
        }
        cbops_append_operator_to_graph(mic_graph,op_ptr);
842014f4:	33 00       	r1 = r4 + Null;
842014f6:	5a 08       	r0 = r9 + Null;
842014f8:	ff fd ac f0 	call (m) 0x16e96;
842014fc:	3f ec 

842014fe <Lc_build_mic_graph_14>:
            goto aFailed;
        }
        cbops_append_operator_to_graph(mic_graph,op_ptr);
    }

    if(sidetone_enabled)
842014fe:	41 d8       	rMAC = M[FP + 32];
84201500:	03 60       	if EQ jump (m) Lc_build_mic_graph_16;

84201502 <Lc_build_mic_graph_15>:
    {
        /* mic sidetone path will be inserted after last operator in inputsubgraph.*/
        op_extra_data->mic_st_point = op_ptr;
84201502:	86 f0 dc 8e 	M[r6 + 880] = r4;

84201506 <Lc_build_mic_graph_16>:
    }

    /* check if output subgraph is needed */
    if(!op_extra_data->mic_graph_no_output)
84201506:	80 f0 dd 88 	Null = M[r6 + 884];
8420150a:	0c 62       	if NE jump (m) Lc_build_mic_graph_18;

8420150c <Lc_build_mic_graph_17>:
        /* append mic output subgraph */
        if(!build_mic_graph_add_output_subgraph(op_extra_data,
                                                idxs,
                                                intern_idx,
                                                out_idx,
                                                sidetone_enabled))
8420150c:	41 d8       	rMAC = M[FP + 32];
8420150e:	09 1c       	pushm <rMAC>;
84201510:	55 08       	r3 = r8 + Null;
84201512:	4c 08       	r2 = r7 + Null;
84201514:	42 08       	r0 = r6 + Null;
84201516:	4b d8       	r1 = M[FP + 36];
84201518:	09 f0 25 ec 	call (m) Lc_build_mic_graph_add_output_subgraph_1;
8420151c:	7f 4c       	SP = SP + -4;
8420151e:	10 04       	Null = r0 - Null;
84201520:	41 60       	if EQ jump (m) Lc_build_mic_graph_30;

84201522 <Lc_build_mic_graph_18>:
        {
            goto aFailed;
        }
    }

    pfree(idxs);
84201522:	4a d8       	r0 = M[FP + 36];
84201524:	ff fd 1d f0 	call (m) 0x4f62;
84201528:	3f e1 

    /* Each mic input has a corresponding output,
     * so it's safe to purge all channels now
     */
    aec_ref_purge_mics(mic_graph,num_mics);
8420152a:	53 08       	r1 = r8 + Null;
8420152c:	5a 08       	r0 = r9 + Null;
8420152e:	0f f0 3b ec 	call (m) $_aec_ref_purge_mics;

84201532 <Lc_build_mic_graph_19>:

    /* see if we need a MIC path */
    if(!build_mic_graph_is_required(op_extra_data, sidetone_enabled))
    {
        /* No need to build mic graph */
        return TRUE;
84201532:	42 20       	r0 = Null + 1;
84201534:	8f 6e       	jump (m) Lc_build_mic_graph_50;

84201536 <Lc_build_mic_graph_20>:

        /* one extra io for sidetone, could be unused*/
        num_io++;
    }
    else if( (op_extra_data->mic_rate_ability==RATEMATCHING_SUPPORT_SW) &&
             (op_extra_data->mic_rate!=op_extra_data->output_rate))
84201536:	81 f0 67 88 	rMAC = M[r6 + 412];
8420153a:	48 24       	Null = rMAC - 1;
8420153c:	0a 62       	if NE jump (m) Lc_build_mic_graph_23;

8420153e <Lc_build_mic_graph_21>:
8420153e:	81 f0 66 88 	rMAC = M[r6 + 408];
84201542:	82 f0 65 88 	r0 = M[r6 + 404];
84201546:	88 04       	Null = rMAC - r0;
84201548:	0b 60       	if EQ jump (m) Lc_build_mic_graph_25;

8420154a <Lc_build_mic_graph_22>:
    {
        /* Need internal buffer between input and output */
        intern_idx = num_io;
8420154a:	31 09       	r7 = r4 + Null;
        num_io    += num_mics;
8420154c:	56 0c       	r4 = r8 + r4;
8420154e:	08 6e       	jump (m) Lc_build_mic_graph_25;

84201550 <Lc_build_mic_graph_23>:
    }
    else if (op_extra_data->mic_rate!=op_extra_data->output_rate)
84201550:	81 f0 66 88 	rMAC = M[r6 + 408];
84201554:	82 f0 65 88 	r0 = M[r6 + 404];
84201558:	88 04       	Null = rMAC - r0;
8420155a:	02 60       	if EQ jump (m) Lc_build_mic_graph_25;

8420155c <Lc_build_mic_graph_24>:
    {
        /* No ratematching or sidetone.  Just resampling  */
        intern_idx = 0;
8420155c:	01 09       	r7 = Null + Null;

8420155e <Lc_build_mic_graph_25>:
    }

    idxs = create_default_indexes(num_io);
8420155e:	32 00       	r0 = r4 + Null;
84201560:	ff fd ac f0 	call (m) 0x16f08;
84201564:	29 ed 
84201566:	4a de       	M[FP + 36] = r0;
    if(idxs == NULL)
84201568:	11 00       	rMAC = r0 + Null;
8420156a:	20 60       	if EQ jump (m) Lc_build_mic_graph_31;

8420156c <Lc_build_mic_graph_26>:
    {
        return(FALSE);
    }

    /* Allocate mic graph */
    mic_graph = cbops_alloc_graph(num_io);
8420156c:	32 00       	r0 = r4 + Null;
8420156e:	ff fd ac f0 	call (m) 0x16d76;
84201572:	29 e0 
84201574:	13 09       	r9 = r0 + Null;
    if(!mic_graph)
84201576:	16 60       	if EQ jump (m) Lc_build_mic_graph_30;

84201578 <Lc_build_mic_graph_27>:
    {
        goto aFailed;
    }
    op_extra_data->mic_graph = mic_graph;
84201578:	8b f0 6a 8e 	M[r6 + 424] = r9;

    /* Setup MIC input Buffers*/
    for(j=0,i=0;(j<MAX_NUMBER_MICS);j++)
8420157c:	07 00       	r5 = Null + Null;
8420157e:	06 00       	r4 = Null + Null;
84201580:	1a 6e       	jump (m) Lc_build_mic_graph_33;

84201582 <Lc_build_mic_graph_28>:
            goto aFailed;
        }
        cbops_append_operator_to_graph(mic_graph,op_ptr);

    }
    else if(intern_idx != 0)
84201582:	0f f9 00 c2 	Null = r7 - Null;
84201586:	bc 61       	if EQ jump (m) Lc_build_mic_graph_14;

84201588 <Lc_build_mic_graph_29>:
    {
        /* Otherwise, just copy data to next section */
        op_ptr = create_shift_op(num_mics, idxs, &idxs[intern_idx], op_extra_data->mic_shift);
84201588:	85 f0 6d 88 	r3 = M[r6 + 436];
8420158c:	01 f9 d2 c8 	r0 = r7 LSHIFT 2;
84201590:	4c d8       	r2 = M[FP + 36];
84201592:	23 00       	r1 = r2 + Null;
84201594:	14 01       	r2 = r0 + r2;
84201596:	52 08       	r0 = r8 + Null;
84201598:	ff fd 24 f1 	call (m) 0x25e08;
8420159c:	31 e3 
8420159e:	16 00       	r4 = r0 + Null;
        if(!op_ptr)
842015a0:	9a 63       	if NE jump (m) Lc_build_mic_graph_12;

842015a2 <Lc_build_mic_graph_30>:

    return(TRUE);
  aFailed:
    DEBUG_GRAPHS("AEC REFERENCE: Building mic graph, Failed!");

    pfree(idxs);
842015a2:	4a d8       	r0 = M[FP + 36];
842015a4:	ff fd 1c f0 	call (m) 0x4f62;
842015a8:	3f ed 

842015aa <Lc_build_mic_graph_31>:
    }

    idxs = create_default_indexes(num_io);
    if(idxs == NULL)
    {
        return(FALSE);
842015aa:	02 00       	r0 = Null + Null;
842015ac:	53 6e       	jump (m) Lc_build_mic_graph_50;

842015ae <Lc_build_mic_graph_32>:
}


inline static unsigned MicrophoneTerminalByIndex(unsigned i)
{
    if(i<4)
842015ae:	30 25       	Null = r4 - 4;
842015b0:	02 f0 89 e0 	if C jump (m) Lc_build_mic_graph_34;

842015b4 <Lc_build_mic_graph_33>:
    {
        return (i + AEC_REF_MIC_TERMINAL1);
842015b4:	b2 20       	r0 = r4 + 2;
842015b6:	02 6e       	jump (m) Lc_build_mic_graph_35;

842015b8 <Lc_build_mic_graph_34>:
    }
    else
    {
        return ((i-4)+ AEC_REF_MIC_TERMINAL5);
842015b8:	32 22       	r0 = r4 + 8;

842015ba <Lc_build_mic_graph_35>:

    /* Setup MIC input Buffers*/
    for(j=0,i=0;(j<MAX_NUMBER_MICS);j++)
    {
        /* MIC inputs may not be consecutive */
        tCbuffer *buffer_ptr_src = op_extra_data->input_stream[MicrophoneTerminalByIndex(j)];
842015ba:	52 54       	r0 = r0 LSHIFT 2;

        if(buffer_ptr_src != NULL)
842015bc:	85 f0 02 e8 	r3 = M[r6 + r0];
842015c0:	0c 60       	if EQ jump (m) Lc_build_mic_graph_39;

842015c2 <Lc_build_mic_graph_36>:
        {
            if(i < num_mics)
842015c2:	af f7 00 c2 	Null = r5 - r8;
842015c6:	02 f0 91 e0 	if C jump (m) Lc_build_mic_graph_38;

842015ca <Lc_build_mic_graph_37>:
            {
                /* Inputs */
                cbops_set_input_io_buffer(mic_graph, i, 0, buffer_ptr_src);
842015ca:	04 00       	r2 = Null + Null;
842015cc:	3b 00       	r1 = r5 + Null;
842015ce:	5a 08       	r0 = r9 + Null;
842015d0:	ff fd ac f0 	call (m) 0x16e02;
842015d4:	33 e1 

842015d6 <Lc_build_mic_graph_38>:
            }
            i++;
842015d6:	7f 20       	r5 = r5 + 1;

842015d8 <Lc_build_mic_graph_39>:
        goto aFailed;
    }
    op_extra_data->mic_graph = mic_graph;

    /* Setup MIC input Buffers*/
    for(j=0,i=0;(j<MAX_NUMBER_MICS);j++)
842015d8:	76 20       	r4 = r4 + 1;
842015da:	30 26       	Null = r4 - 8;
842015dc:	e9 65       	if NC jump (m) Lc_build_mic_graph_32;

842015de <Lc_build_mic_graph_40>:
            }
            i++;
        }
    }
    /* expect to have exactly num_mics mics connected */
    PL_ASSERT(i==num_mics);
842015de:	af f7 00 c2 	Null = r5 - r8;
842015e2:	09 60       	if EQ jump (m) Lc_build_mic_graph_42;

842015e4 <Lc_build_mic_graph_41>:
842015e4:	03 f0 8e 43 	r1 = Null + 910;
842015e8:	02 f0 13 60 	r0 = Null + 4115;
842015ec:	ff fd 94 f0 	call (m) 0x13f12;
842015f0:	27 e9 
842015f2:	30 6e       	jump (m) Lc_build_mic_graph_50;

842015f4 <Lc_build_mic_graph_42>:

    if(intern_idx > out_idx)
842015f4:	af f9 00 c2 	Null = r7 - r8;
842015f8:	09 f0 a9 e0 	if LS jump (m) Lc_build_mic_graph_46;

842015fc <Lc_build_mic_graph_43>:
    {
        for(i=0;i<num_mics;i++)
842015fc:	06 00       	r4 = Null + Null;
842015fe:	87 f0 7c 23 	r5 = r6 + 892;

84201602 <Lc_build_mic_graph_44>:
84201602:	af f6 00 c2 	Null = r4 - r8;
84201606:	02 f0 9b e0 	if C jump (m) Lc_build_mic_graph_46;

8420160a <Lc_build_mic_graph_45>:
        {
            cbops_set_internal_io_buffer(mic_graph,intern_idx+i,intern_idx,op_extra_data->scratch_bufs[i]);
8420160a:	3d e8       	r3 = M[r5 + Null];
8420160c:	9f f6 03 c0 	r1 = r4 + r7;
84201610:	4c 08       	r2 = r7 + Null;
84201612:	5a 08       	r0 = r9 + Null;
84201614:	ff fd ac f0 	call (m) 0x16e66;
84201618:	33 e2 
    /* expect to have exactly num_mics mics connected */
    PL_ASSERT(i==num_mics);

    if(intern_idx > out_idx)
    {
        for(i=0;i<num_mics;i++)
8420161a:	76 20       	r4 = r4 + 1;
8420161c:	3f 21       	r5 = r5 + 4;
8420161e:	f2 6f       	jump (m) Lc_build_mic_graph_44;

84201620 <Lc_build_mic_graph_46>:
        {
            cbops_set_internal_io_buffer(mic_graph,intern_idx+i,intern_idx,op_extra_data->scratch_bufs[i]);
        }
    }

    op_extra_data->mic_rate_adjustment = 0;
84201620:	80 f0 69 8e 	M[r6 + 420] = Null;

    /* create rate monitor op if required */
    op_ptr = NULL;
84201624:	06 00       	r4 = Null + Null;
    if(op_extra_data->mic_rate_ability == RATEMATCHING_SUPPORT_HW)
84201626:	81 f0 67 88 	rMAC = M[r6 + 412];
8420162a:	88 24       	Null = rMAC - 2;
8420162c:	14 63       	if NE jump (m) Lc_build_mic_graph_4;

8420162e <Lc_build_mic_graph_47>:
    {
        /* With HW rate adjustmen we always need rate monitor,
         * except when we are syncing MIC to REF.
         */
        if(!op_extra_data->mic_sync_enable)
8420162e:	80 f0 d4 88 	Null = M[r6 + 848];
84201632:	2d 63       	if NE jump (m) Lc_build_mic_graph_8;

84201634 <Lc_build_mic_graph_48>:
        {
            op_ptr = create_rate_monitor_operator(op_extra_data->task_frequency, 0);
84201634:	82 f0 92 88 	r0 = M[r6 + 584];
84201638:	03 00       	r1 = Null + Null;
8420163a:	0c f0 23 e9 	call (m) $_create_rate_monitor_operator;
8420163e:	16 00       	r4 = r0 + Null;
            if(!op_ptr)
84201640:	b1 61       	if EQ jump (m) Lc_build_mic_graph_30;

84201642 <Lc_build_mic_graph_49>:
            {
                goto aFailed;
            }
            rate_monitor_op_initialise(op_ptr,op_extra_data->mic_rate,TRUE,3*MS_PER_SEC);
84201642:	05 f0 b8 53 	r3 = Null + 3000;
84201646:	44 20       	r2 = Null + 1;
84201648:	83 f0 66 88 	r1 = M[r6 + 408];
8420164c:	f4 ff 30 ee 	call $_rate_monitor_op_initialise;
84201650:	17 6f       	jump (m) Lc_build_mic_graph_7;

84201652 <Lc_build_mic_graph_50>:
  aFailed:
    DEBUG_GRAPHS("AEC REFERENCE: Building mic graph, Failed!");

    pfree(idxs);
    return(FALSE);
}
84201652:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84201654:	d8 4c       	rts;

84201656 <$_build_spkr_graph>:
 *       depending on the connections and microphone state, however they
 *       aren't included by this function, instead they are added to the
 *       speaker graph later.
 */
bool build_spkr_graph(AEC_REFERENCE_OP_DATA *op_extra_data)
{
84201656:	f6 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x20;
84201658:	42 de       	M[FP + 32] = r0;
8420165a:	11 00       	rMAC = r0 + Null;
    cbops_op    *overrid_op_ptr;
    unsigned    num_io;
    tCbuffer    *buffer_ptr;
    unsigned    *idxs;
    unsigned    out_indx,intern_ins_idx,intern_rs_idx,intern_rm_idx;
    unsigned    spkr_channel_status = GetSpkrChannelStatus(op_extra_data);
8420165c:	12 f0 76 88 	r0 = M[rMAC + 472];
84201660:	21 f1 f0 1f 	rMAC = r0 AND 0x3ff0;
         "Sidetone Mix" is added/removed to/from the graph by aec_reference_mic_spkr_include_sidetone function.
         "Reference sub-path" is added/removed to/from the graph by aec_reference_spkr_include_ref_path function.

    **********************************************************************/
    /* Is there a Speaker path */
    if(!(op_extra_data->channel_status&CHAN_STATE_SPKR_MASK))
84201664:	22 f0 f0 0f 	r0 = r0 AND 0xff0;
84201668:	4a 60       	if EQ jump (m) Lc_build_spkr_graph_10;

8420166a <Lc_build_spkr_graph_2>:
    {
        return(TRUE);
    }

    /* Determine IO configuration */
    num_spkrs  = op_extra_data->num_spkr_channels;
8420166a:	42 d8       	r0 = M[FP + 32];
8420166c:	2a f0 77 88 	r8 = M[r0 + 476];
84201670:	ea f0 09 8e 	M[FP + 36] = r8;
    num_inputs = op_extra_data->num_spkr_channels;
    if(!(spkr_channel_status&AEC_REFERENCE_CONSTANT_CONN_TYPE_PARA))
84201674:	ca c5       	r0 = rMAC AND 0x1000;
84201676:	47 62       	if NE jump (m) Lc_build_spkr_graph_12;

84201678 <Lc_build_spkr_graph_3>:
    {
        if(spkr_channel_status&AEC_REFERENCE_CONSTANT_CONN_TYPE_MIX)
84201678:	11 f1 00 00 	rMAC = rMAC AND 0x2000;
8420167c:	43 60       	if EQ jump (m) Lc_build_spkr_graph_11;

8420167e <Lc_build_spkr_graph_4>:
        {
            /* Multiple inputs, mono output */
            num_spkrs=1;
8420167e:	41 20       	rMAC = Null + 1;
84201680:	49 de       	M[FP + 36] = rMAC;
84201682:	41 6e       	jump (m) Lc_build_spkr_graph_12;

84201684 <Lc_build_spkr_graph_5>:
        {
            goto aFailed;
        }
        rate_monitor_op_initialise(op_ptr,op_extra_data->spkr_rate, TRUE, 3*MS_PER_SEC);
    }
    else if(!is_override_ep_locally_clocked(op_extra_data->spkr_endpoint))
84201684:	41 d8       	rMAC = M[FP + 32];
84201686:	12 f0 80 88 	r0 = M[rMAC + 512];
8420168a:	ff fd 1a f0 	call (m) 0x4a8c;
8420168e:	23 e0 
84201690:	10 04       	Null = r0 - Null;
84201692:	26 62       	if NE jump (m) Lc_build_spkr_graph_9;

84201694 <Lc_build_spkr_graph_6>:
    {
        /* With SW rate adjustment we need rate monitor if speaker isn't locally clocked */
        op_ptr = create_rate_monitor_operator(op_extra_data->task_frequency, 0);
84201694:	41 d8       	rMAC = M[FP + 32];
84201696:	12 f0 92 88 	r0 = M[rMAC + 584];
8420169a:	03 00       	r1 = Null + Null;
8420169c:	0c f0 21 e6 	call (m) $_create_rate_monitor_operator;
842016a0:	16 00       	r4 = r0 + Null;
        if(!op_ptr)
842016a2:	9a 60       	if EQ jump (m) Lc_build_spkr_graph_27;

842016a4 <Lc_build_spkr_graph_7>:
        {
            goto aFailed;
        }
        rate_monitor_op_initialise(op_ptr,op_extra_data->spkr_rate, FALSE,
                                    100*MILLISECOND/MILLISECOND);
842016a4:	05 f0 64 40 	r3 = Null + 100;
842016a8:	41 d8       	rMAC = M[FP + 32];
842016aa:	13 f0 6e 88 	r1 = M[rMAC + 440];
842016ae:	04 00       	r2 = Null + Null;
842016b0:	f4 ff 2c eb 	call $_rate_monitor_op_initialise;

842016b4 <Lc_build_spkr_graph_8>:
    if(NULL != op_ptr)
    {
#ifdef AEC_REF_CALC_SPKR_RATE_MONITOR_AMOUNT
    /*  directly pass new amount read by speaker to the operator */
    op_extra_data->spkr_last_offset =
        cbuffer_get_read_mmu_offset(op_extra_data->output_stream[AEC_REF_SPKR_TERMINAL1]);
842016b4:	41 d8       	rMAC = M[FP + 32];
842016b6:	4a a8       	r0 = M[rMAC + 68];
842016b8:	ff fd 89 f0 	call (m) 0x12a28;
842016bc:	31 eb 
842016be:	41 d8       	rMAC = M[FP + 32];
842016c0:	12 f0 d1 8e 	M[rMAC + 836] = r0;
    set_rate_monitor_new_amount_ptr(op_ptr, &op_extra_data->spkr_new_amount);
842016c4:	13 f0 48 23 	r1 = rMAC + 840;
842016c8:	32 00       	r0 = r4 + Null;
842016ca:	f4 ff 36 e9 	call $_set_rate_monitor_new_amount_ptr;
#endif
        /* insert rate monitor op into the graph */
        op_extra_data->spkr_rate_monitor_op = op_ptr;
842016ce:	41 d8       	rMAC = M[FP + 32];
842016d0:	16 f0 73 8e 	M[rMAC + 460] = r4;
        cbops_append_operator_to_graph(spkr_graph, op_ptr);
842016d4:	33 00       	r1 = r4 + Null;
842016d6:	5a 08       	r0 = r9 + Null;
842016d8:	ff fd ab f0 	call (m) 0x16e96;
842016dc:	3f ed 

842016de <Lc_build_spkr_graph_9>:
    }

#ifdef AEC_REF_CALC_SPKR_RATE_MONITOR_AMOUNT
    /* Reset flag showing speaker started to consume data */
    op_extra_data->spkr_flow_started = FALSE;
842016de:	41 d8       	rMAC = M[FP + 32];
842016e0:	10 f0 d3 8e 	M[rMAC + 844] = Null;

#ifdef ENABLE_SW_DAC_DC_OFFSET_COMPENSATION
#ifndef RUNNING_ON_KALSIM
    /* compensate for HW dc offset addition */
    op_extra_data->spkr_dc_offset_op =
        setup_cbops_dc_offset_compensation(spkr_graph, op_extra_data->task_frequency);
842016e4:	13 f0 92 88 	r1 = M[rMAC + 584];
842016e8:	5a 08       	r0 = r9 + Null;
842016ea:	10 f0 31 ea 	call (m) $_setup_cbops_dc_offset_compensation;
842016ee:	41 d8       	rMAC = M[FP + 32];
842016f0:	12 f0 9e 8e 	M[rMAC + 632] = r0;
#endif
#endif
    pfree(idxs);
842016f4:	52 d8       	r0 = M[FP + 40];
842016f6:	ff fd 1c f0 	call (m) 0x4f62;
842016fa:	2d e3 

842016fc <Lc_build_spkr_graph_10>:

    **********************************************************************/
    /* Is there a Speaker path */
    if(!(op_extra_data->channel_status&CHAN_STATE_SPKR_MASK))
    {
        return(TRUE);
842016fc:	42 20       	r0 = Null + 1;
842016fe:	0f f0 8f e8 	jump (m) Lc_build_spkr_graph_79;

84201702 <Lc_build_spkr_graph_11>:
            num_spkrs=1;
        }
        else
        {
            /* Mono input, multiple outputs */
            num_inputs=1;
84201702:	0a 71       	r8 = Null + 1;

84201704 <Lc_build_spkr_graph_12>:
        }
    }

    /* outputs follow inputs */
    /* Internal buffers for output of insert follow outputs */
    out_indx       = num_inputs;
84201704:	ea f0 0b 8e 	M[FP + 44] = r8;

    /* Count the buffers needed */
    num_io         = num_inputs+num_spkrs;
84201708:	49 d8       	rMAC = M[FP + 36];
8420170a:	51 0c       	rMAC = r8 + rMAC;
8420170c:	0a 00       	r0 = rMAC + Null;

    /* reserve one index for sidetone input buffer */
    op_extra_data->spkr_st_in_idx = num_io;
8420170e:	41 d8       	rMAC = M[FP + 32];
84201710:	12 f0 a5 8e 	M[rMAC + 660] = r0;
84201714:	11 00       	rMAC = r0 + Null;
    num_io++;
84201716:	49 20       	rMAC = rMAC + 1;
84201718:	09 09       	r7 = rMAC + Null;

    /* Assume no resampler or rate matching */
    intern_rs_idx = 0;
8420171a:	60 de       	M[FP + 48] = Null;
    intern_rm_idx = 0;
8420171c:	68 de       	M[FP + 52] = Null;
    intern_ins_idx = num_io;

    /* speaker inputs are copied to interm buffers immediately,
       reserve indexes for num_inputs buffers.
     */
    num_io += num_inputs;
8420171e:	51 0c       	rMAC = r8 + rMAC;
84201720:	71 de       	M[FP + 56] = rMAC;
     * scratch buffer for both inputs and outputs.
     */
    usable_scratch_idx = 0;

    /* Check if resampler is required */
    if(op_extra_data->input_rate!=op_extra_data->spkr_rate)
84201722:	41 d8       	rMAC = M[FP + 32];
84201724:	0a 00       	r0 = rMAC + Null;
84201726:	11 f0 64 88 	rMAC = M[rMAC + 400];
8420172a:	22 f0 6e 88 	r0 = M[r0 + 440];
8420172e:	88 04       	Null = rMAC - r0;
84201730:	39 60       	if EQ jump (m) Lc_build_spkr_graph_22;

84201732 <Lc_build_spkr_graph_13>:
    {
        intern_rs_idx = out_indx;
84201732:	ea f0 0c 8e 	M[FP + 48] = r8;

        if(op_extra_data->spkr_rate_ability==RATEMATCHING_SUPPORT_SW)
84201736:	41 d8       	rMAC = M[FP + 32];
84201738:	11 f0 6f 88 	rMAC = M[rMAC + 444];
8420173c:	48 24       	Null = rMAC - 1;
8420173e:	1a 62       	if NE jump (m) Lc_build_spkr_graph_19;

84201740 <Lc_build_spkr_graph_14>:
        {
            /* Need buffers following resampler */
            intern_rs_idx    = num_io;
84201740:	71 d8       	rMAC = M[FP + 56];
84201742:	61 de       	M[FP + 48] = rMAC;
            if(num_spkrs>num_inputs)
84201744:	49 d8       	rMAC = M[FP + 36];
84201746:	af f1 00 c2 	Null = rMAC - r8;
8420174a:	09 f0 d1 e0 	if LS jump (m) Lc_build_spkr_graph_21;

8420174e <Lc_build_spkr_graph_15>:
            {
                /* Resampler is Mono.  Feeds shift */
                num_io++;
8420174e:	71 d8       	rMAC = M[FP + 56];
84201750:	49 20       	rMAC = rMAC + 1;
84201752:	71 de       	M[FP + 56] = rMAC;

84201754 <Lc_build_spkr_graph_16>:
    if(op_extra_data->spkr_rate_ability == RATEMATCHING_SUPPORT_SW
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
       /* not required if having access to external rate adjust op */
       && (0 == op_extra_data->spkr_ext_rate_adjust_op)
#endif
       )
84201754:	41 d8       	rMAC = M[FP + 32];
84201756:	10 f0 ae 88 	Null = M[rMAC + 696];
8420175a:	0c 62       	if NE jump (m) Lc_build_spkr_graph_19;

8420175c <Lc_build_spkr_graph_17>:
    {
        intern_rm_idx = out_indx;
8420175c:	ea f0 0d 8e 	M[FP + 52] = r8;
        /* Split needs buffer following rate matching (Mono)*/
        if(num_spkrs>num_inputs)
84201760:	49 d8       	rMAC = M[FP + 36];
84201762:	af f1 00 c2 	Null = rMAC - r8;
84201766:	09 f0 8d e0 	if LS jump (m) Lc_build_spkr_graph_19;

8420176a <Lc_build_spkr_graph_18>:
        {
            intern_rm_idx = num_io;
8420176a:	71 d8       	rMAC = M[FP + 56];
8420176c:	69 de       	M[FP + 52] = rMAC;
            num_io++;
8420176e:	49 20       	rMAC = rMAC + 1;
84201770:	71 de       	M[FP + 56] = rMAC;

84201772 <Lc_build_spkr_graph_19>:
    /* reserve 2 indexes for reference sub-path,
     * one is for reference output buffer, the
     * other one for scratch buffer for possible
     * resampler in the sub-path.
     */
    op_extra_data->spkr_ref_idx  = num_io;
84201772:	72 d8       	r0 = M[FP + 56];
84201774:	41 d8       	rMAC = M[FP + 32];
84201776:	12 f0 a4 8e 	M[rMAC + 656] = r0;
8420177a:	11 00       	rMAC = r0 + Null;
    num_io +=2;
8420177c:	89 20       	rMAC = rMAC + 2;
8420177e:	71 de       	M[FP + 56] = rMAC;

    /* Allocate buffer index array for easy setup */
    if(num_inputs<num_spkrs)
84201780:	49 d8       	rMAC = M[FP + 36];
84201782:	1f fa 00 c2 	Null = r8 - rMAC;
84201786:	02 f0 a9 e0 	if C jump (m) Lc_build_spkr_graph_23;

8420178a <Lc_build_spkr_graph_20>:
    {
        idxs = create_default_indexes(num_io+num_spkrs);
8420178a:	72 d8       	r0 = M[FP + 56];
8420178c:	49 d8       	rMAC = M[FP + 36];
8420178e:	8a 00       	r0 = rMAC + r0;
84201790:	ff fd ab f0 	call (m) 0x16f08;
84201794:	39 eb 
84201796:	52 de       	M[FP + 40] = r0;
84201798:	10 6e       	jump (m) Lc_build_spkr_graph_24;

8420179a <Lc_build_spkr_graph_21>:
                num_io++;
            }
            else
            {
                /* Resampler is multi channel */
                num_io += num_inputs;
8420179a:	71 d8       	rMAC = M[FP + 56];
8420179c:	51 0c       	rMAC = r8 + rMAC;
8420179e:	71 de       	M[FP + 56] = rMAC;
842017a0:	da 6f       	jump (m) Lc_build_spkr_graph_16;

842017a2 <Lc_build_spkr_graph_22>:
    if(op_extra_data->spkr_rate_ability == RATEMATCHING_SUPPORT_SW
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
       /* not required if having access to external rate adjust op */
       && (0 == op_extra_data->spkr_ext_rate_adjust_op)
#endif
       )
842017a2:	41 d8       	rMAC = M[FP + 32];
842017a4:	11 f0 6f 88 	rMAC = M[rMAC + 444];
842017a8:	48 24       	Null = rMAC - 1;
842017aa:	d5 61       	if EQ jump (m) Lc_build_spkr_graph_16;

842017ac <Lc_19>:
842017ac:	e3 6f       	jump (m) Lc_build_spkr_graph_19;

842017ae <Lc_build_spkr_graph_23>:
    {
        idxs = create_default_indexes(num_io+num_spkrs);
    }
    else
    {
        idxs = create_default_indexes(num_io);
842017ae:	72 d8       	r0 = M[FP + 56];
842017b0:	ff fd ab f0 	call (m) 0x16f08;
842017b4:	39 ea 
842017b6:	52 de       	M[FP + 40] = r0;

842017b8 <Lc_build_spkr_graph_24>:
    }
    if(idxs == NULL)
842017b8:	51 d8       	rMAC = M[FP + 40];
842017ba:	12 60       	if EQ jump (m) Lc_build_spkr_graph_28;

842017bc <Lc_build_spkr_graph_25>:
    {
        return(FALSE);
    }

    /* Allocate num_io buffers in spkr graph */
    spkr_graph = cbops_alloc_graph(num_io);
842017bc:	72 d8       	r0 = M[FP + 56];
842017be:	ff fd aa f0 	call (m) 0x16d76;
842017c2:	39 ed 
842017c4:	13 09       	r9 = r0 + Null;
    if(!spkr_graph)
842017c6:	08 60       	if EQ jump (m) Lc_build_spkr_graph_27;

842017c8 <Lc_build_spkr_graph_26>:
    {
        goto aFailed;
    }
    op_extra_data->spkr_graph = spkr_graph;
842017c8:	41 d8       	rMAC = M[FP + 32];
842017ca:	1b f0 72 8e 	M[rMAC + 456] = r9;
       Internal (after ref resample)    : scratch[num_inputs]
       REF OUT
    */

    /* Input, Output, and insert_op buffers */
    for(j=0,i=0,k=0;j<MAX_NUMBER_SPEAKERS;j++)
842017ce:	07 00       	r5 = Null + Null;
842017d0:	00 09       	r6 = Null + Null;
842017d2:	06 00       	r4 = Null + Null;
842017d4:	0b 6e       	jump (m) Lc_build_spkr_graph_30;

842017d6 <Lc_build_spkr_graph_27>:

    DEBUG_GRAPHS("AEC REFERENCE: Building speaker graph, Done!" );
    return TRUE;
  aFailed:
    DEBUG_GRAPHS("AEC REFERENCE: Building speaker graph, Failed!" );
    pfree(idxs);
842017d6:	52 d8       	r0 = M[FP + 40];
842017d8:	ff fd 1b f0 	call (m) 0x4f62;
842017dc:	2b ec 

842017de <Lc_build_spkr_graph_28>:
    {
        idxs = create_default_indexes(num_io);
    }
    if(idxs == NULL)
    {
        return(FALSE);
842017de:	02 00       	r0 = Null + Null;
842017e0:	0f f0 ad e6 	jump (m) Lc_build_spkr_graph_79;

842017e4 <Lc_build_spkr_graph_29>:

    /* Input, Output, and insert_op buffers */
    for(j=0,i=0,k=0;j<MAX_NUMBER_SPEAKERS;j++)
    {
        /* Inputs may not be contiguous */
        buffer_ptr =  op_extra_data->input_stream[SpeakerInputTerminalByIndex(j)];
842017e4:	b0 24       	Null = r4 - 2;
842017e6:	02 f0 89 e0 	if C jump (m) Lc_build_spkr_graph_31;

842017ea <Lc_build_spkr_graph_30>:
842017ea:	32 00       	r0 = r4 + Null;
842017ec:	02 6e       	jump (m) Lc_build_spkr_graph_32;

842017ee <Lc_build_spkr_graph_31>:
842017ee:	32 21       	r0 = r4 + 4;

842017f0 <Lc_build_spkr_graph_32>:
842017f0:	52 54       	r0 = r0 LSHIFT 2;
842017f2:	41 d8       	rMAC = M[FP + 32];
        if(buffer_ptr)
842017f4:	8d e8       	r3 = M[rMAC + r0];
842017f6:	08 60       	if EQ jump (m) Lc_build_spkr_graph_34;

842017f8 <Lc_build_spkr_graph_33>:
        {
            /* Inputs */
            cbops_set_input_io_buffer(spkr_graph,i,0,buffer_ptr);
842017f8:	04 00       	r2 = Null + Null;
842017fa:	3b 00       	r1 = r5 + Null;
842017fc:	5a 08       	r0 = r9 + Null;
842017fe:	ff fd ab f0 	call (m) 0x16e02;
84201802:	25 e0 
            i++;
84201804:	7f 20       	r5 = r5 + 1;

84201806 <Lc_build_spkr_graph_34>:
        }
        /* Outputs may not be contiguous */
        buffer_ptr =  op_extra_data->output_stream[SpeakerTerminalByIndex(j)];
84201806:	b0 24       	Null = r4 - 2;
84201808:	02 f0 89 e0 	if C jump (m) Lc_build_spkr_graph_36;

8420180c <Lc_build_spkr_graph_35>:
8420180c:	72 20       	r0 = r4 + 1;
8420180e:	02 6e       	jump (m) Lc_build_spkr_graph_37;

84201810 <Lc_build_spkr_graph_36>:
84201810:	72 21       	r0 = r4 + 5;

84201812 <Lc_build_spkr_graph_37>:
84201812:	41 d8       	rMAC = M[FP + 32];
84201814:	52 54       	r0 = r0 LSHIFT 2;
84201816:	01 f0 40 44 	rMAC = rMAC + 64;
        if(buffer_ptr)
8420181a:	8d e8       	r3 = M[rMAC + r0];
8420181c:	09 60       	if EQ jump (m) Lc_build_spkr_graph_39;

8420181e <Lc_build_spkr_graph_38>:
        {
            cbops_set_output_io_buffer(spkr_graph,out_indx + k,out_indx,buffer_ptr);
8420181e:	8f fa 03 c0 	r1 = r8 + r6;
84201822:	54 08       	r2 = r8 + Null;
84201824:	5a 08       	r0 = r9 + Null;
84201826:	ff fd ab f0 	call (m) 0x16e34;
8420182a:	2f e0 
            k++;
8420182c:	08 75       	r6 = r6 + 1;

8420182e <Lc_build_spkr_graph_39>:
       Internal (after ref resample)    : scratch[num_inputs]
       REF OUT
    */

    /* Input, Output, and insert_op buffers */
    for(j=0,i=0,k=0;j<MAX_NUMBER_SPEAKERS;j++)
8420182e:	76 20       	r4 = r4 + 1;
84201830:	30 26       	Null = r4 - 8;
84201832:	d9 65       	if NC jump (m) Lc_build_spkr_graph_29;

84201834 <Lc_build_spkr_graph_40>:
        }
    }


    /* Buffers for transfer from inputs to interm buffers */
    for(i=0; i < num_inputs ; i++)
84201834:	06 00       	r4 = Null + Null;
84201836:	41 d8       	rMAC = M[FP + 32];
84201838:	17 f0 7c 23 	r5 = rMAC + 892;

8420183c <Lc_build_spkr_graph_41>:
8420183c:	af f6 00 c2 	Null = r4 - r8;
84201840:	02 f0 9b e0 	if C jump (m) Lc_build_spkr_graph_43;

84201844 <Lc_build_spkr_graph_42>:
    {
         cbops_set_internal_io_buffer(spkr_graph,
                                      intern_ins_idx + i,
                                      intern_ins_idx,
                                      op_extra_data->scratch_bufs[usable_scratch_idx + i]);
84201844:	3d e8       	r3 = M[r5 + Null];
84201846:	9f f6 03 c0 	r1 = r4 + r7;
8420184a:	4c 08       	r2 = r7 + Null;
8420184c:	5a 08       	r0 = r9 + Null;
8420184e:	ff fd ab f0 	call (m) 0x16e66;
84201852:	39 e0 
        }
    }


    /* Buffers for transfer from inputs to interm buffers */
    for(i=0; i < num_inputs ; i++)
84201854:	76 20       	r4 = r4 + 1;
84201856:	3f 21       	r5 = r5 + 4;
84201858:	f2 6f       	jump (m) Lc_build_spkr_graph_41;

8420185a <Lc_build_spkr_graph_43>:
                                      intern_ins_idx + i,
                                      intern_ins_idx,
                                      op_extra_data->scratch_bufs[usable_scratch_idx + i]);
    }
    /* update usable_scratch_idx for next use */
    usable_scratch_idx = usable_scratch_idx==0? num_inputs:0;
8420185a:	ea f0 0f 8e 	M[FP + 60] = r8;
    /* Building override operator, this operator will transfer speaker
     * inputs to inerim buufers as well as any silence insertion required.
     * This way AEC_REFERERNCE will not write into its input buffer.
     */
    /* Thresholds for Insertion, keep a copy in main structure */
    op_extra_data->spkr_in_threshold  = frac_mult(op_extra_data->input_rate,op_extra_data->task_period_frac) + 1;
8420185e:	41 d8       	rMAC = M[FP + 32];
84201860:	12 f0 64 88 	r0 = M[rMAC + 400];
84201864:	13 f0 93 88 	r1 = M[rMAC + 588];
84201868:	00 f3 72 c9 	r0 = r0 * r1 (frac);
8420186c:	51 20       	rMAC = r0 + 1;
8420186e:	42 d8       	r0 = M[FP + 32];
84201870:	21 f0 af 8e 	M[r0 + 700] = rMAC;
84201874:	11 00       	rMAC = r0 + Null;
    op_extra_data->spkr_out_threshold = frac_mult(op_extra_data->spkr_rate,op_extra_data->task_period_frac) + 1;
84201876:	12 f0 6e 88 	r0 = M[rMAC + 440];
8420187a:	13 f0 93 88 	r1 = M[rMAC + 588];
8420187e:	00 f3 72 c9 	r0 = r0 * r1 (frac);
84201882:	51 20       	rMAC = r0 + 1;
84201884:	42 d8       	r0 = M[FP + 32];
84201886:	21 f0 b0 8e 	M[r0 + 704] = rMAC;
8420188a:	11 00       	rMAC = r0 + Null;
     * task period there will be ~(spkr_out_threshold + max_jitter) in the output buffer,
     * this is to cover a full task period plus possible scheduling uncertainties.
     * 1ms max_jitter might be enough, 0.5ms added in case sidetone mixing will run
     * in decimated task period.
     */
    unsigned max_jitter = frac_mult(op_extra_data->spkr_rate, FRACTIONAL(0.0015));
8420188c:	12 f0 6e 88 	r0 = M[rMAC + 440];
84201890:	03 f0 93 f0 	r1 = Null + 3221225;
84201894:	e9 4a 
84201896:	00 f3 72 c9 	r0 = r0 * r1 (frac);

    overrid_op_ptr = create_aec_ref_spkr_op(num_inputs,idxs,&idxs[intern_ins_idx],
                                            op_extra_data->spkr_in_threshold,
                                            num_spkrs,&idxs[out_indx],
                                            op_extra_data->spkr_out_threshold,
                                            max_jitter);
8420189a:	01 f9 d3 c8 	r1 = r7 LSHIFT 2;
8420189e:	e8 f0 0a 88 	r6 = M[FP + 40];
842018a2:	18 0d       	r6 = r1 + r6;
842018a4:	11 1c       	pushm <r0>;
842018a6:	11 f0 b0 88 	rMAC = M[rMAC + 704];
842018aa:	09 1c       	pushm <rMAC>;
842018ac:	01 fa d2 c8 	r0 = r8 LSHIFT 2;
842018b0:	51 d8       	rMAC = M[FP + 40];
842018b2:	0b 00       	r1 = rMAC + Null;
842018b4:	51 00       	rMAC = r0 + rMAC;
842018b6:	09 1c       	pushm <rMAC>;
842018b8:	49 d8       	rMAC = M[FP + 36];
842018ba:	09 1c       	pushm <rMAC>;
842018bc:	41 d8       	rMAC = M[FP + 32];
842018be:	44 08       	r2 = r6 + Null;
842018c0:	15 f0 af 88 	r3 = M[rMAC + 700];
842018c4:	52 08       	r0 = r8 + Null;
842018c6:	08 f0 2f e8 	call (m) $_create_aec_ref_spkr_op;
842018ca:	7c 4c       	SP = SP + -16;
#if defined(IO_DEBUG)
    insert_op  = overrid_op_ptr;
842018cc:	e0 f0 02 f0 	M[Null + $_insert_op] = r0;
842018d0:	5c 8e 
#endif
    if(!overrid_op_ptr)
842018d2:	10 04       	Null = r0 - Null;
842018d4:	81 61       	if EQ jump (m) Lc_build_spkr_graph_27;

842018d6 <Lc_build_spkr_graph_44>:
    {
        goto aFailed;
    }

    cbops_set_override_operator(spkr_graph,overrid_op_ptr);
842018d6:	13 00       	r1 = r0 + Null;
842018d8:	5a 08       	r0 = r9 + Null;
842018da:	ff fd aa f0 	call (m) 0x16ec2;
842018de:	29 ef 

    /* DC remove before reference tap */
    op_ptr = create_dc_remove_op(num_inputs, &idxs[intern_ins_idx], &idxs[intern_ins_idx]);
842018e0:	44 08       	r2 = r6 + Null;
842018e2:	43 08       	r1 = r6 + Null;
842018e4:	52 08       	r0 = r8 + Null;
842018e6:	ff fd 22 f1 	call (m) 0x25e40;
842018ea:	3b ea 
842018ec:	17 00       	r5 = r0 + Null;
    if(!op_ptr)
842018ee:	74 61       	if EQ jump (m) Lc_build_spkr_graph_27;

842018f0 <Lc_build_spkr_graph_45>:
    {
        goto aFailed;
    }
    cbops_append_operator_to_graph(spkr_graph,op_ptr);
842018f0:	3b 00       	r1 = r5 + Null;
842018f2:	5a 08       	r0 = r9 + Null;
842018f4:	ff fd aa f0 	call (m) 0x16e96;
842018f8:	23 ed 


    /* Add Mixer to section #1 if needed*/
    if(num_inputs > num_spkrs)
842018fa:	49 d8       	rMAC = M[FP + 36];
842018fc:	1f fa 00 c2 	Null = r8 - rMAC;
84201900:	09 f0 bb e0 	if LS jump (m) Lc_build_spkr_graph_51;

84201904 <Lc_build_spkr_graph_46>:
    {
        for(i=1;i<num_inputs;i++)
84201904:	46 20       	r4 = Null + 1;

84201906 <Lc_build_spkr_graph_47>:
84201906:	af f6 00 c2 	Null = r4 - r8;
8420190a:	02 f0 af e0 	if C jump (m) Lc_build_spkr_graph_50;

8420190e <Lc_build_spkr_graph_48>:
        {
            /* NOTE: left scratch input reused for output (inplace) */
            /*  - Add Mix Operator - stereo to mono (left = (left+right)/2 */
            op_ptr = create_mixer_op(intern_ins_idx, intern_ins_idx+i, intern_ins_idx, 0, FRACTIONAL(0.5));
8420190e:	ff f3 ff ff 	push Null + 1073741823;
84201912:	5f ef 
84201914:	9f f6 03 c0 	r1 = r4 + r7;
84201918:	05 00       	r3 = Null + Null;
8420191a:	4c 08       	r2 = r7 + Null;
8420191c:	4a 08       	r0 = r7 + Null;
8420191e:	ff fd 51 f1 	call (m) 0x2bcbc;
84201922:	3f ec 
84201924:	7f 4c       	SP = SP + -4;
84201926:	17 00       	r5 = r0 + Null;
            if(!op_ptr)
84201928:	57 61       	if EQ jump (m) Lc_build_spkr_graph_27;

8420192a <Lc_build_spkr_graph_49>:
            {
                goto aFailed;
            }
            cbops_append_operator_to_graph(spkr_graph,op_ptr);
8420192a:	3b 00       	r1 = r5 + Null;
8420192c:	5a 08       	r0 = r9 + Null;
8420192e:	ff fd aa f0 	call (m) 0x16e96;
84201932:	29 eb 


    /* Add Mixer to section #1 if needed*/
    if(num_inputs > num_spkrs)
    {
        for(i=1;i<num_inputs;i++)
84201934:	76 20       	r4 = r4 + 1;
84201936:	e8 6f       	jump (m) Lc_build_spkr_graph_47;

84201938 <Lc_build_spkr_graph_50>:
                goto aFailed;
            }
            cbops_append_operator_to_graph(spkr_graph,op_ptr);
        }
        /* Input is now mono */
        num_inputs = 1;
84201938:	0a 71       	r8 = Null + 1;

8420193a <Lc_build_spkr_graph_51>:
    /* This is the point where we take input for the
     * reference sub-path, store information about
     * where in the graph the reference sub-path
     * should be inserted to.
     */
    op_extra_data->spkr_ref_input_idx = intern_ins_idx;
8420193a:	41 d8       	rMAC = M[FP + 32];
8420193c:	19 f0 a1 8e 	M[rMAC + 644] = r7;
    op_extra_data->spkr_ref_point_op = op_ptr;
84201940:	17 f0 a8 8e 	M[rMAC + 672] = r5;
    op_extra_data->spkr_ref_scratch_idx = usable_scratch_idx;
84201944:	7a d8       	r0 = M[FP + 60];
84201946:	12 f0 a2 8e 	M[rMAC + 648] = r0;

    /* Add sample rate conversion per channel [num_inputs] (input_rate --> spkr_rate) */
    if(intern_rs_idx!=0)
8420194a:	61 d8       	rMAC = M[FP + 48];
8420194c:	4b 60       	if EQ jump (m) Lc_build_spkr_graph_61;

8420194e <Lc_build_spkr_graph_52>:
    {
        int shift_amount = op_extra_data->spkr_shift;
8420194e:	41 d8       	rMAC = M[FP + 32];
84201950:	11 f0 74 88 	rMAC = M[rMAC + 464];

        if(intern_rs_idx!=out_indx)
84201954:	63 d8       	r1 = M[FP + 48];
84201956:	5a d8       	r0 = M[FP + 44];
84201958:	98 04       	Null = r1 - r0;
8420195a:	1e 60       	if EQ jump (m) Lc_build_spkr_graph_59;

8420195c <Lc_build_spkr_graph_53>:
        {
            /* Buffers for output of resampler. */
            for(i=0; i < num_inputs ; i++)
8420195c:	06 00       	r4 = Null + Null;
8420195e:	7a d8       	r0 = M[FP + 60];
84201960:	41 d8       	rMAC = M[FP + 32];
84201962:	52 54       	r0 = r0 LSHIFT 2;
84201964:	51 00       	rMAC = r0 + rMAC;
84201966:	17 f0 7c 23 	r5 = rMAC + 892;

8420196a <Lc_build_spkr_graph_54>:
8420196a:	af f6 00 c2 	Null = r4 - r8;
8420196e:	02 f0 9b e0 	if C jump (m) Lc_build_spkr_graph_56;

84201972 <Lc_build_spkr_graph_55>:
            {
                cbops_set_internal_io_buffer(spkr_graph,intern_rs_idx+i,intern_rs_idx,
                                             op_extra_data->scratch_bufs[usable_scratch_idx+i]);
84201972:	3d e8       	r3 = M[r5 + Null];
84201974:	61 d8       	rMAC = M[FP + 48];
84201976:	0c 00       	r2 = rMAC + Null;
84201978:	73 00       	r1 = r4 + rMAC;
8420197a:	5a 08       	r0 = r9 + Null;
8420197c:	ff fd aa f0 	call (m) 0x16e66;
84201980:	2b e7 
        int shift_amount = op_extra_data->spkr_shift;

        if(intern_rs_idx!=out_indx)
        {
            /* Buffers for output of resampler. */
            for(i=0; i < num_inputs ; i++)
84201982:	76 20       	r4 = r4 + 1;
84201984:	3f 21       	r5 = r5 + 4;
84201986:	f2 6f       	jump (m) Lc_build_spkr_graph_54;

84201988 <Lc_build_spkr_graph_56>:
            {
                cbops_set_internal_io_buffer(spkr_graph,intern_rs_idx+i,intern_rs_idx,
                                             op_extra_data->scratch_bufs[usable_scratch_idx+i]);
            }
            shift_amount=0;
84201988:	01 00       	rMAC = Null + Null;
            /* update usable_scratch_idx for next use */
            usable_scratch_idx = usable_scratch_idx==0?num_inputs:0;
8420198a:	7a d8       	r0 = M[FP + 60];
8420198c:	04 62       	if NE jump (m) Lc_build_spkr_graph_58;

8420198e <Lc_build_spkr_graph_57>:
8420198e:	ea f0 0f 8e 	M[FP + 60] = r8;
84201992:	02 6e       	jump (m) Lc_build_spkr_graph_59;

84201994 <Lc_build_spkr_graph_58>:
84201994:	78 de       	M[FP + 60] = Null;

84201996 <Lc_build_spkr_graph_59>:
        }

        op_ptr = create_iir_resamplerv2_op(num_inputs, &idxs[intern_ins_idx], &idxs[intern_rs_idx],
                                           op_extra_data->input_rate, op_extra_data->spkr_rate,
                                           op_extra_data->resampler_temp_buffer_size,
                                           op_extra_data->resampler_temp_buffer, shift_amount, 0, 0);
84201996:	00 f0 30 cf 	push Null;
8420199a:	00 f0 30 cf 	push Null;
8420199e:	09 1c       	pushm <rMAC>;
842019a0:	41 d8       	rMAC = M[FP + 32];
842019a2:	11 f0 2c 88 	rMAC = M[rMAC + 176];
842019a6:	09 1c       	pushm <rMAC>;
842019a8:	41 d8       	rMAC = M[FP + 32];
842019aa:	11 f0 91 88 	rMAC = M[rMAC + 580];
842019ae:	09 1c       	pushm <rMAC>;
842019b0:	41 d8       	rMAC = M[FP + 32];
842019b2:	11 f0 6e 88 	rMAC = M[rMAC + 440];
842019b6:	09 1c       	pushm <rMAC>;
842019b8:	41 d8       	rMAC = M[FP + 32];
842019ba:	62 d8       	r0 = M[FP + 48];
842019bc:	54 d8       	r2 = M[FP + 40];
842019be:	43 08       	r1 = r6 + Null;
842019c0:	15 f0 64 88 	r3 = M[rMAC + 400];
842019c4:	52 54       	r0 = r0 LSHIFT 2;
842019c6:	14 01       	r2 = r0 + r2;
842019c8:	52 08       	r0 = r8 + Null;
842019ca:	0b f0 3f e0 	call (m) $_create_iir_resamplerv2_op;
842019ce:	7a 4c       	SP = SP + -24;
842019d0:	17 00       	r5 = r0 + Null;
        if(!op_ptr)
842019d2:	02 61       	if EQ jump (m) Lc_build_spkr_graph_27;

842019d4 <Lc_build_spkr_graph_60>:
        {
            goto aFailed;
        }
        cbops_append_operator_to_graph(spkr_graph,op_ptr);
842019d4:	3b 00       	r1 = r5 + Null;
842019d6:	5a 08       	r0 = r9 + Null;
842019d8:	ff fd aa f0 	call (m) 0x16e96;
842019dc:	3f e5 

        /* Move next input to output of resampler */
        intern_ins_idx = intern_rs_idx;
842019de:	e9 f0 0c 88 	r7 = M[FP + 48];

842019e2 <Lc_build_spkr_graph_61>:
    /* This is the point where we insert possible sidetone
     * mix operator, store both the operator and the input
     * buffer index for the operator. Sidetone mixing
     * will always be done in-place.
     */
    op_extra_data->spkr_st_point_op = op_ptr;
842019e2:	41 d8       	rMAC = M[FP + 32];
842019e4:	17 f0 a9 8e 	M[rMAC + 676] = r5;
    op_extra_data->spkr_stmix_in_idx = intern_ins_idx;
842019e8:	19 f0 a3 8e 	M[rMAC + 652] = r7;

    /* Optional section for SW rate matching */
    if(intern_rm_idx != 0)
842019ec:	69 d8       	rMAC = M[FP + 52];
842019ee:	47 60       	if EQ jump (m) Lc_build_spkr_graph_69;

842019f0 <Lc_build_spkr_graph_62>:
    {
        int shift_amount =  op_extra_data->spkr_shift;
842019f0:	41 d8       	rMAC = M[FP + 32];
842019f2:	11 f0 74 88 	rMAC = M[rMAC + 464];

        if(intern_rm_idx!=out_indx)
842019f6:	6b d8       	r1 = M[FP + 52];
842019f8:	5a d8       	r0 = M[FP + 44];
842019fa:	98 04       	Null = r1 - r0;
842019fc:	18 60       	if EQ jump (m) Lc_build_spkr_graph_67;

842019fe <Lc_build_spkr_graph_63>:
        {
            /* Buffers for output of ratematch if it exists */
            for(i=0; i < num_inputs; i++)
842019fe:	06 00       	r4 = Null + Null;
84201a00:	7a d8       	r0 = M[FP + 60];
84201a02:	41 d8       	rMAC = M[FP + 32];
84201a04:	52 54       	r0 = r0 LSHIFT 2;
84201a06:	51 00       	rMAC = r0 + rMAC;
84201a08:	17 f0 7c 23 	r5 = rMAC + 892;

84201a0c <Lc_build_spkr_graph_64>:
84201a0c:	af f6 00 c2 	Null = r4 - r8;
84201a10:	02 f0 9b e0 	if C jump (m) Lc_build_spkr_graph_66;

84201a14 <Lc_build_spkr_graph_65>:
            {
                cbops_set_internal_io_buffer(spkr_graph,intern_rm_idx+i,intern_rm_idx,
                                             op_extra_data->scratch_bufs[usable_scratch_idx+i]);
84201a14:	3d e8       	r3 = M[r5 + Null];
84201a16:	69 d8       	rMAC = M[FP + 52];
84201a18:	0c 00       	r2 = rMAC + Null;
84201a1a:	73 00       	r1 = r4 + rMAC;
84201a1c:	5a 08       	r0 = r9 + Null;
84201a1e:	ff fd aa f0 	call (m) 0x16e66;
84201a22:	29 e2 
        int shift_amount =  op_extra_data->spkr_shift;

        if(intern_rm_idx!=out_indx)
        {
            /* Buffers for output of ratematch if it exists */
            for(i=0; i < num_inputs; i++)
84201a24:	76 20       	r4 = r4 + 1;
84201a26:	3f 21       	r5 = r5 + 4;
84201a28:	f2 6f       	jump (m) Lc_build_spkr_graph_64;

84201a2a <Lc_build_spkr_graph_66>:
            {
                cbops_set_internal_io_buffer(spkr_graph,intern_rm_idx+i,intern_rm_idx,
                                             op_extra_data->scratch_bufs[usable_scratch_idx+i]);
            }
            shift_amount=0;
84201a2a:	01 00       	rMAC = Null + Null;

84201a2c <Lc_build_spkr_graph_67>:
        }

        /*  SW rate adjustment per channel [num_inputs] */
        op_ptr = create_sw_rate_adj_op(num_inputs, &idxs[intern_ins_idx], &idxs[intern_rm_idx],
                                       CBOPS_RATEADJUST_COEFFS,
                                       &op_extra_data->spkr_rate_adjustment,shift_amount);
84201a2c:	09 1c       	pushm <rMAC>;
84201a2e:	41 d8       	rMAC = M[FP + 32];
84201a30:	85 2a       	r3 = Null + 26;
84201a32:	01 f0 c0 ff 	push rMAC + 448;
84201a36:	11 cf 
84201a38:	6a d8       	r0 = M[FP + 52];
84201a3a:	54 d8       	r2 = M[FP + 40];
84201a3c:	52 54       	r0 = r0 LSHIFT 2;
84201a3e:	23 00       	r1 = r2 + Null;
84201a40:	14 01       	r2 = r0 + r2;
84201a42:	01 f9 d2 c8 	r0 = r7 LSHIFT 2;
84201a46:	d3 00       	r1 = r0 + r1;
84201a48:	52 08       	r0 = r8 + Null;
84201a4a:	ff fd a8 f0 	call (m) 0x16bea;
84201a4e:	21 ed 
84201a50:	7e 4c       	SP = SP + -8;
84201a52:	16 00       	r4 = r0 + Null;
        if(!op_ptr)
84201a54:	f0 ff 83 eb 	if EQ jump (m) Lc_build_spkr_graph_27;

84201a58 <Lc_build_spkr_graph_68>:
        {
            goto aFailed;
        }

        op_extra_data->spkr_sw_rateadj_op=op_ptr;
84201a58:	41 d8       	rMAC = M[FP + 32];
84201a5a:	16 f0 7e 8e 	M[rMAC + 504] = r4;
        cbops_rateadjust_passthrough_mode(op_ptr,(op_extra_data->spkr_rate_enactment==RATEMATCHING_SUPPORT_NONE)?TRUE:FALSE);
84201a5e:	03 00       	r1 = Null + Null;
84201a60:	10 f0 71 88 	Null = M[rMAC + 452];
84201a64:	20 f0 43 ce 	if EQ r1 = Null + 1;
84201a68:	ff fd a9 f0 	call (m) 0x16c96;
84201a6c:	2f e1 

        cbops_append_operator_to_graph(spkr_graph,op_ptr);
84201a6e:	33 00       	r1 = r4 + Null;
84201a70:	5a 08       	r0 = r9 + Null;
84201a72:	ff fd aa f0 	call (m) 0x16e96;
84201a76:	25 e1 

        /* Move next input to output of ratematch */
        intern_ins_idx = intern_rm_idx;
84201a78:	e9 f0 0d 88 	r7 = M[FP + 52];

84201a7c <Lc_build_spkr_graph_69>:
    }


    /* Did previous operator terminate route? */
    if(intern_ins_idx!=out_indx)
84201a7c:	59 d8       	rMAC = M[FP + 44];
84201a7e:	1f f9 00 c2 	Null = r7 - rMAC;
84201a82:	2a 60       	if EQ jump (m) Lc_build_spkr_graph_76;

84201a84 <Lc_build_spkr_graph_70>:
    {
        /* Check for Mono to multi-channel */
        if(num_inputs<num_spkrs)
84201a84:	49 d8       	rMAC = M[FP + 36];
84201a86:	1f fa 00 c2 	Null = r8 - rMAC;
84201a8a:	02 f0 9f e0 	if C jump (m) Lc_build_spkr_graph_74;

84201a8e <Lc_build_spkr_graph_71>:
        {
            for(i=0; i < num_spkrs; i++)
84201a8e:	01 00       	rMAC = Null + Null;
84201a90:	72 d8       	r0 = M[FP + 56];
84201a92:	51 d8       	rMAC = M[FP + 40];
84201a94:	52 54       	r0 = r0 LSHIFT 2;
84201a96:	51 00       	rMAC = r0 + rMAC;
84201a98:	4a d8       	r0 = M[FP + 36];
84201a9a:	14 09       	r10 = r0 + Null;
84201a9c:	04 4c       	do (m) Lc__loop0;

84201a9e <Lc_build_spkr_graph_72>:
            {
                idxs[num_io+i] = intern_ins_idx;
84201a9e:	19 f0 00 ee 	M[rMAC + Null] = r7;
84201aa2:	09 21       	rMAC = rMAC + 4;

84201aa4 <Lc__loop0>:
    if(intern_ins_idx!=out_indx)
    {
        /* Check for Mono to multi-channel */
        if(num_inputs<num_spkrs)
        {
            for(i=0; i < num_spkrs; i++)
84201aa4:	e9 f0 0e 88 	r7 = M[FP + 56];

84201aa8 <Lc_build_spkr_graph_74>:
                idxs[num_io+i] = intern_ins_idx;
            }
            intern_ins_idx = num_io;
        }

        op_ptr = create_shift_op(num_spkrs, &idxs[intern_ins_idx], &idxs[out_indx], op_extra_data->spkr_shift);
84201aa8:	41 d8       	rMAC = M[FP + 32];
84201aaa:	5a d8       	r0 = M[FP + 44];
84201aac:	54 d8       	r2 = M[FP + 40];
84201aae:	15 f0 74 88 	r3 = M[rMAC + 464];
84201ab2:	52 54       	r0 = r0 LSHIFT 2;
84201ab4:	23 00       	r1 = r2 + Null;
84201ab6:	14 01       	r2 = r0 + r2;
84201ab8:	01 f9 d2 c8 	r0 = r7 LSHIFT 2;
84201abc:	d3 00       	r1 = r0 + r1;
84201abe:	4a d8       	r0 = M[FP + 36];
84201ac0:	ff fd 21 f1 	call (m) 0x25e08;
84201ac4:	29 ea 
        if(!op_ptr)
84201ac6:	10 04       	Null = r0 - Null;
84201ac8:	f0 ff 8f ea 	if EQ jump (m) Lc_build_spkr_graph_27;

84201acc <Lc_build_spkr_graph_75>:
        {
            goto aFailed;
        }
        cbops_append_operator_to_graph(spkr_graph,op_ptr);
84201acc:	13 00       	r1 = r0 + Null;
84201ace:	5a 08       	r0 = r9 + Null;
84201ad0:	ff fd a9 f0 	call (m) 0x16e96;
84201ad4:	27 ee 

84201ad6 <Lc_build_spkr_graph_76>:
    }

    op_extra_data->spkr_rate_adjustment=0;
84201ad6:	41 d8       	rMAC = M[FP + 32];
84201ad8:	10 f0 70 8e 	M[rMAC + 448] = Null;

    /* create rate monitor op if required */
    op_ptr = NULL;
    if(op_extra_data->spkr_rate_ability == RATEMATCHING_SUPPORT_HW)
84201adc:	11 f0 6f 88 	rMAC = M[rMAC + 444];
84201ae0:	88 24       	Null = rMAC - 2;
84201ae2:	f1 ff a3 e7 	if NE jump (m) Lc_build_spkr_graph_5;

84201ae6 <Lc_build_spkr_graph_77>:
    {
        /* With HW rate adjustmen we always need rate monitor */
        op_ptr = create_rate_monitor_operator(op_extra_data->task_frequency, out_indx);
84201ae6:	41 d8       	rMAC = M[FP + 32];
84201ae8:	12 f0 92 88 	r0 = M[rMAC + 584];
84201aec:	5b d8       	r1 = M[FP + 44];
84201aee:	0a f0 2f e3 	call (m) $_create_rate_monitor_operator;
84201af2:	16 00       	r4 = r0 + Null;
        if(!op_ptr)
84201af4:	f0 ff e3 e9 	if EQ jump (m) Lc_build_spkr_graph_27;

84201af8 <Lc_build_spkr_graph_78>:
        {
            goto aFailed;
        }
        rate_monitor_op_initialise(op_ptr,op_extra_data->spkr_rate, TRUE, 3*MS_PER_SEC);
84201af8:	05 f0 b8 53 	r3 = Null + 3000;
84201afc:	44 20       	r2 = Null + 1;
84201afe:	41 d8       	rMAC = M[FP + 32];
84201b00:	13 f0 6e 88 	r1 = M[rMAC + 440];
84201b04:	f2 ff 38 e8 	call $_rate_monitor_op_initialise;
84201b08:	ff ff ad e7 	jump (m) Lc_build_spkr_graph_8;

84201b0c <Lc_build_spkr_graph_79>:
    return TRUE;
  aFailed:
    DEBUG_GRAPHS("AEC REFERENCE: Building speaker graph, Failed!" );
    pfree(idxs);
    return FALSE;
}
84201b0c:	f6 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84201b0e:	d8 4c       	rts;

84201b10 <$_validate_channels_and_build>:
 *        paths and rebuild the cbops graphs for each path when needed.
 *
 * \param op_data Pointer to the AEC reference operator data.
 */
bool validate_channels_and_build(OPERATOR_DATA *op_data)
{
84201b10:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84201b12:	12 09       	r8 = r0 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84201b14:	a6 f0 0c 88 	r4 = M[r8 + 48];
bool validate_channels_and_build(OPERATOR_DATA *op_data)
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);

    /* check changes in speaker, microphone and reference paths */
    bool spkr_changed = aec_reference_update_spkr_channel_status(op_extra_data);
84201b18:	32 00       	r0 = r4 + Null;
84201b1a:	ce 4e       	call (m) $_aec_reference_update_spkr_channel_status;
84201b1c:	17 00       	r5 = r0 + Null;
    bool mic_changed = aec_reference_update_mic_channel_status(op_extra_data);
84201b1e:	32 00       	r0 = r4 + Null;
84201b20:	50 4e       	call (m) $_aec_reference_update_mic_channel_status;
84201b22:	10 09       	r6 = r0 + Null;
    bool ref_changed = aec_reference_update_ref_channel_status(op_extra_data);
84201b24:	32 00       	r0 = r4 + Null;
84201b26:	01 f0 3f e2 	call (m) $_aec_reference_update_ref_channel_status;
84201b2a:	11 09       	r7 = r0 + Null;


    patch_fn_shared(aec_reference);

    /* update sidetone method */
    aec_reference_update_sidetone_method(op_extra_data);
84201b2c:	32 00       	r0 = r4 + Null;
84201b2e:	01 f0 31 e4 	call (m) $_aec_reference_update_sidetone_method;

    /* rebuild graphs if there is change in
     * speaker or microphone path
     */
    if(!aec_reference_build_graphs(op_extra_data, spkr_changed, mic_changed))
84201b32:	44 08       	r2 = r6 + Null;
84201b34:	3b 00       	r1 = r5 + Null;
84201b36:	32 00       	r0 = r4 + Null;
84201b38:	01 f0 37 e5 	call (m) $_aec_reference_build_graphs;
84201b3c:	10 04       	Null = r0 - Null;
84201b3e:	3b 60       	if EQ jump (m) Lc_validate_channels_and_build_13;

84201b40 <Lc_validate_channels_and_build_2>:
    }

    /* also if there is changes in reference path, then
     * apply that change to speaker graph
     */
    if(ref_changed || spkr_changed)
84201b40:	0f f9 00 c2 	Null = r7 - Null;
84201b44:	03 62       	if NE jump (m) Lc_validate_channels_and_build_4;

84201b46 <Lc_validate_channels_and_build_3>:
84201b46:	38 04       	Null = r5 - Null;
84201b48:	0a 60       	if EQ jump (m) Lc_validate_channels_and_build_5;

84201b4a <Lc_validate_channels_and_build_4>:
    {
        if(!aec_reference_spkr_include_ref_path(op_extra_data, GetRefChannelStatus(op_extra_data)))
84201b4a:	61 f0 76 88 	rMAC = M[r4 + 472];
84201b4e:	13 f2 00 00 	r1 = rMAC AND 0x4000;
84201b52:	32 00       	r0 = r4 + Null;
84201b54:	03 f0 31 e9 	call (m) $_aec_reference_spkr_include_ref_path;
84201b58:	10 04       	Null = r0 - Null;
84201b5a:	2d 60       	if EQ jump (m) Lc_validate_channels_and_build_13;

84201b5c <Lc_validate_channels_and_build_5>:
            goto aFailed;
        }
    }

    if(op_extra_data->mic_graph != NULL ||
       op_extra_data->spkr_graph!= NULL)
84201b5c:	61 f0 6a 88 	rMAC = M[r4 + 424];
84201b60:	04 62       	if NE jump (m) Lc_validate_channels_and_build_7;

84201b62 <Lc_validate_channels_and_build_6>:
84201b62:	61 f0 72 88 	rMAC = M[r4 + 456];
84201b66:	16 60       	if EQ jump (m) Lc_validate_channels_and_build_10;

84201b68 <Lc_validate_channels_and_build_7>:
    {
        /* start running the graphs if not already running
         */
        if(op_extra_data->kick_id == TIMER_ID_INVALID)
84201b68:	60 f0 5d 88 	Null = M[r4 + 372];
84201b6c:	11 62       	if NE jump (m) Lc_validate_channels_and_build_9;

84201b6e <Lc_validate_channels_and_build_8>:
        {
            op_extra_data->kick_id = timer_schedule_event_in(op_extra_data->kick_period, aec_reference_timer_task,(void*)op_data);
84201b6e:	42 f0 07 f0 	r5 = Null + 69207687;
84201b72:	87 4a 
84201b74:	68 f0 94 88 	r6 = M[r4 + 592];
        INTERVAL time_in,
        tTimerEventFunction TimerEventFunction,
        void *data_pointer)
{
    return create_add_strict_event(
            time_add(hal_get_time(), time_in), TimerEventFunction, data_pointer);
84201b78:	ff fd 7e f1 	call (m) 0x317e8;
84201b7c:	31 e3 
84201b7e:	42 0c       	r0 = r6 + r0;
84201b80:	54 08       	r2 = r8 + Null;
84201b82:	3b 00       	r1 = r5 + Null;
84201b84:	ff fd 92 f0 	call (m) 0x1402a;
84201b88:	27 e5 
}
84201b8a:	62 f0 5d 8e 	M[r4 + 372] = r0;

84201b8e <Lc_validate_channels_and_build_9>:
    else
    {
        timer_cancel_event_atomic(&op_extra_data->kick_id);
    }

    return TRUE;
84201b8e:	42 20       	r0 = Null + 1;
84201b90:	16 6e       	jump (m) Lc_validate_channels_and_build_14;

84201b92 <Lc_validate_channels_and_build_10>:
            op_extra_data->kick_id = timer_schedule_event_in(op_extra_data->kick_period, aec_reference_timer_task,(void*)op_data);
        }
    }
    else
    {
        timer_cancel_event_atomic(&op_extra_data->kick_id);
84201b92:	06 f0 74 45 	r4 = r4 + 372;
                    ((void)timer_cancel_event_ret(timer_id, NULL, NULL))


INLINE_SECTION static inline void timer_cancel_event_atomic(tTimerId *timer_id)
{
    interrupt_block();
84201b96:	ff fd 58 f1 	call (m) 0x2cc9c;
84201b9a:	27 e8 
    if (*timer_id != TIMER_ID_INVALID)
84201b9c:	32 e8       	r0 = M[r4 + Null];
84201b9e:	07 60       	if EQ jump (m) Lc_validate_channels_and_build_12;

84201ba0 <Lc_validate_channels_and_build_11>:
    {
        (void) timer_cancel_event_ret(*timer_id, NULL, NULL);
84201ba0:	04 00       	r2 = Null + Null;
84201ba2:	03 00       	r1 = Null + Null;
84201ba4:	ff fd 93 f0 	call (m) 0x141bc;
84201ba8:	39 e0 
        *timer_id = TIMER_ID_INVALID;
84201baa:	30 ee       	M[r4 + Null] = Null;

84201bac <Lc_validate_channels_and_build_12>:
    }
    interrupt_unblock();
84201bac:	ff fd 58 f1 	call (m) 0x2ccb8;
84201bb0:	2d e8 
84201bb2:	ee 6f       	jump (m) Lc_validate_channels_and_build_9;

84201bb4 <Lc_validate_channels_and_build_13>:

  aFailed:
    /* it failed to complete the build for some reason,
     * clean up all the graphs.
     */
    aec_reference_cleanup(op_data);
84201bb4:	52 08       	r0 = r8 + Null;
84201bb6:	fc ff 31 e2 	call (m) $_aec_reference_cleanup;
    return FALSE;
84201bba:	02 00       	r0 = Null + Null;

84201bbc <Lc_validate_channels_and_build_14>:
}
84201bbc:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84201bbe:	d8 4c       	rts;

84201bc0 <$_aec_reference_update_mic_channel_status>:
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 * \return whether there is a change in speaker channel status that requires
 *         rebuilding of the speaker graph.
 */
bool aec_reference_update_mic_channel_status(AEC_REFERENCE_OP_DATA *op_extra_data)
{
84201bc0:	72 1c       	pushm <FP(=SP), r4, r5>;
    patch_fn_shared(aec_reference);
    unsigned i;
    unsigned mic_channel_status=0;
84201bc2:	03 00       	r1 = Null + Null;
    unsigned number_mics=0;
84201bc4:	04 00       	r2 = Null + Null;
    tCbuffer *inputBuf,*outputBuf;

    patch_fn_shared(aec_reference);

    /* Microphones are connected */
    op_extra_data->source_kicks = 0;
84201bc6:	20 f0 7b 8e 	M[r0 + 492] = Null;
    if(op_extra_data->input_stream[AEC_REF_MIC_TERMINAL1] && op_extra_data->output_stream[AEC_REF_OUTPUT_TERMINAL1])
84201bca:	91 88       	rMAC = M[r0 + 8];
84201bcc:	3c 60       	if EQ jump (m) Lc_aec_reference_update_mic_channel_status_17;

84201bce <Lc_aec_reference_update_mic_channel_status_2>:
84201bce:	d1 a8       	rMAC = M[r0 + 76];
84201bd0:	3a 60       	if EQ jump (m) Lc_aec_reference_update_mic_channel_status_17;

84201bd2 <Lc_aec_reference_update_mic_channel_status_3>:
    {
        bool all_mic_channels = TRUE;
        for(i=0;i<MAX_NUMBER_MICS;i++)
84201bd2:	01 00       	rMAC = Null + Null;
84201bd4:	04 6e       	jump (m) Lc_aec_reference_update_mic_channel_status_5;

84201bd6 <Lc_aec_reference_update_mic_channel_status_4>:
}


inline static unsigned MicrophoneTerminalByIndex(unsigned i)
{
    if(i<4)
84201bd6:	08 25       	Null = rMAC - 4;
84201bd8:	02 f0 8f e0 	if C jump (m) Lc_aec_reference_update_mic_channel_status_6;

84201bdc <Lc_aec_reference_update_mic_channel_status_5>:
    {
        return (i + AEC_REF_MIC_TERMINAL1);
84201bdc:	8d 20       	r3 = rMAC + 2;
        {
            inputBuf  = op_extra_data->input_stream[MicrophoneTerminalByIndex(i)];
84201bde:	6d 54       	r3 = r3 LSHIFT 2;
84201be0:	56 e9       	r4 = M[r0 + r3];

inline static unsigned OutputTerminalByIndex(unsigned i)
{
    if(i<4)
    {
        return (i + AEC_REF_OUTPUT_TERMINAL1);
84201be2:	cd 20       	r3 = rMAC + 3;
84201be4:	05 6e       	jump (m) Lc_aec_reference_update_mic_channel_status_7;

84201be6 <Lc_aec_reference_update_mic_channel_status_6>:
    {
        return (i + AEC_REF_MIC_TERMINAL1);
    }
    else
    {
        return ((i-4)+ AEC_REF_MIC_TERMINAL5);
84201be6:	0d 22       	r3 = rMAC + 8;
84201be8:	6d 54       	r3 = r3 LSHIFT 2;
84201bea:	56 e9       	r4 = M[r0 + r3];
    {
        return (i + AEC_REF_OUTPUT_TERMINAL1);
    }
    else
    {
        return ((i-4) + AEC_REF_OUTPUT_TERMINAL5);
84201bec:	4d 22       	r3 = rMAC + 9;

84201bee <Lc_aec_reference_update_mic_channel_status_7>:
            outputBuf = op_extra_data->output_stream[OutputTerminalByIndex(i)];
84201bee:	27 f0 40 20 	r5 = r0 + 64;
84201bf2:	6d 54       	r3 = r3 LSHIFT 2;
84201bf4:	7d e9       	r3 = M[r5 + r3];

            if(inputBuf && outputBuf)
84201bf6:	30 04       	Null = r4 - Null;
84201bf8:	20 60       	if EQ jump (m) Lc_aec_reference_update_mic_channel_status_15;

84201bfa <Lc_aec_reference_update_mic_channel_status_8>:
84201bfa:	28 04       	Null = r3 - Null;
84201bfc:	20 60       	if EQ jump (m) Lc_aec_reference_update_mic_channel_status_16;

84201bfe <Lc_aec_reference_update_mic_channel_status_9>:
            {
                number_mics++;
84201bfe:	64 20       	r2 = r2 + 1;

                if(i<4)
84201c00:	08 25       	Null = rMAC - 4;
84201c02:	02 f0 a9 e0 	if C jump (m) Lc_aec_reference_update_mic_channel_status_14;

84201c06 <Lc_aec_reference_update_mic_channel_status_10>:
                {
                    mic_channel_status |= (AEC_REFERENCE_CONSTANT_CONN_MIKE_1<<i);
84201c06:	0d 00       	r3 = rMAC + Null;
84201c08:	00 f5 95 de 	r3 = 0x1 LSHIFT r3;
84201c0c:	5b 13       	r1 = r1 OR r3;

inline static unsigned OutputTerminalByIndex(unsigned i)
{
    if(i<4)
    {
        return (i + AEC_REF_OUTPUT_TERMINAL1);
84201c0e:	cd 20       	r3 = rMAC + 3;

84201c10 <Lc_aec_reference_update_mic_channel_status_11>:
                }
                else
                {
                    mic_channel_status |= ((AEC_REFERENCE_CONSTANT_CONN_MIKE_5>>4)<<i);
                }
                op_extra_data->source_kicks |= (1 << OutputTerminalByIndex(i) );
84201c10:	00 f5 95 de 	r3 = 0x1 LSHIFT r3;
84201c14:	26 f0 7b 88 	r4 = M[r0 + 492];
84201c18:	ad 13       	r3 = r3 OR r4;
84201c1a:	25 f0 7b 8e 	M[r0 + 492] = r3;

84201c1e <Lc_aec_reference_update_mic_channel_status_12>:
    /* Microphones are connected */
    op_extra_data->source_kicks = 0;
    if(op_extra_data->input_stream[AEC_REF_MIC_TERMINAL1] && op_extra_data->output_stream[AEC_REF_OUTPUT_TERMINAL1])
    {
        bool all_mic_channels = TRUE;
        for(i=0;i<MAX_NUMBER_MICS;i++)
84201c1e:	49 20       	rMAC = rMAC + 1;
84201c20:	08 26       	Null = rMAC - 8;
84201c22:	da 65       	if NC jump (m) Lc_aec_reference_update_mic_channel_status_4;

84201c24 <Lc_aec_reference_update_mic_channel_status_13>:
            mic_channel_status = 0;
            op_extra_data->source_kicks = 0;
        }
    }

    if(mic_channel_status == 0)
84201c24:	18 04       	Null = r1 - Null;
84201c26:	0f 60       	if EQ jump (m) Lc_aec_reference_update_mic_channel_status_17;

84201c28 <Lc_20>:
84201c28:	33 6e       	jump (m) Lc_aec_reference_update_mic_channel_status_27;

84201c2a <Lc_aec_reference_update_mic_channel_status_14>:
                {
                    mic_channel_status |= (AEC_REFERENCE_CONSTANT_CONN_MIKE_1<<i);
                }
                else
                {
                    mic_channel_status |= ((AEC_REFERENCE_CONSTANT_CONN_MIKE_5>>4)<<i);
84201c2a:	0d 00       	r3 = rMAC + Null;
84201c2c:	10 f0 00 f5 	r3 = 0x1000 LSHIFT r3;
84201c30:	95 ce 
84201c32:	5b 13       	r1 = r1 OR r3;
    }
    else
    {
        return ((i-4) + AEC_REF_OUTPUT_TERMINAL5);
84201c34:	4d 22       	r3 = rMAC + 9;
84201c36:	ed 6f       	jump (m) Lc_aec_reference_update_mic_channel_status_11;

84201c38 <Lc_aec_reference_update_mic_channel_status_15>:
                }
                op_extra_data->source_kicks |= (1 << OutputTerminalByIndex(i) );
            }
            else if(inputBuf || outputBuf)
84201c38:	28 04       	Null = r3 - Null;
84201c3a:	f2 61       	if EQ jump (m) Lc_aec_reference_update_mic_channel_status_12;

84201c3c <Lc_aec_reference_update_mic_channel_status_16>:
                break;
            }
        }
        if(!all_mic_channels)
        {
            number_mics=0;
84201c3c:	04 00       	r2 = Null + Null;
            mic_channel_status = 0;
84201c3e:	03 00       	r1 = Null + Null;
            op_extra_data->source_kicks = 0;
84201c40:	20 f0 7b 8e 	M[r0 + 492] = Null;

84201c44 <Lc_aec_reference_update_mic_channel_status_17>:
        /* we cannot form N->N mic path, see if we
         * can form 1->0 mic path, the latter would enable
         * supporting sidetone without microphone output.
         */
        inputBuf  = op_extra_data->input_stream[MicrophoneTerminalByIndex(0)];
        outputBuf = op_extra_data->output_stream[OutputTerminalByIndex(0)];
84201c44:	d5 a8       	r3 = M[r0 + 76];
        if(inputBuf != NULL && outputBuf == NULL)
84201c46:	91 88       	rMAC = M[r0 + 8];
84201c48:	23 60       	if EQ jump (m) Lc_aec_reference_update_mic_channel_status_27;

84201c4a <Lc_aec_reference_update_mic_channel_status_18>:
84201c4a:	28 04       	Null = r3 - Null;
84201c4c:	21 62       	if NE jump (m) Lc_aec_reference_update_mic_channel_status_27;

84201c4e <Lc_aec_reference_update_mic_channel_status_19>:
        {
            /* mic0 connected, out0 disconnected, we can have 1->0 config */
            mic_channel_status = AEC_REFERENCE_CONSTANT_CONN_MIKE_1_INPUT_ONLY;
84201c4e:	01 f0 03 f0 	r1 = Null + 1048576;
84201c52:	00 40 
            number_mics = 1;
84201c54:	44 20       	r2 = Null + 1;

            /* However check that all other mics/outs are disconnected */
            for(i=1;i<MAX_NUMBER_MICS;i++)
84201c56:	21 00       	rMAC = r2 + Null;
84201c58:	04 6e       	jump (m) Lc_aec_reference_update_mic_channel_status_21;

84201c5a <Lc_aec_reference_update_mic_channel_status_20>:
}


inline static unsigned MicrophoneTerminalByIndex(unsigned i)
{
    if(i<4)
84201c5a:	08 25       	Null = rMAC - 4;
84201c5c:	02 f0 8f e0 	if C jump (m) Lc_aec_reference_update_mic_channel_status_22;

84201c60 <Lc_aec_reference_update_mic_channel_status_21>:
    {
        return (i + AEC_REF_MIC_TERMINAL1);
84201c60:	8d 20       	r3 = rMAC + 2;
            {
                inputBuf  = op_extra_data->input_stream[MicrophoneTerminalByIndex(i)];
84201c62:	6d 54       	r3 = r3 LSHIFT 2;
84201c64:	56 e9       	r4 = M[r0 + r3];

inline static unsigned OutputTerminalByIndex(unsigned i)
{
    if(i<4)
    {
        return (i + AEC_REF_OUTPUT_TERMINAL1);
84201c66:	cd 20       	r3 = rMAC + 3;
84201c68:	05 6e       	jump (m) Lc_aec_reference_update_mic_channel_status_23;

84201c6a <Lc_aec_reference_update_mic_channel_status_22>:
    {
        return (i + AEC_REF_MIC_TERMINAL1);
    }
    else
    {
        return ((i-4)+ AEC_REF_MIC_TERMINAL5);
84201c6a:	0d 22       	r3 = rMAC + 8;
84201c6c:	6d 54       	r3 = r3 LSHIFT 2;
84201c6e:	56 e9       	r4 = M[r0 + r3];
    {
        return (i + AEC_REF_OUTPUT_TERMINAL1);
    }
    else
    {
        return ((i-4) + AEC_REF_OUTPUT_TERMINAL5);
84201c70:	4d 22       	r3 = rMAC + 9;

84201c72 <Lc_aec_reference_update_mic_channel_status_23>:
                outputBuf = op_extra_data->output_stream[OutputTerminalByIndex(i)];
84201c72:	27 f0 40 20 	r5 = r0 + 64;
84201c76:	6d 54       	r3 = r3 LSHIFT 2;
84201c78:	7d e9       	r3 = M[r5 + r3];
                if(inputBuf != NULL || outputBuf != NULL)
84201c7a:	30 04       	Null = r4 - Null;
84201c7c:	03 62       	if NE jump (m) Lc_aec_reference_update_mic_channel_status_25;

84201c7e <Lc_aec_reference_update_mic_channel_status_24>:
84201c7e:	28 04       	Null = r3 - Null;
84201c80:	04 60       	if EQ jump (m) Lc_aec_reference_update_mic_channel_status_26;

84201c82 <Lc_aec_reference_update_mic_channel_status_25>:
                {
                    /* Another mic input and/or output is connected,
                     * we cannot have 1->0 mic path either.
                     */
                    mic_channel_status = 0;
84201c82:	03 00       	r1 = Null + Null;
                    number_mics = 0;
84201c84:	04 00       	r2 = Null + Null;
                    break;
84201c86:	04 6e       	jump (m) Lc_aec_reference_update_mic_channel_status_27;

84201c88 <Lc_aec_reference_update_mic_channel_status_26>:
            /* mic0 connected, out0 disconnected, we can have 1->0 config */
            mic_channel_status = AEC_REFERENCE_CONSTANT_CONN_MIKE_1_INPUT_ONLY;
            number_mics = 1;

            /* However check that all other mics/outs are disconnected */
            for(i=1;i<MAX_NUMBER_MICS;i++)
84201c88:	49 20       	rMAC = rMAC + 1;
84201c8a:	08 26       	Null = rMAC - 8;
84201c8c:	e7 65       	if NC jump (m) Lc_aec_reference_update_mic_channel_status_20;

84201c8e <Lc_aec_reference_update_mic_channel_status_27>:
                }
            }
        }
    }

    if((GetMicChannelStatus(op_extra_data)) == mic_channel_status)
84201c8e:	21 f0 76 88 	rMAC = M[r0 + 472];
84201c92:	0f f0 15 f8 	r3 = rMAC AND 0x1f000f;
84201c96:	0f 00 
84201c98:	e8 04       	Null = r3 - r1;
84201c9a:	03 62       	if NE jump (m) Lc_aec_reference_update_mic_channel_status_29;

84201c9c <Lc_aec_reference_update_mic_channel_status_28>:
    {
        /* No change in the mic path */
        return FALSE;
84201c9c:	02 00       	r0 = Null + Null;
84201c9e:	0a 6e       	jump (m) Lc_aec_reference_update_mic_channel_status_30;

84201ca0 <Lc_aec_reference_update_mic_channel_status_29>:
    }

    /* update number of mics */
    op_extra_data->num_mic_channels = number_mics;
84201ca0:	24 f0 78 8e 	M[r0 + 480] = r2;

    /* update mic channel status */
    SetMicChannelStatus(op_extra_data, mic_channel_status);
84201ca4:	f0 ff 11 f7 	rMAC = rMAC AND 0xffe0fff0;
84201ca8:	f0 1f 
84201caa:	c9 12       	rMAC = rMAC OR r1;
84201cac:	21 f0 76 8e 	M[r0 + 472] = rMAC;

    return TRUE;
84201cb0:	42 20       	r0 = Null + 1;

84201cb2 <Lc_aec_reference_update_mic_channel_status_30>:
}
84201cb2:	72 48       	popm <FP, r4, r5>;
84201cb4:	d8 4c       	rts;

84201cb6 <$_aec_reference_update_spkr_channel_status>:
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 * \return whether there is a change in speaker channel status that requires
 *         rebuilding of the speaker graph.
 */
bool aec_reference_update_spkr_channel_status(AEC_REFERENCE_OP_DATA *op_extra_data)
{
84201cb6:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
    unsigned i;
    unsigned spkr_channel_status=0;
84201cb8:	03 00       	r1 = Null + Null;
    unsigned number_spkrs=0;
84201cba:	01 00       	rMAC = Null + Null;
    tCbuffer *inputBuf,*outputBuf;

    patch_fn_shared(aec_reference);

    /* Speakers are connected */
    op_extra_data->sink_kicks   = 0;
84201cbc:	20 f0 7c 8e 	M[r0 + 496] = Null;
    if(op_extra_data->input_stream[AEC_REF_INPUT_TERMINAL1] && op_extra_data->output_stream[AEC_REF_SPKR_TERMINAL1])
84201cc0:	14 e8       	r2 = M[r0 + Null];
84201cc2:	39 60       	if EQ jump (m) Lc_aec_reference_update_spkr_channel_status_16;

84201cc4 <Lc_aec_reference_update_spkr_channel_status_2>:
84201cc4:	54 a8       	r2 = M[r0 + 68];
84201cc6:	37 60       	if EQ jump (m) Lc_aec_reference_update_spkr_channel_status_16;

84201cc8 <Lc_aec_reference_update_spkr_channel_status_3>:
    {
        int in_count=1;
84201cc8:	45 20       	r3 = Null + 1;
        int out_count=1;
84201cca:	2e 00       	r4 = r3 + Null;

        /* Master Channel is connected */
        spkr_channel_status |= AEC_REFERENCE_CONSTANT_CONN_SPKR_1;
84201ccc:	03 28       	r1 = Null + 16;

        /* Primary sink is connected */
        op_extra_data->sink_kicks = (1<<AEC_REF_INPUT_TERMINAL1);
84201cce:	29 00       	rMAC = r3 + Null;
84201cd0:	21 f0 7c 8e 	M[r0 + 496] = rMAC;

        for(i=1;i<MAX_NUMBER_SPEAKERS;i++)
84201cd4:	04 6e       	jump (m) Lc_aec_reference_update_spkr_channel_status_5;

84201cd6 <Lc_aec_reference_update_spkr_channel_status_4>:
        {
            int sink_idx = SpeakerInputTerminalByIndex(i);
84201cd6:	88 24       	Null = rMAC - 2;
84201cd8:	02 f0 8b e0 	if C jump (m) Lc_aec_reference_update_spkr_channel_status_6;

84201cdc <Lc_aec_reference_update_spkr_channel_status_5>:
84201cdc:	47 20       	r5 = Null + 1;

            /* Old terminals kept for backwards compatibility */
            outputBuf = op_extra_data->output_stream[SpeakerTerminalByIndex(i)];
84201cde:	84 20       	r2 = Null + 2;
84201ce0:	03 6e       	jump (m) Lc_aec_reference_update_spkr_channel_status_7;

84201ce2 <Lc_aec_reference_update_spkr_channel_status_6>:
        /* Primary sink is connected */
        op_extra_data->sink_kicks = (1<<AEC_REF_INPUT_TERMINAL1);

        for(i=1;i<MAX_NUMBER_SPEAKERS;i++)
        {
            int sink_idx = SpeakerInputTerminalByIndex(i);
84201ce2:	0f 21       	r5 = rMAC + 4;

            /* Old terminals kept for backwards compatibility */
            outputBuf = op_extra_data->output_stream[SpeakerTerminalByIndex(i)];
84201ce4:	4c 21       	r2 = rMAC + 5;

84201ce6 <Lc_aec_reference_update_spkr_channel_status_7>:
84201ce6:	28 f0 40 20 	r6 = r0 + 64;
84201cea:	64 54       	r2 = r2 LSHIFT 2;
84201cec:	84 f0 04 e8 	r2 = M[r6 + r2];
            inputBuf  = op_extra_data->input_stream[sink_idx];
84201cf0:	01 f7 d8 c8 	r6 = r5 LSHIFT 2;

            if(inputBuf || outputBuf)
84201cf4:	28 f0 08 e8 	r6 = M[r0 + r6];
84201cf8:	03 62       	if NE jump (m) Lc_aec_reference_update_spkr_channel_status_9;

84201cfa <Lc_aec_reference_update_spkr_channel_status_8>:
84201cfa:	20 04       	Null = r2 - Null;
84201cfc:	15 60       	if EQ jump (m) Lc_aec_reference_update_spkr_channel_status_13;

84201cfe <Lc_aec_reference_update_spkr_channel_status_9>:
            {
                spkr_channel_status |= (AEC_REFERENCE_CONSTANT_CONN_SPKR_1<<i);
84201cfe:	09 09       	r7 = rMAC + Null;
84201d00:	08 f9 99 ce 	r7 = 0x10 LSHIFT r7;
84201d04:	00 f9 73 c8 	r1 = r1 OR r7;

                if(inputBuf)
84201d08:	0f f8 00 c2 	Null = r6 - Null;
84201d0c:	23 60       	if EQ jump (m) Lc_aec_reference_update_spkr_channel_status_18;

84201d0e <Lc_aec_reference_update_spkr_channel_status_10>:
                {
                    op_extra_data->sink_kicks |= (1<<sink_idx);
84201d0e:	00 f7 97 de 	r5 = 0x1 LSHIFT r5;
84201d12:	28 f0 7c 88 	r6 = M[r0 + 496];
84201d16:	00 f8 77 c8 	r5 = r5 OR r6;
84201d1a:	27 f0 7c 8e 	M[r0 + 496] = r5;
                    in_count++;
84201d1e:	6d 20       	r3 = r3 + 1;

84201d20 <Lc_aec_reference_update_spkr_channel_status_11>:
                {
                    /* Special case allows mono input split to multiple outputs*/
                    return(FALSE);
                }

                if(outputBuf)
84201d20:	20 04       	Null = r2 - Null;
84201d22:	1c 60       	if EQ jump (m) Lc_aec_reference_update_spkr_channel_status_20;

84201d24 <Lc_aec_reference_update_spkr_channel_status_12>:
                {
                    out_count++;
84201d24:	76 20       	r4 = r4 + 1;

84201d26 <Lc_aec_reference_update_spkr_channel_status_13>:
        spkr_channel_status |= AEC_REFERENCE_CONSTANT_CONN_SPKR_1;

        /* Primary sink is connected */
        op_extra_data->sink_kicks = (1<<AEC_REF_INPUT_TERMINAL1);

        for(i=1;i<MAX_NUMBER_SPEAKERS;i++)
84201d26:	49 20       	rMAC = rMAC + 1;
84201d28:	08 26       	Null = rMAC - 8;
84201d2a:	d6 65       	if NC jump (m) Lc_aec_reference_update_spkr_channel_status_4;

84201d2c <Lc_aec_reference_update_spkr_channel_status_14>:
                    return(FALSE);
                }
            }
        }
        /* Verify complete channel setup */
        number_spkrs = out_count;
84201d2c:	31 00       	rMAC = r4 + Null;
        if(in_count==out_count)
84201d2e:	a8 05       	Null = r3 - r4;
84201d30:	18 62       	if NE jump (m) Lc_aec_reference_update_spkr_channel_status_21;

84201d32 <Lc_aec_reference_update_spkr_channel_status_15>:
        {
            /* Parallel channels */
            spkr_channel_status |= AEC_REFERENCE_CONSTANT_CONN_TYPE_PARA;
84201d32:	db cd       	r1 = r1 OR 0x1000;

84201d34 <Lc_aec_reference_update_spkr_channel_status_16>:
            /* Mono Input.  Split outputs */
            PL_ASSERT(in_count==1);
        }
    }

    if((GetSpkrChannelStatus(op_extra_data)) == spkr_channel_status)
84201d34:	24 f0 76 88 	r2 = M[r0 + 472];
84201d38:	45 f1 f0 1f 	r3 = r2 AND 0x3ff0;
84201d3c:	e8 04       	Null = r3 - r1;
84201d3e:	0c 60       	if EQ jump (m) Lc_aec_reference_update_spkr_channel_status_19;

84201d40 <Lc_aec_reference_update_spkr_channel_status_17>:
        /* No change in the speaker channel status */
        return FALSE;
    }

    /* update number of speaker channels */
    op_extra_data->num_spkr_channels = number_spkrs;
84201d40:	21 f0 77 8e 	M[r0 + 476] = rMAC;

    /* update speaker channel status */
    SetSpkrChannelStatus(op_extra_data, spkr_channel_status);
84201d44:	41 fe 0f 00 	rMAC = r2 AND 0xffffc00f;
84201d48:	c9 12       	rMAC = rMAC OR r1;
84201d4a:	21 f0 76 8e 	M[r0 + 472] = rMAC;
    return TRUE;
84201d4e:	42 20       	r0 = Null + 1;
84201d50:	18 6e       	jump (m) Lc_aec_reference_update_spkr_channel_status_25;

84201d52 <Lc_aec_reference_update_spkr_channel_status_18>:
                if(inputBuf)
                {
                    op_extra_data->sink_kicks |= (1<<sink_idx);
                    in_count++;
                }
                else if(in_count>1)
84201d52:	68 24       	Null = r3 - 1;
84201d54:	e6 6d       	if LE jump (m) Lc_aec_reference_update_spkr_channel_status_11;

84201d56 <Lc_aec_reference_update_spkr_channel_status_19>:
                {
                    /* Special case allows mono input split to multiple outputs*/
                    return(FALSE);
84201d56:	02 00       	r0 = Null + Null;
84201d58:	14 6e       	jump (m) Lc_aec_reference_update_spkr_channel_status_25;

84201d5a <Lc_aec_reference_update_spkr_channel_status_20>:

                if(outputBuf)
                {
                    out_count++;
                }
                else if(out_count>1)
84201d5a:	70 24       	Null = r4 - 1;
84201d5c:	fd 6b       	if GT jump (m) Lc_aec_reference_update_spkr_channel_status_19;

84201d5e <Lc_21>:
84201d5e:	e4 6f       	jump (m) Lc_aec_reference_update_spkr_channel_status_13;

84201d60 <Lc_aec_reference_update_spkr_channel_status_21>:
        if(in_count==out_count)
        {
            /* Parallel channels */
            spkr_channel_status |= AEC_REFERENCE_CONSTANT_CONN_TYPE_PARA;
        }
        else if(out_count==1)
84201d60:	70 24       	Null = r4 - 1;
84201d62:	06 62       	if NE jump (m) Lc_aec_reference_update_spkr_channel_status_23;

84201d64 <Lc_aec_reference_update_spkr_channel_status_22>:
        {
            /* Mono Output.  Mix inputs */
            spkr_channel_status |= AEC_REFERENCE_CONSTANT_CONN_TYPE_MIX;
84201d64:	20 f0 00 f3 	r1 = r1 OR 0x2000;
84201d68:	53 d8 
            number_spkrs = in_count;
84201d6a:	29 00       	rMAC = r3 + Null;
84201d6c:	e4 6f       	jump (m) Lc_aec_reference_update_spkr_channel_status_16;

84201d6e <Lc_aec_reference_update_spkr_channel_status_23>:
        }
        else
        {
            /* Mono Input.  Split outputs */
            PL_ASSERT(in_count==1);
84201d6e:	68 24       	Null = r3 - 1;
84201d70:	e2 61       	if EQ jump (m) Lc_aec_reference_update_spkr_channel_status_16;

84201d72 <Lc_aec_reference_update_spkr_channel_status_24>:
84201d72:	03 f0 5c 4a 	r1 = Null + 1628;
84201d76:	02 f0 13 60 	r0 = Null + 4115;
84201d7a:	ff fd 90 f0 	call (m) 0x13f12;
84201d7e:	39 ec 

84201d80 <Lc_aec_reference_update_spkr_channel_status_25>:

    /* update speaker channel status */
    SetSpkrChannelStatus(op_extra_data, spkr_channel_status);
    return TRUE;

}
84201d80:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84201d82:	d8 4c       	rts;

84201d84 <$_aec_reference_update_ref_channel_status>:
 *         insertion/deletion of the reference sub-path into/from speaker graph.
 */
bool aec_reference_update_ref_channel_status(AEC_REFERENCE_OP_DATA *op_extra_data)
{

    unsigned ref_channel_status = 0;
84201d84:	01 00       	rMAC = Null + Null;
    patch_fn_shared(aec_reference);

    /* Check AEC reference */
    if(op_extra_data->output_stream[AEC_REF_REFERENCE_TERMINAL] && (op_extra_data->channel_status&AEC_REFERENCE_CONSTANT_CONN_MIKE_1))
84201d86:	13 a8       	r1 = M[r0 + 64];
84201d88:	0c 60       	if EQ jump (m) Lc_aec_reference_update_ref_channel_status_4;

84201d8a <Lc_aec_reference_update_ref_channel_status_2>:
84201d8a:	23 f0 76 88 	r1 = M[r0 + 472];
84201d8e:	1b c0       	r1 = r1 AND 0x1;
84201d90:	08 60       	if EQ jump (m) Lc_aec_reference_update_ref_channel_status_4;

84201d92 <Lc_aec_reference_update_ref_channel_status_3>:
    {
        op_extra_data->source_kicks |= 1<<AEC_REF_REFERENCE_TERMINAL;
84201d92:	21 f0 7b 88 	rMAC = M[r0 + 492];
84201d96:	09 c8       	rMAC = rMAC OR 0x1;
84201d98:	21 f0 7b 8e 	M[r0 + 492] = rMAC;
        ref_channel_status = AEC_REFERENCE_CONSTANT_CONN_TYPE_REF;
84201d9c:	21 f0 00 40 	rMAC = Null + 16384;

84201da0 <Lc_aec_reference_update_ref_channel_status_4>:
    }

    if(ref_channel_status == (GetRefChannelStatus(op_extra_data)))
84201da0:	23 f0 76 88 	r1 = M[r0 + 472];
84201da4:	34 f2 00 00 	r2 = r1 AND 0x4000;
84201da8:	08 05       	Null = rMAC - r2;
84201daa:	03 62       	if NE jump (m) Lc_aec_reference_update_ref_channel_status_6;

84201dac <Lc_aec_reference_update_ref_channel_status_5>:
    {
        /* No change in reference path */
        return FALSE;
84201dac:	02 00       	r0 = Null + Null;
84201dae:	07 6e       	jump (m) Lc_aec_reference_update_ref_channel_status_7;

84201db0 <Lc_aec_reference_update_ref_channel_status_6>:
    }

    /* reference path has changed, update
     * channel status.
     */
    SetRefChannelStatus(op_extra_data, ref_channel_status);
84201db0:	33 fd ff 1f 	r1 = r1 AND 0xffffbfff;
84201db4:	c9 12       	rMAC = rMAC OR r1;
84201db6:	21 f0 76 8e 	M[r0 + 472] = rMAC;
    return TRUE;
84201dba:	42 20       	r0 = Null + 1;

84201dbc <Lc_aec_reference_update_ref_channel_status_7>:
84201dbc:	d8 4c       	rts;

84201dbe <$_aec_reference_update_sidetone_method>:
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 * \return whether there is a change in sidetone mixing method
 */
void aec_reference_update_sidetone_method(AEC_REFERENCE_OP_DATA *op_extra_data)
{
84201dbe:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84201dc0:	16 00       	r4 = r0 + Null;
    AEC_REFERENCE_SIDETONE_METHOD sidetone_method = AEC_SIDETONE_NOT_REQUIRED;
84201dc2:	07 00       	r5 = Null + Null;
    patch_fn_shared(aec_reference);

    /* reset state of sidetone */
    aec_reference_update_sidetone_status(op_extra_data);
84201dc4:	f9 ff 39 ed 	call (m) $_aec_reference_update_sidetone_status;

    /* If the config needs sidetone, decide which method it should use */
    if(op_extra_data->using_sidetone == USE_SIDETONE_FLAG)
84201dc8:	61 f0 7a 88 	rMAC = M[r4 + 488];
84201dcc:	c8 24       	Null = rMAC - 3;
84201dce:	0c 62       	if NE jump (m) Lc_aec_reference_update_sidetone_method_5;

84201dd0 <Lc_aec_reference_update_sidetone_method_2>:
    {
        if(op_extra_data->hw_sidetone_available)
84201dd0:	60 f0 9b 88 	Null = M[r4 + 620];
84201dd4:	03 60       	if EQ jump (m) Lc_aec_reference_update_sidetone_method_4;

84201dd6 <Lc_aec_reference_update_sidetone_method_3>:
        {
            /* if the config can have sidetone mixing in Hw then use that method */
            sidetone_method = AEC_SIDETONE_IN_HW;
84201dd6:	47 20       	r5 = Null + 1;
84201dd8:	07 6e       	jump (m) Lc_aec_reference_update_sidetone_method_5;

84201dda <Lc_aec_reference_update_sidetone_method_4>:
        {
            /* HW side tone isn't supported, and speaker and mic are
             * running at high task period, use separate graph for sidetone
             * mixing which will run at decimated task period.
             */
            sidetone_method = AEC_SIDETONE_IN_SW_USING_SEPARATE_GRAPH;
84201dda:	61 f0 97 88 	rMAC = M[r4 + 604];
84201dde:	c7 20       	r5 = Null + 3;
84201de0:	48 24       	Null = rMAC - 1;
84201de2:	a9 f0 47 ce 	if LS r5 = Null + 2;

84201de6 <Lc_aec_reference_update_sidetone_method_5>:
            sidetone_method = AEC_SIDETONE_IN_SW_BY_MIC_SPKR_GRAPH;
        }
    }

    /* update sidetone mixing method */
    op_extra_data->sidetone_method = sidetone_method;
84201de6:	67 f0 70 9a 	MB[r4 + 624] = r5;

84201dea <Lc_aec_reference_update_sidetone_method_6>:

}
84201dea:	f2 48       	popm <FP, r4, r5, rLink>;
84201dec:	d8 4c       	rts;

84201dee <$_aec_reference_build_graphs>:
 * \brief clean up speaker graph
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 */
bool aec_reference_build_graphs(AEC_REFERENCE_OP_DATA *op_extra_data, bool spkr_changed, bool mic_changed)
{
84201dee:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
84201df0:	16 00       	r4 = r0 + Null;
84201df2:	44 de       	M[FP + 32] = r2;
84201df4:	1b 09       	r9 = r1 + Null;
    unsigned max_sample_rate;

    patch_fn_shared(aec_reference);

    /* nothing to do if neither speaker nor mic has changed */
    if(!spkr_changed && !mic_changed)
84201df6:	03 62       	if NE jump (m) Lc_aec_reference_build_graphs_3;

84201df8 <Lc_aec_reference_build_graphs_2>:
84201df8:	41 d8       	rMAC = M[FP + 32];
84201dfa:	71 60       	if EQ jump (m) Lc_aec_reference_build_graphs_21;

84201dfc <Lc_aec_reference_build_graphs_3>:
    {
        return TRUE;
    }

    max_sample_rate = op_extra_data->mic_rate;
84201dfc:	62 f0 66 88 	r0 = M[r4 + 408];
    max_sample_rate = MAX(max_sample_rate, op_extra_data->spkr_rate);
84201e00:	61 f0 6e 88 	rMAC = M[r4 + 440];
84201e04:	50 04       	Null = r0 - rMAC;
84201e06:	02 f0 87 e0 	if C jump (m) Lc_aec_reference_build_graphs_5;

84201e0a <Lc_aec_reference_build_graphs_4>:
84201e0a:	0a 00       	r0 = rMAC + Null;

84201e0c <Lc_aec_reference_build_graphs_5>:
    max_sample_rate = MAX(max_sample_rate, op_extra_data->input_rate);
84201e0c:	61 f0 64 88 	rMAC = M[r4 + 400];
84201e10:	50 04       	Null = r0 - rMAC;
84201e12:	02 f0 87 e0 	if C jump (m) Lc_aec_reference_build_graphs_7;

84201e16 <Lc_aec_reference_build_graphs_6>:
84201e16:	0a 00       	r0 = rMAC + Null;

84201e18 <Lc_aec_reference_build_graphs_7>:
    max_sample_rate = MAX(max_sample_rate, op_extra_data->output_rate);
84201e18:	61 f0 65 88 	rMAC = M[r4 + 404];
84201e1c:	50 04       	Null = r0 - rMAC;
84201e1e:	02 f0 87 e0 	if C jump (m) Lc_aec_reference_build_graphs_9;

84201e22 <Lc_aec_reference_build_graphs_8>:
84201e22:	0a 00       	r0 = rMAC + Null;

84201e24 <Lc_aec_reference_build_graphs_9>:
    op_extra_data->max_io_rate = max_sample_rate;
84201e24:	62 f0 95 8e 	M[r4 + 596] = r0;

    /* 1ms more than a task period for max sample rate in all corners,
     * few samples more for considering resampling extra outputs.
     */
    size = frac_mult(max_sample_rate, op_extra_data->task_period_frac) + 4;
84201e28:	63 f0 93 88 	r1 = M[r4 + 588];
84201e2c:	00 f3 72 c9 	r0 = r0 * r1 (frac);
84201e30:	29 f0 04 20 	r7 = r0 + 4;

    /* Min size, was constant size of 100 words before introducing,
     * configurable task period, don't go below that tested value.
     */
    size = MAX(size, 100);
84201e34:	90 f0 64 24 	Null = r7 - 100;
84201e38:	02 f0 89 e0 	if C jump (m) Lc_aec_reference_build_graphs_11;

84201e3c <Lc_aec_reference_build_graphs_10>:
84201e3c:	09 f0 64 40 	r7 = Null + 100;

84201e40 <Lc_aec_reference_build_graphs_11>:

    /* allocate buffer needed for resampler */
    if(op_extra_data->resampler_temp_buffer == NULL)
84201e40:	61 f0 2c 88 	rMAC = M[r4 + 176];
84201e44:	58 62       	if NE jump (m) Lc_aec_reference_build_graphs_24;

84201e46 <Lc_aec_reference_build_graphs_12>:
    {
        /* resampler_temp_buffer_size must already have been calculated */
        PL_ASSERT(0 != op_extra_data->resampler_temp_buffer_size);
84201e46:	62 f0 91 88 	r0 = M[r4 + 580];
84201e4a:	4b 62       	if NE jump (m) Lc_aec_reference_build_graphs_22;

84201e4c <Lc_aec_reference_build_graphs_13>:
84201e4c:	03 f0 a7 51 	r1 = Null + 2471;
84201e50:	02 f0 13 60 	r0 = Null + 4115;
84201e54:	ff fd 90 f0 	call (m) 0x13f12;
84201e58:	3f e5 
84201e5a:	6f 6e       	jump (m) Lc_aec_reference_build_graphs_32;

84201e5c <Lc_aec_reference_build_graphs_14>:
        }
    }

    /** Setup Latency Control */
    {
        unsigned jitter = frac_mult(op_extra_data->output_rate,op_extra_data->task_period_frac);
84201e5c:	62 f0 65 88 	r0 = M[r4 + 404];
84201e60:	63 f0 93 88 	r1 = M[r4 + 588];
84201e64:	00 f3 72 c9 	r0 = r0 * r1 (frac);

        op_extra_data->sync_block.jitter     =  jitter + (jitter>>1);               /* 1.5 times task period */
84201e68:	13 50       	r1 = r0 LSHIFT -1;
84201e6a:	99 00       	rMAC = r1 + r0;
84201e6c:	61 f0 85 8e 	M[r4 + 532] = rMAC;
        op_extra_data->sync_block.ref_delay  = frac_mult(op_extra_data->output_rate,FRACTIONAL(0.001));      /* 1.0 msec */
84201e70:	62 f0 65 88 	r0 = M[r4 + 404];
84201e74:	02 f0 63 f0 	r1 = Null + 2147483;
84201e78:	9b 48 
84201e7a:	00 f3 72 c9 	r0 = r0 * r1 (frac);
84201e7e:	62 f0 8a 8e 	M[r4 + 552] = r0;
        op_extra_data->sync_block.block_sync = 0;
84201e82:	60 f0 87 8e 	M[r4 + 540] = Null;
        op_extra_data->sync_block.rm_adjustment = 0;
84201e86:	60 f0 8c 8e 	M[r4 + 560] = Null;
        op_extra_data->sync_block.frm_count = 0;
84201e8a:	60 f0 8b 8e 	M[r4 + 556] = Null;
    }

    if(spkr_changed)
84201e8e:	0f fb 00 c2 	Null = r9 - Null;
84201e92:	09 60       	if EQ jump (m) Lc_aec_reference_build_graphs_16;

84201e94 <Lc_aec_reference_build_graphs_15>:
    {
        /* any change in main speaker path will cause full
         * rebuild of every thing from scratch
         */
        aec_reference_cleanup_spkr_graph(op_extra_data);
84201e94:	32 00       	r0 = r4 + Null;
84201e96:	01 f0 31 ec 	call (m) $_aec_reference_cleanup_spkr_graph;
        /* rebuild speaker graph */
        if(!build_spkr_graph(op_extra_data))
84201e9a:	32 00       	r0 = r4 + Null;
84201e9c:	fb ff 3b ed 	call (m) $_build_spkr_graph;
84201ea0:	10 04       	Null = r0 - Null;
84201ea2:	27 60       	if EQ jump (m) Lc_aec_reference_build_graphs_23;

84201ea4 <Lc_aec_reference_build_graphs_16>:
        {
            return FALSE;
        }
    }

    if(mic_changed)
84201ea4:	41 d8       	rMAC = M[FP + 32];
84201ea6:	09 60       	if EQ jump (m) Lc_aec_reference_build_graphs_18;

84201ea8 <Lc_aec_reference_build_graphs_17>:
    {
        /* if only mic has changed, then only mic graph will be rebuilt */
        aec_reference_cleanup_mic_graph(op_extra_data);
84201ea8:	32 00       	r0 = r4 + Null;
84201eaa:	01 f0 39 e6 	call (m) $_aec_reference_cleanup_mic_graph;

        /* mic graph is rebuilt if there is a change
         * in either mic path or speaker path */
        if(!build_mic_graph(op_extra_data))
84201eae:	32 00       	r0 = r4 + Null;
84201eb0:	fa ff 29 eb 	call (m) $_build_mic_graph;
84201eb4:	10 04       	Null = r0 - Null;
84201eb6:	1d 60       	if EQ jump (m) Lc_aec_reference_build_graphs_23;

84201eb8 <Lc_aec_reference_build_graphs_18>:
        }
    }

    /* update mic and speaker graphs to include sidetone mix if required */
    if(!aec_reference_mic_spkr_include_sidetone(
           op_extra_data, op_extra_data->sidetone_method == AEC_SIDETONE_IN_SW_BY_MIC_SPKR_GRAPH))
84201eb8:	61 f0 70 90 	rMAC = MBS[r4 + 624];
84201ebc:	03 00       	r1 = Null + Null;
84201ebe:	88 24       	Null = rMAC - 2;
84201ec0:	20 f0 43 ce 	if EQ r1 = Null + 1;
84201ec4:	32 00       	r0 = r4 + Null;
84201ec6:	3b 4e       	call (m) $_aec_reference_mic_spkr_include_sidetone;
84201ec8:	10 04       	Null = r0 - Null;
84201eca:	13 60       	if EQ jump (m) Lc_aec_reference_build_graphs_23;

84201ecc <Lc_aec_reference_build_graphs_19>:
        return FALSE;
    }

#ifdef AEC_REFERENCE_CAN_PERFORM_INPLACE_SIDETONE_MIXING
    /* build separate sidetone graph if required */
    if(!build_sidetone_graph(op_extra_data))
84201ecc:	32 00       	r0 = r4 + Null;
84201ece:	03 f0 21 ea 	call (m) $_build_sidetone_graph;
84201ed2:	10 04       	Null = r0 - Null;
84201ed4:	0e 60       	if EQ jump (m) Lc_aec_reference_build_graphs_23;

84201ed6 <Lc_aec_reference_build_graphs_20>:
        return FALSE;
    }
#endif /* AEC_REFERENCE_CAN_PERFORM_INPLACE_SIDETONE_MIXING */

    /*  Re-init */
    op_extra_data->ReInitFlag = TRUE;
84201ed6:	41 20       	rMAC = Null + 1;
84201ed8:	61 f0 5c 8e 	M[r4 + 368] = rMAC;

84201edc <Lc_aec_reference_build_graphs_21>:
    patch_fn_shared(aec_reference);

    /* nothing to do if neither speaker nor mic has changed */
    if(!spkr_changed && !mic_changed)
    {
        return TRUE;
84201edc:	42 20       	r0 = Null + 1;
84201ede:	2d 6e       	jump (m) Lc_aec_reference_build_graphs_32;

84201ee0 <Lc_aec_reference_build_graphs_22>:
    {
        /* resampler_temp_buffer_size must already have been calculated */
        PL_ASSERT(0 != op_extra_data->resampler_temp_buffer_size);

        op_extra_data->resampler_temp_buffer =
            (unsigned*)xzpmalloc(op_extra_data->resampler_temp_buffer_size*sizeof(unsigned));
84201ee0:	c3 20       	r1 = Null + 3;
84201ee2:	52 54       	r0 = r0 LSHIFT 2;
84201ee4:	ff fd 18 f0 	call (m) 0x4f2a;
84201ee8:	27 e2 
        if(op_extra_data->resampler_temp_buffer == NULL)
84201eea:	62 f0 2c 8e 	M[r4 + 176] = r0;
84201eee:	03 62       	if NE jump (m) Lc_aec_reference_build_graphs_24;

84201ef0 <Lc_aec_reference_build_graphs_23>:
        {
            return FALSE;
84201ef0:	02 00       	r0 = Null + Null;
84201ef2:	23 6e       	jump (m) Lc_aec_reference_build_graphs_32;

84201ef4 <Lc_aec_reference_build_graphs_24>:

    /* get the number of required scratch buffers based
     * on the number of speakers and mics that we have.
     */
    num_scratch_buffs = (MAX(op_extra_data->num_spkr_channels,
                             op_extra_data->num_mic_channels))*2;
84201ef4:	61 f0 77 88 	rMAC = M[r4 + 476];
84201ef8:	62 f0 78 88 	r0 = M[r4 + 480];
84201efc:	88 04       	Null = rMAC - r0;
84201efe:	02 f0 87 e0 	if C jump (m) Lc_aec_reference_build_graphs_26;

84201f02 <Lc_aec_reference_build_graphs_25>:
84201f02:	02 6e       	jump (m) Lc_aec_reference_build_graphs_27;

84201f04 <Lc_aec_reference_build_graphs_26>:
84201f04:	0a 00       	r0 = rMAC + Null;

84201f06 <Lc_aec_reference_build_graphs_27>:
84201f06:	00 f2 da d8 	r8 = r0 LSHIFT 1;

    /* create scratch buffers, some of them might
     * already have been created */
    for(i=0;i<num_scratch_buffs;i++)
84201f0a:	07 00       	r5 = Null + Null;
84201f0c:	68 f0 7c 23 	r6 = r4 + 892;

84201f10 <Lc_aec_reference_build_graphs_28>:
84201f10:	af f7 00 c2 	Null = r5 - r8;
84201f14:	f2 ff c9 ee 	if C jump (m) Lc_aec_reference_build_graphs_14;

84201f18 <Lc_aec_reference_build_graphs_29>:
    {
        if(NULL == op_extra_data->scratch_bufs[i])
84201f18:	81 f0 00 e8 	rMAC = M[r6 + Null];
84201f1c:	0b 62       	if NE jump (m) Lc_aec_reference_build_graphs_31;

84201f1e <Lc_aec_reference_build_graphs_30>:
        {
            op_extra_data->scratch_bufs[i] = cbuffer_create_with_malloc_fast(size, BUF_DESC_SW_BUFFER);
84201f1e:	03 00       	r1 = Null + Null;
84201f20:	4a 08       	r0 = r7 + Null;
84201f22:	ff fd 84 f0 	call (m) 0x1279c;
84201f26:	3b e3 
84201f28:	82 f0 00 ee 	M[r6 + Null] = r0;
            if(!op_extra_data->scratch_bufs[i])
84201f2c:	81 f0 00 e8 	rMAC = M[r6 + Null];
84201f30:	e0 61       	if EQ jump (m) Lc_aec_reference_build_graphs_23;

84201f32 <Lc_aec_reference_build_graphs_31>:
    num_scratch_buffs = (MAX(op_extra_data->num_spkr_channels,
                             op_extra_data->num_mic_channels))*2;

    /* create scratch buffers, some of them might
     * already have been created */
    for(i=0;i<num_scratch_buffs;i++)
84201f32:	7f 20       	r5 = r5 + 1;
84201f34:	20 75       	r6 = r6 + 4;
84201f36:	ed 6f       	jump (m) Lc_aec_reference_build_graphs_28;

84201f38 <Lc_aec_reference_build_graphs_32>:

    /*  Re-init */
    op_extra_data->ReInitFlag = TRUE;

    return TRUE;
}
84201f38:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84201f3a:	d8 4c       	rts;

84201f3c <$_aec_reference_mic_spkr_include_sidetone>:
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 * \param include_sidetone whether to add or remove sidetone from graphs
 */
bool aec_reference_mic_spkr_include_sidetone(AEC_REFERENCE_OP_DATA* op_extra_data, bool include_sidetone)
{
84201f3c:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
84201f3e:	16 00       	r4 = r0 + Null;
    cbops_graph *spkr_graph = op_extra_data->spkr_graph;
    cbops_graph *mic_graph = op_extra_data->mic_graph;
84201f40:	68 f0 6a 88 	r6 = M[r4 + 424];

    /* we need to have a speaker graph */
    if(NULL == spkr_graph || NULL == mic_graph)
84201f44:	6b f0 72 88 	r9 = M[r4 + 456];
84201f48:	04 60       	if EQ jump (m) Lc_aec_reference_mic_spkr_include_sidetone_3;

84201f4a <Lc_aec_reference_mic_spkr_include_sidetone_2>:
84201f4a:	0f f8 00 c2 	Null = r6 - Null;
84201f4e:	9d 62       	if NE jump (m) Lc_aec_reference_mic_spkr_include_sidetone_16;

84201f50 <Lc_aec_reference_mic_spkr_include_sidetone_3>:
    {
        /* No action if we don't have a speaker graph
         * however in that case we expect the sidetone is
         * not active.
         */
        PL_ASSERT(op_extra_data->spkr_sidetone_active == FALSE);
84201f50:	60 f0 9f 88 	Null = M[r4 + 636];
84201f54:	98 60       	if EQ jump (m) Lc_aec_reference_mic_spkr_include_sidetone_15;

84201f56 <Lc_aec_reference_mic_spkr_include_sidetone_4>:
84201f56:	03 f0 60 4b 	r1 = Null + 1888;
84201f5a:	02 f0 13 60 	r0 = Null + 4115;
84201f5e:	ff fd 8f f0 	call (m) 0x13f12;
84201f62:	35 ed 
84201f64:	0f f0 9b e4 	jump (m) Lc_aec_reference_mic_spkr_include_sidetone_31;

84201f68 <Lc_aec_reference_mic_spkr_include_sidetone_5>:
            mic_st_rs_idx = op_extra_data->mic_st_input_idx;
        }
        else
        {
            /* no resampler, sidetone filter will transfer from internal buffer to output */
            mic_st_rs_idx = op_extra_data->mic_st_idx;
84201f68:	61 f0 d8 88 	rMAC = M[r4 + 864];
84201f6c:	49 de       	M[FP + 36] = rMAC;

84201f6e <Lc_aec_reference_mic_spkr_include_sidetone_6>:
        }

        /* set sidetone output buffer */
        cbops_set_output_io_buffer(mic_graph, op_extra_data->mic_st_idx, op_extra_data->mic_st_idx, op_extra_data->sidetone_buf);
84201f6e:	63 f0 d8 88 	r1 = M[r4 + 864];
84201f72:	65 f0 2b 88 	r3 = M[r4 + 172];
84201f76:	1c 00       	r2 = r1 + Null;
84201f78:	42 08       	r0 = r6 + Null;
84201f7a:	ff fd a7 f0 	call (m) 0x16e34;
84201f7e:	3b e5 
            Note:  Sidetone is before resampler.
            Better solution is to place it at lowest sample rate */

        op_ptr = create_sidetone_filter_op(op_extra_data->mic_st_input_idx, mic_st_rs_idx, 3,
                                           (cbops_sidetone_params*)&op_extra_data->params.OFFSET_ST_CLIP_POINT,
                                           (void*)&op_extra_data->params.OFFSET_ST_PEQ_CONFIG);
84201f80:	7a ff 16 cf 	push r4 + 244;
84201f84:	65 f0 d8 20 	r3 = r4 + 216;
84201f88:	c4 20       	r2 = Null + 3;
84201f8a:	4b d8       	r1 = M[FP + 36];
84201f8c:	62 f0 da 88 	r0 = M[r4 + 872];
84201f90:	08 f0 2b e0 	call (m) $_create_sidetone_filter_op;
84201f94:	7f 4c       	SP = SP + -4;
84201f96:	17 00       	r5 = r0 + Null;

        op_extra_data->mic_sidetone_op = op_ptr;
        if(!op_ptr)
84201f98:	67 f0 6c 8e 	M[r4 + 432] = r5;
84201f9c:	a2 60       	if EQ jump (m) Lc_aec_reference_mic_spkr_include_sidetone_21;

84201f9e <Lc_aec_reference_mic_spkr_include_sidetone_7>:
        {
            return FALSE;
        }

        /* insert resamler op into mic cbops graph */
        cbops_insert_operator_into_graph(mic_graph, op_ptr, after);
84201f9e:	4c 08       	r2 = r7 + Null;
84201fa0:	3b 00       	r1 = r5 + Null;
84201fa2:	42 08       	r0 = r6 + Null;
84201fa4:	07 f0 39 ea 	call (m) $_cbops_insert_operator_into_graph;
        after = op_ptr;
84201fa8:	3a 09       	r8 = r5 + Null;
        mic_num_st_ops++;
84201faa:	09 71       	r7 = Null + 1;

        if(mic_st_rs_idx != op_extra_data->mic_st_idx)
84201fac:	49 d8       	rMAC = M[FP + 36];
84201fae:	62 f0 d8 88 	r0 = M[r4 + 864];
84201fb2:	88 04       	Null = rMAC - r0;
84201fb4:	22 60       	if EQ jump (m) Lc_aec_reference_mic_spkr_include_sidetone_10;

84201fb6 <Lc_aec_reference_mic_spkr_include_sidetone_8>:
                                               &mic_st_rs_idx,
                                               &op_extra_data->mic_st_idx,
                                               op_extra_data->mic_rate,
                                               op_extra_data->spkr_rate,
                                               op_extra_data->resampler_temp_buffer_size,
                                               op_extra_data->resampler_temp_buffer, 0, 0, 0);
84201fb6:	00 f0 30 cf 	push Null;
84201fba:	00 f0 30 cf 	push Null;
84201fbe:	00 f0 30 cf 	push Null;
84201fc2:	61 f0 2c 88 	rMAC = M[r4 + 176];
84201fc6:	09 1c       	pushm <rMAC>;
84201fc8:	61 f0 91 88 	rMAC = M[r4 + 580];
84201fcc:	09 1c       	pushm <rMAC>;
84201fce:	61 f0 6e 88 	rMAC = M[r4 + 440];
84201fd2:	09 1c       	pushm <rMAC>;
84201fd4:	65 f0 66 88 	r3 = M[r4 + 408];
84201fd8:	64 f0 60 23 	r2 = r4 + 864;
84201fdc:	43 12       	r1 = FP + 36;
84201fde:	4a 08       	r0 = r7 + Null;
84201fe0:	08 f0 29 e0 	call (m) $_create_iir_resamplerv2_op;
84201fe4:	7a 4c       	SP = SP + -24;
84201fe6:	11 09       	r7 = r0 + Null;
            if(!op_ptr)
84201fe8:	7c 60       	if EQ jump (m) Lc_aec_reference_mic_spkr_include_sidetone_21;

84201fea <Lc_aec_reference_mic_spkr_include_sidetone_9>:
            {
                return FALSE;
            }
            cbops_insert_operator_into_graph(mic_graph, op_ptr, after);
84201fea:	3c 00       	r2 = r5 + Null;
84201fec:	4b 08       	r1 = r7 + Null;
84201fee:	42 08       	r0 = r6 + Null;
84201ff0:	07 f0 2d e8 	call (m) $_cbops_insert_operator_into_graph;
            after = op_ptr;
84201ff4:	4a 09       	r8 = r7 + Null;
            mic_num_st_ops++;
84201ff6:	11 71       	r7 = Null + 2;

84201ff8 <Lc_aec_reference_mic_spkr_include_sidetone_10>:
        }

        /* Add in disgard on sidetone */

        op_ptr = create_sink_overflow_disgard_op(1,&op_extra_data->mic_st_idx,threshold);
84201ff8:	63 f0 60 23 	r1 = r4 + 864;
84201ffc:	42 20       	r0 = Null + 1;
84201ffe:	44 d8       	r2 = M[FP + 32];
84202000:	ff fd 4e f1 	call (m) 0x2bdc4;
84202004:	25 ee 
84202006:	17 00       	r5 = r0 + Null;
#if defined(IO_DEBUG)
        st_disgard_op = op_ptr;
84202008:	e0 f0 07 f0 	M[Null + $_st_disgard_op] = r5;
8420200c:	5d 8e 
#endif
        if(!op_ptr)
8420200e:	38 04       	Null = r5 - Null;
84202010:	68 60       	if EQ jump (m) Lc_aec_reference_mic_spkr_include_sidetone_21;

84202012 <Lc_aec_reference_mic_spkr_include_sidetone_11>:
        {
            return FALSE;
        }
        cbops_insert_operator_into_graph(mic_graph,op_ptr, after);
84202012:	54 08       	r2 = r8 + Null;
84202014:	3b 00       	r1 = r5 + Null;
84202016:	42 08       	r0 = r6 + Null;
84202018:	07 f0 25 e7 	call (m) $_cbops_insert_operator_into_graph;
        mic_num_st_ops++;
8420201c:	09 75       	r7 = r7 + 1;

        /* save last operator in sidetone sub-path,
         * will be needed when removing the graph
         */
        op_extra_data->mic_st_last_op = op_ptr;
8420201e:	67 f0 db 8e 	M[r4 + 876] = r5;
        op_extra_data->mic_num_st_ops = mic_num_st_ops;
84202022:	69 f0 d9 8e 	M[r4 + 868] = r7;
        /** -------------------- SPKR SIDETONE SUB PATH ---------------------- **/
        /* Add sidetone mixer to resampler section,  Master channel only */
        cbops_set_input_io_buffer(spkr_graph,
                                  op_extra_data->spkr_st_in_idx,
                                  op_extra_data->spkr_st_in_idx,
                                  op_extra_data->sidetone_buf);
84202026:	63 f0 a5 88 	r1 = M[r4 + 660];
8420202a:	65 f0 2b 88 	r3 = M[r4 + 172];
8420202e:	1c 00       	r2 = r1 + Null;
84202030:	5a 08       	r0 = r9 + Null;
84202032:	ff fd a6 f0 	call (m) 0x16e02;
84202036:	31 ee 

        /* create a multi-channel sidetone mix operator,
         * number of main channels = number of speakers
         * number of sidetone channels = 1
         */
        unsigned num_st_mix_channels  = op_extra_data->num_spkr_channels;
84202038:	62 f0 77 88 	r0 = M[r4 + 476];
        unsigned spkr_channel_status = GetSpkrChannelStatus(op_extra_data);
8420203c:	61 f0 76 88 	rMAC = M[r4 + 472];
84202040:	11 f1 f0 1f 	rMAC = rMAC AND 0x3ff0;
        if((spkr_channel_status&AEC_REFERENCE_CONSTANT_CONN_TYPE_PARA) == 0)
84202044:	c9 c5       	rMAC = rMAC AND 0x1000;
84202046:	02 62       	if NE jump (m) Lc_aec_reference_mic_spkr_include_sidetone_13;

84202048 <Lc_aec_reference_mic_spkr_include_sidetone_12>:
        {
            /* speaker path isn't parallel channels,
             * sidetone mix has only one main channel
             */
            num_st_mix_channels = 1;
84202048:	42 20       	r0 = Null + 1;

8420204a <Lc_aec_reference_mic_spkr_include_sidetone_13>:
            num_st_mix_channels,                /* number of main channels */
            op_extra_data->spkr_stmix_in_idx,   /* idx for first input channel */
            op_extra_data->spkr_stmix_in_idx,   /* idx for first output channel */
            1,                                  /* number of sidetone channels */
            op_extra_data->spkr_st_in_idx,      /* idx for first sidetone input */
            op_extra_data->spkr_out_threshold); /* threshold for latency control */
8420204a:	63 f0 a3 88 	r1 = M[r4 + 652];
8420204e:	61 f0 b0 88 	rMAC = M[r4 + 704];
84202052:	09 1c       	pushm <rMAC>;
84202054:	61 f0 a5 88 	rMAC = M[r4 + 660];
84202058:	09 1c       	pushm <rMAC>;
8420205a:	45 20       	r3 = Null + 1;
8420205c:	1c 00       	r2 = r1 + Null;
8420205e:	08 f0 27 e7 	call (m) $_create_multichan_sidetone_mix_op;
84202062:	7e 4c       	SP = SP + -8;
84202064:	17 00       	r5 = r0 + Null;
        if(op_ptr == NULL)
84202066:	3d 60       	if EQ jump (m) Lc_aec_reference_mic_spkr_include_sidetone_21;

84202068 <Lc_aec_reference_mic_spkr_include_sidetone_14>:
        {
            return FALSE;
        }
        /* configure op to mix the sidetone input into all main channels */
        cbops_sidetone_mix_map_one_to_all(op_ptr, 0);
84202068:	03 00       	r1 = Null + Null;
8420206a:	08 f0 3d e4 	call (m) $_cbops_sidetone_mix_map_one_to_all;

        /* insert sidetone mix operator into speaker graph */
        cbops_insert_operator_into_graph(spkr_graph, op_ptr, op_extra_data->spkr_st_point_op);
8420206e:	64 f0 a9 88 	r2 = M[r4 + 676];
84202072:	3b 00       	r1 = r5 + Null;
84202074:	5a 08       	r0 = r9 + Null;
84202076:	07 f0 27 e4 	call (m) $_cbops_insert_operator_into_graph;

        /* save the sidetone mix operator */
        op_extra_data->spkr_stmix_op = op_ptr;
8420207a:	67 f0 ab 8e 	M[r4 + 684] = r5;

        /* now speaker graph has sidetone mix operator */
        op_extra_data->spkr_sidetone_active = TRUE;
8420207e:	41 20       	rMAC = Null + 1;
84202080:	61 f0 9f 8e 	M[r4 + 636] = rMAC;

84202084 <Lc_aec_reference_mic_spkr_include_sidetone_15>:
        /* No action if we don't have a speaker graph
         * however in that case we expect the sidetone is
         * not active.
         */
        PL_ASSERT(op_extra_data->spkr_sidetone_active == FALSE);
        return TRUE;
84202084:	42 20       	r0 = Null + 1;
84202086:	7c 6e       	jump (m) Lc_aec_reference_mic_spkr_include_sidetone_31;

84202088 <Lc_aec_reference_mic_spkr_include_sidetone_16>:
    }

    if(!include_sidetone == !op_extra_data->spkr_sidetone_active)
84202088:	01 00       	rMAC = Null + Null;
8420208a:	18 04       	Null = r1 - Null;
8420208c:	20 f0 41 ce 	if EQ rMAC = Null + 1;
84202090:	02 00       	r0 = Null + Null;
84202092:	60 f0 9f 88 	Null = M[r4 + 636];
84202096:	20 f0 42 ce 	if EQ r0 = Null + 1;
8420209a:	88 04       	Null = rMAC - r0;
8420209c:	f4 61       	if EQ jump (m) Lc_aec_reference_mic_spkr_include_sidetone_15;

8420209e <Lc_aec_reference_mic_spkr_include_sidetone_17>:
         * as current state.
         */
        return TRUE;
    }

    if(include_sidetone)
8420209e:	18 04       	Null = r1 - Null;
842020a0:	34 60       	if EQ jump (m) Lc_aec_reference_mic_spkr_include_sidetone_24;

842020a2 <Lc_aec_reference_mic_spkr_include_sidetone_18>:
    {
        /** -------------------- MIC SIDETONE SUB PATH ---------------------- **/
        /* side tone buffer size, 2ms more than task period */
        unsigned sidetone_buf_size = frac_mult(op_extra_data->spkr_rate,
                                               op_extra_data->task_period_frac + FRACTIONAL(0.002));
842020a2:	62 f0 6e 88 	r0 = M[r4 + 440];
842020a6:	61 f0 93 88 	rMAC = M[r4 + 588];
842020aa:	06 f1 13 f0 	r1 = rMAC + 4294967;
842020ae:	37 31 
842020b0:	00 f3 72 c9 	r0 = r0 * r1 (frac);
        cbops_op *after = op_extra_data->mic_st_point;
842020b4:	69 f0 dc 88 	r7 = M[r4 + 880];
        unsigned mic_num_st_ops = 0;
        unsigned  mic_st_rs_idx;
        cbops_op    *op_ptr;

        /* we don't expect SidetoneOA buffer already existing at this point */
        PL_ASSERT(op_extra_data->sidetone_buf == NULL);
842020b8:	61 f0 2b 88 	rMAC = M[r4 + 172];
842020bc:	09 60       	if EQ jump (m) Lc_aec_reference_mic_spkr_include_sidetone_20;

842020be <Lc_aec_reference_mic_spkr_include_sidetone_19>:
842020be:	03 f0 7a 4b 	r1 = Null + 1914;
842020c2:	02 f0 13 60 	r0 = Null + 4115;
842020c6:	ff fd 8f f0 	call (m) 0x13f12;
842020ca:	2d e2 
842020cc:	59 6e       	jump (m) Lc_aec_reference_mic_spkr_include_sidetone_31;

842020ce <Lc_aec_reference_mic_spkr_include_sidetone_20>:

        /* Allocate Buffer between cbops Graphs */
        op_extra_data->sidetone_buf = cbuffer_create_with_malloc_fast(sidetone_buf_size, BUF_DESC_SW_BUFFER);
842020ce:	03 00       	r1 = Null + Null;
842020d0:	ff fd 83 f0 	call (m) 0x1279c;
842020d4:	2d e6 
842020d6:	62 f0 2b 8e 	M[r4 + 172] = r0;

        if(!op_extra_data->sidetone_buf)
842020da:	61 f0 2b 88 	rMAC = M[r4 + 172];
842020de:	03 62       	if NE jump (m) Lc_aec_reference_mic_spkr_include_sidetone_22;

842020e0 <Lc_aec_reference_mic_spkr_include_sidetone_21>:
        {
            /* Not going ahead with creating mic sub path if we
             * cannot create shared buffer for sidetone path.
             */
            return FALSE;
842020e0:	02 00       	r0 = Null + Null;
842020e2:	4e 6e       	jump (m) Lc_aec_reference_mic_spkr_include_sidetone_31;

842020e4 <Lc_aec_reference_mic_spkr_include_sidetone_22>:
            hl_limiter_init(op_extra_data);
        }
#endif /* INSTALL_AEC_REFERENCE_HOWL_LIMITER */

        /* Minimum space needed in buffer */
        unsigned threshold = frac_mult(op_extra_data->spkr_rate,op_extra_data->task_period_frac) + 1;
842020e4:	62 f0 6e 88 	r0 = M[r4 + 440];
842020e8:	63 f0 93 88 	r1 = M[r4 + 588];
842020ec:	00 f3 72 c9 	r0 = r0 * r1 (frac);
842020f0:	51 20       	rMAC = r0 + 1;
842020f2:	41 de       	M[FP + 32] = rMAC;

        if(op_extra_data->mic_rate != op_extra_data->spkr_rate)
842020f4:	61 f0 66 88 	rMAC = M[r4 + 408];
842020f8:	62 f0 6e 88 	r0 = M[r4 + 440];
842020fc:	88 04       	Null = rMAC - r0;
842020fe:	35 61       	if EQ jump (m) Lc_aec_reference_mic_spkr_include_sidetone_5;

84202100 <Lc_aec_reference_mic_spkr_include_sidetone_23>:
        {
            /* Sidetone filter is inplace */
            mic_st_rs_idx = op_extra_data->mic_st_input_idx;
84202100:	61 f0 da 88 	rMAC = M[r4 + 872];
84202104:	49 de       	M[FP + 36] = rMAC;
84202106:	34 6f       	jump (m) Lc_aec_reference_mic_spkr_include_sidetone_6;

84202108 <Lc_aec_reference_mic_spkr_include_sidetone_24>:
    }
    else
    {
        /** -------------------- REMOVING MIC SIDETONE SUB PATH ---------------------- **/
        /* removing sub-graph starts from its last operator */
        cbops_op *op = op_extra_data->mic_st_last_op;
84202108:	63 f0 db 88 	r1 = M[r4 + 876];
        unsigned i;

        /* remove all the ops in the sidetone sub-path */
        for (i=0; i < op_extra_data->mic_num_st_ops; ++i)
8420210c:	07 00       	r5 = Null + Null;

8420210e <Lc_aec_reference_mic_spkr_include_sidetone_25>:
8420210e:	61 f0 d9 88 	rMAC = M[r4 + 868];
84202112:	78 04       	Null = r5 - rMAC;
84202114:	02 f0 95 e0 	if C jump (m) Lc_aec_reference_mic_spkr_include_sidetone_27;

84202118 <Lc_aec_reference_mic_spkr_include_sidetone_26>:
        {
            cbops_op *prev_op = op->prev_operator_addr;
84202118:	39 f0 00 e8 	r7 = M[r1 + Null];
            cbops_remove_operator_from_graph(mic_graph, op);
8420211c:	42 08       	r0 = r6 + Null;
8420211e:	06 f0 31 ed 	call (m) $_cbops_remove_operator_from_graph;
            op = prev_op;
84202122:	4b 08       	r1 = r7 + Null;
        /* removing sub-graph starts from its last operator */
        cbops_op *op = op_extra_data->mic_st_last_op;
        unsigned i;

        /* remove all the ops in the sidetone sub-path */
        for (i=0; i < op_extra_data->mic_num_st_ops; ++i)
84202124:	7f 20       	r5 = r5 + 1;
84202126:	f4 6f       	jump (m) Lc_aec_reference_mic_spkr_include_sidetone_25;

84202128 <Lc_aec_reference_mic_spkr_include_sidetone_27>:
            cbops_remove_operator_from_graph(mic_graph, op);
            op = prev_op;
        }

        /*  tell the cbops not to care about sidetone buffer any more */
        cbops_unset_buffer(mic_graph, op_extra_data->mic_st_idx);
84202128:	63 f0 d8 88 	r1 = M[r4 + 864];
8420212c:	42 08       	r0 = r6 + Null;
8420212e:	06 f0 2d ef 	call (m) $_cbops_unset_buffer;

        op_extra_data->mic_st_last_op = NULL;
84202132:	60 f0 db 8e 	M[r4 + 876] = Null;
        op_extra_data->mic_num_st_ops = 0;
84202136:	60 f0 d9 8e 	M[r4 + 868] = Null;
        op_extra_data->mic_sidetone_op = NULL;
8420213a:	60 f0 6c 8e 	M[r4 + 432] = Null;

        /** -------------------- REMOVING SPKR SIDETONE SUB PATH ---------------------- **/
        /* remove the sidetone mix operator from speaker graph */
        PL_ASSERT(NULL != op_extra_data->spkr_stmix_op);
8420213e:	63 f0 ab 88 	r1 = M[r4 + 684];
84202142:	09 62       	if NE jump (m) Lc_aec_reference_mic_spkr_include_sidetone_29;

84202144 <Lc_aec_reference_mic_spkr_include_sidetone_28>:
84202144:	03 f0 1e 50 	r1 = Null + 2078;
84202148:	02 f0 13 60 	r0 = Null + 4115;
8420214c:	ff fd 8e f0 	call (m) 0x13f12;
84202150:	27 ee 
84202152:	16 6e       	jump (m) Lc_aec_reference_mic_spkr_include_sidetone_31;

84202154 <Lc_aec_reference_mic_spkr_include_sidetone_29>:
        cbops_remove_operator_from_graph(spkr_graph, op_extra_data->spkr_stmix_op);
84202154:	5a 08       	r0 = r9 + Null;
84202156:	06 f0 39 eb 	call (m) $_cbops_remove_operator_from_graph;
        op_extra_data->spkr_stmix_op = NULL;
8420215a:	60 f0 ab 8e 	M[r4 + 684] = Null;

        /* also tell the cbops not to care about sidetone buffer any more */
        cbops_unset_buffer(spkr_graph, op_extra_data->spkr_st_in_idx);
8420215e:	63 f0 a5 88 	r1 = M[r4 + 660];
84202162:	5a 08       	r0 = r9 + Null;
84202164:	06 f0 37 ed 	call (m) $_cbops_unset_buffer;

        /* speaker graph no longer has sidetone mix operator*/
        op_extra_data->spkr_sidetone_active = FALSE;
84202168:	60 f0 9f 8e 	M[r4 + 636] = Null;

        /* Free Sidetone buffers, this must be
         * done after removing sidetone mix from
         * speaker graph.
         */
        if(op_extra_data->sidetone_buf != NULL)
8420216c:	62 f0 2b 88 	r0 = M[r4 + 172];
84202170:	8a 61       	if EQ jump (m) Lc_aec_reference_mic_spkr_include_sidetone_15;

84202172 <Lc_aec_reference_mic_spkr_include_sidetone_30>:
        {
            cbuffer_destroy(op_extra_data->sidetone_buf);
84202172:	ff fd 83 f0 	call (m) 0x12802;
84202176:	31 e4 
            op_extra_data->sidetone_buf = NULL;
84202178:	60 f0 2b 8e 	M[r4 + 172] = Null;
8420217c:	84 6f       	jump (m) Lc_aec_reference_mic_spkr_include_sidetone_15;

8420217e <Lc_aec_reference_mic_spkr_include_sidetone_31>:

        DEBUG_GRAPHS("AEC REFERENCE: Side tone path removed!" );
    }

    return TRUE;
}
8420217e:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84202180:	d8 4c       	rts;

84202182 <$_aec_reference_cleanup_mic_graph>:
 * \brief clean up mic graph
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 */
void aec_reference_cleanup_mic_graph(AEC_REFERENCE_OP_DATA *op_extra_data)
{
84202182:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84202184:	16 00       	r4 = r0 + Null;
    patch_fn_shared(aec_reference);

    /* Clear links to graphs */
    op_extra_data->mic_rate_monitor_op = NULL;
84202186:	60 f0 6b 8e 	M[r4 + 428] = Null;
    op_extra_data->mic_sw_rateadj_op = NULL;
8420218a:	60 f0 7d 8e 	M[r4 + 500] = Null;
    op_extra_data->mic_mute_op = NULL;
8420218e:	60 f0 9d 8e 	M[r4 + 628] = Null;

    /* if we have active sidetone path then remove
     * it from speaker graph
     */
    if(op_extra_data->spkr_sidetone_active)
84202192:	60 f0 9f 88 	Null = M[r4 + 636];
84202196:	04 60       	if EQ jump (m) Lc_aec_reference_cleanup_mic_graph_3;

84202198 <Lc_aec_reference_cleanup_mic_graph_2>:
    {
        aec_reference_mic_spkr_include_sidetone(op_extra_data, FALSE);
84202198:	03 00       	r1 = Null + Null;
8420219a:	fe ff 23 ed 	call (m) $_aec_reference_mic_spkr_include_sidetone;

8420219e <Lc_aec_reference_cleanup_mic_graph_3>:
    }

    /* Free cbops mic graph */
    if(op_extra_data->mic_graph != NULL)
8420219e:	62 f0 6a 88 	r0 = M[r4 + 424];
842021a2:	06 60       	if EQ jump (m) Lc_aec_reference_cleanup_mic_graph_5;

842021a4 <Lc_aec_reference_cleanup_mic_graph_4>:
    {
        destroy_graph(op_extra_data->mic_graph);
842021a4:	ff fd a6 f0 	call (m) 0x16daa;
842021a8:	27 e0 
        op_extra_data->mic_graph = NULL;
842021aa:	60 f0 6a 8e 	M[r4 + 424] = Null;

842021ae <Lc_aec_reference_cleanup_mic_graph_5>:
    }

    /* update the state of sidetone */
    aec_reference_update_sidetone_status(op_extra_data);
842021ae:	32 00       	r0 = r4 + Null;
842021b0:	f7 ff 2d ee 	call (m) $_aec_reference_update_sidetone_status;

#ifdef AEC_REFERENCE_GENERATE_MIC_TIMESTAMP
    op_extra_data->mic_metadata_tag_left_words = 0;
842021b4:	60 f0 cb 8e 	M[r4 + 812] = Null;

842021b8 <Lc_aec_reference_cleanup_mic_graph_6>:
#endif

    DEBUG_GRAPHS("AEC REFERENCE: MIC graph's cleanup done!" );
}
842021b8:	f1 48       	popm <FP, r4, rLink>;
842021ba:	d8 4c       	rts;

842021bc <$_aec_reference_cleanup_graphs>:
 * \brief clean up all the cbops graphs
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 */
void aec_reference_cleanup_graphs(AEC_REFERENCE_OP_DATA *op_extra_data)
{
842021bc:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
842021be:	16 00       	r4 = r0 + Null;

    patch_fn_shared(aec_reference);

    /* Kill timer Task */
    /* This needs to be atomic, to make sure the right timer gets cancelled */
    LOCK_INTERRUPTS;
842021c0:	ff fd 55 f1 	call (m) 0x2cc9c;
842021c4:	3d e6 
    if(op_extra_data->kick_id!=TIMER_ID_INVALID)
842021c6:	62 f0 5d 88 	r0 = M[r4 + 372];
842021ca:	08 60       	if EQ jump (m) Lc_aec_reference_cleanup_graphs_3;

842021cc <Lc_aec_reference_cleanup_graphs_2>:
    {
        timer_cancel_event(op_extra_data->kick_id);
842021cc:	04 00       	r2 = Null + Null;
842021ce:	03 00       	r1 = Null + Null;
842021d0:	ff fd 8f f0 	call (m) 0x141bc;
842021d4:	2d ef 
        op_extra_data->kick_id=TIMER_ID_INVALID;
842021d6:	60 f0 5d 8e 	M[r4 + 372] = Null;

842021da <Lc_aec_reference_cleanup_graphs_3>:
    }
    UNLOCK_INTERRUPTS;
842021da:	ff fd 55 f1 	call (m) 0x2ccb8;
842021de:	3f e6 

#ifdef AEC_REFERENCE_CAN_PERFORM_INPLACE_SIDETONE_MIXING
    /* cleanup sidetone graph if we have one */
    if(NULL != op_extra_data->sidetone_graph)
842021e0:	61 f0 99 88 	rMAC = M[r4 + 612];
842021e4:	04 60       	if EQ jump (m) Lc_aec_reference_cleanup_graphs_5;

842021e6 <Lc_aec_reference_cleanup_graphs_4>:
    {
        /* clean sidetone graph */
        aec_reference_cleanup_sidetone_graph(op_extra_data);
842021e6:	32 00       	r0 = r4 + Null;
842021e8:	03 f0 25 e2 	call (m) $_aec_reference_cleanup_sidetone_graph;

842021ec <Lc_aec_reference_cleanup_graphs_5>:
    }
#endif
    /* clean mic graph */
    aec_reference_cleanup_mic_graph(op_extra_data);
842021ec:	32 00       	r0 = r4 + Null;
842021ee:	ca 4f       	call (m) $_aec_reference_cleanup_mic_graph;

    /* clean speaker graph */
    aec_reference_cleanup_spkr_graph(op_extra_data);
842021f0:	32 00       	r0 = r4 + Null;
842021f2:	1a 4e       	call (m) $_aec_reference_cleanup_spkr_graph;

    /* Free Internal buffers */
    for(i=0;i<AEC_NUM_SCRATCH_BUFFERS;i++)
842021f4:	07 00       	r5 = Null + Null;
842021f6:	68 f0 7c 23 	r6 = r4 + 892;

842021fa <Lc_aec_reference_cleanup_graphs_6>:
    {
        if(op_extra_data->scratch_bufs[i] != NULL)
842021fa:	82 f0 00 e8 	r0 = M[r6 + Null];
842021fe:	06 60       	if EQ jump (m) Lc_aec_reference_cleanup_graphs_8;

84202200 <Lc_aec_reference_cleanup_graphs_7>:
        {
            cbuffer_destroy(op_extra_data->scratch_bufs[i]);
84202200:	ff fd 83 f0 	call (m) 0x12802;
84202204:	23 e0 
            op_extra_data->scratch_bufs[i] = NULL;
84202206:	80 f0 00 ee 	M[r6 + Null] = Null;

8420220a <Lc_aec_reference_cleanup_graphs_8>:

    /* clean speaker graph */
    aec_reference_cleanup_spkr_graph(op_extra_data);

    /* Free Internal buffers */
    for(i=0;i<AEC_NUM_SCRATCH_BUFFERS;i++)
8420220a:	7f 20       	r5 = r5 + 1;
8420220c:	20 75       	r6 = r6 + 4;
8420220e:	38 2c       	Null = r5 - 16;
84202210:	f5 65       	if NC jump (m) Lc_aec_reference_cleanup_graphs_6;

84202212 <Lc_aec_reference_cleanup_graphs_9>:
            op_extra_data->scratch_bufs[i] = NULL;
        }
    }

    /* clear scratch buffer used by resampler operator */
    if(op_extra_data->resampler_temp_buffer != NULL)
84202212:	62 f0 2c 88 	r0 = M[r4 + 176];
84202216:	06 60       	if EQ jump (m) Lc_aec_reference_cleanup_graphs_11;

84202218 <Lc_aec_reference_cleanup_graphs_10>:
    {
        pfree(op_extra_data->resampler_temp_buffer);
84202218:	ff fd 16 f0 	call (m) 0x4f62;
8420221c:	2b ea 
        op_extra_data->resampler_temp_buffer = NULL;
8420221e:	60 f0 2c 8e 	M[r4 + 176] = Null;

84202222 <Lc_aec_reference_cleanup_graphs_11>:
    }

    DEBUG_GRAPHS("AEC REFERENCE: Full graphs cleanup done!" );
}
84202222:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84202224:	d8 4c       	rts;

84202226 <$_aec_reference_cleanup_spkr_graph>:
 * \brief clean up speaker graph
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 */
void aec_reference_cleanup_spkr_graph(AEC_REFERENCE_OP_DATA *op_extra_data)
{
84202226:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84202228:	16 00       	r4 = r0 + Null;
    patch_fn_shared(aec_reference);

#if defined(IO_DEBUG)
    insert_op  = NULL;
8420222a:	e0 f0 00 f0 	M[Null + $_insert_op] = Null;
8420222e:	5c 8e 
    st_disgard_op = NULL;
84202230:	e0 f0 00 f0 	M[Null + $_st_disgard_op] = Null;
84202234:	5d 8e 
#endif

    /* Clear links to graphs */
    op_extra_data->spkr_rate_monitor_op = NULL;
84202236:	60 f0 73 8e 	M[r4 + 460] = Null;
    op_extra_data->spkr_sw_rateadj_op = NULL;
8420223a:	60 f0 7e 8e 	M[r4 + 504] = Null;
    op_extra_data->spkr_ref_point_op = NULL;
8420223e:	60 f0 a8 8e 	M[r4 + 672] = Null;
    op_extra_data->spkr_st_point_op = NULL;
84202242:	60 f0 a9 8e 	M[r4 + 676] = Null;
    op_extra_data->spkr_ref_last_op = NULL;
84202246:	60 f0 aa 8e 	M[r4 + 680] = Null;
    op_extra_data->spkr_ref_rs_op = NULL;
8420224a:	60 f0 ac 8e 	M[r4 + 688] = Null;
    op_extra_data->ref_sw_rateadj_op = NULL;
8420224e:	60 f0 90 8e 	M[r4 + 576] = Null;

    /* if we have active sidetone path then remove
     * it from speaker graph
     */
    if(op_extra_data->spkr_sidetone_active)
84202252:	60 f0 9f 88 	Null = M[r4 + 636];
84202256:	04 60       	if EQ jump (m) Lc_aec_reference_cleanup_spkr_graph_3;

84202258 <Lc_aec_reference_cleanup_spkr_graph_2>:
    {
        aec_reference_mic_spkr_include_sidetone(op_extra_data, FALSE);
84202258:	03 00       	r1 = Null + Null;
8420225a:	fe ff 23 e7 	call (m) $_aec_reference_mic_spkr_include_sidetone;

8420225e <Lc_aec_reference_cleanup_spkr_graph_3>:
    }

    /* destroy speaker graph */
    if(op_extra_data->spkr_graph != NULL)
8420225e:	62 f0 72 88 	r0 = M[r4 + 456];
84202262:	06 60       	if EQ jump (m) Lc_aec_reference_cleanup_spkr_graph_5;

84202264 <Lc_aec_reference_cleanup_spkr_graph_4>:
    {
        destroy_graph(op_extra_data->spkr_graph);
84202264:	ff fd a5 f0 	call (m) 0x16daa;
84202268:	27 ea 
        op_extra_data->spkr_graph = NULL;
8420226a:	60 f0 72 8e 	M[r4 + 456] = Null;

8420226e <Lc_aec_reference_cleanup_spkr_graph_5>:
    }

    /* clear flag for reference path */
    op_extra_data->spkr_ref_active = FALSE;
8420226e:	60 f0 a0 8e 	M[r4 + 640] = Null;

    /* clear flag for sidetone path */
    op_extra_data->spkr_sidetone_active = FALSE;
84202272:	60 f0 9f 8e 	M[r4 + 636] = Null;

#ifdef AEC_REFERENCE_SPKR_TTP
    /* destroy any structure allocated for ttp playback */
    aec_reference_spkr_ttp_terminate(op_extra_data);
84202276:	32 00       	r0 = r4 + Null;
84202278:	04 f0 23 e8 	call (m) $_aec_reference_spkr_ttp_terminate;
#endif /* AEC_REFERENCE_SPKR_TTP */

#ifdef AEC_REF_CALC_SPKR_RATE_MONITOR_AMOUNT
    /* Reset flag showing speaker started to consume data */
    op_extra_data->spkr_flow_started = FALSE;
8420227c:	60 f0 d3 8e 	M[r4 + 844] = Null;

84202280 <Lc_aec_reference_cleanup_spkr_graph_6>:
#endif

    /* TODO - Fill speakers with silence */

    DEBUG_GRAPHS("AEC REFERENCE: Speaker graph's cleanup done!" );
}
84202280:	f1 48       	popm <FP, r4, rLink>;
84202282:	d8 4c       	rts;

84202284 <$_aec_reference_spkr_include_ref_path>:
 * \brief updates speaker graph to include/exclude path for reference output
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 */
bool aec_reference_spkr_include_ref_path(AEC_REFERENCE_OP_DATA* op_extra_data, bool include_ref_path)
{
84202284:	f5 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>, SP = SP + 0x10;
84202286:	16 00       	r4 = r0 + Null;
84202288:	19 00       	rMAC = r1 + Null;
    cbops_graph *spkr_graph = op_extra_data->spkr_graph;
8420228a:	68 f0 72 88 	r6 = M[r4 + 456];
    cbops_op    *op_ptr;
    unsigned ref_idx = op_extra_data->spkr_ref_idx;
8420228e:	63 f0 a4 88 	r1 = M[r4 + 656];
84202292:	3b de       	M[FP + 28] = r1;

    /* No action if no speaker graph */
    if(NULL == spkr_graph)
84202294:	0f f8 00 c2 	Null = r6 - Null;
84202298:	56 62       	if NE jump (m) Lc_aec_reference_spkr_include_ref_path_11;

8420229a <Lc_aec_reference_spkr_include_ref_path_2>:
    {
        /* nothing to do but we expect no reference output */
        PL_ASSERT(op_extra_data->spkr_ref_active == FALSE);
8420229a:	60 f0 a0 88 	Null = M[r4 + 640];
8420229e:	51 60       	if EQ jump (m) Lc_aec_reference_spkr_include_ref_path_10;

842022a0 <Lc_aec_reference_spkr_include_ref_path_3>:
842022a0:	03 f0 48 50 	r1 = Null + 2120;
842022a4:	02 f0 13 60 	r0 = Null + 4115;
842022a8:	ff fd 8e f0 	call (m) 0x13f12;
842022ac:	2b e3 
842022ae:	bc 6e       	jump (m) Lc_aec_reference_spkr_include_ref_path_22;

842022b0 <Lc_aec_reference_spkr_include_ref_path_4>:
            {
                return FALSE;
            }

            /* save the resampler op and it's scratch buffer index */
            op_extra_data->spkr_ref_rs_op = op_ptr;
842022b0:	67 f0 ac 8e 	M[r4 + 688] = r5;
            op_extra_data->spkr_ref_rs_idx = ref_rm_in_idx;
842022b4:	49 d8       	rMAC = M[FP + 36];
842022b6:	61 f0 a7 8e 	M[r4 + 668] = rMAC;

            /* insert resamler op into speaker cbops graph */
            cbops_insert_operator_into_graph(spkr_graph,op_ptr, after);
842022ba:	4c 08       	r2 = r7 + Null;
842022bc:	3b 00       	r1 = r5 + Null;
842022be:	42 08       	r0 = r6 + Null;
842022c0:	06 f0 3d e1 	call (m) $_cbops_insert_operator_into_graph;
            after = op_ptr;
842022c4:	39 09       	r7 = r5 + Null;
            spkr_num_ref_ops++;
842022c6:	0a 71       	r8 = Null + 1;

842022c8 <Lc_aec_reference_spkr_include_ref_path_5>:
        }

        /*  SW rate adjustment for reference */
        op_ptr = create_sw_rate_adj_op(1, &ref_rm_in_idx, &ref_idx,
                                       CBOPS_RATEADJUST_COEFFS,
                                       &op_extra_data->sync_block.rm_adjustment, 0);
842022c8:	00 f0 30 cf 	push Null;
842022cc:	85 2a       	r3 = Null + 26;
842022ce:	c4 11       	r2 = FP + 28;
842022d0:	43 12       	r1 = FP + 36;
842022d2:	02 f0 30 ff 	push r4 + 560;
842022d6:	16 cf 
842022d8:	42 20       	r0 = Null + 1;
842022da:	ff fd a4 f0 	call (m) 0x16bea;
842022de:	31 e8 
842022e0:	7e 4c       	SP = SP + -8;
842022e2:	17 00       	r5 = r0 + Null;
        if(op_ptr == NULL)
842022e4:	78 60       	if EQ jump (m) Lc_aec_reference_spkr_include_ref_path_15;

842022e6 <Lc_aec_reference_spkr_include_ref_path_6>:
        {
            return FALSE;
        }

        /* store reference rate adjust operator */
        op_extra_data->ref_sw_rateadj_op = op_ptr;
842022e6:	67 f0 90 8e 	M[r4 + 576] = r5;
        if(op_extra_data->mic_sync_enable)
842022ea:	60 f0 d4 88 	Null = M[r4 + 848];
842022ee:	05 60       	if EQ jump (m) Lc_aec_reference_spkr_include_ref_path_8;

842022f0 <Lc_aec_reference_spkr_include_ref_path_7>:
        {
            /* if input and output are in the same clock, then mic output
             * can get sychronised to ref, and ref won't need rate adjustment.
             * The operator will be doing simple copy here.
             */
            cbops_rateadjust_passthrough_mode(op_ptr, TRUE);
842022f0:	43 20       	r1 = Null + 1;
842022f2:	ff fd a4 f0 	call (m) 0x16c96;
842022f6:	25 ed 

842022f8 <Lc_aec_reference_spkr_include_ref_path_8>:
        }

        /* insert rate adjust op into speaker cbops graph*/
        cbops_insert_operator_into_graph(spkr_graph, op_ptr, after);
842022f8:	4c 08       	r2 = r7 + Null;
842022fa:	3b 00       	r1 = r5 + Null;
842022fc:	42 08       	r0 = r6 + Null;
842022fe:	05 f0 3f ef 	call (m) $_cbops_insert_operator_into_graph;
        after = op_ptr;
        spkr_num_ref_ops++;
84202302:	0a 75       	r8 = r8 + 1;

        /* speaker latency cbops operator */
        op_ptr = create_speaker_latency_op(ref_idx, &op_extra_data->sync_block);
84202304:	63 f0 14 22 	r1 = r4 + 532;
84202308:	3a d8       	r0 = M[FP + 28];
8420230a:	ff fd 2f f1 	call (m) 0x28250;
8420230e:	27 ea 
84202310:	11 09       	r7 = r0 + Null;
        if(op_ptr == NULL)
84202312:	61 60       	if EQ jump (m) Lc_aec_reference_spkr_include_ref_path_15;

84202314 <Lc_aec_reference_spkr_include_ref_path_9>:
        {
            return FALSE;
        }
        /* insert speaker latency op into speaker cbops graph*/
        cbops_insert_operator_into_graph(spkr_graph, op_ptr, after);
84202314:	3c 00       	r2 = r5 + Null;
84202316:	4b 08       	r1 = r7 + Null;
84202318:	42 08       	r0 = r6 + Null;
8420231a:	05 f0 23 ef 	call (m) $_cbops_insert_operator_into_graph;
        spkr_num_ref_ops++;
8420231e:	0a 75       	r8 = r8 + 1;
        /* save last operator in the reference sub-path and
         * also the number of operator in the sub-path,
         * these will be required when removing the
         * reference path
         */
        op_extra_data->spkr_ref_last_op = op_ptr;
84202320:	69 f0 aa 8e 	M[r4 + 680] = r7;
        op_extra_data->spkr_num_ref_ops = spkr_num_ref_ops;
84202324:	6a f0 a6 8e 	M[r4 + 664] = r8;

        /* Now speaker graph includes reference sub path */
        op_extra_data->spkr_ref_active = TRUE;
84202328:	47 20       	r5 = Null + 1;
8420232a:	67 f0 a0 8e 	M[r4 + 640] = r5;

        /* have reasonable distance between MIC and REF at the beginning,
         * assumes MIC buffer is empty now.
         */
        cbuffer_move_write_to_read_point(op_extra_data->output_stream[AEC_REF_REFERENCE_TERMINAL],
                                         op_extra_data->sync_block.jitter/2);
8420232e:	62 f0 85 88 	r0 = M[r4 + 532];
84202332:	13 50       	r1 = r0 LSHIFT -1;
84202334:	32 a8       	r0 = M[r4 + 64];
84202336:	ff fd 51 f1 	call (m) 0x2c57a;
8420233a:	25 e2 
 *
 * \param op pointer to cbop
 */
static inline void cbops_reshresh_buffers(cbops_graph *graph)
{
   graph->refresh_buffers = TRUE;
8420233c:	87 f0 07 8e 	M[r6 + 28] = r5;

84202340 <Lc_aec_reference_spkr_include_ref_path_10>:
    /* No action if no speaker graph */
    if(NULL == spkr_graph)
    {
        /* nothing to do but we expect no reference output */
        PL_ASSERT(op_extra_data->spkr_ref_active == FALSE);
        return TRUE;
84202340:	42 20       	r0 = Null + 1;
84202342:	72 6e       	jump (m) Lc_aec_reference_spkr_include_ref_path_22;

84202344 <Lc_aec_reference_spkr_include_ref_path_11>:
    }

    if(!include_ref_path == !op_extra_data->spkr_ref_active)
84202344:	02 00       	r0 = Null + Null;
84202346:	08 04       	Null = rMAC - Null;
84202348:	20 f0 42 ce 	if EQ r0 = Null + 1;
8420234c:	04 00       	r2 = Null + Null;
8420234e:	60 f0 a0 88 	Null = M[r4 + 640];
84202352:	20 f0 44 ce 	if EQ r2 = Null + 1;
84202356:	10 05       	Null = r0 - r2;
84202358:	f4 61       	if EQ jump (m) Lc_aec_reference_spkr_include_ref_path_10;

8420235a <Lc_aec_reference_spkr_include_ref_path_12>:
         * as current state.
         */
        return TRUE;
    }

    if(include_ref_path)
8420235a:	08 04       	Null = rMAC - Null;
8420235c:	3e 60       	if EQ jump (m) Lc_aec_reference_spkr_include_ref_path_16;

8420235e <Lc_aec_reference_spkr_include_ref_path_13>:
    {
        /* Adding Reference path to speaker graph */

        unsigned ref_input_idx = op_extra_data->spkr_ref_input_idx;
8420235e:	61 f0 a1 88 	rMAC = M[r4 + 644];
84202362:	41 de       	M[FP + 32] = rMAC;
        unsigned ref_rm_in_idx = ref_input_idx;
84202364:	49 de       	M[FP + 36] = rMAC;
        cbops_op *after = op_extra_data->spkr_ref_point_op;
84202366:	69 f0 a8 88 	r7 = M[r4 + 672];
        unsigned spkr_num_ref_ops = 0;
8420236a:	02 09       	r8 = Null + Null;

        /* set buffer index for reference output in cbops graph */
        cbops_set_output_io_buffer(spkr_graph,
                                   ref_idx,
                                   ref_idx,
                                   op_extra_data->output_stream[AEC_REF_REFERENCE_TERMINAL]);
8420236c:	35 a8       	r3 = M[r4 + 64];
8420236e:	1c 00       	r2 = r1 + Null;
84202370:	42 08       	r0 = r6 + Null;
84202372:	ff fd a5 f0 	call (m) 0x16e34;
84202376:	23 e6 

        /* see if resampler is needed in reference path */
        if(op_extra_data->input_rate != op_extra_data->output_rate)
84202378:	61 f0 64 88 	rMAC = M[r4 + 400];
8420237c:	62 f0 65 88 	r0 = M[r4 + 404];
84202380:	88 04       	Null = rMAC - r0;
84202382:	a3 61       	if EQ jump (m) Lc_aec_reference_spkr_include_ref_path_5;

84202384 <Lc_aec_reference_spkr_include_ref_path_14>:
        {
            /* resampler outputs into internal buffer */
            ref_rm_in_idx = ref_idx+1;
84202384:	39 d8       	rMAC = M[FP + 28];
84202386:	4b 20       	r1 = rMAC + 1;
84202388:	4b de       	M[FP + 36] = r1;
            /* NOTE: left scratch input is input to resampler */

            cbops_set_internal_io_buffer(spkr_graph,
                                         ref_rm_in_idx,
                                         ref_rm_in_idx,
                                         op_extra_data->scratch_bufs[op_extra_data->spkr_ref_scratch_idx]);
8420238a:	62 f0 a2 88 	r0 = M[r4 + 648];
8420238e:	31 00       	rMAC = r4 + Null;
84202390:	1c 00       	r2 = r1 + Null;
84202392:	52 54       	r0 = r0 LSHIFT 2;
84202394:	51 00       	rMAC = r0 + rMAC;
84202396:	15 f0 df 88 	r3 = M[rMAC + 892];
8420239a:	42 08       	r0 = r6 + Null;
8420239c:	ff fd a5 f0 	call (m) 0x16e66;
842023a0:	2b e6 

            /* Add reference sample rate conversion (input_rate --> output_rate) - for 1 channel only */
            op_ptr = create_iir_resamplerv2_op(1, &ref_input_idx, &ref_rm_in_idx,
                                               op_extra_data->input_rate, op_extra_data->output_rate,
                                               op_extra_data->resampler_temp_buffer_size,
                                               op_extra_data->resampler_temp_buffer, 0, 0, 0);
842023a2:	00 f0 30 cf 	push Null;
842023a6:	00 f0 30 cf 	push Null;
842023aa:	00 f0 30 cf 	push Null;
842023ae:	61 f0 2c 88 	rMAC = M[r4 + 176];
842023b2:	09 1c       	pushm <rMAC>;
842023b4:	61 f0 91 88 	rMAC = M[r4 + 580];
842023b8:	09 1c       	pushm <rMAC>;
842023ba:	61 f0 65 88 	rMAC = M[r4 + 404];
842023be:	09 1c       	pushm <rMAC>;
842023c0:	65 f0 64 88 	r3 = M[r4 + 400];
842023c4:	44 12       	r2 = FP + 36;
842023c6:	03 12       	r1 = FP + 32;
842023c8:	42 20       	r0 = Null + 1;
842023ca:	06 f0 3f e0 	call (m) $_create_iir_resamplerv2_op;
842023ce:	7a 4c       	SP = SP + -24;
842023d0:	17 00       	r5 = r0 + Null;

            if(op_ptr == NULL)
842023d2:	6f 63       	if NE jump (m) Lc_aec_reference_spkr_include_ref_path_4;

842023d4 <Lc_aec_reference_spkr_include_ref_path_15>:
            {
                return FALSE;
842023d4:	02 00       	r0 = Null + Null;
842023d6:	28 6e       	jump (m) Lc_aec_reference_spkr_include_ref_path_22;

842023d8 <Lc_aec_reference_spkr_include_ref_path_16>:
        DEBUG_GRAPHS("AEC REFERENCE: Reference path added!" );
    }
    else
    {
        /* removing sub-graph starts from its last operator */
        cbops_op *op = op_extra_data->spkr_ref_last_op;
842023d8:	63 f0 aa 88 	r1 = M[r4 + 680];
        unsigned i;

        /* remove all the ops in the reference sub-path */
        for (i=0; i < op_extra_data->spkr_num_ref_ops; ++i)
842023dc:	07 00       	r5 = Null + Null;

842023de <Lc_aec_reference_spkr_include_ref_path_17>:
842023de:	61 f0 a6 88 	rMAC = M[r4 + 664];
842023e2:	78 04       	Null = r5 - rMAC;
842023e4:	02 f0 95 e0 	if C jump (m) Lc_aec_reference_spkr_include_ref_path_19;

842023e8 <Lc_aec_reference_spkr_include_ref_path_18>:
        {
            cbops_op *prev_op = op->prev_operator_addr;
842023e8:	39 f0 00 e8 	r7 = M[r1 + Null];
            cbops_remove_operator_from_graph(spkr_graph, op);
842023ec:	42 08       	r0 = r6 + Null;
842023ee:	05 f0 21 e7 	call (m) $_cbops_remove_operator_from_graph;
            op = prev_op;
842023f2:	4b 08       	r1 = r7 + Null;
        /* removing sub-graph starts from its last operator */
        cbops_op *op = op_extra_data->spkr_ref_last_op;
        unsigned i;

        /* remove all the ops in the reference sub-path */
        for (i=0; i < op_extra_data->spkr_num_ref_ops; ++i)
842023f4:	7f 20       	r5 = r5 + 1;
842023f6:	f4 6f       	jump (m) Lc_aec_reference_spkr_include_ref_path_17;

842023f8 <Lc_aec_reference_spkr_include_ref_path_19>:
            cbops_remove_operator_from_graph(spkr_graph, op);
            op = prev_op;
        }

        /*  tell the cbops not to care about reference buffer any more */
        cbops_unset_buffer(spkr_graph, ref_idx);
842023f8:	3b d8       	r1 = M[FP + 28];
842023fa:	42 08       	r0 = r6 + Null;
842023fc:	05 f0 3f e8 	call (m) $_cbops_unset_buffer;

        if(op_extra_data->spkr_ref_rs_op != NULL)
84202400:	61 f0 ac 88 	rMAC = M[r4 + 688];
84202404:	08 60       	if EQ jump (m) Lc_aec_reference_spkr_include_ref_path_21;

84202406 <Lc_aec_reference_spkr_include_ref_path_20>:
        {
            /* if we have resampler in the reference path
             * then also the reserved index buffer should
             * get unset.
             */
            cbops_unset_buffer(spkr_graph, op_extra_data->spkr_ref_rs_idx);
84202406:	63 f0 a7 88 	r1 = M[r4 + 668];
8420240a:	42 08       	r0 = r6 + Null;
8420240c:	05 f0 2f e8 	call (m) $_cbops_unset_buffer;
            op_extra_data->spkr_ref_rs_op = NULL;
84202410:	60 f0 ac 8e 	M[r4 + 688] = Null;

84202414 <Lc_aec_reference_spkr_include_ref_path_21>:
        }

        op_extra_data->spkr_num_ref_ops = 0;
84202414:	60 f0 a6 8e 	M[r4 + 664] = Null;
        op_extra_data->spkr_ref_last_op = NULL;
84202418:	60 f0 aa 8e 	M[r4 + 680] = Null;
        op_extra_data->ref_sw_rateadj_op = NULL;
8420241c:	60 f0 90 8e 	M[r4 + 576] = Null;

        /* speaker graph no longer has reference sub-path */
        op_extra_data->spkr_ref_active = FALSE;
84202420:	60 f0 a0 8e 	M[r4 + 640] = Null;
84202424:	8e 6f       	jump (m) Lc_aec_reference_spkr_include_ref_path_10;

84202426 <Lc_aec_reference_spkr_include_ref_path_22>:
        DEBUG_GRAPHS("AEC REFERENCE: Reference path removed!" );
    }
    return TRUE;
}
84202426:	f5 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, rLink>;
84202428:	d8 4c       	rts;

8420242a <$_aec_reference_stop_reset>:

    return TRUE;
}

bool aec_reference_stop_reset(OPERATOR_DATA *op_data,void **response_data)
{
8420242a:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
8420242c:	16 00       	r4 = r0 + Null;
8420242e:	1f 00       	r5 = r1 + Null;
    patch_fn_shared(aec_reference);

    if(!base_op_build_std_response(STATUS_CMD_FAILED,op_data->id,response_data))
84202430:	73 88       	r1 = M[r4 + 4];
84202432:	02 f0 00 60 	r0 = Null + 4096;
84202436:	3c 00       	r2 = r5 + Null;
84202438:	ef fd ee ff 	call (m) 0x204;
8420243c:	2d ee 
8420243e:	10 04       	Null = r0 - Null;
84202440:	03 62       	if NE jump (m) Lc_aec_reference_stop_reset_3;

84202442 <Lc_aec_reference_stop_reset_2>:
    {
        return(FALSE);
84202442:	02 00       	r0 = Null + Null;
84202444:	0b 6e       	jump (m) Lc_aec_reference_stop_reset_6;

84202446 <Lc_aec_reference_stop_reset_3>:
    }
    /* do something only if the current state is "running" */
    if(op_data->state == OP_RUNNING)
84202446:	31 b0       	rMAC = MBS[r4 + 24];
84202448:	04 62       	if NE jump (m) Lc_aec_reference_stop_reset_5;

8420244a <Lc_aec_reference_stop_reset_4>:
    {
        aec_reference_cleanup(op_data);
8420244a:	32 00       	r0 = r4 + Null;
8420244c:	f7 ff 3b ed 	call (m) $_aec_reference_cleanup;

84202450 <Lc_aec_reference_stop_reset_5>:
    }

    /* operator state variable set to not running state. based on base_op.c */
    op_data->state = OP_NOT_RUNNING;
84202450:	41 20       	rMAC = Null + 1;
84202452:	31 ba       	MB[r4 + 24] = rMAC;
84202454:	39 e8       	rMAC = M[r5 + Null];
84202456:	48 8e       	M[rMAC + 4] = Null;
    base_op_change_response_status(response_data,STATUS_OK);
    return TRUE;
84202458:	42 20       	r0 = Null + 1;

8420245a <Lc_aec_reference_stop_reset_6>:
}
8420245a:	f2 48       	popm <FP, r4, r5, rLink>;
8420245c:	d8 4c       	rts;

8420245e <$_aec_reference_update_mic_reference_sync>:
 * aec_reference_update_mic_reference_sync
 * \brief keeps mic and ref syncronised by updatin mic or reference path warp value
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 */
void aec_reference_update_mic_reference_sync( AEC_REFERENCE_OP_DATA * op_extra_data)
{
8420245e:	f5 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>, SP = SP + 0x10;
84202460:	16 00       	r4 = r0 + Null;
    int mic_ra = 0;
84202462:	02 09       	r8 = Null + Null;
    int spkr_ra = 0;
84202464:	01 09       	r7 = Null + Null;
    uint32 val;

    /* This is run in main loop, decimate update as it won't be
     * needed to get updated that often
     */
    op_extra_data->ref_update_counter++;
84202466:	61 f0 d0 88 	rMAC = M[r4 + 832];
8420246a:	49 20       	rMAC = rMAC + 1;
8420246c:	61 f0 d0 8e 	M[r4 + 832] = rMAC;
    if(op_extra_data->ref_update_counter >= AEC_REFERENCE_REF_RATE_UPDATE_PERIOD)
84202470:	48 26       	Null = rMAC - 9;
84202472:	a7 64       	if NC jump (m) Lc_aec_reference_update_mic_reference_sync_27;

84202474 <Lc_aec_reference_update_mic_reference_sync_2>:
    {
        op_extra_data->ref_update_counter = 0;
84202474:	60 f0 d0 8e 	M[r4 + 832] = Null;
        if(op_extra_data->spkr_rate_enactment == RATEMATCHING_SUPPORT_HW)
84202478:	61 f0 71 88 	rMAC = M[r4 + 452];
8420247c:	88 24       	Null = rMAC - 2;
8420247e:	0e 62       	if NE jump (m) Lc_aec_reference_update_mic_reference_sync_6;

84202480 <Lc_aec_reference_update_mic_reference_sync_3>:
            /* speaker is using HW rate adjustment, read the latest HW warp rate,
             * when using HW rate adjust pretend it is applied in SW and speaker rate
             * itself is perfect.
             * TODO: might need a constant offset for 44.1kHz-like speaker rates
             */
            if(get_override_ep_current_hw_warp(op_extra_data->spkr_endpoint, &val))
84202480:	c3 11       	r1 = FP + 28;
84202482:	62 f0 80 88 	r0 = M[r4 + 512];
84202486:	06 f0 3f ea 	call (m) $_get_override_ep_current_hw_warp;
8420248a:	10 04       	Null = r0 - Null;
8420248c:	03 60       	if EQ jump (m) Lc_aec_reference_update_mic_reference_sync_5;

8420248e <Lc_aec_reference_update_mic_reference_sync_4>:
            {
                spkr_ra = (int)val;
8420248e:	e9 f0 07 88 	r7 = M[FP + 28];

84202492 <Lc_aec_reference_update_mic_reference_sync_5>:
            }
            spkr_rt = (1<<STREAM_RATEMATCHING_FIX_POINT_SHIFT);
84202492:	04 f0 08 f0 	r6 = Null + 4194304;
84202496:	00 40 
84202498:	15 6e       	jump (m) Lc_aec_reference_update_mic_reference_sync_9;

8420249a <Lc_aec_reference_update_mic_reference_sync_6>:
        }
        else
        {
            /* get the latest speaker rate measurement */
            spkr_rt = rate_monitor_op_get_rate(op_extra_data->spkr_rate_monitor_op,0);
8420249a:	62 f0 73 88 	r0 = M[r4 + 460];
8420249e:	03 00       	r1 = Null + Null;
842024a0:	ff fd 4b f3 	call 0x6bbf0;
842024a4:	30 ea 
842024a6:	10 09       	r6 = r0 + Null;
            if(op_extra_data->spkr_rate_enactment == RATEMATCHING_SUPPORT_SW
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
               /* if using standalone operator, no built-in adjust rate is applied */
               &&(0 == op_extra_data->spkr_ext_rate_adjust_op)
#endif
               )
842024a8:	61 f0 71 88 	rMAC = M[r4 + 452];
842024ac:	48 24       	Null = rMAC - 1;
842024ae:	0a 62       	if NE jump (m) Lc_aec_reference_update_mic_reference_sync_9;

842024b0 <Lc_aec_reference_update_mic_reference_sync_7>:
842024b0:	60 f0 ae 88 	Null = M[r4 + 696];
842024b4:	07 62       	if NE jump (m) Lc_aec_reference_update_mic_reference_sync_9;

842024b6 <Lc_aec_reference_update_mic_reference_sync_8>:
            {
                /* if SW rate adjustment is used, get the current value */
                spkr_ra = cbops_sra_get_current_rate_adjust(op_extra_data->spkr_sw_rateadj_op);
842024b6:	62 f0 7e 88 	r0 = M[r4 + 504];
842024ba:	ff fd a4 f0 	call (m) 0x16cba;
842024be:	21 e0 
842024c0:	11 09       	r7 = r0 + Null;

842024c2 <Lc_aec_reference_update_mic_reference_sync_9>:
            }
        }
        if(op_extra_data->mic_rate_enactment == RATEMATCHING_SUPPORT_HW)
842024c2:	61 f0 68 88 	rMAC = M[r4 + 416];
842024c6:	88 24       	Null = rMAC - 2;
842024c8:	0f 62       	if NE jump (m) Lc_aec_reference_update_mic_reference_sync_13;

842024ca <Lc_aec_reference_update_mic_reference_sync_10>:
            /* MIC is using HW rate adjustment, read the latest HW warp rate,
             * when using HW rate adjust pretend it is applied in SW and mic rate
             * itself is perfect.
             * TODO: might need a constant offset for 44.1khz-like mic rates
             */
            if(get_override_ep_current_hw_warp(op_extra_data->mic_endpoint, &val))
842024ca:	c3 11       	r1 = FP + 28;
842024cc:	62 f0 7f 88 	r0 = M[r4 + 508];
842024d0:	06 f0 35 e8 	call (m) $_get_override_ep_current_hw_warp;
842024d4:	10 04       	Null = r0 - Null;
842024d6:	04 60       	if EQ jump (m) Lc_aec_reference_update_mic_reference_sync_12;

842024d8 <Lc_aec_reference_update_mic_reference_sync_11>:
            {
                mic_ra = -(int)val;
842024d8:	39 d8       	rMAC = M[FP + 28];
842024da:	1f f0 0a c2 	r8 = Null - rMAC;

842024de <Lc_aec_reference_update_mic_reference_sync_12>:
            }
            mic_rt = (1<<STREAM_RATEMATCHING_FIX_POINT_SHIFT);
842024de:	04 f0 07 f0 	r5 = Null + 4194304;
842024e2:	00 40 
842024e4:	15 6e       	jump (m) Lc_aec_reference_update_mic_reference_sync_16;

842024e6 <Lc_aec_reference_update_mic_reference_sync_13>:
        }
        else
        {
            /* get the latest speaker rate measurement */
            mic_rt = rate_monitor_op_get_rate(op_extra_data->mic_rate_monitor_op,0);
842024e6:	62 f0 6b 88 	r0 = M[r4 + 428];
842024ea:	03 00       	r1 = Null + Null;
842024ec:	ff fd 4b f3 	call 0x6bbf0;
842024f0:	24 e8 
842024f2:	17 00       	r5 = r0 + Null;
            if(op_extra_data->mic_rate_enactment == RATEMATCHING_SUPPORT_SW
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
               /* if using standalone operator, no built-in adjust rate is applied */
               &&(0 == op_extra_data->mic_ext_rate_adjust_op)
#endif
               )
842024f4:	61 f0 68 88 	rMAC = M[r4 + 416];
842024f8:	48 24       	Null = rMAC - 1;
842024fa:	0a 62       	if NE jump (m) Lc_aec_reference_update_mic_reference_sync_16;

842024fc <Lc_aec_reference_update_mic_reference_sync_14>:
842024fc:	60 f0 ad 88 	Null = M[r4 + 692];
84202500:	07 62       	if NE jump (m) Lc_aec_reference_update_mic_reference_sync_16;

84202502 <Lc_aec_reference_update_mic_reference_sync_15>:
            {
                mic_ra = cbops_sra_get_current_rate_adjust(op_extra_data->mic_sw_rateadj_op);
84202502:	62 f0 7d 88 	r0 = M[r4 + 500];
84202506:	ff fd a3 f0 	call (m) 0x16cba;
8420250a:	35 ed 
8420250c:	12 09       	r8 = r0 + Null;

8420250e <Lc_aec_reference_update_mic_reference_sync_16>:
         *   However to avoid any need to discard/insert in long runs (will cause echo canceller
         *   re-adaptation) we make sure that latency is always tending towards the centre of the
         *   desired range.
         */

        if(op_extra_data->sync_block.block_size != 0)
8420250e:	60 f0 86 88 	Null = M[r4 + 536];
84202512:	1e 60       	if EQ jump (m) Lc_aec_reference_update_mic_reference_sync_18;

84202514 <Lc_aec_reference_update_mic_reference_sync_17>:
        {
            int ref_mic_delay_to_centre =
                (int) op_extra_data->sync_block.ref_delay +
                (int) (op_extra_data->sync_block.jitter/2) -
                (int) op_extra_data->sync_block.speaker_delay;
84202514:	62 f0 85 88 	r0 = M[r4 + 532];
84202518:	61 f0 8a 88 	rMAC = M[r4 + 552];
8420251c:	12 50       	r0 = r0 LSHIFT -1;
8420251e:	51 00       	rMAC = r0 + rMAC;
84202520:	62 f0 8f 88 	r0 = M[r4 + 572];
84202524:	89 04       	rMAC = rMAC - r0;
            op_extra_data->ref_mic_adj_fix += ref_mic_delay_to_centre * AEC_REFERENCE_REF_MIC_ADJ_COEFF;
84202526:	62 f0 d7 88 	r0 = M[r4 + 860];
8420252a:	53 00       	r1 = r0 + rMAC;
8420252c:	63 f0 d7 8e 	M[r4 + 860] = r1;
            op_extra_data->ref_mic_adj_fix = pl_min(op_extra_data->ref_mic_adj_fix, AEC_REFERENCE_REF_MIC_ADJ_MAX);
84202530:	02 f0 d6 40 	r0 = Null + 214;
84202534:	5f f2 43 ce 	r1 = MIN r0;
84202538:	63 f0 d7 8e 	M[r4 + 860] = r1;
            op_extra_data->ref_mic_adj_fix = pl_max(op_extra_data->ref_mic_adj_fix, -AEC_REFERENCE_REF_MIC_ADJ_MAX);
8420253c:	63 f0 d7 88 	r1 = M[r4 + 860];
84202540:	f2 f7 2a 7b 	r0 = Null + -214;
84202544:	6f f2 43 ce 	r1 = MAX r0;
84202548:	63 f0 d7 8e 	M[r4 + 860] = r1;
8420254c:	03 6e       	jump (m) Lc_aec_reference_update_mic_reference_sync_19;

8420254e <Lc_aec_reference_update_mic_reference_sync_18>:
        }
        else
        {
            /* Note: REF-MIC latency control is disabled for block_size == 0 */
            op_extra_data->ref_mic_adj_fix = 0;
8420254e:	60 f0 d7 8e 	M[r4 + 860] = Null;

84202552 <Lc_aec_reference_update_mic_reference_sync_19>:
        }

        if(op_extra_data->mic_sync_enable)
84202552:	60 f0 d4 88 	Null = M[r4 + 848];
84202556:	22 60       	if EQ jump (m) Lc_aec_reference_update_mic_reference_sync_25;

84202558 <Lc_aec_reference_update_mic_reference_sync_20>:
        {
            /* if we are syncronising MIC to REF then calculate the rate needs
             * to be applied to the mic path, so it will be syncronised to
             * REFERENCE output(i.e. speaker input)*/
            int new_mic_ra = (int) aecref_calc_sync_mic_rate(spkr_ra,spkr_rt,mic_rt) - op_extra_data->ref_mic_adj_fix;
84202558:	3c 00       	r2 = r5 + Null;
8420255a:	43 08       	r1 = r6 + Null;
8420255c:	4a 08       	r0 = r7 + Null;
8420255e:	08 f0 21 e1 	call (m) $_aecref_calc_sync_mic_rate;
84202562:	61 f0 d7 88 	rMAC = M[r4 + 860];
84202566:	57 04       	r5 = r0 - rMAC;
            int diff = new_mic_ra - mic_ra;
84202568:	af f7 03 c2 	r1 = r5 - r8;
            if(diff != 0)
8420256c:	18 04       	Null = r1 - Null;
8420256e:	13 60       	if EQ jump (m) Lc_aec_reference_update_mic_reference_sync_24;

84202570 <Lc_aec_reference_update_mic_reference_sync_21>:
            {
                if(op_extra_data->mic_rate_enactment == RATEMATCHING_SUPPORT_HW)
84202570:	61 f0 68 88 	rMAC = M[r4 + 416];
84202574:	88 24       	Null = rMAC - 2;
84202576:	07 62       	if NE jump (m) Lc_aec_reference_update_mic_reference_sync_23;

84202578 <Lc_aec_reference_update_mic_reference_sync_22>:
                {
                    /* HW rate adjustment, apply the change only */
                    set_override_ep_ratematch_adjustment(op_extra_data->mic_endpoint, diff);
84202578:	62 f0 7f 88 	r0 = M[r4 + 508];
8420257c:	ff fd 12 f0 	call (m) 0x4aa0;
84202580:	25 e9 
84202582:	09 6e       	jump (m) Lc_aec_reference_update_mic_reference_sync_24;

84202584 <Lc_aec_reference_update_mic_reference_sync_23>:
                else
                {
                    /* apply new SW rate adjustment */
                    cbops_sra_set_rate_adjust(op_extra_data->mic_sw_rateadj_op,
                                              op_extra_data->num_mic_channels,
                                              new_mic_ra);
84202584:	63 f0 78 88 	r1 = M[r4 + 480];
84202588:	62 f0 7d 88 	r0 = M[r4 + 500];
8420258c:	3c 00       	r2 = r5 + Null;
8420258e:	ff fd a3 f0 	call (m) 0x16c9c;
84202592:	2f e8 

84202594 <Lc_aec_reference_update_mic_reference_sync_24>:
                }
            }
            op_extra_data->mic_rate_adjustment = new_mic_ra;
84202594:	67 f0 69 8e 	M[r4 + 420] = r5;
84202598:	12 6e       	jump (m) Lc_aec_reference_update_mic_reference_sync_26;

8420259a <Lc_aec_reference_update_mic_reference_sync_25>:
        {

            /* We are synchronising REFERENCE to MIC output,
             * Update reference SW rate adjustment.
             */
            op_extra_data->sync_block.rm_adjustment = (int) aecref_calc_ref_rate(mic_rt,mic_ra,spkr_rt,spkr_ra) + op_extra_data->ref_mic_adj_fix;
8420259a:	4d 08       	r3 = r7 + Null;
8420259c:	44 08       	r2 = r6 + Null;
8420259e:	53 08       	r1 = r8 + Null;
842025a0:	3a 00       	r0 = r5 + Null;
842025a2:	07 f0 35 ed 	call (m) $_aecref_calc_ref_rate;
842025a6:	61 f0 d7 88 	rMAC = M[r4 + 860];
842025aa:	8c 00       	r2 = rMAC + r0;
842025ac:	64 f0 8c 8e 	M[r4 + 560] = r2;

            /* update rate adjust for reference path */
            cbops_sra_set_rate_adjust(op_extra_data->ref_sw_rateadj_op,
                                      1,
                                      op_extra_data->sync_block.rm_adjustment);
842025b0:	43 20       	r1 = Null + 1;
842025b2:	62 f0 90 88 	r0 = M[r4 + 576];
842025b6:	ff fd a3 f0 	call (m) 0x16c9c;
842025ba:	27 e7 

842025bc <Lc_aec_reference_update_mic_reference_sync_26>:

        }
        /* Clear frm_count to disable backup rate adjustment
         *  when rate adjustment is enacted
         */
        op_extra_data->sync_block.frm_count = 0;
842025bc:	60 f0 8b 8e 	M[r4 + 556] = Null;

842025c0 <Lc_aec_reference_update_mic_reference_sync_27>:
    }
}
842025c0:	f5 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, rLink>;
842025c2:	d8 4c       	rts;

842025c4 <$_aec_reference_update_stream_and_validate_channels>:
 * \param bufval, cbuffer buffer pointer for new connection (NULL for disconnection)
 *
 * \return whether re-validation carried out successfully
 */
bool aec_reference_update_stream_and_validate_channels(OPERATOR_DATA *op_data, tCbuffer **bufp, tCbuffer *bufval)
{
842025c4:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
842025c6:	16 00       	r4 = r0 + Null;
842025c8:	1f 00       	r5 = r1 + Null;
842025ca:	20 09       	r6 = r2 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
842025cc:	31 99       	rMAC = M[r4 + 48];
    patch_fn_shared(aec_reference);

    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);

    /* if operator isn't running just set the stream buffer and exit */
    if (op_data->state != OP_RUNNING)
842025ce:	32 b0       	r0 = MBS[r4 + 24];
842025d0:	07 60       	if EQ jump (m) Lc_aec_reference_update_stream_and_validate_channels_5;

842025d2 <Lc_aec_reference_update_stream_and_validate_channels_2>:
    {
        if(bufp != NULL)
842025d2:	38 04       	Null = r5 - Null;
842025d4:	03 60       	if EQ jump (m) Lc_aec_reference_update_stream_and_validate_channels_4;

842025d6 <Lc_aec_reference_update_stream_and_validate_channels_3>:
        {
            *bufp = bufval;
842025d6:	78 f0 00 ee 	M[r5 + Null] = r6;

842025da <Lc_aec_reference_update_stream_and_validate_channels_4>:
        }

        return TRUE;
842025da:	42 20       	r0 = Null + 1;
842025dc:	17 6e       	jump (m) Lc_aec_reference_update_stream_and_validate_channels_10;

842025de <Lc_aec_reference_update_stream_and_validate_channels_5>:
    }

    /* block interrupts if the op has a runnig task */
    bool interrupts_blocked = FALSE;
842025de:	01 09       	r7 = Null + Null;
    if(op_extra_data->kick_id != TIMER_ID_INVALID)
842025e0:	10 f0 5d 88 	Null = M[rMAC + 372];
842025e4:	05 60       	if EQ jump (m) Lc_aec_reference_update_stream_and_validate_channels_7;

842025e6 <Lc_aec_reference_update_stream_and_validate_channels_6>:
    {
        LOCK_INTERRUPTS;
842025e6:	ff fd 53 f1 	call (m) 0x2cc9c;
842025ea:	37 e5 
        interrupts_blocked = TRUE;
842025ec:	09 71       	r7 = Null + 1;

842025ee <Lc_aec_reference_update_stream_and_validate_channels_7>:
    }

    /* set the stream buffer */
    if(bufp != NULL)
842025ee:	38 04       	Null = r5 - Null;
842025f0:	03 60       	if EQ jump (m) Lc_aec_reference_update_stream_and_validate_channels_9;

842025f2 <Lc_aec_reference_update_stream_and_validate_channels_8>:
    {
        *bufp = bufval;
842025f2:	78 f0 00 ee 	M[r5 + Null] = r6;

842025f6 <Lc_aec_reference_update_stream_and_validate_channels_9>:
    }

    /* revisit the graphs based on latest connections */
    bool retval = validate_channels_and_build(op_data);
842025f6:	32 00       	r0 = r4 + Null;
842025f8:	fa ff 39 e8 	call (m) $_validate_channels_and_build;
842025fc:	16 00       	r4 = r0 + Null;
842025fe:	0f f9 00 c2 	Null = r7 - Null;
84202602:	f1 fd 53 f1 	if NE call (m) 0x2ccb8;
84202606:	37 e5 
    if(interrupts_blocked)
    {
        UNLOCK_INTERRUPTS;
    }

    return retval;
84202608:	32 00       	r0 = r4 + Null;

8420260a <Lc_aec_reference_update_stream_and_validate_channels_10>:
}
8420260a:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
8420260c:	d8 4c       	rts;

8420260e <$_build_sidetone_graph>:
 * \brief updates speaker graph to include/exclude side tone mixing
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 */
bool build_sidetone_graph(AEC_REFERENCE_OP_DATA* op_extra_data)
{
8420260e:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
84202610:	16 00       	r4 = r0 + Null;
    tCbuffer *mic_buf = op_extra_data->input_stream[AEC_REF_MIC_TERMINAL1];
84202612:	b7 88       	r5 = M[r4 + 8];
    unsigned* idxs;
    unsigned num_io = 2;
84202614:	10 71       	r6 = Null + 2;
    cbops_graph *sidetone_graph;
    cbops_op *op_ptr;
    cbops_op *override_op_ptr;
    unsigned st_mic_idx = 0;          /* buffer index for mic input */
    unsigned st_filter_out_idx = 1;   /* buffer index for sidetone filter output */
    unsigned resampler_out_idx = 0;   /* buffer index for output of possible resampler */
84202616:	40 de       	M[FP + 32] = Null;
    unsigned sidetone_idx = st_filter_out_idx; /* buffer index for sidetone buffer */
84202618:	0a 71       	r8 = Null + 1;
    unsigned sidetone_buf_size;
    unsigned spkr_threshold = frac_mult(op_extra_data->spkr_rate, op_extra_data->kick_period_frac)+1;
8420261a:	62 f0 6e 88 	r0 = M[r4 + 440];
8420261e:	63 f0 96 88 	r1 = M[r4 + 600];
84202622:	00 f3 72 c9 	r0 = r0 * r1 (frac);
84202626:	51 20       	rMAC = r0 + 1;
84202628:	49 de       	M[FP + 36] = rMAC;
    unsigned safety_threshold;
    unsigned spkr_channel_status = GetSpkrChannelStatus(op_extra_data);
8420262a:	61 f0 76 88 	rMAC = M[r4 + 472];
8420262e:	19 f1 f0 1f 	r7 = rMAC AND 0x3ff0;
    unsigned num_sidetone_spkrs = 1;
84202632:	53 09       	r9 = r8 + Null;
     * --------------------------------------------------------------------------------------------------*/

    patch_fn_shared(aec_reference);

    /* destroy cbops graph if already running */
    if(NULL != op_extra_data->sidetone_graph)
84202634:	61 f0 99 88 	rMAC = M[r4 + 612];
84202638:	03 60       	if EQ jump (m) Lc_build_sidetone_graph_3;

8420263a <Lc_build_sidetone_graph_2>:
    {
        aec_reference_cleanup_sidetone_graph(op_extra_data);
8420263a:	32 00       	r0 = r4 + Null;
8420263c:	f8 4e       	call (m) $_aec_reference_cleanup_sidetone_graph;

8420263e <Lc_build_sidetone_graph_3>:
    }

    /* see if we need to setup a separate graph for sidetone mixing */
    if(op_extra_data->sidetone_method != AEC_SIDETONE_IN_SW_USING_SEPARATE_GRAPH)
8420263e:	61 f0 70 90 	rMAC = MBS[r4 + 624];
84202642:	c8 24       	Null = rMAC - 3;
84202644:	e0 62       	if NE jump (m) Lc_build_sidetone_graph_25;

84202646 <Lc_build_sidetone_graph_4>:
    }

    DEBUG_GRAPHS("AEC_REFERENCE: Building sidetone graph ...");

    /* Determine number of speakers to have sidetone */
    if((spkr_channel_status&AEC_REFERENCE_CONSTANT_CONN_TYPE_PARA) == 0)
84202646:	91 f0 00 10 	rMAC = r7 AND 0x1000;
8420264a:	05 62       	if NE jump (m) Lc_build_sidetone_graph_7;

8420264c <Lc_build_sidetone_graph_5>:
    {
        if((spkr_channel_status&AEC_REFERENCE_CONSTANT_CONN_TYPE_MIX) == 0)
8420264c:	91 f1 00 00 	rMAC = r7 AND 0x2000;
84202650:	02 62       	if NE jump (m) Lc_build_sidetone_graph_7;

84202652 <Lc_build_sidetone_graph_6>:
        {
            /* mono to stereo, mix to both */
            num_sidetone_spkrs = 2;
84202652:	43 09       	r9 = r6 + Null;

84202654 <Lc_build_sidetone_graph_7>:
        }
    }

    /* limit to available speakers */
    num_sidetone_spkrs = MIN(num_sidetone_spkrs, op_extra_data->num_spkr_channels);
84202654:	61 f0 77 88 	rMAC = M[r4 + 476];
84202658:	1f fb 00 c2 	Null = r9 - rMAC;
8420265c:	02 64       	if NC jump (m) Lc_build_sidetone_graph_9;

8420265e <Lc_build_sidetone_graph_8>:
8420265e:	0b 09       	r9 = rMAC + Null;

84202660 <Lc_build_sidetone_graph_9>:

    /* we don't expect Sidetone buffer already existing at this point */
    PL_ASSERT(op_extra_data->sidetone_buf == NULL);
84202660:	61 f0 2b 88 	rMAC = M[r4 + 172];
84202664:	d2 60       	if EQ jump (m) Lc_build_sidetone_graph_26;

84202666 <Lc_build_sidetone_graph_10>:
84202666:	03 f0 cb 41 	r1 = Null + 459;
8420266a:	02 f0 13 60 	r0 = Null + 4115;
8420266e:	ff fd 8c f0 	call (m) 0x13f12;
84202672:	25 e5 
84202674:	da 6e       	jump (m) Lc_build_sidetone_graph_30;

84202676 <Lc_build_sidetone_graph_11>:
    /* Allocate Buffer for sidetone samples,
     * size = sidetone_task_period + 1ms for latency control
     */
    sidetone_buf_size = frac_mult(op_extra_data->spkr_rate,
                                  op_extra_data->kick_period_frac +
                                  FRACTIONAL(0.001));
84202676:	62 f0 6e 88 	r0 = M[r4 + 440];
8420267a:	61 f0 96 88 	rMAC = M[r4 + 600];
8420267e:	83 f0 13 f0 	r1 = rMAC + 2147483;
84202682:	9b 28 
84202684:	00 f3 72 c9 	r0 = r0 * r1 (frac);

    op_extra_data->sidetone_buf = cbuffer_create_with_malloc_fast(sidetone_buf_size, BUF_DESC_SW_BUFFER);
84202688:	03 00       	r1 = Null + Null;
8420268a:	ff fd 80 f0 	call (m) 0x1279c;
8420268e:	33 e8 
84202690:	62 f0 2b 8e 	M[r4 + 172] = r0;
    if(!op_extra_data->sidetone_buf)
84202694:	61 f0 2b 88 	rMAC = M[r4 + 172];
84202698:	c7 60       	if EQ jump (m) Lc_build_sidetone_graph_29;

8420269a <Lc_build_sidetone_graph_12>:
    }

    /* create clone cbuffers for mic buffer */
    op_extra_data->sidetone_mic_buf = cbuffer_create(mic_buf->base_addr,
                                                     cbuffer_get_size_in_words(mic_buf),
                                                     BUF_DESC_SW_BUFFER);
8420269a:	3a 00       	r0 = r5 + Null;
8420269c:	ff fd 80 f0 	call (m) 0x12858;
842026a0:	3d ed 
842026a2:	13 00       	r1 = r0 + Null;
842026a4:	fa 88       	r0 = M[r5 + 12];
842026a6:	04 00       	r2 = Null + Null;
842026a8:	ff fd 80 f0 	call (m) 0x12762;
842026ac:	3b e5 
842026ae:	62 f0 9a 8e 	M[r4 + 616] = r0;
    if(op_extra_data->sidetone_mic_buf == NULL)
842026b2:	61 f0 9a 88 	rMAC = M[r4 + 616];
842026b6:	b8 60       	if EQ jump (m) Lc_build_sidetone_graph_29;

842026b8 <Lc_build_sidetone_graph_13>:
        return FALSE;
    }


    /* do we need resampler for side tone generation */
    if(op_extra_data->spkr_rate != op_extra_data->mic_rate)
842026b8:	61 f0 6e 88 	rMAC = M[r4 + 440];
842026bc:	62 f0 66 88 	r0 = M[r4 + 408];
842026c0:	88 04       	Null = rMAC - r0;
842026c2:	05 60       	if EQ jump (m) Lc_build_sidetone_graph_15;

842026c4 <Lc_build_sidetone_graph_14>:
    {
        /* Extra buffer needed between sidetone filter and resampler,
         * as resampler can't work in-place
         */
        num_io++;
842026c4:	18 71       	r6 = Null + 3;
        resampler_out_idx = st_filter_out_idx + 1;
842026c6:	81 20       	rMAC = Null + 2;
842026c8:	41 de       	M[FP + 32] = rMAC;
        sidetone_idx++;
842026ca:	0a 09       	r8 = rMAC + Null;

842026cc <Lc_build_sidetone_graph_15>:

    /* create indexes for cbops buffers,
     * this needs to be deleted before leaving
     * this function.
     */
    idxs = create_default_indexes(num_io);
842026cc:	42 08       	r0 = r6 + Null;
842026ce:	ff fd a4 f0 	call (m) 0x16f08;
842026d2:	3b e1 
842026d4:	11 09       	r7 = r0 + Null;
    if(idxs == NULL)
842026d6:	a8 60       	if EQ jump (m) Lc_build_sidetone_graph_29;

842026d8 <Lc_build_sidetone_graph_16>:
    {
        return(FALSE);
    }

    /* Allocate sidetone graph */
    sidetone_graph = cbops_alloc_graph(num_io);
842026d8:	42 08       	r0 = r6 + Null;
842026da:	ff fd a3 f0 	call (m) 0x16d76;
842026de:	3d e4 
842026e0:	10 09       	r6 = r0 + Null;
    if(!sidetone_graph)
842026e2:	9e 60       	if EQ jump (m) Lc_build_sidetone_graph_28;

842026e4 <Lc_build_sidetone_graph_17>:
    {
        goto aFailed;
    }
    op_extra_data->sidetone_graph = sidetone_graph;
842026e4:	68 f0 99 8e 	M[r4 + 612] = r6;

    /* set mic input buffer */
    cbops_set_input_io_buffer(sidetone_graph,
                              st_mic_idx,
                              st_mic_idx,
                              op_extra_data->sidetone_mic_buf);
842026e8:	65 f0 9a 88 	r3 = M[r4 + 616];
842026ec:	04 00       	r2 = Null + Null;
842026ee:	03 00       	r1 = Null + Null;
842026f0:	ff fd a3 f0 	call (m) 0x16e02;
842026f4:	33 e8 
     * into speakers by override operator)
     */
    cbops_set_output_io_buffer(sidetone_graph,
                               sidetone_idx,
                               sidetone_idx,
                               op_extra_data->sidetone_buf);
842026f6:	65 f0 2b 88 	r3 = M[r4 + 172];
842026fa:	54 08       	r2 = r8 + Null;
842026fc:	53 08       	r1 = r8 + Null;
842026fe:	42 08       	r0 = r6 + Null;
84202700:	ff fd a3 f0 	call (m) 0x16e34;
84202704:	35 e9 
      Note:  Sidetone is before resampler.
      Better solution is to place it at lowest sample rate
    */
    op_ptr = create_sidetone_filter_op(st_mic_idx, st_filter_out_idx, 3,
                                       (cbops_sidetone_params*)&op_extra_data->params.OFFSET_ST_CLIP_POINT,
                                       (void*)&op_extra_data->params.OFFSET_ST_PEQ_CONFIG);
84202706:	7a ff 16 cf 	push r4 + 244;
8420270a:	65 f0 d8 20 	r3 = r4 + 216;
8420270e:	c4 20       	r2 = Null + 3;
84202710:	43 20       	r1 = Null + 1;
84202712:	02 00       	r0 = Null + Null;
84202714:	04 f0 27 e4 	call (m) $_create_sidetone_filter_op;
84202718:	7f 4c       	SP = SP + -4;
    op_extra_data->mic_sidetone_op = op_ptr;
    if(!op_ptr)
8420271a:	62 f0 6c 8e 	M[r4 + 432] = r0;
8420271e:	80 60       	if EQ jump (m) Lc_build_sidetone_graph_28;

84202720 <Lc_build_sidetone_graph_18>:
    {
        goto aFailed;
    }
    cbops_append_operator_to_graph(sidetone_graph,op_ptr);
84202720:	13 00       	r1 = r0 + Null;
84202722:	42 08       	r0 = r6 + Null;
84202724:	ff fd a3 f0 	call (m) 0x16e96;
84202728:	33 eb 

    /* DC remove on sidetone */
    op_ptr = create_dc_remove_op(1, &idxs[st_filter_out_idx], &idxs[st_filter_out_idx]);
8420272a:	94 f0 04 20 	r2 = r7 + 4;
8420272e:	93 f0 04 20 	r1 = r7 + 4;
84202732:	42 20       	r0 = Null + 1;
84202734:	ff fd 1b f1 	call (m) 0x25e40;
84202738:	2d e8 
    if(!op_ptr)
8420273a:	10 04       	Null = r0 - Null;
8420273c:	71 60       	if EQ jump (m) Lc_build_sidetone_graph_28;

8420273e <Lc_build_sidetone_graph_19>:
    {
        goto aFailed;
    }
    cbops_append_operator_to_graph(sidetone_graph, op_ptr);
8420273e:	13 00       	r1 = r0 + Null;
84202740:	42 08       	r0 = r6 + Null;
84202742:	ff fd a3 f0 	call (m) 0x16e96;
84202746:	35 ea 

    /* see if we need resampler in sidetone path */
    if(resampler_out_idx != 0)
84202748:	41 d8       	rMAC = M[FP + 32];
8420274a:	29 60       	if EQ jump (m) Lc_build_sidetone_graph_22;

8420274c <Lc_build_sidetone_graph_20>:
    {
        /* sidetone filter will write into scratch buff */
        cbops_set_internal_io_buffer(sidetone_graph,
                                     st_filter_out_idx,
                                     st_filter_out_idx,
                                     op_extra_data->scratch_bufs[0]);
8420274c:	65 f0 df 88 	r3 = M[r4 + 892];
84202750:	44 20       	r2 = Null + 1;
84202752:	23 00       	r1 = r2 + Null;
84202754:	42 08       	r0 = r6 + Null;
84202756:	ff fd a3 f0 	call (m) 0x16e66;
8420275a:	31 e8 
                                           &idxs[st_filter_out_idx],
                                           &idxs[resampler_out_idx],
                                           op_extra_data->mic_rate,
                                           op_extra_data->spkr_rate,
                                           op_extra_data->resampler_temp_buffer_size,
                                           op_extra_data->resampler_temp_buffer, 0, 0, 0);
8420275c:	00 f0 30 cf 	push Null;
84202760:	00 f0 30 cf 	push Null;
84202764:	00 f0 30 cf 	push Null;
84202768:	61 f0 2c 88 	rMAC = M[r4 + 176];
8420276c:	09 1c       	pushm <rMAC>;
8420276e:	61 f0 91 88 	rMAC = M[r4 + 580];
84202772:	09 1c       	pushm <rMAC>;
84202774:	61 f0 6e 88 	rMAC = M[r4 + 440];
84202778:	09 1c       	pushm <rMAC>;
8420277a:	65 f0 66 88 	r3 = M[r4 + 408];
8420277e:	94 f0 08 20 	r2 = r7 + 8;
84202782:	93 f0 04 20 	r1 = r7 + 4;
84202786:	42 20       	r0 = Null + 1;
84202788:	04 f0 21 e3 	call (m) $_create_iir_resamplerv2_op;
8420278c:	7a 4c       	SP = SP + -24;
        if(!op_ptr)
8420278e:	10 04       	Null = r0 - Null;
84202790:	47 60       	if EQ jump (m) Lc_build_sidetone_graph_28;

84202792 <Lc_build_sidetone_graph_21>:
        {
            goto aFailed;
        }
        cbops_append_operator_to_graph(sidetone_graph,op_ptr);
84202792:	13 00       	r1 = r0 + Null;
84202794:	42 08       	r0 = r6 + Null;
84202796:	ff fd a3 f0 	call (m) 0x16e96;
8420279a:	21 e8 

8420279c <Lc_build_sidetone_graph_22>:
    op_ptr = create_sink_overflow_disgard_op(1,                   /* number of channels */
                                             &idxs[sidetone_idx], /* buffer indexes */
                                             /* Minimum space needed in buffer at the beginning of
                                              * process, if not enough space this op will discard some
                                              * samples to free space for new incoming mic sapmples */
                                             spkr_threshold);
8420279c:	01 fa d2 c8 	r0 = r8 LSHIFT 2;
842027a0:	49 08       	rMAC = r7 + Null;
842027a2:	51 00       	rMAC = r0 + rMAC;
842027a4:	0f 00       	r5 = rMAC + Null;
842027a6:	42 20       	r0 = Null + 1;
842027a8:	3b 00       	r1 = r5 + Null;
842027aa:	4c d8       	r2 = M[FP + 36];
842027ac:	ff fd 4b f1 	call (m) 0x2bdc4;
842027b0:	39 e0 
#if defined(IO_DEBUG)
    st_disgard_op = op_ptr;
842027b2:	e0 f0 02 f0 	M[Null + $_st_disgard_op] = r0;
842027b6:	5d 8e 
#endif

    if(!op_ptr)
842027b8:	10 04       	Null = r0 - Null;
842027ba:	32 60       	if EQ jump (m) Lc_build_sidetone_graph_28;

842027bc <Lc_build_sidetone_graph_23>:
    {
        goto aFailed;
    }
    cbops_append_operator_to_graph(sidetone_graph,op_ptr);
842027bc:	13 00       	r1 = r0 + Null;
842027be:	42 08       	r0 = r6 + Null;
842027c0:	ff fd a3 f0 	call (m) 0x16e96;
842027c4:	37 e6 
     */

    /* safety_threshold, this is a small safety zone to make sure
     * sidetone mixing is ahead of reading by HW, (1/4 of a ms)
     */
    safety_threshold = frac_mult(op_extra_data->spkr_rate, FRACTIONAL(0.00025))+1;
842027c6:	62 f0 6e 88 	r0 = M[r4 + 440];
842027ca:	00 f0 13 f4 	r1 = Null + 536870;
842027ce:	26 61 
842027d0:	00 f3 72 c9 	r0 = r0 * r1 (frac);
842027d4:	51 20       	rMAC = r0 + 1;
        &op_extra_data->output_stream[AEC_REF_SPKR_TERMINAL1], /* spkr mmu buffer(s) */
        num_sidetone_spkrs,                                 /* number of speaker(s) */
        &idxs[sidetone_idx],                                /* indexes for sidetone buffer */
        spkr_threshold,                                     /* speaker threshold */
        safety_threshold                                    /* safety threshold */
                                                );
842027d6:	09 1c       	pushm <rMAC>;
842027d8:	49 d8       	rMAC = M[FP + 36];
842027da:	08 f0 42 e0 	pushm <rMAC, r5>;
842027de:	64 f0 44 20 	r2 = r4 + 68;
842027e2:	b2 88       	r0 = M[r4 + 8];
842027e4:	03 00       	r1 = Null + Null;
842027e6:	5d 08       	r3 = r9 + Null;
842027e8:	03 f0 3d e2 	call (m) $_create_aec_ref_sidetone_op;
842027ec:	7d 4c       	SP = SP + -12;
    if(!override_op_ptr)
842027ee:	10 04       	Null = r0 - Null;
842027f0:	17 60       	if EQ jump (m) Lc_build_sidetone_graph_28;

842027f2 <Lc_build_sidetone_graph_24>:
    {
        goto aFailed;
    }
    cbops_set_override_operator(sidetone_graph, override_op_ptr);
842027f2:	13 00       	r1 = r0 + Null;
842027f4:	42 08       	r0 = r6 + Null;
842027f6:	ff fd a3 f0 	call (m) 0x16ec2;
842027fa:	2d e6 

    DEBUG_GRAPHS("AEC REFERENCE: Building sidetone graph, Done!");
    pfree(idxs);
842027fc:	4a 08       	r0 = r7 + Null;
842027fe:	ff fd 13 f0 	call (m) 0x4f62;
84202802:	25 eb 

84202804 <Lc_build_sidetone_graph_25>:
    }

    /* see if we need to setup a separate graph for sidetone mixing */
    if(op_extra_data->sidetone_method != AEC_SIDETONE_IN_SW_USING_SEPARATE_GRAPH)
    {
        return TRUE;
84202804:	42 20       	r0 = Null + 1;
84202806:	11 6e       	jump (m) Lc_build_sidetone_graph_30;

84202808 <Lc_build_sidetone_graph_26>:
    /* limit to available speakers */
    num_sidetone_spkrs = MIN(num_sidetone_spkrs, op_extra_data->num_spkr_channels);

    /* we don't expect Sidetone buffer already existing at this point */
    PL_ASSERT(op_extra_data->sidetone_buf == NULL);
    PL_ASSERT(op_extra_data->sidetone_mic_buf == NULL);
84202808:	61 f0 9a 88 	rMAC = M[r4 + 616];
8420280c:	35 61       	if EQ jump (m) Lc_build_sidetone_graph_11;

8420280e <Lc_build_sidetone_graph_27>:
8420280e:	03 f0 cc 41 	r1 = Null + 460;
84202812:	02 f0 13 60 	r0 = Null + 4115;
84202816:	ff fd 8b f0 	call (m) 0x13f12;
8420281a:	3d e7 
8420281c:	06 6e       	jump (m) Lc_build_sidetone_graph_30;

8420281e <Lc_build_sidetone_graph_28>:
    pfree(idxs);

    return TRUE;
  aFailed:
    DEBUG_GRAPHS("AEC REFERENCE: Building sidetone graph, Failed!");
    pfree(idxs);
8420281e:	4a 08       	r0 = r7 + Null;
84202820:	ff fd 13 f0 	call (m) 0x4f62;
84202824:	23 ea 

84202826 <Lc_build_sidetone_graph_29>:
    if(!op_extra_data->sidetone_buf)
    {
        /* Not going ahead with creating sidetone graph if we
         * cannot create shared buffer for sidetone path.
         */
        return FALSE;
84202826:	02 00       	r0 = Null + Null;

84202828 <Lc_build_sidetone_graph_30>:
    return TRUE;
  aFailed:
    DEBUG_GRAPHS("AEC REFERENCE: Building sidetone graph, Failed!");
    pfree(idxs);
    return(FALSE);
}
84202828:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
8420282a:	d8 4c       	rts;

8420282c <$_aec_reference_cleanup_sidetone_graph>:
 * \brief clean up sidetone graph
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 */
void aec_reference_cleanup_sidetone_graph(AEC_REFERENCE_OP_DATA *op_extra_data)
{
8420282c:	f1 1c       	pushm <FP(=SP), r4, rLink>;
8420282e:	16 00       	r4 = r0 + Null;
    patch_fn_shared(aec_reference);

    /* mic_sidetone_op, no longer is valid` */
    op_extra_data->mic_sidetone_op = NULL;
84202830:	60 f0 6c 8e 	M[r4 + 432] = Null;

    /* Free cbops sidetone graph */
    if(op_extra_data->sidetone_graph != NULL)
84202834:	62 f0 99 88 	r0 = M[r4 + 612];
84202838:	06 60       	if EQ jump (m) Lc_aec_reference_cleanup_sidetone_graph_3;

8420283a <Lc_aec_reference_cleanup_sidetone_graph_2>:
    {
        destroy_graph(op_extra_data->sidetone_graph);
8420283a:	ff fd a2 f0 	call (m) 0x16daa;
8420283e:	31 eb 
        op_extra_data->sidetone_graph = NULL;
84202840:	60 f0 99 8e 	M[r4 + 612] = Null;

84202844 <Lc_aec_reference_cleanup_sidetone_graph_3>:
    }

    /* Free Sidetone buffers */
    if(op_extra_data->sidetone_buf != NULL)
84202844:	62 f0 2b 88 	r0 = M[r4 + 172];
84202848:	06 60       	if EQ jump (m) Lc_aec_reference_cleanup_sidetone_graph_5;

8420284a <Lc_aec_reference_cleanup_sidetone_graph_4>:
    {
        cbuffer_destroy(op_extra_data->sidetone_buf);
8420284a:	ff fd 7f f0 	call (m) 0x12802;
8420284e:	39 ed 
        op_extra_data->sidetone_buf = NULL;
84202850:	60 f0 2b 8e 	M[r4 + 172] = Null;

84202854 <Lc_aec_reference_cleanup_sidetone_graph_5>:
    }

    /* free cbuffer structure for clone mic buff */
    if(op_extra_data->sidetone_mic_buf != NULL)
84202854:	62 f0 9a 88 	r0 = M[r4 + 616];
84202858:	06 60       	if EQ jump (m) Lc_aec_reference_cleanup_sidetone_graph_7;

8420285a <Lc_aec_reference_cleanup_sidetone_graph_6>:
    {
        cbuffer_destroy_struct(op_extra_data->sidetone_mic_buf);
8420285a:	ff fd 7f f0 	call (m) 0x12834;
8420285e:	3b ee 
        op_extra_data->sidetone_mic_buf = NULL;
84202860:	60 f0 9a 8e 	M[r4 + 616] = Null;

84202864 <Lc_aec_reference_cleanup_sidetone_graph_7>:
    }

    DEBUG_GRAPHS("AEC REFERENCE: SIDETONE graph's cleanup done!" );
}
84202864:	f1 48       	popm <FP, r4, rLink>;
84202866:	d8 4c       	rts;

84202868 <Lc_build_mic_graph_is_required_1>:
 */
static bool build_mic_graph_is_required(AEC_REFERENCE_OP_DATA *op_extra_data,
                                        bool sidetone_enabled)
{
    /* check if we have mic config at all */
    if((op_extra_data->channel_status&CHAN_STATE_MIC_MASK) == 0)
84202868:	21 f0 76 88 	rMAC = M[r0 + 472];
8420286c:	0f f0 14 f8 	r2 = rMAC AND 0x1f000f;
84202870:	0f 00 
84202872:	03 62       	if NE jump (m) Lc_build_mic_graph_is_required_3;

84202874 <Lc_build_mic_graph_is_required_2>:
    {
        /* mic path isn't needed */
        return FALSE;
84202874:	02 00       	r0 = Null + Null;
84202876:	12 6e       	jump (m) Lc_build_mic_graph_is_required_8;

84202878 <Lc_build_mic_graph_is_required_3>:
    }

    /* default: mic path required with output */
    op_extra_data->mic_graph_no_output = FALSE;
84202878:	20 f0 dd 8e 	M[r0 + 884] = Null;

    if((op_extra_data->channel_status&AEC_REFERENCE_CONSTANT_CONN_MIKE_1_INPUT_ONLY) != 0)
8420287c:	08 f0 11 f0 	rMAC = rMAC AND 0x100000;
84202880:	00 00 
84202882:	0b 60       	if EQ jump (m) Lc_build_mic_graph_is_required_7;

84202884 <Lc_build_mic_graph_is_required_4>:
        /* This check is only for efficiency, knowing that 1->0 mic config
         * only needed if sidetone is enabled. if sidetone not enabled,
         * or enabled but will be done using separate graph then no need
         * to build mic graph at all.
         */
        if(!sidetone_enabled || op_extra_data->task_decim_factor > 1)
84202884:	18 04       	Null = r1 - Null;
84202886:	f7 61       	if EQ jump (m) Lc_build_mic_graph_is_required_2;

84202888 <Lc_build_mic_graph_is_required_5>:
84202888:	21 f0 97 88 	rMAC = M[r0 + 604];
8420288c:	48 24       	Null = rMAC - 1;
8420288e:	f8 ff e7 ef 	if HI jump (m) Lc_build_mic_graph_is_required_2;

84202892 <Lc_build_mic_graph_is_required_6>:
            /* mic path isn't needed */
            return FALSE;
        }

        /* build mic path without output */
        op_extra_data->mic_graph_no_output = TRUE;
84202892:	41 20       	rMAC = Null + 1;
84202894:	21 f0 dd 8e 	M[r0 + 884] = rMAC;

84202898 <Lc_build_mic_graph_is_required_7>:
    }

    return TRUE;
84202898:	42 20       	r0 = Null + 1;

8420289a <Lc_build_mic_graph_is_required_8>:
8420289a:	d8 4c       	rts;

8420289c <Lc_build_mic_graph_add_output_subgraph_1>:
static bool build_mic_graph_add_output_subgraph(AEC_REFERENCE_OP_DATA *op_extra_data,
                                                unsigned *idxs,
                                                unsigned intern_idx,
                                                unsigned out_idx,
                                                bool sidetone_enabled)
{
8420289c:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
8420289e:	12 09       	r8 = r0 + Null;
842028a0:	43 de       	M[FP + 32] = r1;
842028a2:	4c de       	M[FP + 36] = r2;
842028a4:	28 09       	r6 = r3 + Null;
842028a6:	f9 d9       	rMAC = M[FP + -4];
842028a8:	51 de       	M[FP + 40] = rMAC;
    cbops_graph *mic_graph = op_extra_data->mic_graph;
842028aa:	ab f0 6a 88 	r9 = M[r8 + 424];
    unsigned num_mics = op_extra_data->num_mic_channels;
842028ae:	a9 f0 78 88 	r7 = M[r8 + 480];
    cbops_op *op_ptr = NULL;
    unsigned i,j;

    /* Setup output Buffers*/
    for(j=0,i=0;(j<MAX_NUMBER_MICS);j++)
842028b2:	06 00       	r4 = Null + Null;
842028b4:	07 00       	r5 = Null + Null;
842028b6:	04 6e       	jump (m) Lc_build_mic_graph_add_output_subgraph_3;

842028b8 <Lc_build_mic_graph_add_output_subgraph_2>:
    }
}

inline static unsigned OutputTerminalByIndex(unsigned i)
{
    if(i<4)
842028b8:	38 25       	Null = r5 - 4;
842028ba:	02 f0 89 e0 	if C jump (m) Lc_build_mic_graph_add_output_subgraph_4;

842028be <Lc_build_mic_graph_add_output_subgraph_3>:
    {
        return (i + AEC_REF_OUTPUT_TERMINAL1);
842028be:	fa 20       	r0 = r5 + 3;
842028c0:	02 6e       	jump (m) Lc_build_mic_graph_add_output_subgraph_5;

842028c2 <Lc_build_mic_graph_add_output_subgraph_4>:
    }
    else
    {
        return ((i-4) + AEC_REF_OUTPUT_TERMINAL5);
842028c2:	7a 22       	r0 = r5 + 9;

842028c4 <Lc_build_mic_graph_add_output_subgraph_5>:
    {
        /* MIC outputs may not be consecutive */
        tCbuffer *buffer_ptr_snk = op_extra_data->output_stream[OutputTerminalByIndex(j)];
842028c4:	a1 f0 40 20 	rMAC = r8 + 64;
842028c8:	52 54       	r0 = r0 LSHIFT 2;
        if(buffer_ptr_snk != NULL)
842028ca:	8d e8       	r3 = M[rMAC + r0];
842028cc:	0d 60       	if EQ jump (m) Lc_build_mic_graph_add_output_subgraph_9;

842028ce <Lc_build_mic_graph_add_output_subgraph_6>:
        {
            if(i < num_mics)
842028ce:	9f f6 00 c2 	Null = r4 - r7;
842028d2:	02 f0 93 e0 	if C jump (m) Lc_build_mic_graph_add_output_subgraph_8;

842028d6 <Lc_build_mic_graph_add_output_subgraph_7>:
            {
                /* Outputs */
                cbops_set_output_io_buffer(mic_graph, out_idx + i, out_idx, buffer_ptr_snk);
842028d6:	8f f6 03 c0 	r1 = r4 + r6;
842028da:	44 08       	r2 = r6 + Null;
842028dc:	5a 08       	r0 = r9 + Null;
842028de:	ff fd a2 f0 	call (m) 0x16e34;
842028e2:	37 ea 

842028e4 <Lc_build_mic_graph_add_output_subgraph_8>:
            }
            i++;
842028e4:	76 20       	r4 = r4 + 1;

842028e6 <Lc_build_mic_graph_add_output_subgraph_9>:
    unsigned num_mics = op_extra_data->num_mic_channels;
    cbops_op *op_ptr = NULL;
    unsigned i,j;

    /* Setup output Buffers*/
    for(j=0,i=0;(j<MAX_NUMBER_MICS);j++)
842028e6:	7f 20       	r5 = r5 + 1;
842028e8:	38 26       	Null = r5 - 8;
842028ea:	e7 65       	if NC jump (m) Lc_build_mic_graph_add_output_subgraph_2;

842028ec <Lc_build_mic_graph_add_output_subgraph_10>:
            }
            i++;
        }
    }
    /* expect to have exactly num_mics outputs connected */
    PL_ASSERT(i==num_mics);
842028ec:	9f f6 00 c2 	Null = r4 - r7;
842028f0:	09 60       	if EQ jump (m) Lc_build_mic_graph_add_output_subgraph_12;

842028f2 <Lc_build_mic_graph_add_output_subgraph_11>:
842028f2:	03 f0 c8 42 	r1 = Null + 712;
842028f6:	02 f0 13 60 	r0 = Null + 4115;
842028fa:	ff fd 8b f0 	call (m) 0x13f12;
842028fe:	39 e0 
84202900:	68 6e       	jump (m) Lc_build_mic_graph_add_output_subgraph_26;

84202902 <Lc_build_mic_graph_add_output_subgraph_12>:

    /* Handle output */
    if(op_extra_data->mic_rate!=op_extra_data->output_rate)
84202902:	a5 f0 66 88 	r3 = M[r8 + 408];
84202906:	a1 f0 65 88 	rMAC = M[r8 + 404];
8420290a:	68 04       	Null = r3 - rMAC;
8420290c:	21 60       	if EQ jump (m) Lc_build_mic_graph_add_output_subgraph_17;

8420290e <Lc_build_mic_graph_add_output_subgraph_13>:
    {
        /* If only operator then shift input to output */
        unsigned shift_amount = (intern_idx != 0) ? 0 :  op_extra_data->mic_shift;
8420290e:	4a d8       	r0 = M[FP + 36];
84202910:	03 60       	if EQ jump (m) Lc_build_mic_graph_add_output_subgraph_15;

84202912 <Lc_build_mic_graph_add_output_subgraph_14>:
84202912:	02 00       	r0 = Null + Null;
84202914:	03 6e       	jump (m) Lc_build_mic_graph_add_output_subgraph_16;

84202916 <Lc_build_mic_graph_add_output_subgraph_15>:
84202916:	a2 f0 6d 88 	r0 = M[r8 + 436];

8420291a <Lc_build_mic_graph_add_output_subgraph_16>:
        /*  Add Resampler Operators per channel (mic_rate --> output_rate) */
        op_ptr = create_iir_resamplerv2_op(num_mics,
                                           &idxs[intern_idx], &idxs[out_idx],
                                           op_extra_data->mic_rate,op_extra_data->output_rate,
                                           op_extra_data->resampler_temp_buffer_size,
                                           op_extra_data->resampler_temp_buffer, shift_amount, 0, 0);
8420291a:	00 f0 30 cf 	push Null;
8420291e:	00 f0 30 cf 	push Null;
84202922:	11 1c       	pushm <r0>;
84202924:	a2 f0 2c 88 	r0 = M[r8 + 176];
84202928:	11 1c       	pushm <r0>;
8420292a:	a2 f0 91 88 	r0 = M[r8 + 580];
8420292e:	11 1c       	pushm <r0>;
84202930:	09 1c       	pushm <rMAC>;
84202932:	01 f8 d2 c8 	r0 = r6 LSHIFT 2;
84202936:	44 d8       	r2 = M[FP + 32];
84202938:	23 00       	r1 = r2 + Null;
8420293a:	14 01       	r2 = r0 + r2;
8420293c:	4a d8       	r0 = M[FP + 36];
8420293e:	52 54       	r0 = r0 LSHIFT 2;
84202940:	d3 00       	r1 = r0 + r1;
84202942:	4a 08       	r0 = r7 + Null;
84202944:	03 f0 25 e5 	call (m) $_create_iir_resamplerv2_op;
84202948:	7a 4c       	SP = SP + -24;
8420294a:	16 00       	r4 = r0 + Null;
8420294c:	11 6e       	jump (m) Lc_build_mic_graph_add_output_subgraph_19;

8420294e <Lc_build_mic_graph_add_output_subgraph_17>:
        {
            return FALSE;
        }
        cbops_append_operator_to_graph(mic_graph,op_ptr);
    }
    else if (sidetone_enabled)
8420294e:	51 d8       	rMAC = M[FP + 40];
84202950:	1c 60       	if EQ jump (m) Lc_build_mic_graph_add_output_subgraph_23;

84202952 <Lc_build_mic_graph_add_output_subgraph_18>:
    {
        /* Need to copy internal buffer to output before sidetone */
        op_ptr = create_shift_op(num_mics,&idxs[intern_idx], &idxs[out_idx],0);
84202952:	01 f8 d2 c8 	r0 = r6 LSHIFT 2;
84202956:	44 d8       	r2 = M[FP + 32];
84202958:	05 00       	r3 = Null + Null;
8420295a:	23 00       	r1 = r2 + Null;
8420295c:	14 01       	r2 = r0 + r2;
8420295e:	4a d8       	r0 = M[FP + 36];
84202960:	52 54       	r0 = r0 LSHIFT 2;
84202962:	d3 00       	r1 = r0 + r1;
84202964:	4a 08       	r0 = r7 + Null;
84202966:	ff fd 1a f1 	call (m) 0x25e08;
8420296a:	23 e5 
8420296c:	16 00       	r4 = r0 + Null;

8420296e <Lc_build_mic_graph_add_output_subgraph_19>:
        op_ptr = create_iir_resamplerv2_op(num_mics,
                                           &idxs[intern_idx], &idxs[out_idx],
                                           op_extra_data->mic_rate,op_extra_data->output_rate,
                                           op_extra_data->resampler_temp_buffer_size,
                                           op_extra_data->resampler_temp_buffer, shift_amount, 0, 0);
        if(op_ptr == NULL)
8420296e:	30 04       	Null = r4 - Null;
84202970:	03 62       	if NE jump (m) Lc_build_mic_graph_add_output_subgraph_21;

84202972 <Lc_build_mic_graph_add_output_subgraph_20>:
        {
            return FALSE;
84202972:	02 00       	r0 = Null + Null;
84202974:	2e 6e       	jump (m) Lc_build_mic_graph_add_output_subgraph_26;

84202976 <Lc_build_mic_graph_add_output_subgraph_21>:
        }
        cbops_append_operator_to_graph(mic_graph,op_ptr);
84202976:	33 00       	r1 = r4 + Null;
84202978:	5a 08       	r0 = r9 + Null;
8420297a:	ff fd a2 f0 	call (m) 0x16e96;
8420297e:	3d e8 
        }
        cbops_append_operator_to_graph(mic_graph,op_ptr);
    }

    /* Handle sidetone */
    if(sidetone_enabled && op_ptr != NULL)
84202980:	51 d8       	rMAC = M[FP + 40];
84202982:	03 60       	if EQ jump (m) Lc_build_mic_graph_add_output_subgraph_23;

84202984 <Lc_build_mic_graph_add_output_subgraph_22>:
    {
        /* mic sidetone path will be inserted
         * after this operator so it can do in-place
         * processing.
         */
        op_extra_data->mic_st_point = op_ptr;
84202984:	a6 f0 dc 8e 	M[r8 + 880] = r4;

84202988 <Lc_build_mic_graph_add_output_subgraph_23>:
    }

    /* add mute operator, it can be controlled by
     * message to the operator
     */
    op_ptr = create_mute_op(num_mics, &idxs[out_idx]);
84202988:	01 f8 d2 c8 	r0 = r6 LSHIFT 2;
8420298c:	43 d8       	r1 = M[FP + 32];
8420298e:	d3 00       	r1 = r0 + r1;
84202990:	4a 08       	r0 = r7 + Null;
84202992:	07 f0 21 e4 	call (m) $_create_mute_op;
84202996:	16 00       	r4 = r0 + Null;
    if(!op_ptr)
84202998:	ed 61       	if EQ jump (m) Lc_build_mic_graph_add_output_subgraph_20;

8420299a <Lc_build_mic_graph_add_output_subgraph_24>:
    {
        return FALSE;
    }
    cbops_append_operator_to_graph(mic_graph,op_ptr);
8420299a:	33 00       	r1 = r4 + Null;
8420299c:	5a 08       	r0 = r9 + Null;
8420299e:	ff fd a2 f0 	call (m) 0x16e96;
842029a2:	39 e7 
    op_extra_data->mic_mute_op = op_ptr;
842029a4:	a6 f0 9d 8e 	M[r8 + 628] = r4;
    /* apply user config to mute operator, we don't apply
     * ramping at the beginning, so user can mute right from
     * the beginning.
     */
    cbops_mute_enable(op_extra_data->mic_mute_op, op_extra_data->mic_mute_enable_config, TRUE);
842029a8:	44 20       	r2 = Null + 1;
842029aa:	a3 f0 de 88 	r1 = M[r8 + 888];
842029ae:	32 00       	r0 = r4 + Null;
842029b0:	03 f0 23 e4 	call (m) $_cbops_mute_enable;

    /* Insert latency operator */
    op_ptr = create_mic_latency_op(out_idx,&op_extra_data->sync_block);
842029b4:	a3 f0 14 22 	r1 = r8 + 532;
842029b8:	42 08       	r0 = r6 + Null;
842029ba:	ff fd 2c f1 	call (m) 0x2822e;
842029be:	35 e3 
    if(op_ptr == NULL)
842029c0:	10 04       	Null = r0 - Null;
842029c2:	d8 61       	if EQ jump (m) Lc_build_mic_graph_add_output_subgraph_20;

842029c4 <Lc_build_mic_graph_add_output_subgraph_25>:
    {
        return FALSE;
    }
    cbops_append_operator_to_graph(mic_graph,op_ptr);
842029c4:	13 00       	r1 = r0 + Null;
842029c6:	5a 08       	r0 = r9 + Null;
842029c8:	ff fd a2 f0 	call (m) 0x16e96;
842029cc:	2f e6 

    return TRUE;
842029ce:	42 20       	r0 = Null + 1;

842029d0 <Lc_build_mic_graph_add_output_subgraph_26>:
}
842029d0:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
842029d2:	d8 4c       	rts;

842029d4 <$_create_aec_ref_spkr_op>:

/*
 * create_insert_op
 */
cbops_op* create_aec_ref_spkr_op(unsigned nr_inputs,unsigned* input_idx, unsigned *interm_idxs, unsigned in_threshold,unsigned nr_outputs,unsigned* output_idx,unsigned out_threshold, unsigned max_jitter)
{
842029d4:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
842029d6:	10 09       	r6 = r0 + Null;
842029d8:	19 09       	r7 = r1 + Null;
842029da:	23 09       	r9 = r2 + Null;
842029dc:	2a 09       	r8 = r3 + Null;
842029de:	ff d9       	r5 = M[FP + -4];
    // cbop param struct size (header plus cbop-specific parameters)
    cbops_op *op = (cbops_op*)xzpmalloc(sizeof_cbops_op(cbops_aec_ref_op, nr_inputs, nr_outputs) +
                                        /* Extend for interim buffers' indexes */
                                        nr_inputs*sizeof(unsigned));
842029e0:	c3 20       	r1 = Null + 3;
842029e2:	00 f8 d2 d8 	r0 = r6 LSHIFT 1;
842029e6:	ba 00       	r0 = r5 + r0;
842029e8:	52 54       	r0 = r0 LSHIFT 2;
842029ea:	12 39       	r0 = r0 + 52;
842029ec:	ff fd 12 f0 	call (m) 0x4f2a;
842029f0:	3f e9 
842029f2:	16 00       	r4 = r0 + Null;
    if(op)
842029f4:	1e 60       	if EQ jump (m) Lc_create_aec_ref_spkr_op_3;

842029f6 <Lc_create_aec_ref_spkr_op_2>:
    {
        cbops_aec_ref_op *params;

        /* Setup Operator func table */
        op->function_vector    = cbops_aec_ref_spkr_table;
842029f6:	07 f0 01 f0 	rMAC = Null + 7340356;
842029fa:	44 41 
842029fc:	b1 8e       	M[r4 + 8] = rMAC;

        /* Setup cbop param struct header info */
        params = (cbops_aec_ref_op*)cbops_populate_param_hdr(op, nr_inputs, nr_outputs, input_idx, output_idx);
842029fe:	f1 d9       	rMAC = M[FP + -8];
84202a00:	09 1c       	pushm <rMAC>;
84202a02:	4d 08       	r3 = r7 + Null;
84202a04:	3c 00       	r2 = r5 + Null;
84202a06:	43 08       	r1 = r6 + Null;
84202a08:	ff fd a2 f0 	call (m) 0x16f30;
84202a0c:	29 e9 
84202a0e:	7f 4c       	SP = SP + -4;
84202a10:	17 00       	r5 = r0 + Null;

        /* Setup cbop-specific parameters - well, just one in this case. Just exemplifies using the
         * generic macro, but in this cbop's case we could get to the param location "directly"
         */
        params->in_threshold  = in_threshold;
84202a12:	7a f0 00 ee 	M[r5 + Null] = r8;
        params->max_advance   = out_threshold;
84202a16:	e9 d9       	rMAC = M[FP + -12];
84202a18:	79 8e       	M[r5 + 4] = rMAC;
        params->max_jitter   = max_jitter;
84202a1a:	e1 d9       	rMAC = M[FP + -16];
84202a1c:	b9 8f       	M[r5 + 24] = rMAC;

        /* copy intermediate idxs */
        memcpy(params->interm_idxs, interm_idxs, sizeof(unsigned)*nr_inputs);
84202a1e:	01 f8 d4 c8 	r2 = r6 LSHIFT 2;
84202a22:	3a 2b       	r0 = r5 + 28;
84202a24:	5b 08       	r1 = r9 + Null;
84202a26:	ff fd a3 f0 	call (m) 0x170b8;
84202a2a:	33 e4 

        params->buffer_adj = 3;
84202a2c:	c1 20       	rMAC = Null + 3;
84202a2e:	b9 8e       	M[r5 + 8] = rMAC;

84202a30 <Lc_create_aec_ref_spkr_op_3>:
    }

    return(op);
84202a30:	32 00       	r0 = r4 + Null;

84202a32 <Lc_create_aec_ref_spkr_op_4>:
}
84202a32:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84202a34:	d8 4c       	rts;

84202a36 <$_aec_reference_spkr_ttp_run>:
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 * \param error current TTP error in speaker path
 * \param max_to_process Pointer max amount of data available to process by speaker cbops
 */
void aec_reference_spkr_ttp_run(AEC_REFERENCE_OP_DATA  *op_extra_data, unsigned *max_to_process)
{
84202a36:	f5 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>, SP = SP + 0x10;
84202a38:	16 00       	r4 = r0 + Null;
84202a3a:	1a 09       	r8 = r1 + Null;
    TIME_INTERVAL error = 0;
84202a3c:	38 de       	M[FP + 28] = Null;
    bool error_valid;
    unsigned amount_can_process = *max_to_process;
84202a3e:	a8 f0 00 e8 	r6 = M[r8 + Null];
    /* only used for debug log */
    TIME current_time = hal_get_time();
84202a42:	ff fd 76 f1 	call (m) 0x317e8;
84202a46:	27 ed 
84202a48:	11 09       	r7 = r0 + Null;

    patch_fn_shared(aec_reference_run);

    /* calculate current TTP error */
    error_valid = aec_reference_spkr_ttp_get_error(op_extra_data, &error);
84202a4a:	c3 11       	r1 = FP + 28;
84202a4c:	32 00       	r0 = r4 + Null;
84202a4e:	9d 4e       	call (m) Lc_aec_reference_spkr_ttp_get_error_1;

    /* see if we have received void tags while in TTP mode */
    if(op_extra_data->spkr_void_tag_observed)
84202a50:	60 f0 b5 88 	Null = M[r4 + 724];
84202a54:	0b 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_run_4;

84202a56 <Lc_aec_reference_spkr_ttp_run_2>:
    {
        /* increment a counter, so this shows the time that we have
         * continuously seen void tag
         */
        op_extra_data->spkr_void_tag_counter++;
84202a56:	61 f0 b6 88 	rMAC = M[r4 + 728];
84202a5a:	49 20       	rMAC = rMAC + 1;
84202a5c:	61 f0 b6 8e 	M[r4 + 728] = rMAC;

        if(op_extra_data->spkr_void_tag_counter == SPKR_TTP_VOID_TAG_COOL_OFF_TIME_MS)
84202a60:	88 3c       	Null = rMAC - 50;
84202a62:	06 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_run_5;

84202a64 <Lc_aec_reference_spkr_ttp_run_3>:
             */

            /* error isn't valid anymore, only seeing a timestamp tag will
             * make it valid again
             */
            op_extra_data->spkr_last_timestamp_valid = FALSE;
84202a64:	60 f0 b4 8e 	M[r4 + 720] = Null;
84202a68:	74 6e       	jump (m) Lc_aec_reference_spkr_ttp_run_23;

84202a6a <Lc_aec_reference_spkr_ttp_run_4>:
            error_valid = FALSE;
        }
    }
    else
    {
        op_extra_data->spkr_void_tag_counter = 0;
84202a6a:	60 f0 b6 8e 	M[r4 + 728] = Null;

84202a6e <Lc_aec_reference_spkr_ttp_run_5>:
    }

    if(!error_valid)
84202a6e:	10 04       	Null = r0 - Null;
84202a70:	70 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_run_23;

84202a72 <Lc_aec_reference_spkr_ttp_run_6>:
    L2_DBG_MSG2("AEC REFERENCE SPEAKER: time=%d, ttp error=%d", current_time, error);
#endif

    /* See if the input is too late */
    if(error < -op_extra_data->spkr_error_threshold &&
       amount_can_process > 0)
84202a72:	39 d8       	rMAC = M[FP + 28];
84202a74:	62 f0 b7 88 	r0 = M[r4 + 732];
84202a78:	82 04       	r0 = Null - r0;
84202a7a:	88 04       	Null = rMAC - r0;
84202a7c:	30 66       	if GE jump (m) Lc_aec_reference_spkr_ttp_run_13;

84202a7e <Lc_aec_reference_spkr_ttp_run_7>:
84202a7e:	0f f8 00 c2 	Null = r6 - Null;
84202a82:	2d 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_run_13;

84202a84 <Lc_aec_reference_spkr_ttp_run_8>:
    {
        /* Calculate how many samples we are late,
         * we discard late samples, as much as available
         */
        unsigned samples_to_trash = convert_time_to_samples((unsigned)(-error), op_extra_data->input_rate);
84202a84:	63 f0 64 88 	r1 = M[r4 + 400];
84202a88:	42 04       	r0 = Null - rMAC;
84202a8a:	ff fd 97 f0 	call (m) 0x15932;
84202a8e:	29 e5 
84202a90:	13 00       	r1 = r0 + Null;

        /* limit to amount available */
        samples_to_trash = MIN(amount_can_process, samples_to_trash);
84202a92:	2f f8 00 c2 	Null = r6 - r0;
84202a96:	02 f0 e9 e0 	if C jump (m) Lc_aec_reference_spkr_ttp_run_15;

84202a9a <Lc_aec_reference_spkr_ttp_run_9>:
84202a9a:	43 08       	r1 = r6 + Null;

84202a9c <Lc_aec_reference_spkr_ttp_run_10>:

        if(samples_to_trash > 0)
        {
            /* We have something to trash */
            unsigned samples_trashed = aec_reference_spkr_ttp_discard_samples(op_extra_data,samples_to_trash);
84202a9c:	32 00       	r0 = r4 + Null;
84202a9e:	ff fd 2d f1 	call (m) 0x284f4;
84202aa2:	37 e2 
84202aa4:	17 00       	r5 = r0 + Null;
            L3_DBG_MSG3("AEC REFERENCE SPEAKER TTP - discard samples=%d, time =%d , error=%d",
                        samples_trashed, current_time, error);
84202aa6:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
84202aaa:	c8 24       	Null = rMAC - 3;
84202aac:	0a 68       	if LT jump (m) Lc_aec_reference_spkr_ttp_run_12;

84202aae <Lc_aec_reference_spkr_ttp_run_11>:
84202aae:	3d d8       	r3 = M[FP + 28];
84202ab0:	55 f1 02 f0 	r0 = Null + 357564977;
84202ab4:	31 42 
84202ab6:	4c 08       	r2 = r7 + Null;
84202ab8:	3b 00       	r1 = r5 + Null;
84202aba:	ef fd ef ff 	call (m) 0x9de;
84202abe:	25 e9 

84202ac0 <Lc_aec_reference_spkr_ttp_run_12>:

            /* some samples discarded, update error */
            error += convert_samples_to_time(samples_trashed, op_extra_data->input_rate);
84202ac0:	63 f0 64 88 	r1 = M[r4 + 400];
84202ac4:	3a 00       	r0 = r5 + Null;
84202ac6:	ff fd 97 f0 	call (m) 0x15914;
84202aca:	2f e2 
84202acc:	39 d8       	rMAC = M[FP + 28];
84202ace:	51 00       	rMAC = r0 + rMAC;
84202ad0:	39 de       	M[FP + 28] = rMAC;

            /* update amount left to process */
            amount_can_process -= samples_trashed;
84202ad2:	00 f7 38 c2 	r6 = r6 - r5;

            /* ttp play back needs resetting */
            aec_reference_spkr_ttp_reset(op_extra_data);
84202ad6:	32 00       	r0 = r4 + Null;
84202ad8:	01 f0 3b e4 	call (m) Lc_aec_reference_spkr_ttp_reset_1;

84202adc <Lc_aec_reference_spkr_ttp_run_13>:
        }
    }

    if (pl_abs_i32(error) < op_extra_data->spkr_error_threshold)
84202adc:	3a d8       	r0 = M[FP + 28];
84202ade:	61 f0 b7 88 	rMAC = M[r4 + 732];
84202ae2:	4f f2 42 ce 	r0 = ABS r0;
84202ae6:	50 04       	Null = r0 - rMAC;
84202ae8:	02 f0 9d e0 	if C jump (m) Lc_aec_reference_spkr_ttp_run_16;

84202aec <Lc_aec_reference_spkr_ttp_run_14>:
    {
        /* This is normal situation, we have on-time input
         * and we can control ttp error
         */
        aec_reference_spkr_ttp_error_control(op_extra_data, error);
84202aec:	3b d8       	r1 = M[FP + 28];
84202aee:	32 00       	r0 = r4 + Null;
84202af0:	01 f0 27 e5 	call (m) Lc_aec_reference_spkr_ttp_error_control_1;

        /* real audio is played, go to higher threshold */
        op_extra_data->spkr_error_threshold = SPKR_TTP_MAX_LATENCY_HIGH_THRESHOLD_US;
84202af4:	01 f0 d0 4b 	rMAC = Null + 2000;
84202af8:	61 f0 b7 8e 	M[r4 + 732] = rMAC;
84202afc:	28 6e       	jump (m) Lc_aec_reference_spkr_ttp_run_22;

84202afe <Lc_aec_reference_spkr_ttp_run_15>:
        unsigned samples_to_trash = convert_time_to_samples((unsigned)(-error), op_extra_data->input_rate);

        /* limit to amount available */
        samples_to_trash = MIN(amount_can_process, samples_to_trash);

        if(samples_to_trash > 0)
84202afe:	10 04       	Null = r0 - Null;
84202b00:	ce 63       	if NE jump (m) Lc_aec_reference_spkr_ttp_run_10;

84202b02 <Lc_4>:
84202b02:	ed 6f       	jump (m) Lc_aec_reference_spkr_ttp_run_13;

84202b04 <Lc_aec_reference_spkr_ttp_run_16>:
    {
        /* Input is early, so we cannot allow samples from input buffers to be played now
         * instead we need to insert silence until time to play has reached. Silence insertion
         * is managed by cbops, we only tell cbops not to use samples from input buffer.
         */
        unsigned samples_early = convert_time_to_samples((unsigned)(error), op_extra_data->input_rate);
84202b04:	63 f0 64 88 	r1 = M[r4 + 400];
84202b08:	3a d8       	r0 = M[FP + 28];
84202b0a:	ff fd 97 f0 	call (m) 0x15932;
84202b0e:	29 e1 
        if(samples_early >= op_extra_data->spkr_in_threshold)
84202b10:	63 f0 af 88 	r1 = M[r4 + 700];
84202b14:	d0 04       	Null = r0 - r1;
84202b16:	03 64       	if NC jump (m) Lc_aec_reference_spkr_ttp_run_18;

84202b18 <Lc_aec_reference_spkr_ttp_run_17>:
        {
            /* It's early more than the amount cbops is expected to copy,
             * so allow nothing to copy.
             */
            amount_can_process = 0;
84202b18:	00 09       	r6 = Null + Null;
84202b1a:	07 6e       	jump (m) Lc_aec_reference_spkr_ttp_run_20;

84202b1c <Lc_aec_reference_spkr_ttp_run_18>:
        {
            /* It's still early but less than the expected amount, we allow cbops to consume
             * expected amount less the amount early, silence insertion will be used for the amount early.
             * next time we expect to switch to normal TTP playback.
             */
            amount_can_process = MIN(op_extra_data->spkr_in_threshold - samples_early, amount_can_process);
84202b1c:	99 04       	rMAC = r1 - r0;
84202b1e:	8f f1 00 c2 	Null = rMAC - r6;
84202b22:	02 f0 87 e0 	if C jump (m) Lc_aec_reference_spkr_ttp_run_20;

84202b26 <Lc_aec_reference_spkr_ttp_run_19>:
84202b26:	08 09       	r6 = rMAC + Null;

84202b28 <Lc_aec_reference_spkr_ttp_run_20>:
        }

        /* We are not playing real audio, so keep the threshold low */
        op_extra_data->spkr_error_threshold = SPKR_TTP_MAX_LATENCY_LOW_THRESHOLD_US;
84202b28:	01 f0 fa 40 	rMAC = Null + 250;
84202b2c:	61 f0 b7 8e 	M[r4 + 732] = rMAC;

        L3_DBG_MSG3("AEC REFERENCE SPEAKER TTP: possible silence insertion: time=%d, samples=%d, max_proc=%d",
                    current_time, op_extra_data->spkr_in_threshold-amount_can_process, amount_can_process);
84202b30:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
84202b34:	c8 24       	Null = rMAC - 3;
84202b36:	0b 68       	if LT jump (m) Lc_aec_reference_spkr_ttp_run_22;

84202b38 <Lc_aec_reference_spkr_ttp_run_21>:
84202b38:	8f f3 04 c2 	r2 = r1 - r6;
84202b3c:	55 f1 02 f0 	r0 = Null + 357565045;
84202b40:	75 42 
84202b42:	45 08       	r3 = r6 + Null;
84202b44:	4b 08       	r1 = r7 + Null;
84202b46:	ef fd ef ff 	call (m) 0x9de;
84202b4a:	39 e4 

84202b4c <Lc_aec_reference_spkr_ttp_run_22>:

    }

    /* update amount to process */
    *max_to_process = amount_can_process;
84202b4c:	a8 f0 00 ee 	M[r8 + Null] = r6;

84202b50 <Lc_aec_reference_spkr_ttp_run_23>:
    return;
}
84202b50:	f5 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, rLink>;
84202b52:	d8 4c       	rts;

84202b54 <$_aec_reference_spkr_ttp_init>:
84202b54:	d8 4c       	rts;

84202b56 <$_aec_reference_spkr_ttp_update_last_timestamp>:
 *        stamp associated with last consumed sample.
 * \param op_extra_data pointer to AEC_REFERENCE_OP_DATA data
 * \param amount_read amount read from input buffer
 */
void aec_reference_spkr_ttp_update_last_timestamp(AEC_REFERENCE_OP_DATA   *op_extra_data, unsigned amount_read)
{
84202b56:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84202b58:	16 00       	r4 = r0 + Null;
84202b5a:	1a 00       	r0 = r1 + Null;
    if(op_extra_data->spkr_last_timestamp_valid)
84202b5c:	60 f0 b4 88 	Null = M[r4 + 720];
84202b60:	0b 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_update_last_timestamp_3;

84202b62 <Lc_aec_reference_spkr_ttp_update_last_timestamp_2>:
    {
        /* work out time stamp for next input block for the just read block,
         * TODO_AEC_REFERENCE_TTP: for further accuracy we could consider the tag sp_adjust as well */
        TIME_INTERVAL time_passed = convert_samples_to_time(amount_read, op_extra_data->input_rate);
84202b62:	63 f0 64 88 	r1 = M[r4 + 400];
84202b66:	ff fd 96 f0 	call (m) 0x15914;
84202b6a:	2f ed 
        op_extra_data->spkr_last_timestamp = time_add(op_extra_data->spkr_last_timestamp, time_passed);
84202b6c:	61 f0 b3 88 	rMAC = M[r4 + 716];
84202b70:	51 00       	rMAC = r0 + rMAC;
84202b72:	61 f0 b3 8e 	M[r4 + 716] = rMAC;

84202b76 <Lc_aec_reference_spkr_ttp_update_last_timestamp_3>:
    }
}
84202b76:	f1 48       	popm <FP, r4, rLink>;
84202b78:	d8 4c       	rts;

84202b7a <$_aec_reference_spkr_ttp_terminate>:
 */
void aec_reference_spkr_ttp_terminate(AEC_REFERENCE_OP_DATA  *op_extra_data)
{
    patch_fn_shared(aec_reference);

    op_extra_data->spkr_timed_playback_mode = FALSE;
84202b7a:	20 f0 b2 8e 	M[r0 + 712] = Null;
    op_extra_data->spkr_last_timestamp_valid = 0;
84202b7e:	20 f0 b4 8e 	M[r0 + 720] = Null;
    op_extra_data->spkr_void_tag_counter = 0;
84202b82:	20 f0 b6 8e 	M[r0 + 728] = Null;

84202b86 <Lc_aec_reference_spkr_ttp_terminate_2>:
84202b86:	d8 4c       	rts;

84202b88 <Lc_aec_reference_spkr_ttp_get_error_1>:
 *        and (estimated) actual playback time. So the error will be
 *        positive if ttp is later than actual playback time.
 * return whether the error is valid
 */
static bool aec_reference_spkr_ttp_get_error(AEC_REFERENCE_OP_DATA *op_extra_data, TIME_INTERVAL *error)
{
84202b88:	f4 1d       	pushm <FP(=SP), r4, r5, r6, r7, rLink>, SP = SP + 0x10;
84202b8a:	16 00       	r4 = r0 + Null;
84202b8c:	18 09       	r6 = r1 + Null;
    /* see if we have valid metadata buffer */
    tCbuffer *met_buf = op_extra_data->spkr_input_metadata_buffer;
    patch_fn_shared(aec_reference_run);

    if (met_buf!= NULL && buff_has_metadata(met_buf))
84202b8e:	62 f0 c9 88 	r0 = M[r4 + 804];
84202b92:	97 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_24;

84202b94 <Lc_aec_reference_spkr_ttp_get_error_2>:
84202b94:	51 89       	rMAC = M[r0 + 20];
84202b96:	49 c6       	rMAC = rMAC AND 0x8000;
84202b98:	94 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_24;

84202b9a <Lc_aec_reference_spkr_ttp_get_error_3>:
    {
        /* see if input has a timestamped tag */
        unsigned b4idx = 0;
84202b9a:	30 de       	M[FP + 24] = Null;
        metadata_tag *mtag = buff_metadata_peek_ex(met_buf, &b4idx);
84202b9c:	83 11       	r1 = FP + 24;
84202b9e:	ff fd 78 f0 	call (m) 0x11cd8;
84202ba2:	3b e9 
84202ba4:	17 00       	r5 = r0 + Null;

        if(mtag != NULL)
84202ba6:	5f 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_19;

84202ba8 <Lc_aec_reference_spkr_ttp_get_error_4>:
        {
            if(IS_TIMESTAMPED_TAG(mtag))
84202ba8:	79 88       	rMAC = M[r5 + 4];
84202baa:	12 f0 30 00 	r0 = rMAC AND 0x30;
84202bae:	4e 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_15;

84202bb0 <Lc_aec_reference_spkr_ttp_get_error_5>:
84202bb0:	ca c2       	r0 = rMAC AND 0x40;
84202bb2:	4c 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_get_error_15;

84202bb4 <Lc_aec_reference_spkr_ttp_get_error_6>:
            {
                unsigned *err_offset_id;
                unsigned out_length;

                /* go back to first input sample */
                TIME_INTERVAL time_back = convert_samples_to_time(b4idx / OCTETS_PER_SAMPLE, op_extra_data->input_rate);
84202bb4:	63 f0 64 88 	r1 = M[r4 + 400];
84202bb8:	32 d8       	r0 = M[FP + 24];
84202bba:	52 50       	r0 = r0 LSHIFT -2;
84202bbc:	ff fd 96 f0 	call (m) 0x15914;
84202bc0:	39 ea 

                /* set the time stamp,
                 * TODO_AEC_REFERENCE_TTP: for further accuracy we could consider the tag sp_adjust as well */
                op_extra_data->spkr_last_timestamp = time_sub(mtag->timestamp, time_back);
84202bc2:	39 89       	rMAC = M[r5 + 16];
84202bc4:	89 04       	rMAC = rMAC - r0;
84202bc6:	61 f0 b3 8e 	M[r4 + 716] = rMAC;

                /* See if tag's timestamp has an offset*/
                if (buff_metadata_find_private_data(mtag, META_PRIV_KEY_TTP_OFFSET, &out_length,
                                                    (void **)&err_offset_id))
84202bca:	c5 11       	r3 = FP + 28;
84202bcc:	04 12       	r2 = FP + 32;
84202bce:	43 20       	r1 = Null + 1;
84202bd0:	3a 00       	r0 = r5 + Null;
84202bd2:	ff fd 77 f0 	call (m) 0x11a84;
84202bd6:	33 e5 
84202bd8:	10 04       	Null = r0 - Null;
84202bda:	0e 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_9;

84202bdc <Lc_aec_reference_spkr_ttp_get_error_7>:
                {
                    int *err_offset_ptr = ttp_info_get(*err_offset_id);
84202bdc:	39 d8       	rMAC = M[FP + 28];
84202bde:	0a e8       	r0 = M[rMAC + Null];
84202be0:	ff fd 9f f0 	call (m) 0x16bb8;
84202be4:	39 ee 
                    if (err_offset_ptr != NULL)
84202be6:	10 04       	Null = r0 - Null;
84202be8:	07 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_9;

84202bea <Lc_aec_reference_spkr_ttp_get_error_8>:
                    {
                        /* subtract the offset */
                        op_extra_data->spkr_last_timestamp =
                            time_sub(op_extra_data->spkr_last_timestamp, *err_offset_ptr);
84202bea:	61 f0 b3 88 	rMAC = M[r4 + 716];
84202bee:	12 e8       	r0 = M[r0 + Null];
84202bf0:	89 04       	rMAC = rMAC - r0;
84202bf2:	61 f0 b3 8e 	M[r4 + 716] = rMAC;

84202bf6 <Lc_aec_reference_spkr_ttp_get_error_9>:
                    }
                }

                /* this will stay valid */
                op_extra_data->spkr_last_timestamp_valid = TRUE;
84202bf6:	41 20       	rMAC = Null + 1;
84202bf8:	61 f0 b4 8e 	M[r4 + 720] = rMAC;

                /* switch to timed playback mode if not already,
                 * this is irreversible
                 */
                if(!op_extra_data->spkr_timed_playback_mode)
84202bfc:	60 f0 b2 88 	Null = M[r4 + 712];
84202c00:	1b 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_get_error_12;

84202c02 <Lc_aec_reference_spkr_ttp_get_error_10>:
                    /* For the first time we have seen a timestamp,
                     * This means the metadata buffer will supply timestamp tags
                     * that are required for timed playback. Now is the time to
                     * switch to timed playback mode for speaker graph.
                     */
                    op_extra_data->spkr_timed_playback_mode = aec_reference_spkr_ttp_setup_timed_playback(op_extra_data);
84202c02:	32 00       	r0 = r4 + Null;
84202c04:	61 4e       	call (m) Lc_aec_reference_spkr_ttp_setup_timed_playback_1;
84202c06:	62 f0 b2 8e 	M[r4 + 712] = r0;
                    if(op_extra_data->spkr_timed_playback_mode)
84202c0a:	60 f0 b2 88 	Null = M[r4 + 712];
84202c0e:	14 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_12;

84202c10 <Lc_aec_reference_spkr_ttp_get_error_11>:
                        /* tell the endpoint that speaker is performing rate adjustment, normally
                         * this is done when enacting config is received from framework, however
                         * in case we haven't received (can happen if input is coming from a2dp
                         * source) we do it here.
                         */
                        set_override_ep_ratematch_enacting(op_extra_data->spkr_endpoint, TRUE);
84202c10:	43 20       	r1 = Null + 1;
84202c12:	62 f0 80 88 	r0 = M[r4 + 512];
84202c16:	ff fd 0f f0 	call (m) 0x4a3e;
84202c1a:	29 e1 

                        /* tell the overridden endpoint that we are in timed playback mode,
                         * this is to prevent extra accumulation of HW warps in endpoint so it
                         * won't mess with PID controller. (only nedded for hw rate adjust)
                         */
                        set_override_ep_set_hw_warp_apply_mode(op_extra_data->spkr_endpoint, TRUE);
84202c1c:	43 20       	r1 = Null + 1;
84202c1e:	62 f0 80 88 	r0 = M[r4 + 512];
84202c22:	02 f0 31 ed 	call (m) $_set_override_ep_set_hw_warp_apply_mode;

                        L2_DBG_MSG1("AEC REFERENCE: Speaker graph switched to timed play back mode: %d",
                                    op_extra_data->spkr_timed_playback_mode);
84202c26:	63 f0 b2 88 	r1 = M[r4 + 712];
84202c2a:	55 f1 02 f0 	r0 = Null + 357565133;
84202c2e:	cd 42 
84202c30:	ef fd ee ff 	call (m) 0x9b4;
84202c34:	25 ec 

84202c36 <Lc_aec_reference_spkr_ttp_get_error_12>:
                    {
                        /* can't do anything except to retry later */
                    }
                }

                if(op_extra_data->spkr_void_tag_observed)
84202c36:	60 f0 b5 88 	Null = M[r4 + 724];
84202c3a:	05 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_14;

84202c3c <Lc_aec_reference_spkr_ttp_get_error_13>:
                     * in case that happen, we switch to lower threshold so extra latency will
                     * be discarded immediately. It will quickly go back
                     * to normal threshold.
                     */
                    op_extra_data->spkr_error_threshold =
                        SPKR_TTP_MAX_LATENCY_LOW_THRESHOLD_US;
84202c3c:	01 f0 fa 40 	rMAC = Null + 250;
84202c40:	61 f0 b7 8e 	M[r4 + 732] = rMAC;

84202c44 <Lc_aec_reference_spkr_ttp_get_error_14>:
#endif
                }

                /* void tag not seen */
                op_extra_data->spkr_void_tag_observed = FALSE;
84202c44:	60 f0 b5 8e 	M[r4 + 724] = Null;
84202c48:	0e 6e       	jump (m) Lc_aec_reference_spkr_ttp_get_error_19;

84202c4a <Lc_aec_reference_spkr_ttp_get_error_15>:

            } /* IS_TIMESTAMPED_TAG(mtag) */
            else if(IS_VOID_TTP_TAG(mtag) && op_extra_data->spkr_timed_playback_mode)
84202c4a:	11 f0 70 00 	rMAC = rMAC AND 0x70;
84202c4e:	10 f0 50 24 	Null = rMAC - 80;
84202c52:	09 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_get_error_19;

84202c54 <Lc_aec_reference_spkr_ttp_get_error_16>:
84202c54:	38 89       	Null = M[r5 + 16];
84202c56:	07 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_get_error_19;

84202c58 <Lc_aec_reference_spkr_ttp_get_error_17>:
84202c58:	60 f0 b2 88 	Null = M[r4 + 712];
84202c5c:	04 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_19;

84202c5e <Lc_aec_reference_spkr_ttp_get_error_18>:
                if(!op_extra_data->spkr_void_tag_observed)
                {
                    L2_DBG_MSG1("AEC REFERENCE, started seeing VOID tags, time=%d", hal_get_time());
                }
#endif
                op_extra_data->spkr_void_tag_observed = TRUE;
84202c5e:	41 20       	rMAC = Null + 1;
84202c60:	61 f0 b5 8e 	M[r4 + 724] = rMAC;

84202c64 <Lc_aec_reference_spkr_ttp_get_error_19>:
            }
        } /* if(mtag != NULL) */

        if(op_extra_data->spkr_last_timestamp_valid)
84202c64:	60 f0 b4 88 	Null = M[r4 + 720];
84202c68:	29 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_23;

84202c6a <Lc_aec_reference_spkr_ttp_get_error_20>:
             *
             * TODO_AEC_REFERENCE_TTP: since the task for speaker graph is timer based, the time
             * of sampling isn't aligned with the output consuming time, so it
             * could have up to one sample period random jitter.
             */
            TIME cur_time = hal_get_time();
84202c6a:	ff fd 75 f1 	call (m) 0x317e8;
84202c6e:	3f eb 
84202c70:	17 00       	r5 = r0 + Null;
            unsigned amount_in_output = cbuffer_calc_amount_data_in_words(op_extra_data->output_stream[AEC_REF_SPKR_TERMINAL1]);
84202c72:	72 a8       	r0 = M[r4 + 68];
84202c74:	ff fd 4a f1 	call (m) 0x2c208;
84202c78:	35 ec 
            TIME_INTERVAL offset = convert_samples_to_time(amount_in_output, op_extra_data->spkr_rate);
84202c7a:	63 f0 6e 88 	r1 = M[r4 + 440];
84202c7e:	ff fd 96 f0 	call (m) 0x15914;
84202c82:	37 e4 
84202c84:	11 09       	r7 = r0 + Null;
84202c86:	49 08       	rMAC = r7 + Null;

            /* if we have SW rate adjustment in the graph */
            if(op_extra_data->spkr_sw_rateadj_op != NULL)
84202c88:	62 f0 7e 88 	r0 = M[r4 + 504];
84202c8c:	0f 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_22;

84202c8e <Lc_aec_reference_spkr_ttp_get_error_21>:
            {
                /* adjust for the phase difference between first input and first output sample */
                offset -= (int)frac_mult(SECOND, (int)cbops_sra_get_phase(op_extra_data->spkr_sw_rateadj_op)) / (int) op_extra_data->spkr_rate;
84202c8e:	ff fd a0 f0 	call (m) 0x16d48;
84202c92:	3b e5 
84202c94:	00 f0 a3 f7 	r1 = Null + 1000000;
84202c98:	40 42 
84202c9a:	61 f0 6e 88 	rMAC = M[r4 + 440];
84202c9e:	2f f3 42 c9 	r0 = r1 * r0 (frac);
84202ca2:	8a 4c       	Div = r0 / rMAC;
84202ca4:	c1 4c       	rMAC = DivResult;
84202ca6:	1f f9 01 c2 	rMAC = r7 - rMAC;

84202caa <Lc_aec_reference_spkr_ttp_get_error_22>:
            /* Add extra delay that might occur in the path
             * (adjustment for any resampler, HW rate matching,
             *  cbops algorithmic delays and any external delay)
             * TODO_AEC_REFERENCE_TTP: spkr_extra_delay isn't set yet
             */
            offset += op_extra_data->spkr_extra_delay;
84202caa:	62 f0 bb 88 	r0 = M[r4 + 748];
84202cae:	51 00       	rMAC = r0 + rMAC;

            /* compute error */
            *error = time_sub(op_extra_data->spkr_last_timestamp, cur_time) - offset;
84202cb0:	62 f0 b3 88 	r0 = M[r4 + 716];
84202cb4:	d2 05       	r0 = r0 - r5;
84202cb6:	1f f2 88 c3 	M[r6] = r0 - rMAC;

84202cba <Lc_aec_reference_spkr_ttp_get_error_23>:
        }

        return op_extra_data->spkr_last_timestamp_valid;
84202cba:	62 f0 b4 88 	r0 = M[r4 + 720];
84202cbe:	02 6e       	jump (m) Lc_aec_reference_spkr_ttp_get_error_25;

84202cc0 <Lc_aec_reference_spkr_ttp_get_error_24>:
    } /* buff_has_metadata  */

    /* always return invalid error if we don't have metadata buffer */
    return FALSE;
84202cc0:	02 00       	r0 = Null + Null;

84202cc2 <Lc_aec_reference_spkr_ttp_get_error_25>:
}
84202cc2:	f4 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, rLink>;
84202cc4:	d8 4c       	rts;

84202cc6 <Lc_aec_reference_spkr_ttp_setup_timed_playback_1>:
 *
 * \param op_extra_data pointer to AEC_REFERENCE_OP_DATA data
 * return TRUE if setting up was successful else FALSE.
 */
static bool aec_reference_spkr_ttp_setup_timed_playback(AEC_REFERENCE_OP_DATA *op_extra_data)
{
84202cc6:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84202cc8:	16 00       	r4 = r0 + Null;
    patch_fn_shared(aec_reference);

    /* initialise pid controller parameters */
    timed_set_pid_controller_default_settings(&op_extra_data->spkr_pid_params);
84202cca:	62 f0 f4 22 	r0 = r4 + 756;
84202cce:	ff fd 94 f0 	call (m) 0x1557c;
84202cd2:	2f e5 



    /* reset speaker ttp control */
    aec_reference_spkr_ttp_reset(op_extra_data);
84202cd4:	32 00       	r0 = r4 + Null;
84202cd6:	4e 4e       	call (m) Lc_aec_reference_spkr_ttp_reset_1;

    /* use ttp SW rate adjust if speaker is capable */
    if(op_extra_data->spkr_rate_ability == RATEMATCHING_SUPPORT_HW)
84202cd8:	61 f0 6f 88 	rMAC = M[r4 + 444];
84202cdc:	88 24       	Null = rMAC - 2;
84202cde:	17 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_setup_timed_playback_6;

84202ce0 <Lc_aec_reference_spkr_ttp_setup_timed_playback_2>:
    {
        op_extra_data->spkr_ttp_adjust_type = RATEMATCHING_SUPPORT_HW;
84202ce0:	81 20       	rMAC = Null + 2;
84202ce2:	61 f0 bc 8e 	M[r4 + 752] = rMAC;

        /* we want to do HW rate matching in timed playback mode */
        if(op_extra_data->spkr_sw_rateadj_op != NULL)
84202ce6:	62 f0 7e 88 	r0 = M[r4 + 504];
84202cea:	05 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_setup_timed_playback_4;

84202cec <Lc_aec_reference_spkr_ttp_setup_timed_playback_3>:
        {
            /* if we have SW rate adjust, then set it to pass-through mode */
            cbops_rateadjust_passthrough_mode(op_extra_data->spkr_sw_rateadj_op, TRUE);
84202cec:	43 20       	r1 = Null + 1;
84202cee:	ff fd 9f f0 	call (m) 0x16c96;
84202cf2:	29 ed 

84202cf4 <Lc_aec_reference_spkr_ttp_setup_timed_playback_4>:
        }

        /* fresh start from 0 warp value */
        set_override_ep_ratematch_adjustment(op_extra_data->spkr_endpoint, 0);
84202cf4:	62 f0 80 88 	r0 = M[r4 + 512];
84202cf8:	03 00       	r1 = Null + Null;
84202cfa:	ff fd 0e f0 	call (m) 0x4aa0;
84202cfe:	27 ed 

84202d00 <Lc_aec_reference_spkr_ttp_setup_timed_playback_5>:
         */
        return FALSE;
    }

	/* even if we aren't told, speaker graph is enacting */
	op_extra_data->spkr_rate_enactment = op_extra_data->spkr_rate_ability;
84202d00:	61 f0 6f 88 	rMAC = M[r4 + 444];
84202d04:	61 f0 71 8e 	M[r4 + 452] = rMAC;

    return TRUE;
84202d08:	42 20       	r0 = Null + 1;
84202d0a:	32 6e       	jump (m) Lc_aec_reference_spkr_ttp_setup_timed_playback_12;

84202d0c <Lc_aec_reference_spkr_ttp_setup_timed_playback_6>:

        /* fresh start from 0 warp value */
        set_override_ep_ratematch_adjustment(op_extra_data->spkr_endpoint, 0);
    }
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
    else if(0 != op_extra_data->spkr_ext_rate_adjust_op)
84202d0c:	62 f0 ae 88 	r0 = M[r4 + 696];
84202d10:	19 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_setup_timed_playback_9;

84202d12 <Lc_aec_reference_spkr_ttp_setup_timed_playback_7>:
    {
        /* we will do software TTP using a standalone rate adjust operator */
        op_extra_data->spkr_ttp_adjust_type = RATEMATCHING_SUPPORT_SW;
84202d12:	41 20       	rMAC = Null + 1;
84202d14:	61 f0 bc 8e 	M[r4 + 752] = rMAC;
        op_extra_data->spkr_rate_adjustment = 0;
84202d18:	60 f0 70 8e 	M[r4 + 448] = Null;

        /* reset the current rate */
        stream_delegate_rate_adjust_set_current_rate(op_extra_data->spkr_ext_rate_adjust_op, 0);
84202d1c:	03 00       	r1 = Null + Null;
84202d1e:	02 f0 39 e9 	call (m) $_stream_delegate_rate_adjust_set_current_rate;

        /* not in passthrough mode */
        stream_delegate_rate_adjust_set_passthrough_mode(op_extra_data->spkr_ext_rate_adjust_op, FALSE);
84202d22:	62 f0 ae 88 	r0 = M[r4 + 696];
84202d26:	03 00       	r1 = Null + Null;
84202d28:	02 f0 27 e8 	call (m) $_stream_delegate_rate_adjust_set_passthrough_mode;

        /* we shouldn't have created built-in rate adjust operator */
        PL_ASSERT(op_extra_data->spkr_sw_rateadj_op == NULL);
84202d2c:	61 f0 7e 88 	rMAC = M[r4 + 504];
84202d30:	e8 61       	if EQ jump (m) Lc_aec_reference_spkr_ttp_setup_timed_playback_5;

84202d32 <Lc_aec_reference_spkr_ttp_setup_timed_playback_8>:
84202d32:	03 f0 06 42 	r1 = Null + 518;
84202d36:	02 f0 13 60 	r0 = Null + 4115;
84202d3a:	ff fd 88 f0 	call (m) 0x13f12;
84202d3e:	39 ee 
84202d40:	17 6e       	jump (m) Lc_aec_reference_spkr_ttp_setup_timed_playback_12;

84202d42 <Lc_aec_reference_spkr_ttp_setup_timed_playback_9>:
    }
#endif /* INSTALL_DELEGATE_RATE_ADJUST_SUPPORT */
    else if(op_extra_data->spkr_sw_rateadj_op != NULL)
84202d42:	62 f0 7e 88 	r0 = M[r4 + 504];
84202d46:	13 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_setup_timed_playback_11;

84202d48 <Lc_aec_reference_spkr_ttp_setup_timed_playback_10>:
    {
        /* We have a rate adjust operator, so we can do software TTP */
        op_extra_data->spkr_ttp_adjust_type = RATEMATCHING_SUPPORT_SW;
84202d48:	41 20       	rMAC = Null + 1;
84202d4a:	61 f0 bc 8e 	M[r4 + 752] = rMAC;
        op_extra_data->spkr_rate_adjustment=0;
84202d4e:	60 f0 70 8e 	M[r4 + 448] = Null;
        cbops_sra_set_rate_adjust(op_extra_data->spkr_sw_rateadj_op, op_extra_data->num_spkr_channels, 0);
84202d52:	63 f0 77 88 	r1 = M[r4 + 476];
84202d56:	04 00       	r2 = Null + Null;
84202d58:	ff fd 9f f0 	call (m) 0x16c9c;
84202d5c:	25 ea 
		/* force coming out of pass-through mode */
        cbops_rateadjust_passthrough_mode(op_extra_data->spkr_sw_rateadj_op, FALSE);
84202d5e:	62 f0 7e 88 	r0 = M[r4 + 504];
84202d62:	03 00       	r1 = Null + Null;
84202d64:	ff fd 9f f0 	call (m) 0x16c96;
84202d68:	33 e9 
84202d6a:	cb 6f       	jump (m) Lc_aec_reference_spkr_ttp_setup_timed_playback_5;

84202d6c <Lc_aec_reference_spkr_ttp_setup_timed_playback_11>:
    else
    {
        /* For doing TTP playback either it should support HW rate adjustment
         * or have a SW rate adjust operator in the graph.
         */
        return FALSE;
84202d6c:	02 00       	r0 = Null + Null;

84202d6e <Lc_aec_reference_spkr_ttp_setup_timed_playback_12>:

	/* even if we aren't told, speaker graph is enacting */
	op_extra_data->spkr_rate_enactment = op_extra_data->spkr_rate_ability;

    return TRUE;
}
84202d6e:	f1 48       	popm <FP, r4, rLink>;
84202d70:	d8 4c       	rts;

84202d72 <Lc_aec_reference_spkr_ttp_reset_1>:
 * \brief reset timed playback mode internal state
 * \param op_extra_data pointer to AEC_REFERENCE_OP_DATA data
 * \param error difference between expected ttp and now
 */
static void aec_reference_spkr_ttp_reset(AEC_REFERENCE_OP_DATA *op_extra_data)
{
84202d72:	c8 1c       	pushm <FP(=SP), rLink>;
    patch_fn_shared(aec_reference);

    op_extra_data->spkr_ttp_error_acc = 0;
84202d74:	20 f0 b9 8e 	M[r0 + 740] = Null;
    op_extra_data->spkr_ttp_error_acc_cnt = 0;
84202d78:	20 f0 ba 8e 	M[r0 + 744] = Null;
    op_extra_data->spkr_last_ttp_error = 0;
84202d7c:	20 f0 b8 8e 	M[r0 + 736] = Null;
    op_extra_data->spkr_error_threshold = SPKR_TTP_MAX_LATENCY_LOW_THRESHOLD_US;
84202d80:	01 f0 fa 40 	rMAC = Null + 250;
84202d84:	21 f0 b7 8e 	M[r0 + 732] = rMAC;

    /* pid controller will be started */
    timed_reset_pid_controller(&op_extra_data->spkr_pid_state);
84202d88:	02 f0 08 47 	r0 = r0 + 776;
84202d8c:	ff fd 93 f0 	call (m) 0x15562;
84202d90:	37 ee 

84202d92 <Lc_aec_reference_spkr_ttp_reset_2>:
}
84202d92:	c8 48       	popm <FP, rLink>;
84202d94:	d8 4c       	rts;

84202d96 <Lc_aec_reference_spkr_ttp_error_control_1>:
 * \brief running PID controller to minimise the ttp error
 * \param pointer to AEC_REFERENCE_OP_DATA data
 * \param error difference between expected and estimated time to play
 */
static void aec_reference_spkr_ttp_error_control(AEC_REFERENCE_OP_DATA *op_extra_data, TIME_INTERVAL error)
{
84202d96:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84202d98:	16 00       	r4 = r0 + Null;
    int error_diff;
    patch_fn_shared(aec_reference);

    /* ignore the error if we have a big jump in error */
    error_diff = error - op_extra_data->spkr_last_ttp_error;
84202d9a:	61 f0 b8 88 	rMAC = M[r4 + 736];
84202d9e:	5a 04       	r0 = r1 - rMAC;
    op_extra_data->spkr_last_ttp_error = error;
84202da0:	63 f0 b8 8e 	M[r4 + 736] = r1;
    if (pl_abs_i32(error_diff) > SPKR_TTP_MAX_ERROR_JUMP_US)
84202da4:	4f f2 42 ce 	r0 = ABS r0;
84202da8:	90 3c       	Null = r0 - 50;
84202daa:	08 f0 c5 e0 	if HI jump (m) Lc_aec_reference_spkr_ttp_error_control_4;

84202dae <Lc_aec_reference_spkr_ttp_error_control_2>:
    {
        return;
    }

    /* accumulate error for averaging */
    op_extra_data->spkr_ttp_error_acc_cnt++;
84202dae:	61 f0 ba 88 	rMAC = M[r4 + 744];
84202db2:	49 20       	rMAC = rMAC + 1;
84202db4:	61 f0 ba 8e 	M[r4 + 744] = rMAC;
    op_extra_data->spkr_ttp_error_acc += error;
84202db8:	62 f0 b9 88 	r0 = M[r4 + 740];
84202dbc:	9a 00       	r0 = r1 + r0;
84202dbe:	62 f0 b9 8e 	M[r4 + 740] = r0;
    if(op_extra_data->spkr_ttp_error_acc_cnt == SPKR_TTP_ERROR_AVERAGING_PERIOD_MS)
84202dc2:	88 26       	Null = rMAC - 10;
84202dc4:	15 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_error_control_4;

84202dc6 <Lc_aec_reference_spkr_ttp_error_control_3>:
    {
        /* calculate average error */
        int error_avg = frac_mult(op_extra_data->spkr_ttp_error_acc,
                                  FRACTIONAL(1.0/SPKR_TTP_ERROR_AVERAGING_PERIOD_MS));
84202dc6:	cc f0 63 f6 	r1 = Null + 214748364;
84202dca:	cc 58 
84202dcc:	3f f2 44 c9 	r2 = r0 * r1 (frac);

        /* run controller to minimise the error */
        timed_run_pid_controller(&op_extra_data->spkr_pid_state, &op_extra_data->spkr_pid_params, error_avg);
84202dd0:	63 f0 f4 22 	r1 = r4 + 756;
84202dd4:	62 f0 08 23 	r0 = r4 + 776;
84202dd8:	ff fd 93 f0 	call (m) 0x15484;
84202ddc:	2d e5 
                    hal_get_time(),
                    error_avg,
                    op_extra_data->spkr_pid_state.warp);
#endif
        /* apply the last calculated warp rate */
        aec_reference_spkr_ttp_adjust_rate(op_extra_data, op_extra_data->spkr_pid_state.warp);         /* reset the averaging accumulator */
84202dde:	63 f0 c2 88 	r1 = M[r4 + 776];
84202de2:	32 00       	r0 = r4 + Null;
84202de4:	07 4e       	call (m) Lc_aec_reference_spkr_ttp_adjust_rate_1;

        op_extra_data->spkr_ttp_error_acc_cnt = 0;
84202de6:	60 f0 ba 8e 	M[r4 + 744] = Null;
        op_extra_data->spkr_ttp_error_acc = 0;
84202dea:	60 f0 b9 8e 	M[r4 + 740] = Null;

84202dee <Lc_aec_reference_spkr_ttp_error_control_4>:
    }
}
84202dee:	f1 48       	popm <FP, r4, rLink>;
84202df0:	d8 4c       	rts;

84202df2 <Lc_aec_reference_spkr_ttp_adjust_rate_1>:
 * \brief applies warp rate to enacting sra
 * \param pointer to AEC_REFERENCE_OP_DATA data
 * \param warp warp value
 */
static void aec_reference_spkr_ttp_adjust_rate(AEC_REFERENCE_OP_DATA *op_extra_data, int warp)
{
84202df2:	c8 1c       	pushm <FP(=SP), rLink>;
84202df4:	1c 00       	r2 = r1 + Null;
    patch_fn_shared(aec_reference);

    /* expect to come here only in timed playback mode */
    PL_ASSERT(op_extra_data->spkr_timed_playback_mode);
84202df6:	20 f0 b2 88 	Null = M[r0 + 712];
84202dfa:	09 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_adjust_rate_3;

84202dfc <Lc_aec_reference_spkr_ttp_adjust_rate_2>:
84202dfc:	03 f0 6b 42 	r1 = Null + 619;
84202e00:	02 f0 13 60 	r0 = Null + 4115;
84202e04:	ff fd 88 f0 	call (m) 0x13f12;
84202e08:	2f e8 
84202e0a:	1b 6e       	jump (m) Lc_aec_reference_spkr_ttp_adjust_rate_9;

84202e0c <Lc_aec_reference_spkr_ttp_adjust_rate_3>:

    if(op_extra_data->spkr_ttp_adjust_type == RATEMATCHING_SUPPORT_HW)
84202e0c:	21 f0 bc 88 	rMAC = M[r0 + 752];
84202e10:	88 24       	Null = rMAC - 2;
84202e12:	07 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_adjust_rate_5;

84202e14 <Lc_aec_reference_spkr_ttp_adjust_rate_4>:
    {
        /* set the HW warp value by sending that to real audio ep
         * NOTE TODO_AEC_REFERENCE_TTP: HW warp hasn't been tested */
        set_override_ep_ratematch_adjustment(op_extra_data->spkr_endpoint, warp);
84202e14:	22 f0 80 88 	r0 = M[r0 + 512];
84202e18:	ff fd 0e f0 	call (m) 0x4aa0;
84202e1c:	29 e4 
84202e1e:	11 6e       	jump (m) Lc_aec_reference_spkr_ttp_adjust_rate_9;

84202e20 <Lc_aec_reference_spkr_ttp_adjust_rate_5>:
    }
    else if(op_extra_data->spkr_ttp_adjust_type == RATEMATCHING_SUPPORT_SW)
84202e20:	48 24       	Null = rMAC - 1;
84202e22:	0f 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_adjust_rate_9;

84202e24 <Lc_aec_reference_spkr_ttp_adjust_rate_6>:
    {
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
        if(0 != op_extra_data->spkr_ext_rate_adjust_op)
84202e24:	21 f0 ae 88 	rMAC = M[r0 + 696];
84202e28:	05 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_adjust_rate_8;

84202e2a <Lc_aec_reference_spkr_ttp_adjust_rate_7>:
        {
            /* rate adjust using external rate adjust operator */
            stream_delegate_rate_adjust_set_current_rate(op_extra_data->spkr_ext_rate_adjust_op, warp);
84202e2a:	0a 00       	r0 = rMAC + Null;
84202e2c:	02 f0 2b e1 	call (m) $_stream_delegate_rate_adjust_set_current_rate;
84202e30:	08 6e       	jump (m) Lc_aec_reference_spkr_ttp_adjust_rate_9;

84202e32 <Lc_aec_reference_spkr_ttp_adjust_rate_8>:
        }
        else
#endif /* INSTALL_DELEGATE_RATE_ADJUST_SUPPORT */
        {
            /* set the SW rate adjust warp value */
            cbops_sra_set_rate_adjust(op_extra_data->spkr_sw_rateadj_op, op_extra_data->num_spkr_channels, warp);
84202e32:	23 f0 77 88 	r1 = M[r0 + 476];
84202e36:	22 f0 7e 88 	r0 = M[r0 + 504];
84202e3a:	ff fd 9f f0 	call (m) 0x16c9c;
84202e3e:	23 e3 

84202e40 <Lc_aec_reference_spkr_ttp_adjust_rate_9>:
        }
    }
}
84202e40:	c8 48       	popm <FP, rLink>;
84202e42:	d8 4c       	rts;

84202e44 <$_create_aec_ref_sidetone_op>:
                                     unsigned nr_spkrs,
                                     unsigned *sidetone_idx,
                                     unsigned spkr_threshold,
                                     unsigned safety_threshold)

{
84202e44:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
84202e46:	13 09       	r9 = r0 + Null;
84202e48:	1a 09       	r8 = r1 + Null;
84202e4a:	21 09       	r7 = r2 + Null;
84202e4c:	2f 00       	r5 = r3 + Null;
84202e4e:	ee d9       	r4 = M[FP + -12];
    cbops_op *op = NULL;
84202e50:	02 00       	r0 = Null + Null;

    patch_fn_shared(aec_reference);

    /* sidetone can be mixed to 1 or 2 speakers only */
    if(nr_spkrs > 2)
84202e52:	b8 24       	Null = r5 - 2;
84202e54:	09 f0 87 e0 	if LS jump (m) Lc_create_aec_ref_sidetone_op_3;

84202e58 <Lc_create_aec_ref_sidetone_op_2>:
    {
        return op;
84202e58:	2c 6e       	jump (m) Lc_create_aec_ref_sidetone_op_6;

84202e5a <Lc_create_aec_ref_sidetone_op_3>:
    }

    // cbop param struct size (header plus cbop-specific parameters)
    op = (cbops_op*)xzpmalloc(sizeof_cbops_op(cbops_aec_ref_sidetone_op, 1, nr_spkrs));
84202e5a:	c3 20       	r1 = Null + 3;
84202e5c:	7a 20       	r0 = r5 + 1;
84202e5e:	52 54       	r0 = r0 LSHIFT 2;
84202e60:	02 f0 58 44 	r0 = r0 + 88;
84202e64:	ff fd 10 f0 	call (m) 0x4f2a;
84202e68:	27 e6 
84202e6a:	10 09       	r6 = r0 + Null;
    if(op)
84202e6c:	21 60       	if EQ jump (m) Lc_create_aec_ref_sidetone_op_5;

84202e6e <Lc_create_aec_ref_sidetone_op_4>:
    {
        cbops_aec_ref_sidetone_op *params;

        /* Setup Operator func table */
        op->function_vector    = cbops_aec_ref_sidetone_table;
84202e6e:	07 f0 01 f0 	rMAC = Null + 7340368;
84202e72:	50 41 
84202e74:	81 f0 02 8e 	M[r6 + 8] = rMAC;
        /* Setup cbop param struct header info */
        params = (cbops_aec_ref_sidetone_op*)cbops_populate_param_hdr(op,
                                                                      1,
                                                                      0,
                                                                      sidetone_idx,
                                                                      NULL);
84202e78:	00 f0 30 cf 	push Null;
84202e7c:	fd d9       	r3 = M[FP + -4];
84202e7e:	43 20       	r1 = Null + 1;
84202e80:	04 00       	r2 = Null + Null;
84202e82:	ff fd a0 f0 	call (m) 0x16f30;
84202e86:	2f e5 
84202e88:	7f 4c       	SP = SP + -4;

        /* Setup cbop-specific parameters */
        params->spkr_threshold  = spkr_threshold;
84202e8a:	f1 d9       	rMAC = M[FP + -8];
84202e8c:	51 9e       	M[r0 + 36] = rMAC;
        params->safety_threshold_low = safety_threshold;
84202e8e:	96 8f       	M[r0 + 24] = r4;
        params->safety_threshold_high = safety_threshold*2;
84202e90:	33 54       	r1 = r4 LSHIFT 1;
84202e92:	d3 8f       	M[r0 + 28] = r1;
        params->safety_set_threshold = (params->safety_threshold_low + params->safety_threshold_high)/2;
84202e94:	f3 00       	r1 = r4 + r1;
84202e96:	1b 50       	r1 = r1 LSHIFT -1;
84202e98:	13 9e       	M[r0 + 32] = r1;
        params->mic_buf = mic_buf;
84202e9a:	2b f0 01 8e 	M[r0 + 4] = r9;
        params->spkr_bufs = spkr_bufs;
84202e9e:	29 f0 00 ee 	M[r0 + Null] = r7;
        params->mic_idx = mic_idx;
84202ea2:	2a f0 05 8e 	M[r0 + 20] = r8;
        params->nr_spkrs = nr_spkrs;
84202ea6:	97 8e       	M[r0 + 8] = r5;

        /* initialise the operator */
        aec_ref_sidetone_initialise(op);
84202ea8:	42 08       	r0 = r6 + Null;
84202eaa:	04 f0 21 e9 	call (m) $_aec_ref_sidetone_initialise;

84202eae <Lc_create_aec_ref_sidetone_op_5>:
    }

    return(op);
84202eae:	42 08       	r0 = r6 + Null;

84202eb0 <Lc_create_aec_ref_sidetone_op_6>:
}
84202eb0:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84202eb2:	d8 4c       	rts;

84202eb4 <$_AEC_REFERENCE_GetDefaults>:
   0x000001F4u,			// HL_LIMIT_DETECT_FC
   0x00000032u			// HL_LIMIT_TC
};

unsigned *AEC_REFERENCE_GetDefaults(unsigned capid){
	switch(capid){
84202eb4:	20 f0 43 24 	Null = r0 - 67;
84202eb8:	05 60       	if EQ jump (m) Lc_AEC_REFERENCE_GetDefaults_3;

84202eba <Lc_AEC_REFERENCE_GetDefaults_2>:
84202eba:	01 f0 20 f0 	Null = r0 - 16391;
84202ebe:	07 24 
84202ec0:	05 62       	if NE jump (m) Lc_AEC_REFERENCE_GetDefaults_4;

84202ec2 <Lc_AEC_REFERENCE_GetDefaults_3>:
		case 0x0043: return defaults_aec_referenceAECREF;
84202ec2:	f8 ff 02 f0 	r0 = Null + -8388604;
84202ec6:	04 40 
84202ec8:	02 6e       	jump (m) Lc_AEC_REFERENCE_GetDefaults_5;

84202eca <Lc_AEC_REFERENCE_GetDefaults_4>:
		case 0x4007: return defaults_aec_referenceAECREF;
	}
	return((unsigned *)0);
84202eca:	02 00       	r0 = Null + Null;

84202ecc <Lc_AEC_REFERENCE_GetDefaults_5>:
84202ecc:	d8 4c       	rts;

84202ece <$_cbops_remove_operator_from_graph>:
        pfree(op);
    }
}

void cbops_remove_operator_from_graph(cbops_graph *graph,cbops_op *op)
{
84202ece:	c8 1c       	pushm <FP(=SP), rLink>;
    cbops_op   *prev_op = op->prev_operator_addr;
84202ed0:	19 e8       	rMAC = M[r1 + Null];
    cbops_op   *next_op = op->next_operator_addr;
84202ed2:	5c 88       	r2 = M[r1 + 4];

   if(graph->first == op)
84202ed4:	15 e8       	r3 = M[r0 + Null];
84202ed6:	e8 04       	Null = r3 - r1;
84202ed8:	07 62       	if NE jump (m) Lc_cbops_remove_operator_from_graph_5;

84202eda <Lc_cbops_remove_operator_from_graph_2>:
   {
       /* we are removing the first operator in the graph,
        * next op will become new first
        */
       graph->first = next_op;
       if(next_op == NULL)
84202eda:	14 ee       	M[r0 + Null] = r2;
84202edc:	03 62       	if NE jump (m) Lc_cbops_remove_operator_from_graph_4;

84202ede <Lc_cbops_remove_operator_from_graph_3>:
       {
           /* this op was the only op in the graph
            * now graph is empty
            */
           graph->last = NULL;
84202ede:	50 8e       	M[r0 + 4] = Null;
84202ee0:	0a 6e       	jump (m) Lc_cbops_remove_operator_from_graph_8;

84202ee2 <Lc_cbops_remove_operator_from_graph_4>:
       else
       {
           /* there is still op remaing,
            * just config the new first
            */
           next_op->prev_operator_addr = NULL;
84202ee2:	20 ee       	M[r2 + Null] = Null;
84202ee4:	08 6e       	jump (m) Lc_cbops_remove_operator_from_graph_8;

84202ee6 <Lc_cbops_remove_operator_from_graph_5>:
       }
   }
   else if(next_op == NULL)
84202ee6:	20 04       	Null = r2 - Null;
84202ee8:	04 62       	if NE jump (m) Lc_cbops_remove_operator_from_graph_7;

84202eea <Lc_cbops_remove_operator_from_graph_6>:
   {
       /* This isn't the only operator in the graph,
        * but it is the last one in chain
        */
       prev_op->next_operator_addr = NULL;
84202eea:	48 8e       	M[rMAC + 4] = Null;
       graph->last = prev_op;
84202eec:	51 8e       	M[r0 + 4] = rMAC;
84202eee:	03 6e       	jump (m) Lc_cbops_remove_operator_from_graph_8;

84202ef0 <Lc_cbops_remove_operator_from_graph_7>:
   else
   {
       /* easy part, the op is neither first
        * nor last
        */
       prev_op->next_operator_addr = next_op;
84202ef0:	4c 8e       	M[rMAC + 4] = r2;
       next_op->prev_operator_addr = prev_op;
84202ef2:	21 ee       	M[r2 + Null] = rMAC;

84202ef4 <Lc_cbops_remove_operator_from_graph_8>:
   }

   /* op removed from the graph, now
    * destroy the operator
    */
   destroy_operator(op);
84202ef4:	1a 00       	r0 = r1 + Null;
84202ef6:	1c 4e       	call (m) Lc_destroy_operator_1;

84202ef8 <Lc_cbops_remove_operator_from_graph_9>:
}
84202ef8:	c8 48       	popm <FP, rLink>;
84202efa:	d8 4c       	rts;

84202efc <$_cbops_insert_operator_into_graph>:


void cbops_insert_operator_into_graph(cbops_graph *graph,cbops_op *op, cbops_op *after)
{
84202efc:	c8 1c       	pushm <FP(=SP), rLink>;
    if(after->next_operator_addr == NULL)
84202efe:	61 88       	rMAC = M[r2 + 4];
84202f00:	05 62       	if NE jump (m) Lc_cbops_insert_operator_into_graph_3;

84202f02 <Lc_cbops_insert_operator_into_graph_2>:
    {
        /* if this is the last operator in the graph
         * then append it to end of graph
         */
        cbops_append_operator_to_graph(graph, op);
84202f02:	ff fd 9f f0 	call (m) 0x16e96;
84202f06:	35 ec 
84202f08:	07 6e       	jump (m) Lc_cbops_insert_operator_into_graph_4;

84202f0a <Lc_cbops_insert_operator_into_graph_3>:
    }
    else
    {
        /* put the operator between after and after->next */
        op->prev_operator_addr = after;
84202f0a:	1c ee       	M[r1 + Null] = r2;
        op->next_operator_addr = after->next_operator_addr;
84202f0c:	61 88       	rMAC = M[r2 + 4];
84202f0e:	59 8e       	M[r1 + 4] = rMAC;
        after->next_operator_addr->prev_operator_addr = op;        
84202f10:	61 88       	rMAC = M[r2 + 4];
84202f12:	0b ee       	M[rMAC + Null] = r1;
        after->next_operator_addr = op;
84202f14:	63 8e       	M[r2 + 4] = r1;

84202f16 <Lc_cbops_insert_operator_into_graph_4>:
    }
}
84202f16:	c8 48       	popm <FP, rLink>;
84202f18:	d8 4c       	rts;

84202f1a <$_cbops_unset_buffer>:

void cbops_unset_buffer(cbops_graph *graph,unsigned index)
{
    cbops_buffer *buffer = &graph->buffers[index];
84202f1a:	19 47       	rMAC = r1 * 28 (int);
84202f1c:	51 00       	rMAC = r0 + rMAC;
    if(buffer != NULL)
84202f1e:	09 31       	rMAC = rMAC + 36;
84202f20:	06 60       	if EQ jump (m) Lc_cbops_unset_buffer_3;

84202f22 <Lc_cbops_unset_buffer_2>:
    {
        /* make the buffer index unused */
        buffer->type = 0;
84202f22:	08 ec       	MH[rMAC + Null] = Null;
        buffer->buffer = NULL;
84202f24:	48 8e       	M[rMAC + 4] = Null;
        buffer->transfer_ptr = NULL;
84202f26:	48 8f       	M[rMAC + 20] = Null;
84202f28:	41 20       	rMAC = Null + 1;
84202f2a:	d1 8f       	M[r0 + 28] = rMAC;

84202f2c <Lc_cbops_unset_buffer_3>:
84202f2c:	d8 4c       	rts;

84202f2e <Lc_destroy_operator_1>:
 */
#include "cbops_c.h"
#include "pmalloc/pl_malloc.h"

static void destroy_operator(cbops_op *op)
{
84202f2e:	c8 1c       	pushm <FP(=SP), rLink>;
    if(op->function_vector == (void*)cbops_rate_adjust_table)
84202f30:	91 88       	rMAC = M[r0 + 8];
84202f32:	03 f0 28 42 	r1 = Null + 552;
84202f36:	c8 04       	Null = rMAC - r1;
84202f38:	05 62       	if NE jump (m) Lc_destroy_operator_3;

84202f3a <Lc_destroy_operator_2>:
    {
         destroy_sw_rate_adj_op((cbops_op*)op);
84202f3a:	ff fd 9e f0 	call (m) 0x16c7c;
84202f3e:	23 ea 
84202f40:	0c 6e       	jump (m) Lc_destroy_operator_6;

84202f42 <Lc_destroy_operator_3>:
    }
    else if(op->function_vector == (void*)cbops_iir_resampler_table)
84202f42:	03 f0 4c 42 	r1 = Null + 588;
84202f46:	c8 04       	Null = rMAC - r1;
84202f48:	05 62       	if NE jump (m) Lc_destroy_operator_5;

84202f4a <Lc_destroy_operator_4>:
    {
         destroy_iir_resamplerv2_op(op);
84202f4a:	ff fd a0 f0 	call (m) 0x17064;
84202f4e:	3b e8 
84202f50:	04 6e       	jump (m) Lc_destroy_operator_6;

84202f52 <Lc_destroy_operator_5>:
    }
    else
    {
        pfree(op);
84202f52:	ff fd 10 f0 	call (m) 0x4f62;
84202f56:	31 e0 

84202f58 <Lc_destroy_operator_6>:
    }
}
84202f58:	c8 48       	popm <FP, rLink>;
84202f5a:	d8 4c       	rts;

84202f5c <$_create_rate_monitor_operator>:
 * create_rate_monitor_operator
 */
#define RATE_MATCH_OP_NUM_INPUTS    1

cbops_op* create_rate_monitor_operator(unsigned clk_per_sec,unsigned idx)
{
84202f5c:	f2 1d       	pushm <FP(=SP), r4, r5, rLink>, SP = SP + 0x10;
84202f5e:	16 00       	r4 = r0 + Null;
84202f60:	23 de       	M[FP + 16] = r1;
    // cbop param struct size (header plus cbop-specific parameters)
    cbops_op *op = (cbops_op*)xzpmalloc(sizeof_cbops_op(cbops_rate_monitor_op, RATE_MATCH_OP_NUM_INPUTS, 0));
84202f62:	c3 20       	r1 = Null + 3;
84202f64:	02 f0 5c 40 	r0 = Null + 92;
84202f68:	ff fd 0f f0 	call (m) 0x4f2a;
84202f6c:	23 ee 
84202f6e:	17 00       	r5 = r0 + Null;

    if(op)
84202f70:	12 60       	if EQ jump (m) Lc_create_rate_monitor_operator_3;

84202f72 <Lc_create_rate_monitor_operator_2>:
    {
        cbops_rate_monitor_op *params;
        
        /* Setup Operator func table */
        op->function_vector    = cbops_rate_monitor_table;
84202f72:	01 f0 e4 42 	rMAC = Null + 740;
84202f76:	b9 8e       	M[r5 + 8] = rMAC;

        /* Setup cbop param struct header info */
        params  = (cbops_rate_monitor_op*)cbops_populate_param_hdr(op, RATE_MATCH_OP_NUM_INPUTS, 0, &idx, NULL);
84202f78:	00 f0 30 cf 	push Null;
84202f7c:	05 11       	r3 = FP + 16;
84202f7e:	43 20       	r1 = Null + 1;
84202f80:	04 00       	r2 = Null + Null;
84202f82:	ff fd 9f f0 	call (m) 0x16f30;
84202f86:	2f ed 
84202f88:	7f 4c       	SP = SP + -4;

        params->period_per_second = clk_per_sec;
84202f8a:	16 ee       	M[r0 + Null] = r4;
        params->average_io_rate = FRACTIONAL(0.5);
84202f8c:	ff f3 f1 f7 	rMAC = Null + 1073741823;
84202f90:	ff 7b 
84202f92:	11 8f       	M[r0 + 16] = rMAC;

84202f94 <Lc_create_rate_monitor_operator_3>:
    }

    return(op);
84202f94:	3a 00       	r0 = r5 + Null;

84202f96 <Lc_create_rate_monitor_operator_4>:
}
84202f96:	f2 49       	SP = SP - 0x10, popm <FP, r4, r5, rLink>;
84202f98:	d8 4c       	rts;

84202f9a <$_create_sidetone_filter_op>:
 * It fits into multi-channel model, but it only ever actually uses single in/out channel.
 */
cbops_op* create_sidetone_filter_op(unsigned input_idx, unsigned output_idx,
                                          unsigned max_stages, cbops_sidetone_params *st_params,
                                          unsigned *peq_params)
{
84202f9a:	f3 1d       	pushm <FP(=SP), r4, r5, r6, rLink>, SP = SP + 0x10;
84202f9c:	26 00       	r4 = r2 + Null;
84202f9e:	28 09       	r6 = r3 + Null;
84202fa0:	33 de       	M[FP + 24] = r1;
84202fa2:	2a de       	M[FP + 20] = r0;
    cbops_op *op;
    /* extra 2 words compared to ROM, needed as we use standard PEQ for filtering */
    op = (cbops_op*)xzpmalloc(sizeof_cbops_op(cbops_sidetone_filter_op, 1, 1) +
                              (2*(max_stages+1) + 2)*sizeof(unsigned) );
84202fa4:	c3 20       	r1 = Null + 3;
84202fa6:	b2 20       	r0 = r4 + 2;
84202fa8:	92 54       	r0 = r0 LSHIFT 3;
84202faa:	02 f0 5c 44 	r0 = r0 + 92;
84202fae:	ff fd 0f f0 	call (m) 0x4f2a;
84202fb2:	3d eb 
84202fb4:	17 00       	r5 = r0 + Null;
    if(op)
84202fb6:	16 60       	if EQ jump (m) Lc_create_sidetone_filter_op_3;

84202fb8 <Lc_create_sidetone_filter_op_2>:
    {
        cbops_sidetone_filter_op  *params;

        op->function_vector    = cbops_sidetone_filter_table;
84202fb8:	01 f0 cc 42 	rMAC = Null + 716;
84202fbc:	b9 8e       	M[r5 + 8] = rMAC;

        /* Setup cbop param struct header info */
        params = (cbops_sidetone_filter_op*)cbops_populate_param_hdr(op, 1, 1, &input_idx, &output_idx);
84202fbe:	81 11       	rMAC = FP + 24;
84202fc0:	09 1c       	pushm <rMAC>;
84202fc2:	45 11       	r3 = FP + 20;
84202fc4:	44 20       	r2 = Null + 1;
84202fc6:	23 00       	r1 = r2 + Null;
84202fc8:	ff fd 9f f0 	call (m) 0x16f30;
84202fcc:	29 eb 
84202fce:	7f 4c       	SP = SP + -4;

        /* Set up the parameters - there are no channel-specific params as such, as it only works on a
         * single channel.
         */

        params->inv_dac_gain = FRACTIONAL(1.0); // TODO - handle gain adjustment for post volume
84202fd0:	ff f7 f1 f7 	rMAC = Null + 2147483647;
84202fd4:	ff 7b 
84202fd6:	d1 8e       	M[r0 + 12] = rMAC;

        params->params = st_params;
84202fd8:	28 f0 00 ee 	M[r0 + Null] = r6;
        params->peq.max_stages = max_stages;
84202fdc:	16 9e       	M[r0 + 32] = r4;
        params->peq.params = peq_params;
84202fde:	f9 d9       	rMAC = M[FP + -4];
84202fe0:	51 9e       	M[r0 + 36] = rMAC;

84202fe2 <Lc_create_sidetone_filter_op_3>:
    }

    return(op);
84202fe2:	3a 00       	r0 = r5 + Null;

84202fe4 <Lc_create_sidetone_filter_op_4>:
}
84202fe4:	f3 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, rLink>;
84202fe6:	d8 4c       	rts;

84202fe8 <$_create_iir_resamplerv2_op>:
    unsigned inter_stage_size,
    unsigned *inter_stage,
    int shift,
    unsigned dbl_precision,
    unsigned low_mips)
{
84202fe8:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84202fea:	e6 d9       	r4 = M[FP + -16];
        out_rate,
        inter_stage_size,
        inter_stage,
        shift,
        dbl_precision,
        low_mips);
84202fec:	b1 f0 b3 5b 	rMAC = Null + 94131;
84202ff0:	d7 d9       	r5 = M[FP + -24];
84202ff2:	39 1c       	pushm <r5>;
84202ff4:	df d9       	r5 = M[FP + -20];
84202ff6:	39 1c       	pushm <r5>;
84202ff8:	31 1c       	pushm <r4>;
84202ffa:	ef d9       	r5 = M[FP + -12];
84202ffc:	39 1c       	pushm <r5>;
84202ffe:	f7 d9       	r5 = M[FP + -8];
84203000:	39 1c       	pushm <r5>;
84203002:	ff d9       	r5 = M[FP + -4];
84203004:	39 1c       	pushm <r5>;
84203006:	d1 4c       	call rMAC;
84203008:	7a 4c       	SP = SP + -24;

    if(op_ptr != NULL)
8420300a:	10 04       	Null = r0 - Null;
8420300c:	11 60       	if EQ jump (m) Lc_create_iir_resamplerv2_op_5;

8420300e <Lc_create_iir_resamplerv2_op_2>:
    {
        /* increase the headroom by 1 bit (6dB) */
        cbops_param_hdr *params_hdr = (cbops_param_hdr*)CBOPS_OPERATOR_DATA_PTR(op_ptr);
8420300e:	11 23       	rMAC = r0 + 12;

        cbops_iir_resampler_op *params =
            (cbops_iir_resampler_op *) params_hdr->operator_data_ptr;
84203010:	09 e8       	rMAC = M[rMAC + Null];
         * will increase the headroom by 1 bit or 6dB.
         */
        COMPILE_TIME_ASSERT(IIR_RESAMPLEV2_IO_SCALE_FACTOR == 9,
                        IIR_RESAMPLEV2_IO_SCALE_FACTOR_Not_Accepted);

        if(shift >= 0)
84203012:	30 04       	Null = r4 - Null;
84203014:	04 f0 91 e0 	if NEG jump (m) Lc_create_iir_resamplerv2_op_4;

84203018 <Lc_create_iir_resamplerv2_op_3>:
        {
            params->common.input_scale =  shift - IIR_RESAMPLEV2_IO_SCALE_FACTOR;
84203018:	63 f3 f7 3b 	r1 = r4 + -9;
8420301c:	4b 8e       	M[rMAC + 4] = r1;
            params->common.output_scale =  IIR_RESAMPLEV2_IO_SCALE_FACTOR;
8420301e:	43 22       	r1 = Null + 9;
84203020:	8b 8e       	M[rMAC + 8] = r1;
84203022:	06 6e       	jump (m) Lc_create_iir_resamplerv2_op_5;

84203024 <Lc_create_iir_resamplerv2_op_4>:
        }
        else
        {
            params->common.input_scale = -IIR_RESAMPLEV2_IO_SCALE_FACTOR;
84203024:	bb 78       	r1 = Null + -9;
84203026:	4b 8e       	M[rMAC + 4] = r1;
            params->common.output_scale =  IIR_RESAMPLEV2_IO_SCALE_FACTOR - shift;
84203028:	04 f6 53 d6 	r1 = 9 - r4;
8420302c:	8b 8e       	M[rMAC + 8] = r1;

8420302e <Lc_create_iir_resamplerv2_op_5>:
        }
    }

    return op_ptr;
8420302e:	f2 48       	popm <FP, r4, r5, rLink>;
84203030:	d8 4c       	rts;

84203032 <$_cbops_mute_enable>:
 * \param no_ramp if enabled it will be immediate mute/unmute
 *   else a ramping will apply during first processed block of samples.
 */
void cbops_mute_enable(cbops_op *op, bool enable, bool no_ramp)
{
    cbops_mute *params = CBOPS_PARAM_PTR(op, cbops_mute);
84203032:	d1 88       	rMAC = M[r0 + 12];
    params->mute_enable = enable;
84203034:	0b ee       	M[rMAC + Null] = r1;
    if(no_ramp)
84203036:	20 04       	Null = r2 - Null;
84203038:	02 60       	if EQ jump (m) Lc_cbops_mute_enable_3;

8420303a <Lc_cbops_mute_enable_2>:
    {
        /* no ramping, apply mute config immediately */
        params->mute_state = enable;
8420303a:	4b 8e       	M[rMAC + 4] = r1;

8420303c <Lc_cbops_mute_enable_3>:
8420303c:	d8 4c       	rts;

8420303e <$_create_multichan_sidetone_mix_op_base>:
                                                unsigned *input_idxs,
                                                unsigned *output_idxs,
                                                unsigned nr_st_channels,
                                                unsigned *st_in_idxs,
                                                unsigned threshold)
{
8420303e:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84203040:	17 00       	r5 = r0 + Null;
84203042:	1a 09       	r8 = r1 + Null;
84203044:	20 09       	r6 = r2 + Null;
84203046:	2e 00       	r4 = r3 + Null;
    /* Expect at least one sidetone channel*/
    if(nr_st_channels == 0 || /* At least one sidetone input channel */
       nr_channels == 0    || /* At least one main channel */
       nr_st_channels > CBOPS_SIDETONE_MIX_MAX_ST_CHANNELS)
84203048:	06 60       	if EQ jump (m) Lc_create_multichan_sidetone_mix_op_base_4;

8420304a <Lc_create_multichan_sidetone_mix_op_base_2>:
8420304a:	38 04       	Null = r5 - Null;
8420304c:	04 60       	if EQ jump (m) Lc_create_multichan_sidetone_mix_op_base_4;

8420304e <Lc_create_multichan_sidetone_mix_op_base_3>:
8420304e:	30 26       	Null = r4 - 8;
84203050:	09 f0 89 e0 	if LS jump (m) Lc_create_multichan_sidetone_mix_op_base_5;

84203054 <Lc_create_multichan_sidetone_mix_op_base_4>:
    {
        /* something is wrong with the caller */
        return NULL;
84203054:	02 00       	r0 = Null + Null;
84203056:	32 6e       	jump (m) Lc_create_multichan_sidetone_mix_op_base_10;

84203058 <Lc_create_multichan_sidetone_mix_op_base_5>:
    }

    cbops_op *op = (cbops_op*)xzpmalloc(sizeof_cbops_op(cbops_multichan_sidetone_mix_op, nr_channels, nr_channels)
                                        + (nr_channels + nr_st_channels - 1)*sizeof(unsigned));
84203058:	c3 20       	r1 = Null + 3;
8420305a:	f9 40       	rMAC = r5 * 3 (int);
8420305c:	71 00       	rMAC = r4 + rMAC;
8420305e:	4a 24       	r0 = rMAC - 1;
84203060:	52 54       	r0 = r0 LSHIFT 2;
84203062:	12 38       	r0 = r0 + 48;
84203064:	ff fd 0f f0 	call (m) 0x4f2a;
84203068:	27 e6 
8420306a:	11 09       	r7 = r0 + Null;
    if(op != NULL)
8420306c:	26 60       	if EQ jump (m) Lc__loop0;

8420306e <Lc_create_multichan_sidetone_mix_op_base_6>:
    {
        cbops_multichan_sidetone_mix_op  *params;

        op->function_vector    = cbops_multichan_sidetone_mix_table;
8420306e:	07 f0 01 f0 	rMAC = Null + 7340380;
84203072:	5c 41 
84203074:	91 f0 02 8e 	M[r7 + 8] = rMAC;

        /* Setup cbops param struct header info */
        params = (cbops_multichan_sidetone_mix_op*)cbops_populate_param_hdr(op, nr_channels, nr_channels, input_idxs, output_idxs);
84203078:	10 1c       	pushm <r6>;
8420307a:	55 08       	r3 = r8 + Null;
8420307c:	3c 00       	r2 = r5 + Null;
8420307e:	3b 00       	r1 = r5 + Null;
84203080:	ff fd 9f f0 	call (m) 0x16f30;
84203084:	31 e5 
84203086:	7f 4c       	SP = SP + -4;
84203088:	10 09       	r6 = r0 + Null;

        /* Only config param which is threshold which is for all of the
         * sidetone channels
         */
        params->max_samples = threshold;
8420308a:	f1 d9       	rMAC = M[FP + -8];
8420308c:	81 f0 00 ee 	M[r6 + Null] = rMAC;

        /* number of main channels */
        params->nr_channels = nr_channels;
84203090:	87 f0 03 8e 	M[r6 + 12] = r5;

        /* number of sidetone channels */
        params->nr_st_channels = nr_st_channels;
84203094:	86 f0 04 8e 	M[r6 + 16] = r4;

        /* write cbops buffer indexes for sidetone buffers */
        unsigned *params_st_in_idxs = &params->st_idxs[0];
84203098:	82 f0 14 20 	r0 = r6 + 20;
        memcpy(params_st_in_idxs, st_in_idxs, sizeof(unsigned)*nr_st_channels);
8420309c:	74 54       	r2 = r4 LSHIFT 2;
8420309e:	fb d9       	r1 = M[FP + -4];
842030a0:	ff fd a0 f0 	call (m) 0x170b8;
842030a4:	39 e0 

        /* initialise sidetone mixing mapping */
        unsigned i;
        unsigned *params_st_map_idxs = &params->st_idxs[nr_st_channels];
842030a6:	72 54       	r0 = r4 LSHIFT 2;
842030a8:	10 0d       	r6 = r0 + r6;
842030aa:	82 f0 14 20 	r0 = r6 + 20;
        for(i = 0; i < nr_channels; ++i)
842030ae:	41 24       	rMAC = Null - 1;
842030b0:	3c 09       	r10 = r5 + Null;
842030b2:	03 4c       	do (m) Lc__loop0;

842030b4 <Lc_create_multichan_sidetone_mix_op_base_7>:
        {
            /* initialise to no sidetone mixing, this needs to be
             * configured later to do any sidetone mixing
             */
            params_st_map_idxs[i] = CBOPS_BUFFER_NOT_SUPPLIED;
842030b4:	11 ee       	M[r0 + Null] = rMAC;
842030b6:	12 21       	r0 = r0 + 4;

842030b8 <Lc__loop0>:
        memcpy(params_st_in_idxs, st_in_idxs, sizeof(unsigned)*nr_st_channels);

        /* initialise sidetone mixing mapping */
        unsigned i;
        unsigned *params_st_map_idxs = &params->st_idxs[nr_st_channels];
        for(i = 0; i < nr_channels; ++i)
842030b8:	4a 08       	r0 = r7 + Null;

842030ba <Lc_create_multichan_sidetone_mix_op_base_10>:
            params_st_map_idxs[i] = CBOPS_BUFFER_NOT_SUPPLIED;
        }
    }

    return(op);
}
842030ba:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
842030bc:	d8 4c       	rts;

842030be <$_cbops_sidetone_mix_map_channel>:
 * \param op cbops multichannel sidetone mix operator (input)
 * \param input_channel main channel number (0 to (nr_channels-1))
 * \param use_st_channel use this sidetone channel (0 to (nr_st_channels-1))
 */
void cbops_sidetone_mix_map_channel(cbops_op *op, unsigned input_channel, unsigned use_st_channel)
{
842030be:	c8 1c       	pushm <FP(=SP), rLink>;
    if(NULL != op)
842030c0:	10 04       	Null = r0 - Null;
842030c2:	20 60       	if EQ jump (m) Lc_cbops_sidetone_mix_map_channel_7;

842030c4 <Lc_cbops_sidetone_mix_map_channel_2>:
    {
        cbops_multichan_sidetone_mix_op  *params = CBOPS_PARAM_PTR(op, cbops_multichan_sidetone_mix_op);
842030c4:	d1 88       	rMAC = M[r0 + 12];
        PL_ASSERT(use_st_channel < params->nr_st_channels);
842030c6:	0d 89       	r3 = M[rMAC + 16];
842030c8:	60 05       	Null = r2 - r3;
842030ca:	09 64       	if NC jump (m) Lc_cbops_sidetone_mix_map_channel_4;

842030cc <Lc_cbops_sidetone_mix_map_channel_3>:
842030cc:	03 f0 9a 40 	r1 = Null + 154;
842030d0:	02 f0 13 60 	r0 = Null + 4115;
842030d4:	ff fd 87 f0 	call (m) 0x13f12;
842030d8:	3f e1 
842030da:	14 6e       	jump (m) Lc_cbops_sidetone_mix_map_channel_7;

842030dc <Lc_cbops_sidetone_mix_map_channel_4>:
        PL_ASSERT(input_channel < params->nr_channels);
842030dc:	ca 88       	r0 = M[rMAC + 12];
842030de:	98 04       	Null = r1 - r0;
842030e0:	09 64       	if NC jump (m) Lc_cbops_sidetone_mix_map_channel_6;

842030e2 <Lc_cbops_sidetone_mix_map_channel_5>:
842030e2:	03 f0 9b 40 	r1 = Null + 155;
842030e6:	02 f0 13 60 	r0 = Null + 4115;
842030ea:	ff fd 87 f0 	call (m) 0x13f12;
842030ee:	29 e1 
842030f0:	09 6e       	jump (m) Lc_cbops_sidetone_mix_map_channel_7;

842030f2 <Lc_cbops_sidetone_mix_map_channel_6>:

        /* get sidetone indexes */
        unsigned *st_in_idxs = &params->st_idxs[0];
842030f2:	0a 29       	r0 = rMAC + 20;

        /* get mapping table indexes */
        unsigned *st_map_idxs = &params->st_idxs[params->nr_st_channels];
842030f4:	6d 54       	r3 = r3 LSHIFT 2;
842030f6:	69 00       	rMAC = r3 + rMAC;
842030f8:	09 29       	rMAC = rMAC + 20;

        /* configure this channel to use sidetone mixing from use_st_channel */
        st_map_idxs[input_channel] = st_in_idxs[use_st_channel];
842030fa:	64 54       	r2 = r2 LSHIFT 2;
842030fc:	5b 54       	r1 = r1 LSHIFT 2;
842030fe:	12 e9       	r0 = M[r0 + r2];
84203100:	ca ee       	M[rMAC + r1] = r0;

84203102 <Lc_cbops_sidetone_mix_map_channel_7>:
    }
}
84203102:	c8 48       	popm <FP, rLink>;
84203104:	d8 4c       	rts;

84203106 <$_cbops_sidetone_mix_map_one_to_all>:
 * \brief configures a sidetone channel to be mixed into all main channels
 * \param op cbops multichannel sidetone mix operator (input)
 * \param use_st_channel use this sidetone channel to mix into all channels
 */
void cbops_sidetone_mix_map_one_to_all(cbops_op *op, unsigned use_st_channel)
{
84203106:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
84203108:	18 09       	r6 = r1 + Null;
8420310a:	16 00       	r4 = r0 + Null;
    if(NULL != op)
8420310c:	1a 60       	if EQ jump (m) Lc_cbops_sidetone_mix_map_one_to_all_7;

8420310e <Lc_cbops_sidetone_mix_map_one_to_all_2>:
    {
        unsigned i;
        cbops_multichan_sidetone_mix_op  *params = CBOPS_PARAM_PTR(op, cbops_multichan_sidetone_mix_op);
8420310e:	f7 88       	r5 = M[r4 + 12];
        PL_ASSERT(use_st_channel < params->nr_st_channels);
84203110:	39 89       	rMAC = M[r5 + 16];
84203112:	1f f8 00 c2 	Null = r6 - rMAC;
84203116:	09 64       	if NC jump (m) Lc_cbops_sidetone_mix_map_one_to_all_4;

84203118 <Lc_cbops_sidetone_mix_map_one_to_all_3>:
84203118:	03 f0 b3 40 	r1 = Null + 179;
8420311c:	02 f0 13 60 	r0 = Null + 4115;
84203120:	ff fd 86 f0 	call (m) 0x13f12;
84203124:	33 ef 
84203126:	0d 6e       	jump (m) Lc_cbops_sidetone_mix_map_one_to_all_7;

84203128 <Lc_cbops_sidetone_mix_map_one_to_all_4>:
        for(i = 0; i < params->nr_channels; ++i)
84203128:	01 09       	r7 = Null + Null;

8420312a <Lc_cbops_sidetone_mix_map_one_to_all_5>:
8420312a:	f9 88       	rMAC = M[r5 + 12];
8420312c:	1f f9 00 c2 	Null = r7 - rMAC;
84203130:	02 f0 91 e0 	if C jump (m) Lc_cbops_sidetone_mix_map_one_to_all_7;

84203134 <Lc_cbops_sidetone_mix_map_one_to_all_6>:
        {
            cbops_sidetone_mix_map_channel(op, i, use_st_channel);
84203134:	44 08       	r2 = r6 + Null;
84203136:	4b 08       	r1 = r7 + Null;
84203138:	32 00       	r0 = r4 + Null;
8420313a:	c2 4f       	call (m) $_cbops_sidetone_mix_map_channel;
    if(NULL != op)
    {
        unsigned i;
        cbops_multichan_sidetone_mix_op  *params = CBOPS_PARAM_PTR(op, cbops_multichan_sidetone_mix_op);
        PL_ASSERT(use_st_channel < params->nr_st_channels);
        for(i = 0; i < params->nr_channels; ++i)
8420313c:	09 75       	r7 = r7 + 1;
8420313e:	f6 6f       	jump (m) Lc_cbops_sidetone_mix_map_one_to_all_5;

84203140 <Lc_cbops_sidetone_mix_map_one_to_all_7>:
        {
            cbops_sidetone_mix_map_channel(op, i, use_st_channel);
        }
    }
}
84203140:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84203142:	d8 4c       	rts;

84203144 <$_create_multichan_sidetone_mix_op>:
                                           unsigned first_output_idx,
                                           unsigned nr_st_channels,
                                           unsigned first_st_in_idx,
                                           unsigned threshold
                                           )
{
84203144:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
84203146:	13 09       	r9 = r0 + Null;
84203148:	1a 09       	r8 = r1 + Null;
8420314a:	20 09       	r6 = r2 + Null;
8420314c:	2f 00       	r5 = r3 + Null;
8420314e:	e9 f3 ff b9 	r7 = M[FP + -4];
    /* We have first index only, to create we need an array of indexes,
     * create buffer indexes using maximum index.
     */
    unsigned max_idx = pl_max(first_input_idx, first_output_idx)+nr_channels;
84203152:	52 08       	r0 = r8 + Null;
84203154:	43 08       	r1 = r6 + Null;
84203156:	6f f3 42 ce 	r0 = MAX r1;
8420315a:	5a 0c       	r0 = r9 + r0;
    max_idx = pl_max(max_idx, nr_st_channels + first_st_in_idx);
8420315c:	7f f9 03 c0 	r1 = r7 + r5;
84203160:	6f f3 42 ce 	r0 = MAX r1;
    unsigned *idxs = create_default_indexes(max_idx);
84203164:	ff fd 9e f0 	call (m) 0x16f08;
84203168:	25 ed 
8420316a:	16 00       	r4 = r0 + Null;
    if(NULL == idxs)
8420316c:	03 62       	if NE jump (m) Lc_create_multichan_sidetone_mix_op_3;

8420316e <Lc_create_multichan_sidetone_mix_op_2>:
    {
        return NULL;
8420316e:	02 00       	r0 = Null + Null;
84203170:	1a 6e       	jump (m) Lc_create_multichan_sidetone_mix_op_4;

84203172 <Lc_create_multichan_sidetone_mix_op_3>:
    cbops_op* op = create_multichan_sidetone_mix_op_base(nr_channels,
                                                         &idxs[first_input_idx],
                                                         &idxs[first_output_idx],
                                                         nr_st_channels,
                                                         &idxs[first_st_in_idx],
                                                         threshold);
84203172:	f1 d9       	rMAC = M[FP + -8];
84203174:	09 1c       	pushm <rMAC>;
84203176:	01 f9 d2 c8 	r0 = r7 LSHIFT 2;
8420317a:	31 00       	rMAC = r4 + Null;
8420317c:	51 00       	rMAC = r0 + rMAC;
8420317e:	09 1c       	pushm <rMAC>;
84203180:	01 f8 d2 c8 	r0 = r6 LSHIFT 2;
84203184:	34 00       	r2 = r4 + Null;
84203186:	33 00       	r1 = r4 + Null;
84203188:	3d 00       	r3 = r5 + Null;
8420318a:	14 01       	r2 = r0 + r2;
8420318c:	01 fa d2 c8 	r0 = r8 LSHIFT 2;
84203190:	d3 00       	r1 = r0 + r1;
84203192:	5a 08       	r0 = r9 + Null;
84203194:	55 4f       	call (m) $_create_multichan_sidetone_mix_op_base;
84203196:	7e 4c       	SP = SP + -8;
84203198:	17 00       	r5 = r0 + Null;
    pfree(idxs);
8420319a:	32 00       	r0 = r4 + Null;
8420319c:	ff fd 0e f0 	call (m) 0x4f62;
842031a0:	27 ee 
    return op;
842031a2:	3a 00       	r0 = r5 + Null;

842031a4 <Lc_create_multichan_sidetone_mix_op_4>:
}
842031a4:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
842031a6:	d8 4c       	rts;

842031a8 <$_opmgr_op_is_running>:
842031a8:	01 00       	rMAC = Null + Null;
 *
 * \param op_data The data structure of the operator to query
 */
bool opmgr_op_is_running(OPERATOR_DATA *op_data)
{
    return op_data->state == OP_RUNNING;
842031aa:	10 b0       	Null = MBS[r0 + 24];
842031ac:	20 f0 41 ce 	if EQ rMAC = Null + 1;
842031b0:	0a 00       	r0 = rMAC + Null;

842031b2 <Lc_opmgr_op_is_running_2>:
842031b2:	d8 4c       	rts;

842031b4 <$_get_override_ep_rate_adjust_op>:
842031b4:	f1 1e       	pushm <FP(=SP), r4, rLink>, SP = SP + 0x20;
#define EP_CURRENT_HW_WARP ((uint32)0x1001A)

#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
/* get_override_ep_rate_adjust_op */
bool get_override_ep_rate_adjust_op(OVERRIDE_EP_HANDLE ep_hdl, uint32* value)
{
842031b6:	1e 00       	r4 = r1 + Null;
/** Set the unreliable flag
 * \param rm Rate measurement context
 */
static void inline rate_measure_set_unreliable(RATE_MEASURE* rm)
{
    rm->unreliable = TRUE;
842031b8:	c4 10       	r2 = FP + 12;
842031ba:	58 dc       	MH[FP + 22] = Null;
842031bc:	80 da       	MB[FP + 16] = Null;
    ENDPOINT_GET_CONFIG_RESULT result;
    result.u.value = 0;
842031be:	18 de       	M[FP + 12] = Null;
    bool success = stream_get_connected_to_endpoint_config((ENDPOINT*)ep_hdl, EP_RATE_ADJUST_OP, &result);
842031c0:	83 f0 18 40 	r1 = Null + 65560;
842031c4:	ff fd 17 f0 	call (m) 0x6128;
842031c8:	25 eb 
    *value = result.u.value;
842031ca:	19 d8       	rMAC = M[FP + 12];
842031cc:	31 ee       	M[r4 + Null] = rMAC;

842031ce <Lc_get_override_ep_rate_adjust_op_2>:
    return success;
842031ce:	f1 4a       	SP = SP - 0x20, popm <FP, r4, rLink>;
842031d0:	d8 4c       	rts;

842031d2 <$_set_override_ep_set_hw_warp_apply_mode>:
}
#endif /* INSTALL_DELEGATE_RATE_ADJUST_SUPPORT */
/* set_override_ep_set_hw_warp_apply_mode */
bool set_override_ep_set_hw_warp_apply_mode(OVERRIDE_EP_HANDLE ep_hdl, uint32 value)
{
842031d2:	c8 1c       	pushm <FP(=SP), rLink>;
842031d4:	1c 00       	r2 = r1 + Null;
    return stream_configure_connected_to_endpoint((ENDPOINT*)ep_hdl, EP_HW_WARP_APPLY_MODE, value);
842031d6:	83 f0 19 40 	r1 = Null + 65561;
842031da:	ff fd 17 f0 	call (m) 0x6146;
842031de:	2d eb 

842031e0 <Lc_set_override_ep_set_hw_warp_apply_mode_2>:
}
842031e0:	c8 48       	popm <FP, rLink>;
842031e2:	d8 4c       	rts;

842031e4 <$_get_override_ep_current_hw_warp>:


/* get_override_ep_current_hw_warp */
bool get_override_ep_current_hw_warp(OVERRIDE_EP_HANDLE ep_hdl, uint32* value)
{
842031e4:	f1 1e       	pushm <FP(=SP), r4, rLink>, SP = SP + 0x20;
842031e6:	1e 00       	r4 = r1 + Null;
842031e8:	c4 10       	r2 = FP + 12;
842031ea:	58 dc       	MH[FP + 22] = Null;
842031ec:	80 da       	MB[FP + 16] = Null;
    ENDPOINT_GET_CONFIG_RESULT result;
    result.u.value = 0;
842031ee:	18 de       	M[FP + 12] = Null;
    bool success = stream_get_connected_to_endpoint_config((ENDPOINT*)ep_hdl, EP_CURRENT_HW_WARP, &result);
842031f0:	83 f0 1a 40 	r1 = Null + 65562;
842031f4:	ff fd 17 f0 	call (m) 0x6128;
842031f8:	35 e9 
    *value = result.u.value;
842031fa:	19 d8       	rMAC = M[FP + 12];
842031fc:	31 ee       	M[r4 + Null] = rMAC;

842031fe <Lc_get_override_ep_current_hw_warp_2>:
    return success;
842031fe:	f1 4a       	SP = SP - 0x20, popm <FP, r4, rLink>;
84203200:	d8 4c       	rts;

84203202 <$_stream_delegate_rate_adjust_set_target_rate>:
84203202:	c8 1d       	pushm <FP(=SP), rLink>, SP = SP + 0x10;
 *
 * \param opid operator id for the standalone rate adjust operator
 * \param target_rate_addr target rate
 */
void stream_delegate_rate_adjust_set_target_rate(unsigned opid, unsigned target_rate)
{
84203204:	11 00       	rMAC = r0 + Null;
    unsigned params[3];

    /* send SET_TARGET_RATE message to the operator */
    params[0] = OPMSG_COMMON_SET_RATE_ADJUST_TARGET_RATE;
84203206:	12 f0 18 40 	r0 = Null + 8216;
8420320a:	12 de       	M[FP + 8] = r0;
    params[1] = (uint16) (target_rate >> 16);
8420320c:	9a 52       	r0 = r1 LSHIFT -16;
8420320e:	1a de       	M[FP + 12] = r0;
    params[2] = (uint16) (target_rate & 0xFFFF);
84203210:	9a c6       	r0 = r1 AND 0xffff;
84203212:	22 de       	M[FP + 16] = r0;
    opmgr_operator_message(RESPOND_TO_OBPM,
                           opid,
                           sizeof(params)/sizeof(unsigned),
                           params,
                           stream_delegate_rate_adjust_message_callback);
84203214:	42 f0 32 f0 	push Null + 69218947;
84203218:	53 e8 
8420321a:	85 10       	r3 = FP + 8;
8420321c:	c4 20       	r2 = Null + 3;
8420321e:	c2 2b       	r0 = Null + 31;
84203220:	0b 00       	r1 = rMAC + Null;
84203222:	ff fd 02 f0 	call (m) 0x37ca;
84203226:	29 ed 
84203228:	7f 4c       	SP = SP + -4;

8420322a <Lc_stream_delegate_rate_adjust_set_target_rate_2>:
}
8420322a:	c8 49       	SP = SP - 0x10, popm <FP, rLink>;
8420322c:	d8 4c       	rts;

8420322e <$_stream_delegate_rate_adjust_set_passthrough_mode>:
 *
 * \param opid operator id for the standalone rate adjust operator
 * \param enable if TRUE enables pass-through mode else disables it
 */
void stream_delegate_rate_adjust_set_passthrough_mode(unsigned opid, bool enable)
{
8420322e:	c8 1d       	pushm <FP(=SP), rLink>, SP = SP + 0x10;
84203230:	11 00       	rMAC = r0 + Null;
    unsigned params[2];

    /* send PASSTHROUGH_MODE message to the operator */
    params[0] = OPMSG_COMMON_SET_RATE_ADJUST_PASSTHROUGH_MODE;
84203232:	12 f0 19 40 	r0 = Null + 8217;
84203236:	12 de       	M[FP + 8] = r0;
    params[1] = (uint16) enable;
84203238:	9a c6       	r0 = r1 AND 0xffff;
8420323a:	1a de       	M[FP + 12] = r0;
    opmgr_operator_message(RESPOND_TO_OBPM,
                           opid,
                           sizeof(params)/sizeof(unsigned),
                           params,
                           stream_delegate_rate_adjust_message_callback);
8420323c:	42 f0 32 f0 	push Null + 69218947;
84203240:	53 e8 
84203242:	85 10       	r3 = FP + 8;
84203244:	84 20       	r2 = Null + 2;
84203246:	c2 2b       	r0 = Null + 31;
84203248:	0b 00       	r1 = rMAC + Null;
8420324a:	ff fd 02 f0 	call (m) 0x37ca;
8420324e:	21 ec 
84203250:	7f 4c       	SP = SP + -4;

84203252 <Lc_stream_delegate_rate_adjust_set_passthrough_mode_2>:
}
84203252:	c8 49       	SP = SP - 0x10, popm <FP, rLink>;
84203254:	d8 4c       	rts;

84203256 <$_stream_delegate_rate_adjust_set_current_rate>:
 *
 * Note: This message when delivered will directly set the current sra rate,
 *       suitable for TTP-type rate adjustment.
 */
void stream_delegate_rate_adjust_set_current_rate(unsigned opid, unsigned rate)
{
84203256:	c8 1d       	pushm <FP(=SP), rLink>, SP = SP + 0x10;
84203258:	11 00       	rMAC = r0 + Null;
    unsigned params[3];

    /* send SET_CURRENT_RATE message to the operator */
    params[0] = OPMSG_COMMON_SET_RATE_ADJUST_CURRENT_RATE;
8420325a:	12 f0 17 40 	r0 = Null + 8215;
8420325e:	12 de       	M[FP + 8] = r0;
    params[1] = (uint16) (rate >> 16);
84203260:	9a 52       	r0 = r1 LSHIFT -16;
84203262:	1a de       	M[FP + 12] = r0;
    params[2] = (uint16) (rate & 0xFFFF);
84203264:	9a c6       	r0 = r1 AND 0xffff;
84203266:	22 de       	M[FP + 16] = r0;
    opmgr_operator_message(RESPOND_TO_OBPM,
                           opid,
                           sizeof(params)/sizeof(unsigned),
                           params,
                           stream_delegate_rate_adjust_message_callback);
84203268:	42 f0 32 f0 	push Null + 69218947;
8420326c:	53 e8 
8420326e:	85 10       	r3 = FP + 8;
84203270:	c4 20       	r2 = Null + 3;
84203272:	c2 2b       	r0 = Null + 31;
84203274:	0b 00       	r1 = rMAC + Null;
84203276:	ff fd 02 f0 	call (m) 0x37ca;
8420327a:	35 ea 
8420327c:	7f 4c       	SP = SP + -4;

8420327e <Lc_stream_delegate_rate_adjust_set_current_rate_2>:
}
8420327e:	c8 49       	SP = SP - 0x10, popm <FP, rLink>;
84203280:	d8 4c       	rts;

84203282 <Lc_stream_delegate_rate_adjust_message_callback_1>:
static bool stream_delegate_rate_adjust_message_callback(unsigned con_id,
                                                         unsigned status,
                                                         unsigned op_id,
                                                         unsigned num_resp_params,
                                                         unsigned *resp_params)
{
84203282:	c8 1c       	pushm <FP(=SP), rLink>;
84203284:	11 00       	rMAC = r0 + Null;
    /* No action, just log the response if message if it failed */
    if(status != STATUS_OK)
84203286:	18 04       	Null = r1 - Null;
84203288:	11 60       	if EQ jump (m) Lc_stream_delegate_rate_adjust_message_callback_6;

8420328a <Lc_stream_delegate_rate_adjust_message_callback_2>:
    {
        L2_DBG_MSG4("Message to standalone rate adjust op failed: conid=%d, opid=%d, status=%d, messageID=%d",
                    con_id,
                    op_id,
                    status,
                    num_resp_params == 0?-1:resp_params[0]);
8420328a:	28 04       	Null = r3 - Null;
8420328c:	03 62       	if NE jump (m) Lc_stream_delegate_rate_adjust_message_callback_4;

8420328e <Lc_stream_delegate_rate_adjust_message_callback_3>:
8420328e:	42 24       	r0 = Null - 1;
84203290:	03 6e       	jump (m) Lc_stream_delegate_rate_adjust_message_callback_5;

84203292 <Lc_stream_delegate_rate_adjust_message_callback_4>:
84203292:	fa d9       	r0 = M[FP + -4];
84203294:	12 e8       	r0 = M[r0 + Null];

84203296 <Lc_stream_delegate_rate_adjust_message_callback_5>:
84203296:	11 1c       	pushm <r0>;
84203298:	55 f1 02 f0 	r0 = Null + 357565199;
8420329c:	0f 43 
8420329e:	1d 00       	r3 = r1 + Null;
842032a0:	0b 00       	r1 = rMAC + Null;
842032a2:	ef fd eb ff 	call (m) 0x9f6;
842032a6:	35 ea 
842032a8:	7f 4c       	SP = SP + -4;

842032aa <Lc_stream_delegate_rate_adjust_message_callback_6>:
    }

    return TRUE;
842032aa:	42 20       	r0 = Null + 1;

842032ac <Lc_stream_delegate_rate_adjust_message_callback_7>:
}
842032ac:	c8 48       	popm <FP, rLink>;
842032ae:	d8 4c       	rts;

842032b0 <$kdc_start>:
.MODULE $M.kdc_start;
.CODESEGMENT PM;
.DATASEGMENT DM;

$kdc_start:
r0 = $_aec_reference_cap_data;
842032b0:	07 f0 02 f0 	r0 = Null + 7340032;
842032b4:	00 40 
    /* Force this symbol to be exported in ELF */
    Null = $___kymera_debug_map_addr;
842032b6:	20 f0 b0 41 	Null = Null + 16816;

842032ba <$cbops.aec_ref_spkr_op.amount_to_use>:
          
#ifdef PATCH_LIBS
    LIBS_SLOW_SW_ROM_PATCH_POINT($cbops.aec_ref_spkr_op.amount_to_use.PATCH_ID_0, r7)
#endif
          
   push rlink;
842032ba:	00 f0 3d cf 	push rLink;
   
   // Get data pointer
   r7 = M[r8 + $cbops.param_hdr.OPERATOR_DATA_PTR_FIELD];
842032be:	a9 f0 00 88 	r7 = M[r8 + 0];
   // Get amount of input
   r0 = M[r8 + $cbops.param_hdr.CHANNEL_INDEX_START_FIELD];    
842032c2:	a2 f0 03 88 	r0 = M[r8 + 12];
   call $cbops.get_amount_ptr;
842032c6:	ff fd c5 f2 	call 0x5bd9c;
842032ca:	36 e6 
   r5 = M[r0];
842032cc:	17 e8       	r5 = M[r0 + Null];
   // Save data at input and make input large, will re-adjust for insertion
   M[r7 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.AMOUNT_DATA_FIELD] = r5;
842032ce:	97 f0 03 8e 	M[r7 + 12] = r5;
   r5 = 0x7FFF;
842032d2:	37 f0 ff 7b 	r5 = Null + 32767;
   M[r0] = r5;
842032d6:	87 ee       	M[Null + r0] = r5;

#ifndef CHIP_BASE_A7DA_KAS
   // Get first output index
   r9 = M[r8 + $cbops.param_hdr.NR_INPUT_CHANNELS_FIELD];
842032d8:	ab f0 01 88 	r9 = M[r8 + 4];
   Words2Addr(r9);
842032dc:	01 fb 1b c9 	r9 = r9 ASHIFT 2;
   r9 = r9 + $cbops.param_hdr.CHANNEL_INDEX_START_FIELD;
842032e0:	63 75       	r9 = r9 + 12;
   r0 = M[r8 + r9];
842032e2:	a2 f0 0b e8 	r0 = M[r8 + r9];
   call $cbops.get_cbuffer;
842032e6:	ff fd c5 f2 	call 0x5bd8c;
842032ea:	26 e5 
   NULL = r0;
842032ec:	10 00       	Null = r0 + Null;
   if Z jump aec_ref_spkr_op.amount_to_use_done;
842032ee:	16 60       	if EQ jump (m) $M.cbops.aec_ref_spkr_op.aec_ref_spkr_op.amount_to_use_done;

   // First Port (r0);
   r5 = NULL;
842032f0:	07 00       	r5 = Null + Null;
   r6 = M[r7 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.MAX_ADVANCE_FIELD];
842032f2:	98 f0 01 88 	r6 = M[r7 + 4];
   r1 = M[r7 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.MAX_JITTER_FIELD];
842032f6:	93 f0 06 88 	r1 = M[r7 + 24];
   r6 = r6 + r1;  
842032fa:	18 0d       	r6 = r1 + r6;

   call calc_dac_amount_of_data;
842032fc:	d4 4e       	call (m) $M.cbops.aec_ref_spkr_op.calc_dac_amount_of_data;
   // r2 is data in port (negative if wrap), r10 is max advance, r0 is adjustment
   // Limit amount of data after transfer to two times maximum advance
   NULL = r2 + r0;
842032fe:	a0 00       	Null = r2 + r0;
   if POS r1 = r6 - r2;
84203300:	45 f8 03 c2 	if POS r1 = r6 - r2;
   if NEG r1 = Null;
84203304:	04 f0 03 c0 	if NEG r1 = Null + Null;

   // Setup the limited transfer at output
   r0 = M[r8 + r9];
84203308:	a2 f0 0b e8 	r0 = M[r8 + r9];
   call $cbops.get_amount_ptr;
8420330c:	ff fd c5 f2 	call 0x5bd9c;
84203310:	30 e4 
   M[r0]=r1;
84203312:	83 ee       	M[Null + r0] = r1;
   if Z call $cbops.force_processing;
84203314:	f0 fd c5 f2 	if EQ call 0x5bdac;
84203318:	38 e4 

8420331a <$M.cbops.aec_ref_spkr_op.aec_ref_spkr_op.amount_to_use_done>:
#endif

aec_ref_spkr_op.amount_to_use_done:
   pop rlink;
8420331a:	00 f4 3d cf 	pop rLink;
   rts;
8420331e:	d8 4c       	rts;

84203320 <$cbops.aec_ref_spkr_op.pre_main>:

#ifndef CBOPS_AEC_REF_SPKR_OP_PRE_MAIN_USE_ROM
// Called after amount to use of graph but before main processing of graph
$cbops.aec_ref_spkr_op.pre_main:
   push rLink;
84203320:	00 f0 3d cf 	push rLink;
    *                       |
    *                       |
    *                Possible Silence Insert
    *-----------------------------------------------------------------------*/
   // Get data pointer
   r7 = M[r8 + $cbops.param_hdr.OPERATOR_DATA_PTR_FIELD];
84203324:	a9 f0 00 88 	r7 = M[r8 + 0];

   // Get intermediate buffer indexes
   I7 = r7 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.INTERM_IDXS_FIELD;
84203328:	97 f8 1c 20 	I7 = r7 + 28;

   // Get input buffer indexes
   I2 = r8 + $cbops.param_hdr.CHANNEL_INDEX_START_FIELD;
8420332c:	a2 f8 0c 20 	I2 = r8 + 12;

   // Get number of input channels
   r0 = M[r8 + $cbops.param_hdr.NR_INPUT_CHANNELS_FIELD];
84203330:	a2 f0 01 88 	r0 = M[r8 + 4];
   M2 = r0;
84203334:	12 0b       	M2 = r0 + Null;

   // r5 will hold the amount of silence needed
   // to insert this run
   r5 = 0;
84203336:	07 00       	r5 = Null + Null;

   // transfer amount from input
   r0 = M[I2, 0];
84203338:	28 f0 30 c0 	Null = Null + Null, r0 = M[I2,0];
   call $cbops.get_amount_ptr;
8420333c:	ff fd c5 f2 	call 0x5bd9c;
84203340:	20 e3 
   r10 = r0;
84203342:	14 09       	r10 = r0 + Null;

   // transfer amount to interm stage
   r0 = M[I7, 0];
84203344:	2c f0 30 d0 	Null = Null + Null, r0 = M[I7,0];
   call $cbops.get_amount_ptr;
84203348:	ff fd c5 f2 	call 0x5bd9c;
8420334c:	34 e2 
   r6 = M[r0];
8420334e:	28 f0 00 e8 	r6 = M[r0 + Null];

   // optimisation, early exit if nothing can transfer
   // to interm stage.
   if Z M[r10] = r6;
84203352:	00 f8 8c c1 	if EQ M[r10] = r6 + Null;
   if Z jump aec_ref_spkr_op.pre_main_done;
84203356:	4f 60       	if EQ jump (m) $M.cbops.aec_ref_spkr_op.aec_ref_spkr_op.pre_main_done;

   // Get amount of data and threshold. Determine if need to insert.
   r3 = M[r7 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.AMOUNT_DATA_FIELD];
84203358:	95 f0 03 88 	r3 = M[r7 + 12];
   NULL = r6 - r3;
8420335c:	5f f8 00 c2 	Null = r6 - r3;
   if LE jump aec_ref_spkr_op.pre_main_transfer;
84203360:	0f 6c       	if LE jump (m) $M.cbops.aec_ref_spkr_op.aec_ref_spkr_op.pre_main_transfer;

   // Insufficient data, limit transfer to threshold.
   r2 = M[r7 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.IN_THRESHOLD_FIELD];
84203362:	94 f0 00 88 	r2 = M[r7 + 0];
   r6 = MIN r2;
84203366:	5f f4 48 ce 	r6 = MIN r2;
   // r3: amount of data in the input buffer
   // r6: amount of data that "must" be pushed into next stage
   //  if input has enough data then transfer needed samples from
   //  input buffer otherwise silence will be inserted to make sure
   //  exactly r6 samples will be pushed into next stage.
   r5 = r6 - r3;
8420336a:	5f f8 07 c2 	r5 = r6 - r3;
   if LE r5 = 0;
8420336e:	0d f0 07 c0 	if LE r5 = Null + Null;
   if Z jump aec_ref_spkr_op.pre_main_transfer;
84203372:	06 60       	if EQ jump (m) $M.cbops.aec_ref_spkr_op.aec_ref_spkr_op.pre_main_transfer;
   // Insert (r5) zeroes with this transfer, update counter
   r1 = M[r7 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.NUM_INSERTS_FIELD];
84203374:	93 f0 05 88 	r1 = M[r7 + 20];
   r1 = r1 + r5;
84203378:	fb 00       	r1 = r5 + r1;
   M[r7 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.NUM_INSERTS_FIELD]=r1;
8420337a:	93 f0 05 8e 	M[r7 + 20] = r1;

8420337e <$M.cbops.aec_ref_spkr_op.aec_ref_spkr_op.pre_main_transfer>:
   //  r7: data pointer of the operator
   //  r0: transfer amount ptr for intermediate buffer
   //  r10: transfer amount ptr for input buffer

   // update transfer amount for interm bufs
   M[r0] = r6;
8420337e:	08 f0 02 ee 	M[Null + r0] = r6;

   // amount that should be transferred from input
   r6 = r6 - r5;
84203382:	00 f7 38 c2 	r6 = r6 - r5;

   // update transfer amount for input bufs
   M[r10] = r6;
84203386:	08 f0 0c ee 	M[Null + r10] = r6;

8420338a <$M.cbops.aec_ref_spkr_op.transfer_and_silence_insert_channel>:

   // r5: amount of silence to insert
   // r6: amount of transfer from input buffer
   transfer_and_silence_insert_channel:
      // Setup Input Buffer
      r0 = M[I2,0];
8420338a:	28 f0 30 c0 	Null = Null + Null, r0 = M[I2,0];
      call $cbops.get_buffer_address_and_length;
8420338e:	ff fd c4 f2 	call 0x5bd20;
84203392:	32 ec 
      I0 = r0;
84203394:	10 0a       	I0 = r0 + Null;
      if Z jump next_transfer_and_silence_insert_channel;
84203396:	1d 60       	if EQ jump (m) $M.cbops.aec_ref_spkr_op.next_transfer_and_silence_insert_channel;
      L0 = r1;
84203398:	1c 0b       	L0 = r1 + Null;
      push r2;
8420339a:	00 f0 34 cf 	push r2;
      pop B0;
8420339e:	00 f6 3a cf 	pop B0;

      // Setup Interm Buffer
      r0 = M[I7,0];
842033a2:	2c f0 30 d0 	Null = Null + Null, r0 = M[I7,0];
      call $cbops.get_buffer_address_and_length;
842033a6:	ff fd c4 f2 	call 0x5bd20;
842033aa:	3a eb 
      I4 = r0;
842033ac:	14 0a       	I4 = r0 + Null;
      if Z jump next_transfer_and_silence_insert_channel;
842033ae:	11 60       	if EQ jump (m) $M.cbops.aec_ref_spkr_op.next_transfer_and_silence_insert_channel;
      L4 = r1;
842033b0:	1e 0b       	L4 = r1 + Null;
      push r2;
842033b2:	00 f0 34 cf 	push r2;
      pop B4;
842033b6:	00 f6 3c cf 	pop B4;

      // first silence insertion if needed
      r10 = r5;
842033ba:	3c 09       	r10 = r5 + Null;
      r0 = 0;
842033bc:	02 00       	r0 = Null + Null;
      do silence_insert_loop;
842033be:	03 4c       	do (m) $M.cbops.aec_ref_spkr_op.silence_insert_loop;
         M[I4, MK1] = r0;
842033c0:	a1 f0 30 d0 	Null = Null + Null, M[I4,4] = r0;

842033c4 <$M.cbops.aec_ref_spkr_op.silence_insert_loop>:
      silence_insert_loop:

      // then transfer real audio from input
      r10 = r6;
842033c4:	44 09       	r10 = r6 + Null;
      do transfer_loop;
842033c6:	05 4c       	do (m) $M.cbops.aec_ref_spkr_op.next_transfer_and_silence_insert_channel;
         r0 = M[I0, MK1];
842033c8:	21 f0 30 c0 	Null = Null + Null, r0 = M[I0,4];
         M[I4, MK1] = r0;
842033cc:	a1 f0 30 d0 	Null = Null + Null, M[I4,4] = r0;

842033d0 <$M.cbops.aec_ref_spkr_op.next_transfer_and_silence_insert_channel>:
      transfer_loop:

      next_transfer_and_silence_insert_channel:
      r0 = M[I2, MK1], r1 = M[I7, MK1];
842033d0:	3d f9 32 d0 	Null = Null + Null, r0 = M[I2,4], r1 = M[I7,4];
      M2 = M2 - 1;
842033d4:	aa fc 01 24 	M2 = M2 - 1;
   if GT jump transfer_and_silence_insert_channel;
842033d8:	d9 6b       	if GT jump (m) $M.cbops.aec_ref_spkr_op.transfer_and_silence_insert_channel;

   // Reset Buffering control
   L0 = 0;
842033da:	04 0b       	L0 = Null + Null;
   L4 = 0;
842033dc:	06 0b       	L4 = Null + Null;
   push NULL;
842033de:	00 f0 30 cf 	push Null;
   pop B0;
842033e2:	00 f6 3a cf 	pop B0;
   push NULL;
842033e6:	00 f0 30 cf 	push Null;
   pop B4;
842033ea:	00 f6 3c cf 	pop B4;

   /* Something written at the interim stage
    * force going ahead
    */
   call $cbops.force_processing;
842033ee:	ff fd c4 f2 	call 0x5bdac;
842033f2:	3e ed 

842033f4 <$M.cbops.aec_ref_spkr_op.aec_ref_spkr_op.pre_main_done>:

aec_ref_spkr_op.pre_main_done:
   pop rlink;
842033f4:	00 f4 3d cf 	pop rLink;
   rts;
842033f8:	d8 4c       	rts;

842033fa <$_get_aec_ref_cbops_inserts_total>:
#endif /* #ifndef CBOPS_AEC_REF_SPKR_OP_PRE_MAIN_USE_ROM */
// unsigned get_aec_ref_cbops_inserts_total(cbops_op *op);
$_get_aec_ref_cbops_inserts_total:
    r0 = M[r0 + ($cbops_c.cbops_op_struct.PARAMETER_AREA_START_FIELD+$cbops.param_hdr.OPERATOR_DATA_PTR_FIELD)];
842033fa:	d2 88       	r0 = M[r0 + 12];
    r1 = M[r0 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.WRAP_COUNT_FIELD];
842033fc:	13 89       	r1 = M[r0 + 16];
    r0 = M[r0 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.NUM_INSERTS_FIELD];
842033fe:	52 89       	r0 = M[r0 + 20];
    r0 = r0 + r1;
84203400:	9a 00       	r0 = r1 + r0;
    rts;
84203402:	d8 4c       	rts;

84203404 <$_get_aec_ref_cbops_insert_op_insert_total>:

// unsigned get_aec_ref_cbops_insert_op_insert_total(cbops_op *op);
$_get_aec_ref_cbops_insert_op_insert_total:
    r0 = M[r0 + ($cbops_c.cbops_op_struct.PARAMETER_AREA_START_FIELD+$cbops.param_hdr.OPERATOR_DATA_PTR_FIELD)];
84203404:	d2 88       	r0 = M[r0 + 12];
    r0 = M[r0 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.NUM_INSERTS_FIELD];
84203406:	52 89       	r0 = M[r0 + 20];
    rts;
84203408:	d8 4c       	rts;

8420340a <$_get_aec_ref_cbops_wrap_op_insert_total>:

// unsigned get_aec_ref_cbops_wrap_op_insert_total(cbops_op *op);
$_get_aec_ref_cbops_wrap_op_insert_total:
    r0 = M[r0 + ($cbops_c.cbops_op_struct.PARAMETER_AREA_START_FIELD+$cbops.param_hdr.OPERATOR_DATA_PTR_FIELD)];
8420340a:	d2 88       	r0 = M[r0 + 12];
    r0 = M[r0 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.WRAP_COUNT_FIELD];
8420340c:	12 89       	r0 = M[r0 + 16];
    rts;
8420340e:	d8 4c       	rts;

84203410 <$cbops.aec_ref_spkr_op.post_main>:
#ifndef CHIP_BASE_A7DA_KAS
// Called after main processing of graph before buffer update
$cbops.aec_ref_spkr_op.post_main:

   // Check for Buffer Wrapping
    push rLink;
84203410:	00 f0 3d cf 	push rLink;
#ifdef PATCH_LIBS
    LIBS_SLOW_SW_ROM_PATCH_POINT($cbops.aec_ref_spkr_op.post_main.PATCH_ID_0, r9)
#endif

    // Get first output index
    r9 = M[r8 + $cbops.param_hdr.NR_INPUT_CHANNELS_FIELD];
84203414:	ab f0 01 88 	r9 = M[r8 + 4];
    Words2Addr(r9);
84203418:	01 fb 1b c9 	r9 = r9 ASHIFT 2;
    r9 = r9 + r8;
8420341c:	53 0d       	r9 = r8 + r9;
    I4 = r9 + $cbops.param_hdr.CHANNEL_INDEX_START_FIELD;
8420341e:	b4 f8 0c 20 	I4 = r9 + 12;

    // Get first buffer entry 
    r0 = M[I4,0];
84203422:	20 f0 30 d0 	Null = Null + Null, r0 = M[I4,0];
    r3 = r0 * $CBOP_BUFTAB_ENTRY_SIZE_IN_ADDR (int);
84203426:	15 47       	r3 = r0 * 28 (int);
    r3 = r3 + r4;
84203428:	75 01       	r3 = r4 + r3;

    // Get Cbuffer Ptr
    r0 = M[r3 + $cbops_c.cbops_buffer_struct.BUFFER_FIELD];
8420342a:	6a 88       	r0 = M[r3 + 4];
    if Z jump $pop_rLink_and_rts;
8420342c:	7c ff 30 f5 	if EQ jump (m) 0x2cf82;
84203430:	d7 e6 

#if !defined(CHIP_BASE_BC7)   
    // Get transfer amount (r5)
    r1 = M[r3 + $cbops_c.cbops_buffer_struct.TRANSFER_PTR_FIELD];
84203432:	6b 89       	r1 = M[r3 + 20];
    r5 = M[r1];
84203434:	1f e8       	r5 = M[r1 + Null];
#else
    r5 = NULL;
#endif

    // Compute amount of data in source
    r7 = M[r8 + $cbops.param_hdr.OPERATOR_DATA_PTR_FIELD];
84203436:	a9 f0 00 88 	r7 = M[r8 + 0];
    r6 = M[r7 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.MAX_JITTER_FIELD];
8420343a:	98 f0 06 88 	r6 = M[r7 + 24];
    call calc_dac_amount_of_data;
8420343e:	33 4e       	call (m) $M.cbops.aec_ref_spkr_op.calc_dac_amount_of_data;

    r6 = M[r7 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.MAX_ADVANCE_FIELD];
84203440:	98 f0 01 88 	r6 = M[r7 + 4];

    // r2 is number of samples in port, negative if overflow
    r10 = r6 - r2;
84203444:	4f f8 0c c2 	r10 = r6 - r2;
    if LE jump $pop_rLink_and_rts;
84203448:	7c ff 3d f5 	if LE jump (m) 0x2cf82;
8420344c:	bb e6 

    // Increment Wrap count
    r1 = M[r7 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.WRAP_COUNT_FIELD];
8420344e:	93 f0 04 88 	r1 = M[r7 + 16];
    r1 = r1 + r10;    
84203452:	63 0c       	r1 = r10 + r1;
    M[r7 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.WRAP_COUNT_FIELD]=r1;
84203454:	93 f0 04 8e 	M[r7 + 16] = r1;
    
    // setup amounts for insertions
    r5 = r5 + r10;
84203458:	67 0c       	r5 = r10 + r5;
    r6 = r10;
8420345a:	60 09       	r6 = r10 + Null;

    // Number of Ports
    r9 = M[r8 + $cbops.param_hdr.NR_OUTPUT_CHANNELS_FIELD];
8420345c:	ab f0 02 88 	r9 = M[r8 + 8];

84203460 <$M.cbops.aec_ref_spkr_op.process_channel>:

    // Perform insertion
 process_channel:
    r0 = M[I4,0];
84203460:	20 f0 30 d0 	Null = Null + Null, r0 = M[I4,0];
    call $cbops.get_buffer_address_and_length;
84203464:	ff fd c4 f2 	call 0x5bd20;
84203468:	3c e5 
    I0 = r0;
8420346a:	10 0a       	I0 = r0 + Null;
    if Z jump process_channel_next;
8420346c:	11 60       	if EQ jump (m) $M.cbops.aec_ref_spkr_op.process_channel_next;
      // Insert r6 zeros
      r10 = r6;
8420346e:	44 09       	r10 = r6 + Null;
      L0 = r1;
84203470:	1c 0b       	L0 = r1 + Null;
      push r2;
84203472:	00 f0 34 cf 	push r2;
      pop B0;
84203476:	00 f6 3a cf 	pop B0;
      r1  = Null;
8420347a:	03 00       	r1 = Null + Null;
      do lp_insert_loop;
8420347c:	03 4c       	do (m) $M.cbops.aec_ref_spkr_op.lp_insert_loop;
         M[I0, MK1] = r1;
8420347e:	b1 f0 30 c0 	Null = Null + Null, M[I0,4] = r1;

84203482 <$M.cbops.aec_ref_spkr_op.lp_insert_loop>:
      lp_insert_loop:
      // Update amount (r5)
      r0 = M[I4,MK1];
84203482:	21 f0 30 d0 	Null = Null + Null, r0 = M[I4,4];
      call $cbops.get_amount_ptr;
84203486:	ff fd c4 f2 	call 0x5bd9c;
8420348a:	36 e8 
      M[r0]=r5;
8420348c:	87 ee       	M[Null + r0] = r5;

8420348e <$M.cbops.aec_ref_spkr_op.process_channel_next>:
    process_channel_next:
    r9 = r9 - 1;
8420348e:	bb f0 01 24 	r9 = r9 - 1;
    if GT jump process_channel;
84203492:	e7 6b       	if GT jump (m) $M.cbops.aec_ref_spkr_op.process_channel;

    // Clear circular buffer
    L0=NULL;
84203494:	04 0b       	L0 = Null + Null;
    push NULL;
84203496:	00 f0 30 cf 	push Null;
    pop B0;
8420349a:	00 f6 3a cf 	pop B0;

    pop rlink;
8420349e:	00 f4 3d cf 	pop rLink;
    rts;
842034a2:	d8 4c       	rts;

842034a4 <$M.cbops.aec_ref_spkr_op.calc_dac_amount_of_data>:
// TRASHED REGISTERS:
//    r0,r1,r2
//
// *****************************************************************************
calc_dac_amount_of_data:
    push rLink;
842034a4:	00 f0 3d cf 	push rLink;
    call $cbuffer.calc_amount_space_in_words;
842034a8:	ff fd 46 f1 	call (m) 0x2c1b6;
842034ac:	2f e8 

#ifdef CHIP_BASE_HYDRA
    // Hydra: r2 is local buffer size in addr
    Addr2Words(r2);
842034ae:	64 58       	r2 = r2 ASHIFT -2;
    // Adjust space for amount written, buffer not port
    r0 = r0 - r5;
842034b0:	d2 05       	r0 = r0 - r5;
#endif

    // r0 is space in port minus one
    // r2 = amount data in port
    // r6 min required space
    r2  = r2 - r0;    
842034b2:	a4 04       	r2 = r2 - r0;
    // check minimum space, if less than that
    // wrap has happened
    Null = r0 - r6;
842034b4:	8f f2 00 c2 	Null = r0 - r6;
    if NEG r2 = NULL - r0;
842034b8:	24 f0 04 c2 	if NEG r2 = Null - r0;

    r0 = M[r7 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.BUFFER_ADJ_FIELD];
842034bc:	92 f0 02 88 	r0 = M[r7 + 8];
    r2 = r2 - r0;
842034c0:	a4 04       	r2 = r2 - r0;
    // r2 is number of samples in port, negative if overflow
    pop rLink;
842034c2:	00 f4 3d cf 	pop rLink;
    rts;
842034c6:	d8 4c       	rts;

842034c8 <$_aec_ref_purge_mics>:
   .CODESEGMENT PM;

// void aec_ref_purge_mics(cbops_graph *mic_graph,unsigned num_mics);
$_aec_ref_purge_mics:
  // Save registers
	push rLink;
842034c8:	00 f0 3d cf 	push rLink;
	pushm <r5,r6,r7,r8,r10>;
842034cc:	78 f1 40 e0 	pushm <r5, r6, r7, r8, r10>;
	pushm <M0,L0>;
842034d0:	10 f1 40 e4 	pushm <M0, L0>;
	push I0;
842034d4:	00 f1 30 cf 	push I0;
	push B0;
842034d8:	00 f2 3a cf 	push B0;

  // Force cbops to update buffers
  M[r0 + $cbops_c.cbops_graph_struct.FORCE_UPDATE_FIELD]=r0;
842034dc:	12 9e       	M[r0 + 32] = r0;

	// Extra parameters
	r7 = r0 + $cbops_c.cbops_graph_struct.BUFFERS_FIELD;
842034de:	29 f0 24 20 	r7 = r0 + 36;
	r8 = r1;
842034e2:	1a 09       	r8 = r1 + Null;
	r6 = MAXINT;
842034e4:	ff f7 f8 f7 	r6 = Null + 2147483647;
842034e8:	ff 7b 

	// Get minimum data in mics
	r10 = r8;
842034ea:	54 09       	r10 = r8 + Null;
	r5  = r7;
842034ec:	4f 08       	r5 = r7 + Null;
	do aec_ref_purge_mics.data_loop;
842034ee:	08 4c       	do (m) $M.cbops.aec_ref_purge_mics.aec_ref_purge_mics.data_loop;
		// Get amount of data in mic
		r0 = M[r5 + $cbops_c.cbops_buffer_struct.BUFFER_FIELD];
842034f0:	7a 88       	r0 = M[r5 + 4];
		call $cbuffer.calc_amount_data_in_words;
842034f2:	ff fd 46 f1 	call (m) 0x2c208;
842034f6:	37 e8 
		// update minimum
		r6 = MIN r0;
842034f8:	5f f2 48 ce 	r6 = MIN r0;
		// Go to next mic
		r5 = r5 + $CBOP_BUFTAB_ENTRY_SIZE_IN_ADDR;
842034fc:	3f 2b       	r5 = r5 + 28;

842034fe <$M.cbops.aec_ref_purge_mics.aec_ref_purge_mics.data_loop>:
	aec_ref_purge_mics.data_loop:

  r0 = r6;
842034fe:	42 08       	r0 = r6 + Null;
   Words2Addr(r0);
84203500:	52 5c       	r0 = r0 ASHIFT 2;
   M0 = r0;
84203502:	10 0b       	M0 = r0 + Null;
   if Z jump aec_ref_purge_mics_done;
84203504:	1e 60       	if EQ jump (m) $M.cbops.aec_ref_purge_mics.aec_ref_purge_mics_done;

	// Read Data
	r5  = r7;
84203506:	4f 08       	r5 = r7 + Null;

84203508 <$M.cbops.aec_ref_purge_mics.aec_ref_purge_mics.advance_loop>:
aec_ref_purge_mics.advance_loop:
		// Get Input buffer (source)
		r0 = M[r5 + $cbops_c.cbops_buffer_struct.BUFFER_FIELD];
84203508:	7a 88       	r0 = M[r5 + 4];
    call $cbuffer.get_read_address_and_size_and_start_address;
8420350a:	ff fd 48 f1 	call (m) 0x2c6a4;
8420350e:	3b ec 
		L0 = r1;
84203510:	1c 0b       	L0 = r1 + Null;
		push r2;
84203512:	00 f0 34 cf 	push r2;
		pop B0;
84203516:	00 f6 3a cf 	pop B0;
	  I0 = r0;
8420351a:	10 0a       	I0 = r0 + Null;
		// Advance buffer
		NULL = r1 - MK1;
8420351c:	18 25       	Null = r1 - 4;
		if NZ jump aec_ref_purge_mics.sw_buf;
8420351e:	06 62       	if NE jump (m) $M.cbops.aec_ref_purge_mics.aec_ref_purge_mics.sw_buf;
			// MMU buffer must be read
			r10 = r6;
84203520:	44 09       	r10 = r6 + Null;
			do aec_ref_purge_mics.mmu_buf;
84203522:	03 4c       	do (m) $M.cbops.aec_ref_purge_mics.aec_ref_purge_mics.mmu_buf;
				r0 = M[I0,MK1];
84203524:	21 f0 30 c0 	Null = Null + Null, r0 = M[I0,4];

84203528 <$M.cbops.aec_ref_purge_mics.aec_ref_purge_mics.mmu_buf>:
			aec_ref_purge_mics.mmu_buf:

			jump aec_ref_purge_mics.next;
84203528:	03 6e       	jump (m) $M.cbops.aec_ref_purge_mics.aec_ref_purge_mics.next;

8420352a <$M.cbops.aec_ref_purge_mics.aec_ref_purge_mics.sw_buf>:

aec_ref_purge_mics.sw_buf:
			r0 = M[I0,M0];
8420352a:	20 f0 20 c0 	Null = Null + Null, r0 = M[I0,M0];

8420352e <$M.cbops.aec_ref_purge_mics.aec_ref_purge_mics.next>:
aec_ref_purge_mics.next:
		// Update buffer
		r0 = M[r5 + $cbops_c.cbops_buffer_struct.BUFFER_FIELD];
8420352e:	7a 88       	r0 = M[r5 + 4];
		r1 = I0;
84203530:	83 08       	r1 = I0 + Null;
		call $cbuffer.set_read_address;
84203532:	ff fd 48 f1 	call (m) 0x2c708;
84203536:	37 ee 
		// Go to next mic
		r5 = r5 + $CBOP_BUFTAB_ENTRY_SIZE_IN_ADDR;
84203538:	3f 2b       	r5 = r5 + 28;
		r8 = r8 - 1;
8420353a:	aa f0 01 24 	r8 = r8 - 1;
		if GT jump aec_ref_purge_mics.advance_loop;
8420353e:	e5 6b       	if GT jump (m) $M.cbops.aec_ref_purge_mics.aec_ref_purge_mics.advance_loop;

84203540 <$M.cbops.aec_ref_purge_mics.aec_ref_purge_mics_done>:

aec_ref_purge_mics_done:
  // Restore registers
	pop B0;
84203540:	00 f6 3a cf 	pop B0;
	pop I0;
84203544:	00 f5 30 cf 	pop I0;
	popm <M0,L0>;
84203548:	10 f1 60 e4 	popm <M0, L0>;
	popm <r5,r6,r7,r8,r10>;
8420354c:	78 f1 60 e0 	popm <r5, r6, r7, r8, r10>;
  pop rLink;
84203550:	00 f4 3d cf 	pop rLink;
	rts;
84203554:	d8 4c       	rts;

84203556 <$_aecref_calc_ref_rate>:
//
// *****************************************************************************
.MODULE $M.aecref_calc_ref_rate;
   .CODESEGMENT PM;
$_aecref_calc_ref_rate:
    push r4;
84203556:	00 f0 36 cf 	push r4;
    r4 = 0.5;
8420355a:	00 f4 06 f0 	r4 = Null + 1073741824;
8420355e:	00 40 
    // RateAdjREF = ([( mic_ra + 1.0) x (spkr_ra + 1.0) x mic_rt ] / spkr_rt) - 1.0

    // (mic_ra+1) x (spkr_ra+1.0) x 0.25 =
    //       (mic_ra*0.5 + 0.5) x (spkr_ra*0.5 + 0.5)
    r1 = r1 ASHIFT -1;
84203560:	1b 58       	r1 = r1 ASHIFT -1;
    r1 = r1 + r4;
84203562:	f3 00       	r1 = r4 + r1;
    r3 = r3 ASHIFT -1;
84203564:	2d 58       	r3 = r3 ASHIFT -1;
    r3 = r3 + r4;
84203566:	75 01       	r3 = r4 + r3;
    rMAC = r1*r3;
84203568:	5f f3 c1 cc 	rMAC = r1 * r3 (SS);

    // (mic_ra+1) x (spkr_ra+1.0) x mic_rt x 0.25
    rMAC = rMAC * r0;
8420356c:	2f f1 c1 cc 	rMAC = rMAC * r0 (SS);

    //  Note:  Multiplier is 0.25 instead of 0.5 because it is going
    //         into a fractional divide

    // [(mic_ra+1) x (spkr_ra+1.0) x mic_rt x 0.25]/spkr_rt
    DIV = rMAC / r2;
84203570:	a1 4c       	Div = rMAC / r2;
    r0 = DivResult;
84203572:	c2 4c       	r0 = DivResult;

    // Result of the divide is [0.0 ... 1.0], 0.5 is unity
    //   Convert to [-1.0 ... +1.0]
    r0 = r0 - r4;
84203574:	92 05       	r0 = r0 - r4;
    r0 = r0 ASHIFT 1;
84203576:	12 5c       	r0 = r0 ASHIFT 1;
    pop r4;
84203578:	00 f4 36 cf 	pop r4;
    rts;
8420357c:	d8 4c       	rts;

8420357e <$_aecref_calc_sync_mic_rate>:
$_aecref_calc_sync_mic_rate:
    // r0 = spkr_ra
    // r1 = spkr_rt
    // r2 = mic_rt
    // return spkr_rt/(mic_rt*(1+spkr_ra))
    rMAC = -r0;
8420357e:	81 04       	rMAC = Null - r0;
    r3 = r0 * r0 (frac);
84203580:	2f f2 45 c9 	r3 = r0 * r0 (frac);
    rMAC = rMAC + r0 * r0;
84203584:	2f f2 c1 ca 	rMAC = rMAC + r0 * r0 (SS);
    rMAC = rMAC - r0*r3;   // rMAC = -spkr_ra + spkr_ra^2 - spkr_ra^3
84203588:	5f f2 c1 cb 	rMAC = rMAC - r0 * r3 (SS);
                           // good enough estimation of 1.0/(1.0+spkr_ra) -1.0
    r0 = rMAC;
8420358c:	0a 00       	r0 = rMAC + Null;
    rMAC = r1 - r2;
8420358e:	19 05       	rMAC = r1 - r2;
    if Z rts;              // all done if mic_rt==spkr_rt
84203590:	00 fd c0 cd 	if EQ rts;
    // calculate (spkr_rt/mic_rt)-1.0
#if DAWTH>24
   // division & rounding
   rMAC0 = r2;
84203594:	05 f0 00 f4 	rMAC0 = r2 LSHIFT 0;
84203598:	de c8 
   r2 = r2 + r2;
8420359a:	24 01       	r2 = r2 + r2;
   Div = rMAC / r2;
8420359c:	a1 4c       	Div = rMAC / r2;
   r1 = DivResult;       // r1 = (spkr_rt/mic_rt)-1.0
8420359e:	c3 4c       	r1 = DivResult;
   r1 = r1 - 0.5;    // r1 = 0.5(spkr_rt/mic_rt-1.0)
   r1 = r1 + r1;     // r1 = (spkr_rt/mic_rt)-1.0
#endif
    // r1 = (spkr_rt/mic_rt)-1.0
    // r0 = 1.0/(1.0+spkr_ra)-1.0
    r2 = r1 * r0 (frac);
842035a0:	2f f3 44 c9 	r2 = r1 * r0 (frac);
    r0 = r1 + r0;
842035a4:	9a 00       	r0 = r1 + r0;
    r0 = r0 + r2;
842035a6:	a2 00       	r0 = r2 + r0;
    // r0 = spkr_rt/mic_rt/(1+spkr_ra) - 1.0
    rts;
842035a8:	d8 4c       	rts;

842035aa <$cbops.aec_ref_sidetone_op.amount_to_use>:
// Called before amount_to_use of graph
$cbops.aec_ref_sidetone_op.amount_to_use:
#ifdef PATCH_LIBS
   LIBS_SLOW_SW_ROM_PATCH_POINT($cbops.aec_ref_sidetone_op.amount_to_use.PATCH_ID_0, r7)
#endif
   push rlink;
842035aa:	00 f0 3d cf 	push rLink;

   // Get data pointer
   r7 = M[r8 + $cbops.param_hdr.OPERATOR_DATA_PTR_FIELD];
842035ae:	a9 f0 00 88 	r7 = M[r8 + 0];

   // update sidetone mic buffer
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.MIC_BUF_FIELD];
842035b2:	92 f0 01 88 	r0 = M[r7 + 4];
   call $cbuffer.get_write_address_and_size_and_start_address;
842035b6:	ff fd 48 f1 	call (m) 0x2c6d6;
842035ba:	21 e9 
   r6 = r0;
842035bc:	10 09       	r6 = r0 + Null;
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.MIC_IDX_FIELD];
842035be:	92 f0 05 88 	r0 = M[r7 + 20];
   call $cbops.get_cbuffer;
842035c2:	ff fd c3 f2 	call 0x5bd8c;
842035c6:	2a ee 
   r1 = r6;
842035c8:	43 08       	r1 = r6 + Null;
   r6 = r0;
842035ca:	10 09       	r6 = r0 + Null;
   call $cbuffer.set_write_address;
842035cc:	ff fd 48 f1 	call (m) 0x2c73e;
842035d0:	33 eb 

   // update amount to read from mic
   r0 = r6;
842035d2:	42 08       	r0 = r6 + Null;
   call $cbuffer.calc_amount_data_in_words;
842035d4:	ff fd 46 f1 	call (m) 0x2c208;
842035d8:	35 e1 
   r6 = r0;
842035da:	10 09       	r6 = r0 + Null;
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.MIC_IDX_FIELD];
842035dc:	92 f0 05 88 	r0 = M[r7 + 20];
   call $cbops.get_amount_ptr;
842035e0:	ff fd c3 f2 	call 0x5bd9c;
842035e4:	3c ed 
   M[r0] = r6;
842035e6:	08 f0 02 ee 	M[Null + r0] = r6;

   /* See how many samples speakr has moved, we will mix the same
    * number of samples from sidetone buffer.
    */
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SPKR_BUFS_FIELD];
842035ea:	92 f0 00 88 	r0 = M[r7 + 0];
   r0 = M[r0];
842035ee:	12 e8       	r0 = M[r0 + Null];
   call $cbuffer.get_read_address_and_size_and_start_address;
842035f0:	ff fd 48 f1 	call (m) 0x2c6a4;
842035f4:	35 e5 
   r3 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.LAST_SPKR_ADDR_FIELD];
842035f6:	95 f0 0e 88 	r3 = M[r7 + 56];
   M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.LAST_SPKR_ADDR_FIELD] = r0;
842035fa:	92 f0 0e 8e 	M[r7 + 56] = r0;
   r3 = r0 - r3;
842035fe:	55 05       	r3 = r0 - r3;
   if NEG r3 = r3 + r1;
84203600:	34 f5 05 c0 	if NEG r3 = r3 + r1;
   BUFFER_ADDRS_TO_WORDS_ASM(r3);
84203604:	6d 58       	r3 = r3 ASHIFT -2;
   M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.AMOUNT_TO_MIX_FIELD] = r3;
84203606:	95 f0 0f 8e 	M[r7 + 60] = r3;
   pop rlink;
8420360a:	00 f4 3d cf 	pop rLink;
   rts;
8420360e:	d8 4c       	rts;

84203610 <$cbops.aec_ref_sidetone_op.pre_main>:
// TRASHED REGISTERS:
//    Assume anything except r4 and r8
//
// *****************************************************************************
$cbops.aec_ref_sidetone_op.pre_main:
   push rLink;
84203610:	00 f0 3d cf 	push rLink;
   /* Force processing */
#ifdef PATCH_LIBS
   LIBS_SLOW_SW_ROM_PATCH_POINT($cbops.aec_ref_sidetone_op.pre_main.PATCH_ID_0, r6)
#endif
   call $cbops.force_processing;
84203614:	ff fd c3 f2 	call 0x5bdac;
84203618:	38 ec 
   pop rlink;
8420361a:	00 f4 3d cf 	pop rLink;
   rts;
8420361e:	d8 4c       	rts;

84203620 <$cbops.aec_ref_sidetone_op.post_main>:
// *****************************************************************************
$cbops.aec_ref_sidetone_op.post_main:
#ifdef PATCH_LIBS
   LIBS_SLOW_SW_ROM_PATCH_POINT($cbops.aec_ref_sidetone_op.post_main.PATCH_ID_0, r7)
#endif
   push rlink;
84203620:	00 f0 3d cf 	push rLink;

   // Get data pointer
   r7 = M[r8 + $cbops.param_hdr.OPERATOR_DATA_PTR_FIELD];
84203624:	a9 f0 00 88 	r7 = M[r8 + 0];

   // get speaker buffer
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SPKR_BUFS_FIELD];
84203628:	92 f0 00 88 	r0 = M[r7 + 0];
   r0 = M[r0];
8420362c:	12 e8       	r0 = M[r0 + Null];
   call $cbuffer.get_read_address_and_size_and_start_address;
8420362e:	ff fd 48 f1 	call (m) 0x2c6a4;
84203632:	37 e3 
   I0 = r0;
84203634:	10 0a       	I0 = r0 + Null;
   L0 = r1;
84203636:	1c 0b       	L0 = r1 + Null;
   push r2;
84203638:	00 f0 34 cf 	push r2;
   pop B0;
8420363c:	00 f6 3a cf 	pop B0;
   // save read address for later use
   I6 = r0;
84203640:	16 0a       	I6 = r0 + Null;
   // I6 = read address of first speaker buffer

   // get threshold
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SAFETY_THRESHOLD_LOW_FIELD];
84203642:	92 f0 06 88 	r0 = M[r7 + 24];
   BUFFER_WORDS_TO_ADDRS_ASM(r0);
84203646:	52 5c       	r0 = r0 ASHIFT 2;
   M0 = r0;
84203648:	10 0b       	M0 = r0 + Null;

   // r6 = spkr_rd + threshold_low
   r0 = M[I0, M0];
8420364a:	20 f0 20 c0 	Null = Null + Null, r0 = M[I0,M0];
   r6 = I0;
8420364e:	80 09       	r6 = I0 + Null;

   // r5 = spkr_rd + threshold_high
   I0 = I6;
84203650:	b0 0a       	I0 = I6 + Null;
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SAFETY_THRESHOLD_HIGH_FIELD];
84203652:	92 f0 07 88 	r0 = M[r7 + 28];
   BUFFER_WORDS_TO_ADDRS_ASM(r0);
84203656:	52 5c       	r0 = r0 ASHIFT 2;
   M0 = r0;
84203658:	10 0b       	M0 = r0 + Null;
   r0 = M[I0, M0];
8420365a:	20 f0 20 c0 	Null = Null + Null, r0 = M[I0,M0];
   r5 = I0;
8420365e:	87 08       	r5 = I0 + Null;

   r0 = r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SPKR_MIXING_OFFSETS_FIELD;
84203660:	92 f0 0c 20 	r0 = r7 + 12;
   r0 = M[r0];
84203664:	12 e8       	r0 = M[r0 + Null];
   I0 = r0;
84203666:	10 0a       	I0 = r0 + Null;
   I7 = r0;
84203668:	17 0a       	I7 = r0 + Null;
   //            r0
   // --|----|---^---|-------------------------------------|--
   //   RD   Low     High                                 WR
   //
   // ====================================================================
   Null = r5 - r6;
8420366a:	8f f7 00 c2 	Null = r5 - r6;
   if NEG jump neg_part;
8420366e:	04 f0 95 e0 	if NEG jump (m) $M.cbops.aec_ref_sidetone_op.neg_part;

84203672 <$M.cbops.aec_ref_sidetone_op.pos_part>:
   pos_part:
      // expect: r6 <= r0 < r5
      Null = r0 - r5;
84203672:	d0 05       	Null = r0 - r5;
      if POS jump reset_mixing_offset;
84203674:	05 f0 9d e0 	if POS jump (m) $M.cbops.aec_ref_sidetone_op.reset_mixing_offset;
      Null = r0 - r6;
84203678:	8f f2 00 c2 	Null = r0 - r6;
      if NEG jump reset_mixing_offset;
8420367c:	04 f0 95 e0 	if NEG jump (m) $M.cbops.aec_ref_sidetone_op.reset_mixing_offset;
      jump mixing_point_check_done;
84203680:	1a 6e       	jump (m) $M.cbops.aec_ref_sidetone_op.mixing_point_check_done;

84203682 <$M.cbops.aec_ref_sidetone_op.neg_part>:

   neg_part:
      // expect: r0 < r5 or r0 >= r6
      Null = r0 - r6;
84203682:	8f f2 00 c2 	Null = r0 - r6;
      if POS jump mixing_point_check_done;
84203686:	05 f0 af e0 	if POS jump (m) $M.cbops.aec_ref_sidetone_op.mixing_point_check_done;
      Null = r0 - r5;
8420368a:	d0 05       	Null = r0 - r5;
      if NEG jump mixing_point_check_done;
8420368c:	04 f0 a9 e0 	if NEG jump (m) $M.cbops.aec_ref_sidetone_op.mixing_point_check_done;

84203690 <$M.cbops.aec_ref_sidetone_op.reset_mixing_offset>:

reset_mixing_offset:
   /* reset mixing offset */
   r1 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SAFETY_SET_THRESHOLD_FIELD];
84203690:	93 f0 08 88 	r1 = M[r7 + 32];
   BUFFER_WORDS_TO_ADDRS_ASM(r1);
84203694:	5b 5c       	r1 = r1 ASHIFT 2;
   M0 = r1;
84203696:	18 0b       	M0 = r1 + Null;
   I0 = I6;
84203698:	b0 0a       	I0 = I6 + Null;
   r1 = M[I0, M0];
8420369a:	30 f0 20 c0 	Null = Null + Null, r1 = M[I0,M0];

   // update debug counter showing mixing offset has been re-aligned
   r2 = I0 - r0;
8420369e:	2f f0 84 c6 	r2 = I0 - r0;
   if NEG r2 = r2 + L0;
842036a2:	c4 f4 44 c4 	if NEG r2 = r2 + L0;
   BUFFER_ADDRS_TO_WORDS_ASM(r2);
842036a6:	64 58       	r2 = r2 ASHIFT -2;
   r1 = M[r7+ $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SIDETONE_ALIGNED_SAMPLES_FIELD];
842036a8:	93 f0 0d 88 	r1 = M[r7 + 52];
   r1 = r1 + r2;
842036ac:	e3 00       	r1 = r2 + r1;
   M[r7+ $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SIDETONE_ALIGNED_SAMPLES_FIELD] = r1;
842036ae:	93 f0 0d 8e 	M[r7 + 52] = r1;

   // r0 = mixing offset updated
   r0 = I0;
842036b2:	82 08       	r0 = I0 + Null;

842036b4 <$M.cbops.aec_ref_sidetone_op.mixing_point_check_done>:
   // L0 = speaker buffer length
   // I6 = speaker buffer read address

   // work out the distance between HW read address and
   // mixing address in samples
   push B0;
842036b4:	00 f2 3a cf 	push B0;
   pop r1;
842036b8:	00 f4 33 cf 	pop r1;
   r1 = r0 - I6;
842036bc:	6f f2 43 c6 	r1 = r0 - I6;
   if NEG r1 = r1 + L0;
842036c0:	c4 f3 43 c4 	if NEG r1 = r1 + L0;
   BUFFER_ADDRS_TO_WORDS_ASM(r1);
842036c4:	5b 58       	r1 = r1 ASHIFT -2;

   // get amount to mix
   r5 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.AMOUNT_TO_MIX_FIELD];
842036c6:	97 f0 0f 88 	r5 = M[r7 + 60];
   // r1 = distance before mixing
   // r3 = distance after mixing
   r3 = r5 + r1;
842036ca:	fd 00       	r3 = r5 + r1;

   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SPKR_THRESHOLD_FIELD];
842036cc:	92 f0 09 88 	r0 = M[r7 + 36];
   r1 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SAFETY_THRESHOLD_LOW_FIELD];
842036d0:	93 f0 06 88 	r1 = M[r7 + 24];
   r2 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SAFETY_THRESHOLD_HIGH_FIELD];
842036d4:	94 f0 07 88 	r2 = M[r7 + 28];
   r9 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SAFETY_SET_THRESHOLD_FIELD];
842036d8:	9b f0 08 88 	r9 = M[r7 + 32];
   r1 = r0 + r1;   // low threshold after mixing
842036dc:	d3 00       	r1 = r0 + r1;
   r2 = r0 + r2;   // high threshold after mixing
842036de:	14 01       	r2 = r0 + r2;
   r9 = r0 + r9;   // good threshold after mixing
842036e0:	13 0d       	r9 = r0 + r9;

   // r6 = samples to insert
   r6 = 0;
842036e2:	00 09       	r6 = Null + Null;

   // expect r1 < r3 < r2
   r0 = r1 - r3;
842036e4:	5a 05       	r0 = r1 - r3;
   if GT jump insert_sidetone;
842036e6:	0c 6a       	if GT jump (m) $M.cbops.aec_ref_sidetone_op.insert_sidetone;
   r0 = r3 - r2;
842036e8:	2a 05       	r0 = r3 - r2;
   if LE jump mix_sidetone;
842036ea:	12 6c       	if LE jump (m) $M.cbops.aec_ref_sidetone_op.mix_sidetone;

842036ec <$M.cbops.aec_ref_sidetone_op.discard_sidetone>:

discard_sidetone:
   // discard here means ignore, we are doing in-place mixing
   // actual discard if needed will be done by sink_overflow_disgard operator
   r1 = r5 - r9;
842036ec:	bf f7 03 c2 	r1 = r5 - r9;
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SIDETONE_DISCARDED_SAMPLES_FIELD];
842036f0:	92 f0 0a 88 	r0 = M[r7 + 40];
   r0 = r0 + r1;
842036f4:	9a 00       	r0 = r1 + r0;
   M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SIDETONE_DISCARDED_SAMPLES_FIELD] = r0;
842036f6:	92 f0 0a 8e 	M[r7 + 40] = r0;
   r5 = r9;
842036fa:	5f 08       	r5 = r9 + Null;
   jump mix_sidetone;
842036fc:	09 6e       	jump (m) $M.cbops.aec_ref_sidetone_op.mix_sidetone;

842036fe <$M.cbops.aec_ref_sidetone_op.insert_sidetone>:

insert_sidetone:
   // we don't have enough samples to mix, we needs to mix
   // the difference, it will be mixing using last mixed sample
   r6 = r9 - r5;
842036fe:	7f fb 08 c2 	r6 = r9 - r5;
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SIDETONE_INSERTED_SAMPLES_FIELD];
84203702:	92 f0 0b 88 	r0 = M[r7 + 44];
   r0 = r0 + r6;
84203706:	42 0c       	r0 = r6 + r0;
   M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SIDETONE_INSERTED_SAMPLES_FIELD] = r0;
84203708:	92 f0 0b 8e 	M[r7 + 44] = r0;
   r5 = r9;
8420370c:	5f 08       	r5 = r9 + Null;

8420370e <$M.cbops.aec_ref_sidetone_op.mix_sidetone>:
mix_sidetone:

   // M0 = amount to adjust
   M0 = I0 - I7;
8420370e:	7f f0 c8 c7 	M0 = I0 - I7;
   if NEG M0 = M0 + L0;
84203712:	c4 f8 c8 c5 	if NEG M0 = M0 + L0;

   // get number of speakers (1 or 2)
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.NR_SPKRS_FIELD];
84203716:	92 f0 02 88 	r0 = M[r7 + 8];
   M3 = r0;
8420371a:	13 0b       	M3 = r0 + Null;

   // mixing offset address
   I2 = r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SPKR_MIXING_OFFSETS_FIELD;
8420371c:	92 f8 0c 20 	I2 = r7 + 12;

   // Get sidetone buffer and see how much we need to read
   r0 = M[r8 + $cbops.param_hdr.CHANNEL_INDEX_START_FIELD];
84203720:	a2 f0 03 88 	r0 = M[r8 + 12];
   call $cbops.get_cbuffer;
84203724:	ff fd c3 f2 	call 0x5bd8c;
84203728:	28 e3 
   I5 = r0;
8420372a:	15 0a       	I5 = r0 + Null;

   // see how much data is in sidetone buffer
   call $cbuffer.calc_amount_data_in_words;
8420372c:	ff fd 45 f1 	call (m) 0x2c208;
84203730:	3d e6 
   r3 = r0;
84203732:	15 00       	r3 = r0 + Null;
   r0 = M[r8 + $cbops.param_hdr.CHANNEL_INDEX_START_FIELD];
84203734:	a2 f0 03 88 	r0 = M[r8 + 12];
   call $cbops.get_amount_ptr;
84203738:	ff fd c3 f2 	call 0x5bd9c;
8420373c:	24 e3 
   r0 = M[r0];
8420373e:	12 e8       	r0 = M[r0 + Null];
   r0 = r0 + r3;
84203740:	aa 00       	r0 = r3 + r0;
   // r0: amount we have
   // r5: amount we need
   // r6: amount to invent
   r1 = r5 - r0;
84203742:	bb 04       	r1 = r5 - r0;
   if LE jump enough_data;
84203744:	03 6c       	if LE jump (m) $M.cbops.aec_ref_sidetone_op.enough_data;
      // Limit to amount available
      r5 = r5 - r1;
84203746:	ff 04       	r5 = r5 - r1;
      r6 = r6 + r1;
84203748:	18 0d       	r6 = r1 + r6;

8420374a <$M.cbops.aec_ref_sidetone_op.enough_data>:
   enough_data:

   r0 = I5;
8420374a:	aa 08       	r0 = I5 + Null;
   call $cbuffer.get_read_address_and_size_and_start_address;
8420374c:	ff fd 47 f1 	call (m) 0x2c6a4;
84203750:	39 ea 
   I7 = r0;
84203752:	17 0a       	I7 = r0 + Null;
   L4 = r1;
84203754:	1e 0b       	L4 = r1 + Null;
   push r2;
84203756:	00 f0 34 cf 	push r2;
   pop B4;
8420375a:	00 f6 3c cf 	pop B4;

   // speaker buffers
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SPKR_BUFS_FIELD];
8420375e:	92 f0 00 88 	r0 = M[r7 + 0];
   I3 = r0;
84203762:	13 0a       	I3 = r0 + Null;

84203764 <$M.cbops.aec_ref_sidetone_op.channel_mixing_loop>:

channel_mixing_loop:

      // get base address for this speaker channel
      r0 = M[I3, MK1];
84203764:	2d f0 30 c0 	Null = Null + Null, r0 = M[I3,4];
      r0 = M[r0 + $cbuffer.START_ADDR_FIELD];
84203768:	d2 88       	r0 = M[r0 + 12];
      push r0;
8420376a:	00 f0 32 cf 	push r0;
      pop B0;
8420376e:	00 f6 3a cf 	pop B0;

      // get sidetone buffer
      I4 = I7;
84203772:	bc 0a       	I4 = I7 + Null;

      // get speaker mixing point
      r0 = M[I2, 0];
84203774:	28 f0 30 c0 	Null = Null + Null, r0 = M[I2,0];
      I0 = r0;
84203778:	10 0a       	I0 = r0 + Null;

      // M0 is amount to fix the mixing point (should be 0 in normal condition)
      r0 = M[I0, M0];
8420377a:	20 f0 20 c0 	Null = Null + Null, r0 = M[I0,M0];

      // get last sidetone sample
      r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.LAST_SIDETONE_SAMPLE_FIELD];
8420377e:	92 f0 0c 88 	r0 = M[r7 + 48];

      r2 = 1.0;
84203782:	ff f7 f4 f7 	r2 = Null + 2147483647;
84203786:	ff 7b 

      // r5 = sidetone samples to read and mix
      // r6 = sidetone samples to invent and mix
      r10 = r6;
84203788:	44 09       	r10 = r6 + Null;
      if Z jump insert_done;
8420378a:	08 60       	if EQ jump (m) $M.cbops.aec_ref_sidetone_op.insert_done;
      do insert_loop;
8420378c:	07 4c       	do (m) $M.cbops.aec_ref_sidetone_op.insert_done;
         rMAC = M[I0, 0];
8420378e:	10 f0 30 c0 	Null = Null + Null, rMAC = M[I0,0];
         rMAC = rMAC + r0 * r2;
84203792:	4f f2 c1 ca 	rMAC = rMAC + r0 * r2 (SS);
         M[I0, MK1] = rMAC;
84203796:	91 f0 30 c0 	Null = Null + Null, M[I0,4] = rMAC;

8420379a <$M.cbops.aec_ref_sidetone_op.insert_done>:
      insert_loop:

      insert_done:
      r10 = r5;
8420379a:	3c 09       	r10 = r5 + Null;
      do mix_loop;
8420379c:	07 4c       	do (m) $M.cbops.aec_ref_sidetone_op.mix_loop;
         rMAC = M[I0, 0], r0 = M[I4,MK1];
8420379e:	21 f0 31 d0 	Null = Null + Null, rMAC = M[I0,0], r0 = M[I4,4];
         rMAC = rMAC + r0 * r2;
842037a2:	4f f2 c1 ca 	rMAC = rMAC + r0 * r2 (SS);
         M[I0, MK1] = rMAC;
842037a6:	91 f0 30 c0 	Null = Null + Null, M[I0,4] = rMAC;

842037aa <$M.cbops.aec_ref_sidetone_op.mix_loop>:
      mix_loop:
      M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.LAST_SIDETONE_SAMPLE_FIELD] = r0;
842037aa:	92 f0 0c 8e 	M[r7 + 48] = r0;

      // update mixing point for next time
      r1 = I0;
842037ae:	83 08       	r1 = I0 + Null;
      M[I2, MK1] = r1;
842037b0:	b9 f0 30 c0 	Null = Null + Null, M[I2,4] = r1;
   // next channel
   M3 = M3 - 1;
842037b4:	bb fc 01 24 	M3 = M3 - 1;
   if GT jump channel_mixing_loop;
842037b8:	d6 6b       	if GT jump (m) $M.cbops.aec_ref_sidetone_op.channel_mixing_loop;

   // update sidetone buffer
   r0 = I5;
842037ba:	aa 08       	r0 = I5 + Null;
   r1 = I4;
842037bc:	a3 08       	r1 = I4 + Null;
   call $cbuffer.set_read_address;
842037be:	ff fd 47 f1 	call (m) 0x2c708;
842037c2:	2b ea 

   pop rlink;
842037c4:	00 f4 3d cf 	pop rLink;
   rts;
842037c8:	d8 4c       	rts;

842037ca <$_aec_ref_sidetone_initialise>:
// TRASHED REGISTERS:
//    r0 (C callable)
//
// *****************************************************************************
$_aec_ref_sidetone_initialise:
   push rLink;
842037ca:	00 f0 3d cf 	push rLink;
   pushm <I2,I3>;
842037ce:	00 f0 4c e4 	pushm <I2, I3>;
   pushm <r1,r2,r3,r7>;
842037d2:	23 f0 48 e0 	pushm <r1, r2, r3, r7>;

   // here we got pointer to the cbops structure, so need to get to the
   // parameter struct first.
   r7 = M[r0 + ($cbops_c.cbops_op_struct.PARAMETER_AREA_START_FIELD+$cbops.param_hdr.OPERATOR_DATA_PTR_FIELD)];
842037d6:	29 f0 03 88 	r7 = M[r0 + 12];

   // save the read address of first speaker buffer, we use this to see how many
   // samples speaker has read since last run
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SPKR_BUFS_FIELD];
842037da:	92 f0 00 88 	r0 = M[r7 + 0];
   r0 = M[r0];
842037de:	12 e8       	r0 = M[r0 + Null];
   call $cbuffer.get_read_address_and_size_and_start_address;
842037e0:	ff fd 47 f1 	call (m) 0x2c6a4;
842037e4:	25 e6 

   /* initialise mixing points */
   M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.LAST_SPKR_ADDR_FIELD] = r0;
842037e6:	92 f0 0e 8e 	M[r7 + 56] = r0;
   r10 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.NR_SPKRS_FIELD];
842037ea:	9c f0 02 88 	r10 = M[r7 + 8];
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SPKR_BUFS_FIELD];
842037ee:	92 f0 00 88 	r0 = M[r7 + 0];
   I2 = r0;
842037f2:	12 0a       	I2 = r0 + Null;
   I3 = r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SPKR_MIXING_OFFSETS_FIELD;
842037f4:	93 f8 0c 20 	I3 = r7 + 12;
   do init_mixing_points;
842037f8:	06 4c       	do (m) $M.cbops.aec_ref_sidetone_op.init_mixing_points;
      r0 = M[I2, MK1];   // get speaker buffer
842037fa:	29 f0 30 c0 	Null = Null + Null, r0 = M[I2,4];
      r0 = M[r0 + $cbuffer.START_ADDR_FIELD];
842037fe:	d2 88       	r0 = M[r0 + 12];
      M[I3, MK1] = r0;   // mixing point
84203800:	ad f0 30 c0 	Null = Null + Null, M[I3,4] = r0;

84203804 <$M.cbops.aec_ref_sidetone_op.init_mixing_points>:
   init_mixing_points:

   popm <r1,r2,r3,r7>;
84203804:	23 f0 68 e0 	popm <r1, r2, r3, r7>;
   popm <I2,I3>;
84203808:	00 f0 6c e4 	popm <I2, I3>;
   pop rLink;
8420380c:	00 f4 3d cf 	pop rLink;
   rts;
84203810:	d8 4c       	rts;

84203812 <$_create_mute_op>:
.MODULE $M.download_support_lib.create_mute_op;
.CODESEGMENT PM;
.MINIM;

$_create_mute_op:
    rMAC = M[$_patched_fw_version];
84203812:	01 f0 4b 98 	rMAC = M[Null + 0x92c];
    Null = rMAC - PATCH_BUILD_ID;
84203816:	00 f0 10 f2 	Null = rMAC - 10748;
8420381a:	fc 35 
    if EQ jump PATCH_ENTRY_CREATE_MUTE_OP;
8420381c:	fc ff 00 f0 	if EQ jump (m) 0x4003baa;
84203820:	8f e7 

84203822 <$M.download_support_lib.create_mute_op.L_pb_mismatch>:

L_pb_mismatch:
    /* Stub: return false; */
    r0 = 0;
84203822:	02 00       	r0 = Null + Null;
    rts;
84203824:	d8 4c       	rts;

84203826 <$_set_aec_reference_not_running_from_rom>:
.CODESEGMENT PM;
.MINIM;
$_set_aec_reference_not_running_from_rom:
#ifndef DISABLE_PATCH_BUILD_ID_CHECK
    // panic if not using the right patch
    r0 = 0;
84203826:	02 00       	r0 = Null + Null;
    rMAC = M[$_patched_fw_version];
84203828:	01 f0 4b 98 	rMAC = M[Null + 0x92c];
    Null = rMAC - PATCH_BUILD_ID;
8420382c:	00 f0 10 f2 	Null = rMAC - 10748;
84203830:	fc 35 
    if NZ call $error;
84203832:	f1 fd 49 f1 	if NE call (m) 0x2cb9c;
84203836:	2b eb 
    // if we have patch entry for setting the downloadable flag
    // then go to that patch.
    jump PATCH_ENTRY_SET_AEC_REFERENCE_NOT_RUNNING_FROM_ROM;
#else
   // otherwise quietly return
   rts;
84203838:	d8 4c       	rts;

8420383a <$_setup_cbops_dc_offset_compensation>:
#ifdef DISABLE_PATCH_BUILD_ID_CHECK
   .const $_setup_cbops_dc_offset_compensation PATCH_ENTRY_SETUP_CBOPS_DC_OFFSET_COMPENSATION;
#else /* PATCH_ENTRY_SETUP_CBOPS_DC_OFFSET_COMPENSATION */
$_setup_cbops_dc_offset_compensation:
   /* Check patch version */
    rMAC = M[$_patched_fw_version];
8420383a:	01 f0 4b 98 	rMAC = M[Null + 0x92c];
    Null = rMAC - PATCH_BUILD_ID;
8420383e:	00 f0 10 f2 	Null = rMAC - 10748;
84203842:	fc 35 
    if EQ jump PATCH_ENTRY_SETUP_CBOPS_DC_OFFSET_COMPENSATION;
84203844:	fc ff 60 f0 	if EQ jump (m) 0x4006b00;
84203848:	bd e5 

8420384a <$M.download_support_lib.setup_cbops_dc_offset_compensation.return_null>:
#endif
return_null:
   /* if not matching then just return NULL,
    * so no dc offset op created/added
    */
    r0 = 0;
8420384a:	02 00       	r0 = Null + Null;
    rts;
8420384c:	d8 4c       	rts;

8420384e <$cbops.multichan_sidetone_mix_op.main>:
//    r0-r3, r5, r6, r7, r9, r10, rMAC, M1-M3, I0-I7, L0, L1, L4, DoLoop
//
// *****************************************************************************
$cbops.multichan_sidetone_mix_op.main:
   // push rLink onto stack
   push rLink;
8420384e:	00 f0 3d cf 	push rLink;

   r7 = M[r8 + $cbops.param_hdr.OPERATOR_DATA_PTR_FIELD];
84203852:	a9 f0 00 88 	r7 = M[r8 + 0];

   // used throughout this function
   M1 = MK1;
84203856:	21 73       	M1 = Null + 4;
   // Go through all sidetone buffers and and find minimum
   // amount of data among them.
   // Note: We could just look at first buffer since we expect
   // all sidetone buffers to be synchronised but this will
   // prevent failing in dramatic way if they aren't synced.
   r6 = 0x7FFF; // start with reasonably large value
84203858:	38 f0 ff 7b 	r6 = Null + 32767;
   r10 = M[r7 + $cbops_sidetone_mix_op.multichan_st_mix_struct.NR_ST_CHANNELS_FIELD];
8420385c:	9c f0 04 88 	r10 = M[r7 + 16];
   I6 = r7 + $cbops_sidetone_mix_op.multichan_st_mix_struct.ST_IDXS_FIELD;
84203860:	96 f8 14 20 	I6 = r7 + 20;
   // r6: Minimum amount of data in sidetone buffers
   do sidetone_buffers_get_amount_loop;
84203864:	0b 4c       	do (m) $M.cbops.sidetone_mix_op.sidetone_buffers_get_amount_loop;
      // Get buffer index for sidetone buffer
      r0 = M[I6, M1];
84203866:	29 f0 20 d0 	Null = Null + Null, r0 = M[I6,M1];

      // get sidetone buffer
      call $cbops.get_cbuffer;
8420386a:	ff fd c2 f2 	call 0x5bd8c;
8420386e:	22 e9 

      // get the amount of sidetone data
      call $cbuffer.calc_amount_data_in_words;
84203870:	ff fd 44 f1 	call (m) 0x2c208;
84203874:	39 ec 

      // r6 holds minimum data in all connected sidetone channels
      r6  = MIN r0;
84203876:	5f f2 48 ce 	r6 = MIN r0;

8420387a <$M.cbops.sidetone_mix_op.sidetone_buffers_get_amount_loop>:
  sidetone_buffers_get_amount_loop:

   // Get transfer amount from input to output
   //  r0: transfer amount in samples
   //  r9: offset to output channels in addrs (from the start of index table)
   call $cbops.get_transfer_and_update_multi_channel;
8420387a:	ff fd c2 f2 	call 0x5bcec;
8420387e:	32 e3 

   // M3: amount of sidetone to invent this run
   //     if sidetone buffers don't have enough data.
   M3 = r0 - r6;
84203880:	8f f2 0b c7 	M3 = r0 - r6;
   if NEG M3 = 0;
84203884:	04 f0 0b c5 	if NEG M3 = Null + Null;

   // update insert counter
   r1 = M[r7 + $cbops_sidetone_mix_op.multichan_st_mix_struct.NUM_INSERTS_FIELD];
84203888:	93 f0 01 88 	r1 = M[r7 + 4];
   r1 = r1 + M3;
8420388c:	db 0c       	r1 = M3 + r1;
   M[r7 +  $cbops_sidetone_mix_op.multichan_st_mix_struct.NUM_INSERTS_FIELD]=r1;
8420388e:	93 f0 01 8e 	M[r7 + 4] = r1;

   // M2: Amount of real sidetone that will be mixed this run
   M2 = r0 - M3;
84203892:	bf f2 4a c7 	M2 = r0 - M3;

   // If amount of sidetone after transfer is > 2*SIDETONE_MAX_SAMPLES_FIELD
   // drop sidetone to leave SIDETONE_MAX_SAMPLES_FIELD samples
   // r5 is amount to drop
   r1 = M[r7 + $cbops_sidetone_mix_op.multichan_st_mix_struct.MAX_SAMPLES_FIELD];
84203896:	93 f0 00 88 	r1 = M[r7 + 0];
   r0 = r6 - r0;    //Amount remaining sidetone samples in the buffers after mix
8420389a:	2f f8 02 c2 	r0 = r6 - r0;
   r5 = r0 - r1;    // remaining sidetone samples - SIDETONE_MAX_SAMPLES_FIELD
8420389e:	d7 04       	r5 = r0 - r1;
   NULL = r5 - r1;
842038a0:	f8 04       	Null = r5 - r1;
   if NEG r5 = NULL; // remaining data < 2*SIDETONE_MAX_SAMPLES_FIELD (no drop)
842038a2:	04 f0 07 c0 	if NEG r5 = Null + Null;

   // r5 sidetone samples are dropped to control latency, update the accumulator
   r2 = M[r7 + $cbops_sidetone_mix_op.multichan_st_mix_struct.NUM_DROPS_FIELD];
842038a6:	94 f0 02 88 	r2 = M[r7 + 8];
   r2 = r2 + r5;
842038aa:	3c 01       	r2 = r5 + r2;
   M[r7 + $cbops_sidetone_mix_op.multichan_st_mix_struct.NUM_DROPS_FIELD]=r2;
842038ac:	94 f0 02 8e 	M[r7 + 8] = r2;

   // Total sidetone samples consumed =
   //   M2: mixed sidetone samples +
   //   r5: dropped sidetone samples
   r5 = M2 + r5;
842038b0:	d7 0c       	r5 = M2 + r5;

   // Go through all sidetone buffers and
   // update transfer amount (=r5)
   r10 = M[r7 + $cbops_sidetone_mix_op.multichan_st_mix_struct.NR_ST_CHANNELS_FIELD];
842038b2:	9c f0 04 88 	r10 = M[r7 + 16];
   I6 = r7 + $cbops_sidetone_mix_op.multichan_st_mix_struct.ST_IDXS_FIELD;
842038b6:	96 f8 14 20 	I6 = r7 + 20;
   do sidetone_buffers_update_transfer_amount_loop;
842038ba:	07 4c       	do (m) $M.cbops.sidetone_mix_op.sidetone_buffers_update_transfer_amount_loop;
      r0 = M[I6, M1];
842038bc:	29 f0 20 d0 	Null = Null + Null, r0 = M[I6,M1];
      call $cbops.get_amount_ptr;
842038c0:	ff fd c2 f2 	call 0x5bd9c;
842038c4:	3c e6 
      M[r0] = r5;
842038c6:	87 ee       	M[Null + r0] = r5;

842038c8 <$M.cbops.sidetone_mix_op.sidetone_buffers_update_transfer_amount_loop>:
   sidetone_buffers_update_transfer_amount_loop:

   // see if we have something to transfer
   // from input to output
   NULL = M2 + M3;
842038c8:	bf fa c0 c4 	Null = M2 + M3;
   if LE jump all_done;
842038cc:	6c 6c       	if LE jump (m) $M.cbops.sidetone_mix_op.all_done;

   // set M0 to number of channels
   r0 = M[r7 + $cbops_sidetone_mix_op.multichan_st_mix_struct.NR_CHANNELS_FIELD];
842038ce:	92 f0 03 88 	r0 = M[r7 + 12];
   M0 = r0;
842038d2:	10 0b       	M0 = r0 + Null;

   // set I6 to sidetone map indexes
   r0 = M[r7 + $cbops_sidetone_mix_op.multichan_st_mix_struct.NR_ST_CHANNELS_FIELD];
842038d4:	92 f0 04 88 	r0 = M[r7 + 16];
   Words2Addr(r0);
842038d8:	52 5c       	r0 = r0 ASHIFT 2;
   I6 = r7 +  $cbops_sidetone_mix_op.multichan_st_mix_struct.ST_IDXS_FIELD;
842038da:	96 f8 14 20 	I6 = r7 + 20;
   I6 = I6 + r0;
842038de:	16 0e       	I6 = r0 + I6;

   // set I2 to input indexes
   I2 = r8 + $cbops.param_hdr.CHANNEL_INDEX_START_FIELD;
842038e0:	a2 f8 0c 20 	I2 = r8 + 12;

   // set I3 to output indexes
   I3 = I2 + r9;
842038e4:	bf f2 83 c5 	I3 = I2 + r9;

   // Sidetone attenuation (0dB)
   r5 = 1.0;
842038e8:	ff f7 f7 f7 	r5 = Null + 2147483647;
842038ec:	ff 7b 

842038ee <$M.cbops.sidetone_mix_op.transfer_and_sidetone_mix_channel_loop>:

   transfer_and_sidetone_mix_channel_loop:
      // get input, output and sidetone indexes
      // for this channel
      r0 = M[I6, M1];          // get sidetone index
842038ee:	29 f0 20 d0 	Null = Null + Null, r0 = M[I6,M1];
      r7 = r0, r0 = M[I3, M1]; // get output index
842038f2:	2d f0 0f f2 	r7 = r0 + Null, r0 = M[I3,M1];
842038f6:	09 c0 
      r3 = r0, r0 = M[I2, M1]; // get input index
842038f8:	29 f0 0f f2 	r3 = r0 + Null, r0 = M[I2,M1];
842038fc:	05 c0 
      I7 = r3 - r0;
842038fe:	2f f5 07 c7 	I7 = r3 - r0;
      // r3 = output index
      // r0 = input index
      // I7 = output index - input index (useful to skip transfer only)

      // Setup Input Buffer
      call $cbops.get_buffer_address_and_length;
84203902:	ff fd c2 f2 	call 0x5bd20;
84203906:	3e e0 
      I0 = r0;
84203908:	10 0a       	I0 = r0 + Null;
      if Z jump transfer_and_sidetone_mix_next_channel;
8420390a:	3f 60       	if EQ jump (m) $M.cbops.sidetone_mix_op.just_transfer_loop;
      L0 = r1;
8420390c:	1c 0b       	L0 = r1 + Null;
      push r2;
8420390e:	00 f0 34 cf 	push r2;
      pop B0;
84203912:	00 f6 3a cf 	pop B0;

      // Setup Output Buffer
      r0 = r3;
84203916:	2a 00       	r0 = r3 + Null;
      call $cbops.get_buffer_address_and_length;
84203918:	ff fd c2 f2 	call 0x5bd20;
8420391c:	28 e0 
      I4 = r0;
8420391e:	14 0a       	I4 = r0 + Null;
      if Z jump transfer_and_sidetone_mix_next_channel;
84203920:	34 60       	if EQ jump (m) $M.cbops.sidetone_mix_op.just_transfer_loop;
      L4 = r1;
84203922:	1e 0b       	L4 = r1 + Null;
      push r2;
84203924:	00 f0 34 cf 	push r2;
      pop B4;
84203928:	00 f6 3c cf 	pop B4;

      // setup sidetone buffer
      r0 = r7;
8420392c:	4a 08       	r0 = r7 + Null;
      // if not mapped to any sidetone buffer just
      // simple transfer from input to output
      if NEG jump just_transfer_input_to_output;
8420392e:	04 f0 c9 e0 	if NEG jump (m) $M.cbops.sidetone_mix_op.just_transfer_input_to_output;
      call $cbops.get_buffer_address_and_length;
84203932:	ff fd c1 f2 	call 0x5bd20;
84203936:	2e ef 
      push r2;
84203938:	00 f0 34 cf 	push r2;
      pop B1;
8420393c:	00 f6 3b cf 	pop B1;
      // set the length & get the first input sample
      I1 = r0;
84203940:	11 0a       	I1 = r0 + Null;
      L1 = r1, rMAC = M[I0,M1];
84203942:	11 f0 3f f0 	L1 = Null + r1, rMAC = M[I0,M1];
84203946:	0d c5 
      // I1/L1/B1 = Sidetone buffer
      // I0/L0/B0 = Input buffer
      // I4/L4/B4 = Output buffer

      // Mixing loop
      r10 = M2;
84203948:	d4 09       	r10 = M2 + Null;
      do mix_real_sidetone_loop;
8420394a:	07 4c       	do (m) $M.cbops.sidetone_mix_op.mix_real_sidetone_loop;
         // calculate the current output sample and read a side tone sample
         r0 = M[I1,M1];
8420394c:	25 f0 20 c0 	Null = Null + Null, r0 = M[I1,M1];
         rMAC = rMAC + r0 * r5;
84203950:	7f f2 c1 ca 	rMAC = rMAC + r0 * r5 (SS);

         // get the next input value and write current output
         rMAC = M[I0,M1], M[I4,M1] = rMAC;
84203954:	91 f1 21 d0 	Null = Null + Null, rMAC = M[I0,M1], M[I4,M1] = rMAC;

84203958 <$M.cbops.sidetone_mix_op.mix_real_sidetone_loop>:
      mix_real_sidetone_loop:

      // continue only of we need to invent sidetone samples
      r10 = M3;
84203958:	dc 09       	r10 = M3 + Null;
      if Z jump transfer_and_sidetone_mix_next_channel;
8420395a:	17 60       	if EQ jump (m) $M.cbops.sidetone_mix_op.just_transfer_loop;
      // Repeat Last sample of sidetone buffer (insert sidetone samples)
      r0 = M[I1,-MK1];
8420395c:	27 f0 30 c0 	Null = Null + Null, r0 = M[I1,-4];
      r0 = M[I1,M1];
84203960:	25 f0 20 c0 	Null = Null + Null, r0 = M[I1,M1];
      // Ensure sidetone is connected repeat last sample, else mix silence
      NULL = r6;
84203964:	40 08       	Null = r6 + Null;
      if Z r0=NULL;
84203966:	00 f0 02 c0 	if EQ r0 = Null + Null;
      do mix_invented_sidetone_loop;
8420396a:	05 4c       	do (m) $M.cbops.sidetone_mix_op.mix_invented_sidetone_loop;
         // calculate the current output sample
         rMAC = rMAC + r0 * r5;
8420396c:	7f f2 c1 ca 	rMAC = rMAC + r0 * r5 (SS);
         // get the next input value and write the result
         rMAC = M[I0,M1], M[I4,M1] = rMAC;
84203970:	91 f1 21 d0 	Null = Null + Null, rMAC = M[I0,M1], M[I4,M1] = rMAC;

84203974 <$M.cbops.sidetone_mix_op.mix_invented_sidetone_loop>:
      mix_invented_sidetone_loop:
      jump transfer_and_sidetone_mix_next_channel;
84203974:	0a 6e       	jump (m) $M.cbops.sidetone_mix_op.just_transfer_loop;

84203976 <$M.cbops.sidetone_mix_op.just_transfer_input_to_output>:

      just_transfer_input_to_output:
      NULL = I7; // if output index == input index then skip transfer
84203976:	b8 08       	Null = I7 + Null;
      if Z jump transfer_and_sidetone_mix_next_channel;
84203978:	08 60       	if EQ jump (m) $M.cbops.sidetone_mix_op.just_transfer_loop;
      r10 = M2 + M3;
8420397a:	bf fa cc c4 	r10 = M2 + M3;
      do just_transfer_loop;
8420397e:	05 4c       	do (m) $M.cbops.sidetone_mix_op.just_transfer_loop;
         r0 = M[I0,M1];
84203980:	21 f0 20 c0 	Null = Null + Null, r0 = M[I0,M1];
         M[I4,M1] = r0;
84203984:	a1 f0 20 d0 	Null = Null + Null, M[I4,M1] = r0;

84203988 <$M.cbops.sidetone_mix_op.just_transfer_loop>:
      just_transfer_loop:
   transfer_and_sidetone_mix_next_channel:
   M0 = M0 - 1;
84203988:	88 fc 01 24 	M0 = M0 - 1;
   if NZ jump transfer_and_sidetone_mix_channel_loop;
8420398c:	b1 63       	if NE jump (m) $M.cbops.sidetone_mix_op.transfer_and_sidetone_mix_channel_loop;

   // zero the remaining length registers we have used
   L0 = 0;
8420398e:	04 0b       	L0 = Null + Null;
   L4 = 0;
84203990:	06 0b       	L4 = Null + Null;
   L1 = 0;
84203992:	05 0b       	L1 = Null + Null;
   push Null;
84203994:	00 f0 30 cf 	push Null;
   B0 = M[SP - 1*ADDR_PER_WORD];
84203998:	fe fa 1a cf 	B0 = M[SP + -0x4];
   B1 = M[SP - 1*ADDR_PER_WORD];
8420399c:	fe fa 1b cf 	B1 = M[SP + -0x4];
   pop B4;
842039a0:	00 f6 3c cf 	pop B4;

842039a4 <$M.cbops.sidetone_mix_op.all_done>:
all_done:
   // pop rLink from stack
   pop rLink;
842039a4:	00 f4 3d cf 	pop rLink;
   rts;
842039a8:	d8 4c       	rts;
