
/home/svc-audio-dspsw/kymera_builds/builds/2020/kymera_2004201807/kalimba/kymera/tools/KCSMaker/out/4786/stre_rom_v02_release/download/debugbin/download_aec_reference.elf:     file format elf32-littlekalimba

Disassembly of section .text_maxim:

84200000 <$_set_rate_monitor_new_amount_ptr>:
// *****************************************************************************
.MODULE $cbops.rate_monitor_op.set_rate_monitor_new_amount_ptr;
.CODESEGMENT PM;
.MAXIM;
$_set_rate_monitor_new_amount_ptr:
   NULL = r0;
84200000:	0f 00 02 00 	Null = r0 + Null;
   if Z rts;
84200004:	00 00 0d dc 	if EQ rts;
   push r3;
84200008:	00 00 50 f3 	push r3;
   r3 = M[r0 +   ($cbops_c.cbops_op_struct.PARAMETER_AREA_START_FIELD+$cbops.param_hdr.OPERATOR_DATA_PTR_FIELD)];
8420000c:	0c 00 52 d1 	r3 = M[r0 + 12];
   M[r3 + $cbops_rate_monitor_op.rate_monitor_op_struct.NEW_AMOUNT_PTR_FIELD] = r1;
84200010:	34 00 35 d5 	M[r3 + 52] = r1;
   pop r3;
84200014:	00 00 54 f3 	pop r3;
   rts;
84200018:	0f 00 0d dc 	rts;

8420001c <$_rate_monitor_op_initialise>:
// *****************************************************************************
.MODULE $cbops.rate_monitor_op.rate_monitor_op_initialise;
.CODESEGMENT PM;
.MAXIM;
$_rate_monitor_op_initialise:
   push rLink;
8420001c:	00 00 d0 f3 	push rLink;
   // run init function from ROM
   call $_rate_monitor_op_initiatlize;
84200020:	06 00 00 fd 	call 0x6bb84;
84200024:	84 bb f0 e1 
   // then do the extra init
   M[r0 + $cbops_rate_monitor_op.rate_monitor_op_struct.ACC_DRIFT_FIELD] = Null;
84200028:	3c 00 02 d5 	M[r0 + 60] = Null;
   M[r0 + $cbops_rate_monitor_op.rate_monitor_op_struct.EXPECTED_ACC_SUM_FIELD] = Null;
8420002c:	38 00 02 d5 	M[r0 + 56] = Null;
   M[r0 + $cbops_rate_monitor_op.rate_monitor_op_struct.STALL_FIELD] = NULL;
84200030:	20 00 02 d5 	M[r0 + 32] = Null;
   pop rLink;
84200034:	00 00 d4 f3 	pop rLink;
   rts;
84200038:	0f 00 0d dc 	rts;
Disassembly of section .text_minim:

8420003c <$_aec_reference_create>:
aec_latency_common *aec_latency_ptr = NULL;
#endif


bool aec_reference_create(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
8420003c:	f4 1d       	pushm <FP(=SP), r4, r5, r6, r7, rLink>, SP = SP + 0x10;
8420003e:	17 00       	r5 = r0 + Null;
84200040:	21 09       	r7 = r2 + Null;
84200042:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84200044:	3e 99       	r4 = M[r5 + 48];

    patch_fn_shared(aec_reference);

#ifdef CAPABILITY_DOWNLOAD_BUILD
    /* let the patches know it's not running from ROM */
    set_aec_reference_not_running_from_rom();
84200046:	1b f0 3f e1 	call (m) $_set_aec_reference_not_running_from_rom;
#endif

    /* Setup Response to Creation Request.   Assume Failure*/
    *response_id = OPCMD_CREATE;
8420004a:	90 f0 00 ee 	M[r7 + Null] = Null;
    if(!base_op_build_std_response(STATUS_CMD_FAILED,op_data->id,response_data))
8420004e:	7b 88       	r1 = M[r5 + 4];
84200050:	02 f0 00 60 	r0 = Null + 4096;
84200054:	44 08       	r2 = r6 + Null;
84200056:	ff fd 00 f0 	call (m) 0x204;
8420005a:	2f ed 
8420005c:	10 04       	Null = r0 - Null;
8420005e:	03 62       	if NE jump (m) Lc_aec_reference_create_3;

84200060 <Lc_aec_reference_create_2>:
    {
        return(FALSE);
84200060:	02 00       	r0 = Null + Null;
84200062:	6e 6e       	jump (m) Lc_aec_reference_create_14;

84200064 <Lc_aec_reference_create_3>:
    }

    /* Processing is in timer task.  This prevents kicks from
       propagating to the main processing function */
    op_data->stop_chain_kicks = TRUE;
84200064:	09 71       	r7 = Null + 1;
84200066:	79 f0 19 8a 	MB[r5 + 25] = r7;

    /* Initialize extended data for operator.  Assume intialized to zero*/
    op_extra_data->cap_id = op_data->cap_data->id;
8420006a:	79 89       	rMAC = M[r5 + 20];
8420006c:	09 e8       	rMAC = M[rMAC + Null];
8420006e:	61 f0 59 8e 	M[r4 + 356] = rMAC;
    op_extra_data->ReInitFlag = TRUE;
84200072:	49 08       	rMAC = r7 + Null;
84200074:	61 f0 5c 8e 	M[r4 + 368] = rMAC;
    op_extra_data->Cur_mode = AEC_REFERENCE_SYSMODE_FULL;
84200078:	61 f0 5a 8e 	M[r4 + 360] = rMAC;
    op_extra_data->kick_id = TIMER_ID_INVALID;
8420007c:	60 f0 5d 8e 	M[r4 + 372] = Null;
                         (AEC_REFERENCE_DEFAULT_TASK_PERIOD >= AEC_REFERENCE_MIN_TASK_PERIOD) &&
                         ((SECOND%AEC_REFERENCE_DEFAULT_TASK_PERIOD)==0)),
                        AEC_REFERENCE_DEFAULT_TASK_PERIOD_Not_Accepted);

    /* set default task period */
    if(!aec_reference_set_task_period(op_extra_data, AEC_REFERENCE_DEFAULT_TASK_PERIOD, 1))
84200080:	03 f0 e8 43 	r1 = Null + 1000;
84200084:	0c 00       	r2 = rMAC + Null;
84200086:	32 00       	r0 = r4 + Null;
84200088:	06 f0 31 ed 	call (m) $_aec_reference_set_task_period;
8420008c:	10 04       	Null = r0 - Null;
8420008e:	42 60       	if EQ jump (m) Lc_aec_reference_create_8;

84200090 <Lc_aec_reference_create_4>:
    }


#ifdef AEC_REFERENCE_GENERATE_MIC_TIMESTAMP
    /* set minimum tag length for mic output metadata tags */
    op_extra_data->mic_metadata_min_tag_len = AEC_REFERENCE_MIC_METADATA_MIN_TAG_LEN;
84200090:	01 3b       	rMAC = Null + 60;
84200092:	61 f0 cc 8e 	M[r4 + 816] = rMAC;

    /* create time to play with default params */
    op_extra_data->mic_time_to_play = ttp_init();
84200096:	ff fd b3 f0 	call (m) 0x16698;
8420009a:	23 e0 
8420009c:	62 f0 cf 8e 	M[r4 + 828] = r0;
    if (op_extra_data->mic_time_to_play != NULL)
842000a0:	61 f0 cf 88 	rMAC = M[r4 + 828];
842000a4:	37 60       	if EQ jump (m) Lc_aec_reference_create_8;

842000a6 <Lc_aec_reference_create_5>:
    {
        ttp_params params;
        ttp_get_default_params(&params, TTP_TYPE_PCM);
842000a6:	4b 08       	r1 = r7 + Null;
842000a8:	82 11       	r0 = FP + 24;
842000aa:	ff fd b3 f0 	call (m) 0x166de;
842000ae:	35 e1 
        ttp_configure_params(op_extra_data->mic_time_to_play, &params);
842000b0:	83 11       	r1 = FP + 24;
842000b2:	62 f0 cf 88 	r0 = M[r4 + 828];
842000b6:	ff fd b3 f0 	call (m) 0x16822;
842000ba:	2d eb 
       but is not declared as such because we may want it to be configurable in the future */

    /* For Atlas this must be less than for equal to the ping/pong period.
       Also set AEC_REFERENCE_TIME_PERIOD
    */
    op_extra_data->mic_rate_ability  = RATEMATCHING_SUPPORT_NONE;
842000bc:	60 f0 67 8e 	M[r4 + 412] = Null;
    op_extra_data->spkr_rate_ability = RATEMATCHING_SUPPORT_NONE;
842000c0:	60 f0 6f 8e 	M[r4 + 444] = Null;
    op_extra_data->mic_shift  = AEC_REFERENCE_DEFAULT_EP_SHIFT;
842000c4:	60 f0 6d 8e 	M[r4 + 436] = Null;
    op_extra_data->spkr_shift = -AEC_REFERENCE_DEFAULT_EP_SHIFT;
842000c8:	60 f0 74 8e 	M[r4 + 464] = Null;

    /* Note:  sample rate config must be sent before the operator's terminals may be connected
       input_rate and output_rate are initialized to zero and checked in the connect operation */

    /*allocate the volume control shared memory */
    op_extra_data->shared_volume_ptr = allocate_shared_volume_cntrl();
842000cc:	ff fd 8b f0 	call (m) 0x1181c;
842000d0:	31 ea 
842000d2:	62 f0 58 8e 	M[r4 + 352] = r0;
    if(!op_extra_data->shared_volume_ptr)
842000d6:	61 f0 58 88 	rMAC = M[r4 + 352];
842000da:	24 60       	if EQ jump (m) Lc_aec_reference_create_10;

842000dc <Lc_aec_reference_create_6>:
    {
        goto aFailed;
    }

    if(!cpsInitParameters(&op_extra_data->parms_def,(unsigned*)AEC_REFERENCE_GetDefaults(op_extra_data->cap_id),(unsigned*)&op_extra_data->params,sizeof(AEC_REFERENCE_PARAMETERS)))
842000dc:	62 f0 59 88 	r0 = M[r4 + 356];
842000e0:	16 f0 33 e1 	call (m) $_AEC_REFERENCE_GetDefaults;
842000e4:	13 00       	r1 = r0 + Null;
842000e6:	05 f0 94 40 	r3 = Null + 148;
842000ea:	64 f0 cc 20 	r2 = r4 + 204;
842000ee:	62 f0 78 21 	r0 = r4 + 376;
842000f2:	ff fd 01 f0 	call (m) 0x424;
842000f6:	33 e9 
842000f8:	10 04       	Null = r0 - Null;
842000fa:	0c 60       	if EQ jump (m) Lc_aec_reference_create_8;

842000fc <Lc_aec_reference_create_7>:
    {
        goto aFailed;
    }

#if defined(IO_DEBUG)
    aec_latency_ptr = &op_extra_data->sync_block;
842000fc:	61 f0 14 22 	rMAC = r4 + 532;
84200100:	e0 f0 01 f0 	M[Null + $_aec_latency_ptr] = rMAC;
84200104:	5b 8e 
#endif

    /* operator state variable set to not running state. based on base_op.c */
    op_data->state = OP_NOT_RUNNING;
84200106:	79 f0 18 8a 	MB[r5 + 24] = r7;
 * \param  response_data Pointer to the pointer to message that is allocated in the function.
 * \param  new_status  A status ID that is to be sent in the message.
 */
inline static void base_op_change_response_status(void **response_data, STATUS_KYMERA new_status)
{
    (((OP_STD_RSP *)(*response_data))->status = new_status);
8420010a:	81 f0 00 e8 	rMAC = M[r6 + Null];
8420010e:	48 8e       	M[rMAC + 4] = Null;
84200110:	16 6e       	jump (m) Lc_aec_reference_create_13;

84200112 <Lc_aec_reference_create_8>:
    patch_fn_shared(aec_reference);

    base_op_change_response_status(response_data,STATUS_OK);
    return TRUE;
  aFailed:
    if(op_extra_data->shared_volume_ptr)
84200112:	62 f0 58 88 	r0 = M[r4 + 352];
84200116:	06 60       	if EQ jump (m) Lc_aec_reference_create_10;

84200118 <Lc_aec_reference_create_9>:
    {
        release_shared_volume_cntrl(op_extra_data->shared_volume_ptr);
84200118:	ff fd 8b f0 	call (m) 0x11840;
8420011c:	29 e9 
        op_extra_data->shared_volume_ptr = NULL;
8420011e:	60 f0 58 8e 	M[r4 + 352] = Null;

84200122 <Lc_aec_reference_create_10>:
    }

#ifdef AEC_REFERENCE_GENERATE_MIC_TIMESTAMP
    /* free it if we created time to play context for mic */
    if (op_extra_data->mic_time_to_play != NULL)
84200122:	62 f0 cf 88 	r0 = M[r4 + 828];
84200126:	06 60       	if EQ jump (m) Lc_aec_reference_create_12;

84200128 <Lc_aec_reference_create_11>:
    {
        ttp_free(op_extra_data->mic_time_to_play);
84200128:	ff fd b4 f0 	call (m) 0x16af4;
8420012c:	2d ee 
        op_extra_data->mic_time_to_play = NULL;
8420012e:	60 f0 cf 8e 	M[r4 + 828] = Null;

84200132 <Lc_aec_reference_create_12>:
84200132:	01 f0 00 60 	rMAC = Null + 4096;
84200136:	82 f0 00 e8 	r0 = M[r6 + Null];
8420013a:	51 8e       	M[r0 + 4] = rMAC;

8420013c <Lc_aec_reference_create_13>:

    /* chance to fix up */
    patch_fn_shared(aec_reference);

    base_op_change_response_status(response_data,STATUS_OK);
    return TRUE;
8420013c:	4a 08       	r0 = r7 + Null;

8420013e <Lc_aec_reference_create_14>:
    }
#endif /* AEC_REFERENCE_GENERATE_MIC_TIMESTAMP */

    base_op_change_response_status(response_data, STATUS_CMD_FAILED);
    return TRUE;
}
8420013e:	f4 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, rLink>;
84200140:	d8 4c       	rts;

84200142 <$_aec_reference_destroy>:
     */
    op_extra_data->channel_status = 0;
}

bool aec_reference_destroy(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200142:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84200144:	17 00       	r5 = r0 + Null;
84200146:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84200148:	3e 99       	r4 = M[r5 + 48];
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);

    patch_fn_shared(aec_reference);

    /* Setup Response to Destroy Request.*/
    if(!base_op_destroy(op_data, message_data, response_id, response_data))
8420014a:	ef fd ff ff 	call (m) 0xac;
8420014e:	23 eb 
84200150:	10 04       	Null = r0 - Null;
84200152:	03 62       	if NE jump (m) Lc_aec_reference_destroy_3;

84200154 <Lc_aec_reference_destroy_2>:
    {
        return(FALSE);
84200154:	02 00       	r0 = Null + Null;
84200156:	17 6e       	jump (m) Lc_aec_reference_destroy_6;

84200158 <Lc_aec_reference_destroy_3>:
    }

    /* Make sure everything is cleared */
    aec_reference_cleanup(op_data);
84200158:	3a 00       	r0 = r5 + Null;
8420015a:	08 f0 27 e8 	call (m) $_aec_reference_cleanup;

    /* calling the "destroy" assembly function - this frees up all the capability-internal memory */
    /*free volume control shared memory*/
    release_shared_volume_cntrl(op_extra_data->shared_volume_ptr);
8420015e:	62 f0 58 88 	r0 = M[r4 + 352];
84200162:	ff fd 8b f0 	call (m) 0x11840;
84200166:	3f e6 
    op_extra_data->shared_volume_ptr = NULL;
84200168:	60 f0 58 8e 	M[r4 + 352] = Null;


#ifdef AEC_REFERENCE_GENERATE_MIC_TIMESTAMP
    /* delete mic time-to-play object */
    if(op_extra_data->mic_time_to_play != NULL)
8420016c:	62 f0 cf 88 	r0 = M[r4 + 828];
84200170:	06 60       	if EQ jump (m) Lc_aec_reference_destroy_5;

84200172 <Lc_aec_reference_destroy_4>:
    {
        ttp_free(op_extra_data->mic_time_to_play);
84200172:	ff fd b4 f0 	call (m) 0x16af4;
84200176:	23 ec 
        op_extra_data->mic_time_to_play = NULL;
84200178:	60 f0 cf 8e 	M[r4 + 828] = Null;

8420017c <Lc_aec_reference_destroy_5>:
8420017c:	81 f0 00 e8 	rMAC = M[r6 + Null];
84200180:	48 8e       	M[rMAC + 4] = Null;
    }
#endif

    base_op_change_response_status(response_data,STATUS_OK);
    return(TRUE);
84200182:	42 20       	r0 = Null + 1;

84200184 <Lc_aec_reference_destroy_6>:
}
84200184:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84200186:	d8 4c       	rts;

84200188 <$_aec_reference_reset>:
    *response_id = OPCMD_STOP;
    return(aec_reference_stop_reset(op_data,response_data));
}

bool aec_reference_reset(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200188:	c8 1c       	pushm <FP(=SP), rLink>;
8420018a:	2b 00       	r1 = r3 + Null;
    /* Setup Response to Reset Request.   Assume Failure*/
    *response_id = OPCMD_RESET;
8420018c:	01 21       	rMAC = Null + 4;
8420018e:	21 ee       	M[r2 + Null] = rMAC;
    return(aec_reference_stop_reset(op_data,response_data));
84200190:	10 f0 37 e7 	call (m) $_aec_reference_stop_reset;

84200194 <Lc_aec_reference_reset_2>:
}
84200194:	c8 48       	popm <FP, rLink>;
84200196:	d8 4c       	rts;

84200198 <$_aec_reference_connect>:


bool aec_reference_connect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200198:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
8420019a:	13 09       	r9 = r0 + Null;
8420019c:	20 09       	r6 = r2 + Null;
8420019e:	45 de       	M[FP + 32] = r3;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
842001a0:	b7 f0 0c 88 	r5 = M[r9 + 48];

bool aec_reference_connect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    tCbuffer **bufp = NULL;
    unsigned terminal_id    = ((unsigned*)message_data)[0];    /* extract the terminal_id */
842001a4:	1e e8       	r4 = M[r1 + Null];
    tCbuffer* pterminal_buf = (tCbuffer*)(uintptr_t)(((unsigned *)message_data)[1]);
842001a6:	3a f0 01 88 	r8 = M[r1 + 4];
    INT_OP_ID int_id = op_data->id;
842001aa:	b9 f0 01 88 	r7 = M[r9 + 4];

    patch_fn_shared(aec_reference);

    L3_DBG_MSG1("AEC REFERENCE --- connect TID = %x", terminal_id);
842001ae:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
842001b2:	c8 24       	Null = rMAC - 3;
842001b4:	08 68       	if LT jump (m) Lc_aec_reference_connect_3;

842001b6 <Lc_aec_reference_connect_2>:
842001b6:	55 f1 02 f0 	r0 = Null + 357564416;
842001ba:	00 40 
842001bc:	33 00       	r1 = r4 + Null;
842001be:	ff fd 03 f0 	call (m) 0x9b4;
842001c2:	37 ef 

842001c4 <Lc_aec_reference_connect_3>:


    /* Setup Response to Connection Request.   Assume Failure*/
    *response_id = OPCMD_CONNECT;
842001c4:	41 21       	rMAC = Null + 5;
842001c6:	81 f0 00 ee 	M[r6 + Null] = rMAC;
    if(!base_op_build_std_response(STATUS_CMD_FAILED,op_data->id,response_data))
842001ca:	b3 f0 01 88 	r1 = M[r9 + 4];
842001ce:	02 f0 00 60 	r0 = Null + 4096;
842001d2:	44 d8       	r2 = M[FP + 32];
842001d4:	ff fd 00 f0 	call (m) 0x204;
842001d8:	31 e1 
842001da:	10 04       	Null = r0 - Null;
842001dc:	03 62       	if NE jump (m) Lc_aec_reference_connect_5;

842001de <Lc_aec_reference_connect_4>:
    {
        return(FALSE);
842001de:	02 00       	r0 = Null + Null;
842001e0:	d4 6e       	jump (m) Lc_aec_reference_connect_44;

842001e2 <Lc_aec_reference_connect_5>:
    }

    /* Only allow connection if operator has been configured */
    if((op_extra_data->input_rate==0) || (op_extra_data->output_rate==0) )
842001e2:	70 f0 64 88 	Null = M[r5 + 400];
842001e6:	13 60       	if EQ jump (m) Lc_aec_reference_connect_10;

842001e8 <Lc_aec_reference_connect_6>:
842001e8:	70 f0 65 88 	Null = M[r5 + 404];
842001ec:	10 60       	if EQ jump (m) Lc_aec_reference_connect_10;

842001ee <Lc_aec_reference_connect_7>:
        return(TRUE);
    }

    /* (i)  check if the terminal ID is valid . The number has to be less than the maximum number of sinks or sources .  */
    /* (ii) check if we are connecting to the right type . It has to be a buffer pointer and not endpoint connection */
    if( !base_op_is_terminal_valid(op_data, terminal_id) || !pterminal_buf)
842001ee:	33 00       	r1 = r4 + Null;
842001f0:	5a 08       	r0 = r9 + Null;
842001f2:	ef fd ff ff 	call (m) 0x1de;
842001f6:	2d ef 
842001f8:	10 04       	Null = r0 - Null;
842001fa:	04 60       	if EQ jump (m) Lc_aec_reference_connect_9;

842001fc <Lc_aec_reference_connect_8>:
842001fc:	0f fa 00 c2 	Null = r8 - Null;
84200200:	08 62       	if NE jump (m) Lc_aec_reference_connect_11;

84200202 <Lc_aec_reference_connect_9>:
84200202:	01 f0 03 60 	rMAC = Null + 4099;
84200206:	42 d8       	r0 = M[FP + 32];
84200208:	12 e8       	r0 = M[r0 + Null];
8420020a:	51 8e       	M[r0 + 4] = rMAC;

8420020c <Lc_aec_reference_connect_10>:
    }

    /* Only allow connection if operator has been configured */
    if((op_extra_data->input_rate==0) || (op_extra_data->output_rate==0) )
    {
        return(TRUE);
8420020c:	42 20       	r0 = Null + 1;
8420020e:	bd 6e       	jump (m) Lc_aec_reference_connect_44;

84200210 <Lc_aec_reference_connect_11>:
        base_op_change_response_status(response_data,STATUS_INVALID_CMD_PARAMS);
        return TRUE;
    }

    /* check if the terminal is already connected and if not , connect the terminal */
    if(terminal_id & TERMINAL_SINK_MASK)
84200210:	40 f0 61 f0 	rMAC = r4 AND 0x800000;
84200214:	00 00 
84200216:	5b 60       	if EQ jump (m) Lc_aec_reference_connect_27;

84200218 <Lc_aec_reference_connect_12>:
    {
        terminal_id &= ~ TERMINAL_SINK_MASK;
84200218:	bf ff 66 ff 	r4 = r4 AND 0xff7fffff;
8420021c:	ff 1f 

        if(terminal_id==AEC_REF_MIC_TERMINAL1)
8420021e:	b0 24       	Null = r4 - 2;
84200220:	34 62       	if NE jump (m) Lc_aec_reference_connect_19;

84200222 <Lc_aec_reference_connect_13>:
        {
            uint32 config_value;

            /* get info about overridden endpoints */
            op_extra_data->mic_endpoint = get_overriden_endpoint(int_id,
                                                                 AEC_REF_MIC_TERMINAL1 | TERMINAL_SINK_MASK);
84200222:	08 f0 03 f0 	r1 = Null + 8388610;
84200226:	02 40 
84200228:	4a 08       	r0 = r7 + Null;
8420022a:	ff fd 24 f0 	call (m) 0x4ab0;
8420022e:	27 e4 
84200230:	72 f0 7f 8e 	M[r5 + 508] = r0;

            if(!get_override_ep_ratematch_ability(op_extra_data->mic_endpoint,&config_value))
84200234:	43 12       	r1 = FP + 36;
84200236:	72 f0 7f 88 	r0 = M[r5 + 508];
8420023a:	ff fd 24 f0 	call (m) 0x4a4e;
8420023e:	35 e0 
84200240:	10 04       	Null = r0 - Null;
84200242:	e0 61       	if EQ jump (m) Lc_aec_reference_connect_9;

84200244 <Lc_aec_reference_connect_14>:
            /* Save rate matching ability HW or SW*/
            op_extra_data->mic_rate_ability   = RATEMATCHING_SUPPORT_SW;
            op_extra_data->mic_rate_enactment = RATEMATCHING_SUPPORT_SW;
#else
            /* Save rate matching ability HW or SW*/
            op_extra_data->mic_rate_ability   = (unsigned)config_value;
84200244:	49 d8       	rMAC = M[FP + 36];
84200246:	71 f0 67 8e 	M[r5 + 412] = rMAC;
            op_extra_data->mic_rate_enactment = RATEMATCHING_SUPPORT_NONE;
8420024a:	70 f0 68 8e 	M[r5 + 416] = Null;
#endif
            if(op_extra_data->mic_sync_enable)
8420024e:	70 f0 d4 88 	Null = M[r5 + 848];
84200252:	0b 60       	if EQ jump (m) Lc_aec_reference_connect_17;

84200254 <Lc_aec_reference_connect_15>:
            {
                /* Mic output will be synchronised to speaker input, SW or HW depends on
                 * it's ability.
                 */
                op_extra_data->mic_rate_enactment = op_extra_data->mic_rate_ability;
84200254:	71 f0 68 8e 	M[r5 + 416] = rMAC;
                if(op_extra_data->mic_rate_enactment == RATEMATCHING_SUPPORT_HW)
84200258:	88 24       	Null = rMAC - 2;
8420025a:	07 62       	if NE jump (m) Lc_aec_reference_connect_17;

8420025c <Lc_aec_reference_connect_16>:
                {
                    set_override_ep_ratematch_enacting(op_extra_data->mic_endpoint, TRUE);
8420025c:	43 20       	r1 = Null + 1;
8420025e:	72 f0 7f 88 	r0 = M[r5 + 508];
84200262:	ff fd 23 f0 	call (m) 0x4a3e;
84200266:	3d ee 

84200268 <Lc_aec_reference_connect_17>:
                }
            }

#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
            /* see if mic graph wants to use an external rate adjust operator */
            aec_reference_mic_check_external_rate_adjust_op(op_extra_data);
84200268:	3a 00       	r0 = r5 + Null;
8420026a:	06 f0 3f ee 	call (m) $_aec_reference_mic_check_external_rate_adjust_op;
#endif /* INSTALL_DELEGATE_RATE_ADJUST_SUPPORT */

            if(!get_override_ep_sample_rate(op_extra_data->mic_endpoint,&config_value))
8420026e:	43 12       	r1 = FP + 36;
84200270:	72 f0 7f 88 	r0 = M[r5 + 508];
84200274:	ff fd 23 f0 	call (m) 0x4a02;
84200278:	2f ec 
8420027a:	10 04       	Null = r0 - Null;
8420027c:	c3 61       	if EQ jump (m) Lc_aec_reference_connect_9;

8420027e <Lc_aec_reference_connect_18>:
            {
                /* Should never fail */
                base_op_change_response_status(response_data,STATUS_INVALID_CMD_PARAMS);
                return TRUE;
            }
            op_extra_data->mic_rate = (unsigned)config_value;
8420027e:	49 d8       	rMAC = M[FP + 36];
84200280:	71 f0 66 8e 	M[r5 + 408] = rMAC;
        else if(terminal_id==AEC_REF_INPUT_TERMINAL1)
        {
            op_extra_data->spkr_in_endpoint = get_overriden_endpoint(int_id,
                                                                     AEC_REF_INPUT_TERMINAL1 | TERMINAL_SINK_MASK);
        }
        bufp = &op_extra_data->input_stream[terminal_id];
84200284:	3b 22       	r1 = r5 + 8;
84200286:	60 6e       	jump (m) Lc_aec_reference_connect_36;

84200288 <Lc_aec_reference_connect_19>:
                return TRUE;
            }
            op_extra_data->mic_rate = (unsigned)config_value;

        }
        else if(terminal_id==AEC_REF_INPUT_TERMINAL1)
84200288:	30 04       	Null = r4 - Null;
8420028a:	15 62       	if NE jump (m) Lc_aec_reference_connect_24;

8420028c <Lc_aec_reference_connect_20>:
        {
            op_extra_data->spkr_in_endpoint = get_overriden_endpoint(int_id,
                                                                     AEC_REF_INPUT_TERMINAL1 | TERMINAL_SINK_MASK);
8420028c:	08 f0 03 f0 	r1 = Null + 8388608;
84200290:	00 40 
84200292:	4a 08       	r0 = r7 + Null;
84200294:	ff fd 24 f0 	call (m) 0x4ab0;
84200298:	3d e0 
8420029a:	72 f0 82 8e 	M[r5 + 520] = r0;
        }
        bufp = &op_extra_data->input_stream[terminal_id];
8420029e:	3b 00       	r1 = r5 + Null;

842002a0 <Lc_aec_reference_connect_21>:
 *
 * \return TRUE if the buffer supports metadata. FALSE if it doesn't.
 */
static inline bool buff_has_metadata(tCbuffer *buff)
{
    if (BUFF_METADATA(buff))
842002a0:	a1 f0 05 88 	rMAC = M[r8 + 20];
842002a4:	49 c6       	rMAC = rMAC AND 0x8000;
842002a6:	50 60       	if EQ jump (m) Lc_aec_reference_connect_36;

842002a8 <Lc_aec_reference_connect_22>:
         */
        if(IsSpeakerInputTerminal(terminal_id) &&
           buff_has_metadata(pterminal_buf))
        {
            /* set metadata buffer if it hasn't been set already */
            if(NULL == op_extra_data->spkr_input_metadata_buffer)
842002a8:	71 f0 c9 88 	rMAC = M[r5 + 804];
842002ac:	4d 62       	if NE jump (m) Lc_aec_reference_connect_36;

842002ae <Lc_aec_reference_connect_23>:
            {
                op_extra_data->spkr_input_metadata_buffer = pterminal_buf;
842002ae:	7a f0 c9 8e 	M[r5 + 804] = r8;
842002b2:	4a 6e       	jump (m) Lc_aec_reference_connect_36;

842002b4 <Lc_aec_reference_connect_24>:
        else if(terminal_id==AEC_REF_INPUT_TERMINAL1)
        {
            op_extra_data->spkr_in_endpoint = get_overriden_endpoint(int_id,
                                                                     AEC_REF_INPUT_TERMINAL1 | TERMINAL_SINK_MASK);
        }
        bufp = &op_extra_data->input_stream[terminal_id];
842002b4:	72 54       	r0 = r4 LSHIFT 2;
842002b6:	39 00       	rMAC = r5 + Null;
842002b8:	51 00       	rMAC = r0 + rMAC;
842002ba:	0b 00       	r1 = rMAC + Null;
inline static bool IsSpeakerInputTerminal(unsigned term_idx)
{
    return ( (term_idx==AEC_REF_INPUT_TERMINAL1)
          || (term_idx==AEC_REF_INPUT_TERMINAL2)
          || ( (term_idx>=AEC_REF_INPUT_TERMINAL3)
              && (term_idx<=AEC_REF_INPUT_TERMINAL8) ) );
842002bc:	70 24       	Null = r4 - 1;
842002be:	f1 61       	if EQ jump (m) Lc_aec_reference_connect_21;

842002c0 <Lc_aec_reference_connect_25>:
842002c0:	b0 25       	Null = r4 - 6;
842002c2:	42 64       	if NC jump (m) Lc_aec_reference_connect_36;

842002c4 <Lc_aec_reference_connect_26>:
842002c4:	f0 26       	Null = r4 - 11;
842002c6:	f9 ff db ef 	if LS jump (m) Lc_aec_reference_connect_21;

842002ca <Lc_14>:
842002ca:	3e 6e       	jump (m) Lc_aec_reference_connect_36;

842002cc <Lc_aec_reference_connect_27>:
        }
#endif /* AEC_REFERENCE_SUPPORT_METADATA */
    }
    else
    {
        if(terminal_id==AEC_REF_SPKR_TERMINAL1)
842002cc:	70 24       	Null = r4 - 1;
842002ce:	26 62       	if NE jump (m) Lc_aec_reference_connect_31;

842002d0 <Lc_aec_reference_connect_28>:
        {
            uint32 config_value;

            op_extra_data->spkr_endpoint = get_overriden_endpoint(int_id,
                                                                  AEC_REF_SPKR_TERMINAL1);
842002d0:	43 20       	r1 = Null + 1;
842002d2:	4a 08       	r0 = r7 + Null;
842002d4:	ff fd 23 f0 	call (m) 0x4ab0;
842002d8:	3d ee 
842002da:	72 f0 80 8e 	M[r5 + 512] = r0;

            if(!get_override_ep_ratematch_ability(op_extra_data->spkr_endpoint,&config_value))
842002de:	83 12       	r1 = FP + 40;
842002e0:	72 f0 80 88 	r0 = M[r5 + 512];
842002e4:	ff fd 23 f0 	call (m) 0x4a4e;
842002e8:	2b eb 
842002ea:	10 04       	Null = r0 - Null;
842002ec:	8b 61       	if EQ jump (m) Lc_aec_reference_connect_9;

842002ee <Lc_aec_reference_connect_29>:

#if defined(ENABLE_FORCE_SW_RATEMATCH)
            op_extra_data->spkr_rate_ability   = RATEMATCHING_SUPPORT_SW;
            op_extra_data->spkr_rate_enactment = RATEMATCHING_SUPPORT_SW;
#else
            op_extra_data->spkr_rate_ability   = (unsigned)config_value;
842002ee:	51 d8       	rMAC = M[FP + 40];
842002f0:	71 f0 6f 8e 	M[r5 + 444] = rMAC;
            op_extra_data->spkr_rate_enactment = RATEMATCHING_SUPPORT_NONE;
842002f4:	70 f0 71 8e 	M[r5 + 452] = Null;
#endif

#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
            /* see if speaker graph wants to use an external rate adjust operator */
            aec_reference_spkr_check_external_rate_adjust_op(op_extra_data);
842002f8:	3a 00       	r0 = r5 + Null;
842002fa:	06 f0 31 e8 	call (m) $_aec_reference_spkr_check_external_rate_adjust_op;
#endif
            if(!get_override_ep_sample_rate(op_extra_data->spkr_endpoint,&config_value))
842002fe:	83 12       	r1 = FP + 40;
84200300:	72 f0 80 88 	r0 = M[r5 + 512];
84200304:	ff fd 23 f0 	call (m) 0x4a02;
84200308:	3f e7 
8420030a:	10 04       	Null = r0 - Null;
8420030c:	7b 61       	if EQ jump (m) Lc_aec_reference_connect_9;

8420030e <Lc_aec_reference_connect_30>:
            {
                /* Should never fail */
                base_op_change_response_status(response_data,STATUS_INVALID_CMD_PARAMS);
                return TRUE;
            }
            op_extra_data->spkr_rate = (unsigned)config_value;
8420030e:	51 d8       	rMAC = M[FP + 40];
84200310:	71 f0 6e 8e 	M[r5 + 440] = rMAC;
        }
        else if(terminal_id==AEC_REF_REFERENCE_TERMINAL)
        {
            op_extra_data->sync_block.speaker_data = 0;
        }
        bufp = &op_extra_data->output_stream[terminal_id];
84200314:	73 f0 44 20 	r1 = r5 + 68;
84200318:	17 6e       	jump (m) Lc_aec_reference_connect_36;

8420031a <Lc_aec_reference_connect_31>:
                return TRUE;
            }
            op_extra_data->spkr_rate = (unsigned)config_value;

        }
        else if (terminal_id==AEC_REF_OUTPUT_TERMINAL1)
8420031a:	f0 24       	Null = r4 - 3;
8420031c:	1f 62       	if NE jump (m) Lc_aec_reference_connect_38;

8420031e <Lc_aec_reference_connect_32>:
        {
            op_extra_data->mic_out_endpoint = get_overriden_endpoint(int_id,
                                                                     AEC_REF_OUTPUT_TERMINAL1);
8420031e:	c3 20       	r1 = Null + 3;
84200320:	4a 08       	r0 = r7 + Null;
84200322:	ff fd 23 f0 	call (m) 0x4ab0;
84200326:	2f ec 
84200328:	72 f0 81 8e 	M[r5 + 516] = r0;
            op_extra_data->sync_block.mic_data = 0;
8420032c:	70 f0 88 8e 	M[r5 + 544] = Null;
        }
        else if(terminal_id==AEC_REF_REFERENCE_TERMINAL)
        {
            op_extra_data->sync_block.speaker_data = 0;
        }
        bufp = &op_extra_data->output_stream[terminal_id];
84200330:	73 f0 4c 20 	r1 = r5 + 76;

84200334 <Lc_aec_reference_connect_33>:
84200334:	a1 f0 05 88 	rMAC = M[r8 + 20];
84200338:	49 c6       	rMAC = rMAC AND 0x8000;
8420033a:	06 60       	if EQ jump (m) Lc_aec_reference_connect_36;

8420033c <Lc_aec_reference_connect_34>:
#ifdef AEC_REFERENCE_GENERATE_MIC_TIMESTAMP
       /* set metadata buffer for mic outputs */
       if(IsMicrophoneOutputTerminal(terminal_id) &&
          buff_has_metadata(pterminal_buf))
       {
           if(NULL == op_extra_data->mic_metadata_buffer)
8420033c:	71 f0 ca 88 	rMAC = M[r5 + 808];
84200340:	03 62       	if NE jump (m) Lc_aec_reference_connect_36;

84200342 <Lc_aec_reference_connect_35>:
           {   /* first connected mic output buffer with metadata */
               op_extra_data->mic_metadata_buffer = pterminal_buf;
84200342:	7a f0 ca 8e 	M[r5 + 808] = r8;

84200346 <Lc_aec_reference_connect_36>:
#endif /* AEC_REFERENCE_GENERATE_MIC_TIMESTAMP */

    }

    /* set the stream buffer for this terminal and rebuild the graphs if needed */
    if(aec_reference_update_stream_and_validate_channels(op_data, bufp, pterminal_buf))
84200346:	54 08       	r2 = r8 + Null;
84200348:	5a 08       	r0 = r9 + Null;
8420034a:	10 f0 37 e6 	call (m) $_aec_reference_update_stream_and_validate_channels;
8420034e:	10 04       	Null = r0 - Null;
84200350:	5e 61       	if EQ jump (m) Lc_aec_reference_connect_10;

84200352 <Lc_aec_reference_connect_37>:
84200352:	41 d8       	rMAC = M[FP + 32];
84200354:	09 e8       	rMAC = M[rMAC + Null];
84200356:	48 8e       	M[rMAC + 4] = Null;
84200358:	5a 6f       	jump (m) Lc_aec_reference_connect_10;

8420035a <Lc_aec_reference_connect_38>:
        {
            op_extra_data->mic_out_endpoint = get_overriden_endpoint(int_id,
                                                                     AEC_REF_OUTPUT_TERMINAL1);
            op_extra_data->sync_block.mic_data = 0;
        }
        else if(terminal_id==AEC_REF_REFERENCE_TERMINAL)
8420035a:	30 04       	Null = r4 - Null;
8420035c:	06 62       	if NE jump (m) Lc_aec_reference_connect_40;

8420035e <Lc_aec_reference_connect_39>:
        {
            op_extra_data->sync_block.speaker_data = 0;
8420035e:	70 f0 89 8e 	M[r5 + 548] = Null;
        }
        bufp = &op_extra_data->output_stream[terminal_id];
84200362:	73 f0 40 20 	r1 = r5 + 64;
84200366:	f0 6f       	jump (m) Lc_aec_reference_connect_36;

84200368 <Lc_aec_reference_connect_40>:
84200368:	72 54       	r0 = r4 LSHIFT 2;
8420036a:	39 00       	rMAC = r5 + Null;
8420036c:	51 00       	rMAC = r0 + rMAC;
8420036e:	13 f0 40 20 	r1 = rMAC + 64;
{
    return ((AEC_REF_OUTPUT_TERMINAL1 <= term_idx &&
            AEC_REF_OUTPUT_TERMINAL4 >= term_idx) ||
            (AEC_REF_OUTPUT_TERMINAL5 <= term_idx &&
                         AEC_REF_OUTPUT_TERMINAL8 >= term_idx)
            );
84200372:	f0 24       	Null = r4 - 3;
84200374:	e9 65       	if NC jump (m) Lc_aec_reference_connect_36;

84200376 <Lc_aec_reference_connect_41>:
84200376:	b0 25       	Null = r4 - 6;
84200378:	f9 ff bd ef 	if LS jump (m) Lc_aec_reference_connect_33;

8420037c <Lc_aec_reference_connect_42>:
8420037c:	70 27       	Null = r4 - 13;
8420037e:	e4 65       	if NC jump (m) Lc_aec_reference_connect_36;

84200380 <Lc_aec_reference_connect_43>:
84200380:	30 2c       	Null = r4 - 16;
84200382:	f9 ff b3 ef 	if LS jump (m) Lc_aec_reference_connect_33;

84200386 <Lc_15>:
84200386:	e0 6f       	jump (m) Lc_aec_reference_connect_36;

84200388 <Lc_aec_reference_connect_44>:
    if(aec_reference_update_stream_and_validate_channels(op_data, bufp, pterminal_buf))
    {
        base_op_change_response_status(response_data,STATUS_OK);
    }
    return TRUE;
}
84200388:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
8420038a:	d8 4c       	rts;

8420038c <$_aec_reference_disconnect>:

bool aec_reference_disconnect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
8420038c:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
8420038e:	11 09       	r7 = r0 + Null;
84200390:	20 09       	r6 = r2 + Null;
84200392:	2a 09       	r8 = r3 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84200394:	96 f0 0c 88 	r4 = M[r7 + 48];

bool aec_reference_disconnect(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    tCbuffer **bufp = NULL;
    unsigned terminal_id = *((unsigned*)message_data);
84200398:	1f e8       	r5 = M[r1 + Null];

    patch_fn_shared(aec_reference);

    L3_DBG_MSG1("AEC REFERENCE --- disconnect TID = %x", terminal_id);
8420039a:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
8420039e:	c8 24       	Null = rMAC - 3;
842003a0:	08 68       	if LT jump (m) Lc_aec_reference_disconnect_3;

842003a2 <Lc_aec_reference_disconnect_2>:
842003a2:	55 f1 02 f0 	r0 = Null + 357564451;
842003a6:	23 40 
842003a8:	3b 00       	r1 = r5 + Null;
842003aa:	ff fd 03 f0 	call (m) 0x9b4;
842003ae:	2b e0 

842003b0 <Lc_aec_reference_disconnect_3>:

    /* Setup Response to Disconnection Request. Assume Failure*/
    *response_id = OPCMD_DISCONNECT;
842003b0:	81 21       	rMAC = Null + 6;
842003b2:	81 f0 00 ee 	M[r6 + Null] = rMAC;
    if(!base_op_build_std_response(STATUS_CMD_FAILED,op_data->id,response_data))
842003b6:	93 f0 01 88 	r1 = M[r7 + 4];
842003ba:	02 f0 00 60 	r0 = Null + 4096;
842003be:	54 08       	r2 = r8 + Null;
842003c0:	ef fd ff ff 	call (m) 0x204;
842003c4:	25 e2 
842003c6:	10 04       	Null = r0 - Null;
842003c8:	03 62       	if NE jump (m) Lc_aec_reference_disconnect_5;

842003ca <Lc_aec_reference_disconnect_4>:
    {
        return(FALSE);
842003ca:	02 00       	r0 = Null + Null;
842003cc:	9a 6e       	jump (m) Lc_aec_reference_disconnect_53;

842003ce <Lc_aec_reference_disconnect_5>:
    }

    /* check if the terminal ID is valid . The number has to be less than the maximum number of sinks or sources.  */
    if(!base_op_is_terminal_valid(op_data, terminal_id))
842003ce:	3b 00       	r1 = r5 + Null;
842003d0:	4a 08       	r0 = r7 + Null;
842003d2:	ef fd ff ff 	call (m) 0x1de;
842003d6:	2d e0 
842003d8:	10 04       	Null = r0 - Null;
842003da:	07 62       	if NE jump (m) Lc_aec_reference_disconnect_7;

842003dc <Lc_aec_reference_disconnect_6>:
842003dc:	01 f0 03 60 	rMAC = Null + 4099;
842003e0:	a2 f0 00 e8 	r0 = M[r8 + Null];
842003e4:	51 8e       	M[r0 + 4] = rMAC;
842003e6:	7a 6e       	jump (m) Lc_aec_reference_disconnect_47;

842003e8 <Lc_aec_reference_disconnect_7>:
        base_op_change_response_status(response_data,STATUS_INVALID_CMD_PARAMS);
        return TRUE;
    }

    /* check if the terminal is connected and if so , disconnect the terminal */
    if(terminal_id & TERMINAL_SINK_MASK)
842003e8:	40 f0 71 f0 	rMAC = r5 AND 0x800000;
842003ec:	00 00 
842003ee:	3c 60       	if EQ jump (m) Lc_aec_reference_disconnect_28;

842003f0 <Lc_aec_reference_disconnect_8>:
inline static bool IsSpeakerInputTerminal(unsigned term_idx)
{
    return ( (term_idx==AEC_REF_INPUT_TERMINAL1)
          || (term_idx==AEC_REF_INPUT_TERMINAL2)
          || ( (term_idx>=AEC_REF_INPUT_TERMINAL3)
              && (term_idx<=AEC_REF_INPUT_TERMINAL8) ) );
842003f0:	bf ff 77 ff 	r5 = r5 AND 0xff7fffff;
842003f4:	ff 1f 
842003f6:	08 60       	if EQ jump (m) Lc_aec_reference_disconnect_12;

842003f8 <Lc_aec_reference_disconnect_9>:
842003f8:	78 24       	Null = r5 - 1;
842003fa:	06 60       	if EQ jump (m) Lc_aec_reference_disconnect_12;

842003fc <Lc_aec_reference_disconnect_10>:
842003fc:	b8 25       	Null = r5 - 6;
842003fe:	27 64       	if NC jump (m) Lc_aec_reference_disconnect_25;

84200400 <Lc_aec_reference_disconnect_11>:
84200400:	f8 26       	Null = r5 - 11;
84200402:	08 f0 c3 e0 	if HI jump (m) Lc_aec_reference_disconnect_24;

84200406 <Lc_aec_reference_disconnect_12>:
        terminal_id &= ~ TERMINAL_SINK_MASK;

#ifdef AEC_REFERENCE_SUPPORT_METADATA
        if(IsSpeakerInputTerminal(terminal_id))
        {
            tCbuffer *this_buf = op_extra_data->input_stream[terminal_id];
84200406:	7a 54       	r0 = r5 LSHIFT 2;
84200408:	b1 e8       	rMAC = M[r4 + r0];
            if(this_buf == op_extra_data->spkr_input_metadata_buffer)
8420040a:	62 f0 c9 88 	r0 = M[r4 + 804];
8420040e:	88 04       	Null = rMAC - r0;
84200410:	16 62       	if NE jump (m) Lc_aec_reference_disconnect_22;

84200412 <Lc_aec_reference_disconnect_13>:
            {
                /* disconnecting buffer is the metadata buffer,
                 * change the metadata buffer to another connected
                 * buffer with metadata, if there is any.
                 */
                tCbuffer *new_metadata_buf = NULL;
84200412:	02 00       	r0 = Null + Null;
                int idx;
                for(idx=0; idx < MAX_NUMBER_SPEAKERS; idx++)
84200414:	03 00       	r1 = Null + Null;
84200416:	03 6e       	jump (m) Lc_aec_reference_disconnect_15;

84200418 <Lc_aec_reference_disconnect_14>:
                {
                    tCbuffer *inp_buf = op_extra_data->input_stream[SpeakerInputTerminalByIndex(idx)];
84200418:	98 24       	Null = r1 - 2;
8420041a:	03 66       	if GE jump (m) Lc_aec_reference_disconnect_16;

8420041c <Lc_aec_reference_disconnect_15>:
8420041c:	1c 00       	r2 = r1 + Null;
8420041e:	02 6e       	jump (m) Lc_aec_reference_disconnect_17;

84200420 <Lc_aec_reference_disconnect_16>:
84200420:	1c 21       	r2 = r1 + 4;

84200422 <Lc_aec_reference_disconnect_17>:
84200422:	64 54       	r2 = r2 LSHIFT 2;
                    if(inp_buf != NULL &&
                       inp_buf != this_buf &&
                       buff_has_metadata(inp_buf))
84200424:	34 e9       	r2 = M[r4 + r2];
84200426:	06 60       	if EQ jump (m) Lc_aec_reference_disconnect_20;

84200428 <Lc_aec_reference_disconnect_18>:
84200428:	60 04       	Null = r2 - rMAC;
8420042a:	04 60       	if EQ jump (m) Lc_aec_reference_disconnect_20;

8420042c <Lc_aec_reference_disconnect_19>:
8420042c:	65 89       	r3 = M[r2 + 20];
8420042e:	6d c6       	r3 = r3 AND 0x8000;
84200430:	64 62       	if NE jump (m) Lc_aec_reference_disconnect_51;

84200432 <Lc_aec_reference_disconnect_20>:
                 * change the metadata buffer to another connected
                 * buffer with metadata, if there is any.
                 */
                tCbuffer *new_metadata_buf = NULL;
                int idx;
                for(idx=0; idx < MAX_NUMBER_SPEAKERS; idx++)
84200432:	5b 20       	r1 = r1 + 1;
84200434:	18 26       	Null = r1 - 8;
84200436:	f1 69       	if LT jump (m) Lc_aec_reference_disconnect_14;

84200438 <Lc_aec_reference_disconnect_21>:
                    {
                        new_metadata_buf = inp_buf;
                        break;
                    }
                }
                op_extra_data->spkr_input_metadata_buffer = new_metadata_buf;
84200438:	62 f0 c9 8e 	M[r4 + 804] = r0;

8420043c <Lc_aec_reference_disconnect_22>:
                op_extra_data->mic_ext_rate_adjust_op = 0;
            }
#endif /* INSTALL_DELEGATE_RATE_ADJUST_SUPPORT */

        }
        else if(terminal_id==AEC_REF_INPUT_TERMINAL1)
8420043c:	38 04       	Null = r5 - Null;
8420043e:	03 62       	if NE jump (m) Lc_aec_reference_disconnect_24;

84200440 <Lc_aec_reference_disconnect_23>:
        {
            op_extra_data->spkr_in_endpoint=NULL;
84200440:	60 f0 82 8e 	M[r4 + 520] = Null;

84200444 <Lc_aec_reference_disconnect_24>:
        }
        bufp = &op_extra_data->input_stream[terminal_id];
84200444:	7a 54       	r0 = r5 LSHIFT 2;
84200446:	33 00       	r1 = r4 + Null;
84200448:	d3 00       	r1 = r0 + r1;
8420044a:	3f 6e       	jump (m) Lc_aec_reference_disconnect_45;

8420044c <Lc_aec_reference_disconnect_25>:
                op_extra_data->spkr_input_metadata_buffer = new_metadata_buf;
            }
        }
#endif /* AEC_REFERENCE_SUPPORT_METADATA */

        if(terminal_id==AEC_REF_MIC_TERMINAL1)
8420044c:	b8 24       	Null = r5 - 2;
8420044e:	fb 63       	if NE jump (m) Lc_aec_reference_disconnect_24;

84200450 <Lc_aec_reference_disconnect_26>:
        {
            op_extra_data->mic_endpoint=NULL;
84200450:	60 f0 7f 8e 	M[r4 + 508] = Null;
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
            if(op_extra_data->mic_ext_rate_adjust_op != 0)
84200454:	62 f0 ad 88 	r0 = M[r4 + 692];
84200458:	f6 61       	if EQ jump (m) Lc_aec_reference_disconnect_24;

8420045a <Lc_aec_reference_disconnect_27>:
            {
                /* set external op to passthrough mode */
                stream_delegate_rate_adjust_set_passthrough_mode(op_extra_data->mic_ext_rate_adjust_op, TRUE);
8420045a:	43 20       	r1 = Null + 1;
8420045c:	16 f0 31 e1 	call (m) $_stream_delegate_rate_adjust_set_passthrough_mode;
                op_extra_data->mic_ext_rate_adjust_op = 0;
84200460:	60 f0 ad 8e 	M[r4 + 692] = Null;
84200464:	f0 6f       	jump (m) Lc_aec_reference_disconnect_24;

84200466 <Lc_aec_reference_disconnect_28>:
{
    return ((AEC_REF_OUTPUT_TERMINAL1 <= term_idx &&
            AEC_REF_OUTPUT_TERMINAL4 >= term_idx) ||
            (AEC_REF_OUTPUT_TERMINAL5 <= term_idx &&
                         AEC_REF_OUTPUT_TERMINAL8 >= term_idx)
            );
84200466:	f8 24       	Null = r5 - 3;
84200468:	3b 64       	if NC jump (m) Lc_aec_reference_disconnect_48;

8420046a <Lc_aec_reference_disconnect_29>:
8420046a:	b8 25       	Null = r5 - 6;
8420046c:	09 f0 8f e0 	if LS jump (m) Lc_aec_reference_disconnect_32;

84200470 <Lc_aec_reference_disconnect_30>:
84200470:	78 27       	Null = r5 - 13;
84200472:	27 64       	if NC jump (m) Lc_aec_reference_disconnect_44;

84200474 <Lc_aec_reference_disconnect_31>:
84200474:	38 2c       	Null = r5 - 16;
84200476:	08 f0 cb e0 	if HI jump (m) Lc_aec_reference_disconnect_44;

8420047a <Lc_aec_reference_disconnect_32>:
    else
    {
#ifdef AEC_REFERENCE_GENERATE_MIC_TIMESTAMP
        if(IsMicrophoneOutputTerminal(terminal_id))
        {
            tCbuffer *this_buf = op_extra_data->output_stream[terminal_id];
8420047a:	7a 54       	r0 = r5 LSHIFT 2;
8420047c:	31 00       	rMAC = r4 + Null;
8420047e:	51 00       	rMAC = r0 + rMAC;
84200480:	09 a8       	rMAC = M[rMAC + 64];
            if(this_buf == op_extra_data->mic_metadata_buffer)
84200482:	62 f0 ca 88 	r0 = M[r4 + 808];
84200486:	88 04       	Null = rMAC - r0;
84200488:	18 62       	if NE jump (m) Lc_aec_reference_disconnect_42;

8420048a <Lc_aec_reference_disconnect_33>:
            {
                /* disconnecting buffer is the mic metadata buffer,
                 * change the metadata buffer to another connected
                 * buffer with metadata, if there is any.
                 */
                tCbuffer *new_metadata_buf = NULL;
8420048a:	02 00       	r0 = Null + Null;
                int idx;
                for(idx=0; idx < MAX_NUMBER_MICS; idx++)
8420048c:	03 00       	r1 = Null + Null;
8420048e:	03 6e       	jump (m) Lc_aec_reference_disconnect_35;

84200490 <Lc_aec_reference_disconnect_34>:
                {
                    tCbuffer *out_buf = op_extra_data->output_stream[MicrophoneOutputTerminalByIndex(idx)];
84200490:	98 24       	Null = r1 - 2;
84200492:	03 66       	if GE jump (m) Lc_aec_reference_disconnect_36;

84200494 <Lc_aec_reference_disconnect_35>:
84200494:	dc 20       	r2 = r1 + 3;
84200496:	02 6e       	jump (m) Lc_aec_reference_disconnect_37;

84200498 <Lc_aec_reference_disconnect_36>:
84200498:	5c 22       	r2 = r1 + 9;

8420049a <Lc_aec_reference_disconnect_37>:
8420049a:	65 f0 40 20 	r3 = r4 + 64;
8420049e:	64 54       	r2 = r2 LSHIFT 2;
                    if(out_buf != NULL &&
                       out_buf != this_buf &&
                       buff_has_metadata(out_buf))
842004a0:	2c e9       	r2 = M[r3 + r2];
842004a2:	06 60       	if EQ jump (m) Lc_aec_reference_disconnect_40;

842004a4 <Lc_aec_reference_disconnect_38>:
842004a4:	60 04       	Null = r2 - rMAC;
842004a6:	04 60       	if EQ jump (m) Lc_aec_reference_disconnect_40;

842004a8 <Lc_aec_reference_disconnect_39>:
842004a8:	65 89       	r3 = M[r2 + 20];
842004aa:	6d c6       	r3 = r3 AND 0x8000;
842004ac:	28 62       	if NE jump (m) Lc_aec_reference_disconnect_52;

842004ae <Lc_aec_reference_disconnect_40>:
                 * change the metadata buffer to another connected
                 * buffer with metadata, if there is any.
                 */
                tCbuffer *new_metadata_buf = NULL;
                int idx;
                for(idx=0; idx < MAX_NUMBER_MICS; idx++)
842004ae:	5b 20       	r1 = r1 + 1;
842004b0:	18 26       	Null = r1 - 8;
842004b2:	ef 69       	if LT jump (m) Lc_aec_reference_disconnect_34;

842004b4 <Lc_aec_reference_disconnect_41>:
                    {
                        new_metadata_buf = out_buf;
                        break;
                    }
                }
                op_extra_data->mic_metadata_buffer = new_metadata_buf;
842004b4:	62 f0 ca 8e 	M[r4 + 808] = r0;

842004b8 <Lc_aec_reference_disconnect_42>:
                op_extra_data->spkr_ext_rate_adjust_op = 0;
            }
#endif /* INSTALL_DELEGATE_RATE_ADJUST_SUPPORT */

        }
        else if(terminal_id==AEC_REF_OUTPUT_TERMINAL1)
842004b8:	f8 24       	Null = r5 - 3;
842004ba:	03 62       	if NE jump (m) Lc_aec_reference_disconnect_44;

842004bc <Lc_aec_reference_disconnect_43>:
        {
            op_extra_data->mic_out_endpoint=NULL;
842004bc:	60 f0 81 8e 	M[r4 + 516] = Null;

842004c0 <Lc_aec_reference_disconnect_44>:
        }
        bufp = &op_extra_data->output_stream[terminal_id];
842004c0:	7a 54       	r0 = r5 LSHIFT 2;
842004c2:	96 01       	r4 = r0 + r4;
842004c4:	63 f0 40 20 	r1 = r4 + 64;

842004c8 <Lc_aec_reference_disconnect_45>:
    }

    /* clear the stream buffer for this terminal and rebuild the graphs if needed */
    if(aec_reference_update_stream_and_validate_channels(op_data, bufp, NULL))
842004c8:	04 00       	r2 = Null + Null;
842004ca:	4a 08       	r0 = r7 + Null;
842004cc:	0f f0 35 ea 	call (m) $_aec_reference_update_stream_and_validate_channels;
842004d0:	10 04       	Null = r0 - Null;
842004d2:	04 60       	if EQ jump (m) Lc_aec_reference_disconnect_47;

842004d4 <Lc_aec_reference_disconnect_46>:
842004d4:	a1 f0 00 e8 	rMAC = M[r8 + Null];
842004d8:	48 8e       	M[rMAC + 4] = Null;

842004da <Lc_aec_reference_disconnect_47>:

    /* check if the terminal ID is valid . The number has to be less than the maximum number of sinks or sources.  */
    if(!base_op_is_terminal_valid(op_data, terminal_id))
    {
        base_op_change_response_status(response_data,STATUS_INVALID_CMD_PARAMS);
        return TRUE;
842004da:	42 20       	r0 = Null + 1;
842004dc:	12 6e       	jump (m) Lc_aec_reference_disconnect_53;

842004de <Lc_aec_reference_disconnect_48>:
                op_extra_data->mic_metadata_buffer = new_metadata_buf;
            }
        }
#endif /* AEC_REFERENCE_GENERATE_MIC_TIMESTAMP */

        if(terminal_id==AEC_REF_SPKR_TERMINAL1)
842004de:	78 24       	Null = r5 - 1;
842004e0:	f0 63       	if NE jump (m) Lc_aec_reference_disconnect_44;

842004e2 <Lc_aec_reference_disconnect_49>:
        {
            op_extra_data->spkr_endpoint=NULL;
842004e2:	60 f0 80 8e 	M[r4 + 512] = Null;
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
            if(op_extra_data->spkr_ext_rate_adjust_op != 0)
842004e6:	62 f0 ae 88 	r0 = M[r4 + 696];
842004ea:	eb 61       	if EQ jump (m) Lc_aec_reference_disconnect_44;

842004ec <Lc_aec_reference_disconnect_50>:
            {
                /* set external op to passthrough mode */
                stream_delegate_rate_adjust_set_passthrough_mode(op_extra_data->spkr_ext_rate_adjust_op, TRUE);
842004ec:	43 20       	r1 = Null + 1;
842004ee:	15 f0 3f ec 	call (m) $_stream_delegate_rate_adjust_set_passthrough_mode;
                op_extra_data->spkr_ext_rate_adjust_op = 0;
842004f2:	60 f0 ae 8e 	M[r4 + 696] = Null;
842004f6:	e5 6f       	jump (m) Lc_aec_reference_disconnect_44;

842004f8 <Lc_aec_reference_disconnect_51>:
                    tCbuffer *inp_buf = op_extra_data->input_stream[SpeakerInputTerminalByIndex(idx)];
                    if(inp_buf != NULL &&
                       inp_buf != this_buf &&
                       buff_has_metadata(inp_buf))
                    {
                        new_metadata_buf = inp_buf;
842004f8:	22 00       	r0 = r2 + Null;
                        break;
842004fa:	9f 6f       	jump (m) Lc_aec_reference_disconnect_21;

842004fc <Lc_aec_reference_disconnect_52>:
                    tCbuffer *out_buf = op_extra_data->output_stream[MicrophoneOutputTerminalByIndex(idx)];
                    if(out_buf != NULL &&
                       out_buf != this_buf &&
                       buff_has_metadata(out_buf))
                    {
                        new_metadata_buf = out_buf;
842004fc:	22 00       	r0 = r2 + Null;
                        break;
842004fe:	db 6f       	jump (m) Lc_aec_reference_disconnect_41;

84200500 <Lc_aec_reference_disconnect_53>:
    {
        base_op_change_response_status(response_data,STATUS_OK);
    }

    return TRUE;
}
84200500:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84200502:	d8 4c       	rts;

84200504 <$_aec_reference_start>:

    return TRUE;
}

bool aec_reference_start(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200504:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84200506:	16 00       	r4 = r0 + Null;
84200508:	2f 00       	r5 = r3 + Null;
    patch_fn_shared(aec_reference);

    /* Setup Response to Start Request.   Assume Failure*/
    *response_id = OPCMD_START;
8420050a:	81 20       	rMAC = Null + 2;
8420050c:	21 ee       	M[r2 + Null] = rMAC;
    if(!base_op_build_std_response(STATUS_CMD_FAILED,op_data->id,response_data))
8420050e:	73 88       	r1 = M[r4 + 4];
84200510:	02 f0 00 60 	r0 = Null + 4096;
84200514:	3c 00       	r2 = r5 + Null;
84200516:	ef fd fe ff 	call (m) 0x204;
8420051a:	2f e7 
8420051c:	10 04       	Null = r0 - Null;
8420051e:	03 62       	if NE jump (m) Lc_aec_reference_start_3;

84200520 <Lc_aec_reference_start_2>:
    {
        return(FALSE);
84200520:	02 00       	r0 = Null + Null;
84200522:	0f 6e       	jump (m) Lc_aec_reference_start_8;

84200524 <Lc_aec_reference_start_3>:
    }
    /* do something only if the current state is "connected" */
    if(op_data->state == OP_RUNNING)
84200524:	31 b0       	rMAC = MBS[r4 + 24];
84200526:	0a 60       	if EQ jump (m) Lc_aec_reference_start_6;

84200528 <Lc_aec_reference_start_4>:
        base_op_change_response_status(response_data,STATUS_OK);
        return(TRUE);
    }

    /* Validate channel configuration */
    if(!validate_channels_and_build(op_data))
84200528:	32 00       	r0 = r4 + Null;
8420052a:	0a f0 21 e2 	call (m) $_validate_channels_and_build;
8420052e:	10 04       	Null = r0 - Null;
84200530:	07 60       	if EQ jump (m) Lc_aec_reference_start_7;

84200532 <Lc_aec_reference_start_5>:
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84200532:	32 99       	r0 = M[r4 + 48];
    }
#ifdef AEC_REFERENCE_SPKR_TTP
    {
        AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
        /* initialisation for timed playback in speaker path */
        aec_reference_spkr_ttp_init(op_extra_data);
84200534:	12 f0 3f e3 	call (m) $_aec_reference_spkr_ttp_init;
    }
#endif /* AEC_REFERENCE_SPKR_TTP */
    /* set internal capability state variable to "running" */
    /* operator state variable set to not running state. based on base_op.c */
    op_data->state = OP_RUNNING;
84200538:	30 ba       	MB[r4 + 24] = Null;

8420053a <Lc_aec_reference_start_6>:
8420053a:	39 e8       	rMAC = M[r5 + Null];
8420053c:	48 8e       	M[rMAC + 4] = Null;

8420053e <Lc_aec_reference_start_7>:
    }
    /* do something only if the current state is "connected" */
    if(op_data->state == OP_RUNNING)
    {
        base_op_change_response_status(response_data,STATUS_OK);
        return(TRUE);
8420053e:	42 20       	r0 = Null + 1;

84200540 <Lc_aec_reference_start_8>:
    /* operator state variable set to not running state. based on base_op.c */
    op_data->state = OP_RUNNING;

    base_op_change_response_status(response_data,STATUS_OK);
    return TRUE;
}
84200540:	f2 48       	popm <FP, r4, r5, rLink>;
84200542:	d8 4c       	rts;

84200544 <$_aec_reference_stop>:

    return retval;
}

bool aec_reference_stop(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200544:	c8 1c       	pushm <FP(=SP), rLink>;
84200546:	2b 00       	r1 = r3 + Null;
    /* Setup Response to Stop Request.   Assume Failure*/
    *response_id = OPCMD_STOP;
84200548:	c1 20       	rMAC = Null + 3;
8420054a:	21 ee       	M[r2 + Null] = rMAC;
    return(aec_reference_stop_reset(op_data,response_data));
8420054c:	0e f0 3b e9 	call (m) $_aec_reference_stop_reset;

84200550 <Lc_aec_reference_stop_2>:
}
84200550:	c8 48       	popm <FP, rLink>;
84200552:	d8 4c       	rts;

84200554 <$_aec_reference_buffer_details>:

    return TRUE;
}

bool aec_reference_buffer_details(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
84200554:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84200556:	28 09       	r6 = r3 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84200558:	16 99       	r4 = M[r0 + 48];
}

bool aec_reference_buffer_details(OPERATOR_DATA *op_data, void *message_data, unsigned *response_id, void **response_data)
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    unsigned term_id =  *((unsigned *)message_data);
8420055a:	1f e8       	r5 = M[r1 + Null];
    OP_BUF_DETAILS_RSP *resp;

    patch_fn_shared(aec_reference);

    if(!base_op_buffer_details(op_data, message_data, response_id, response_data))
8420055c:	ef fd fd ff 	call (m) 0xbe;
84200560:	23 eb 
84200562:	10 04       	Null = r0 - Null;
84200564:	03 62       	if NE jump (m) Lc_aec_reference_buffer_details_3;

84200566 <Lc_aec_reference_buffer_details_2>:
    {
        return FALSE;
84200566:	02 00       	r0 = Null + Null;
84200568:	8e 6e       	jump (m) Lc_aec_reference_buffer_details_30;

8420056a <Lc_aec_reference_buffer_details_3>:
    }
    resp = (OP_BUF_DETAILS_RSP*)*response_data;
8420056a:	88 f0 00 e8 	r6 = M[r6 + Null];

    if ( term_id & TERMINAL_SINK_MASK)
8420056e:	40 f0 71 f0 	rMAC = r5 AND 0x800000;
84200572:	00 00 
84200574:	0d 60       	if EQ jump (m) Lc_aec_reference_buffer_details_7;

84200576 <Lc_aec_reference_buffer_details_4>:
          || ( (term_idx>=AEC_REF_INPUT_TERMINAL3)
              && (term_idx<=AEC_REF_INPUT_TERMINAL8) ) );
}
inline static bool IsMicrophoneTerminal(unsigned term_idx)
{
    term_idx &= ~TERMINAL_SINK_MASK;
84200576:	bf ff 71 ff 	rMAC = r5 AND 0xff7fffff;
8420057a:	ff 1f 

    if(term_idx < AEC_REF_MIC_TERMINAL1)
8420057c:	88 24       	Null = rMAC - 2;
8420057e:	02 f0 f3 e1 	if C jump (m) Lc_aec_reference_buffer_details_28;

84200582 <Lc_aec_reference_buffer_details_5>:
            resp->needs_override = TRUE;
            resp->b.buffer_size  = 0;
        }
        else
        {
            if(op_extra_data->input_buffer_size != 0)
84200582:	61 f0 d6 88 	rMAC = M[r4 + 856];
84200586:	10 60       	if EQ jump (m) Lc_aec_reference_buffer_details_9;

84200588 <Lc_aec_reference_buffer_details_6>:
            {
                /* buffer size based on user configuration */
                resp->b.buffer_size = op_extra_data->input_buffer_size;
84200588:	81 f0 04 8e 	M[r6 + 16] = rMAC;
8420058c:	18 6e       	jump (m) Lc_aec_reference_buffer_details_10;

8420058e <Lc_aec_reference_buffer_details_7>:
inline static bool IsSpeakerTerminal(unsigned term_idx)
{
    return ( (term_idx==AEC_REF_SPKR_TERMINAL1)
          || (term_idx==AEC_REF_SPKR_TERMINAL2)
          || ( (term_idx>=AEC_REF_SPKR_TERMINAL3)
              && (term_idx<=AEC_REF_SPKR_TERMINAL8) ) );
8420058e:	78 24       	Null = r5 - 1;
84200590:	2d 62       	if NE jump (m) Lc_aec_reference_buffer_details_15;

84200592 <Lc_aec_reference_buffer_details_8>:
    if ( term_id & TERMINAL_SINK_MASK)
    {
        if(IsMicrophoneTerminal(term_id))
        {
            /* override MIC endpoints */
            resp->needs_override = TRUE;
84200592:	81 f0 08 82 	rMAC = MBU[r6 + 8];
84200596:	11 ff fb 1f 	rMAC = rMAC AND 0xfffffffb;
8420059a:	c9 c8       	rMAC = rMAC OR 0x4;
8420059c:	81 f0 08 8a 	MB[r6 + 8] = rMAC;
            resp->b.buffer_size  = 0;
842005a0:	80 f0 04 8e 	M[r6 + 16] = Null;
842005a4:	21 6e       	jump (m) Lc_aec_reference_buffer_details_14;

842005a6 <Lc_aec_reference_buffer_details_9>:
                /* buffer size based on sample rate. task period + 2ms for safety,
                 * 2ms extra should be enough as assumption is that scheduling jitter
                 * assumed will not be too high.
                 */
                resp->b.buffer_size  =
                    frac_mult(op_extra_data->input_rate,FRACTIONAL(0.002)+op_extra_data->task_period_frac);
842005a6:	62 f0 64 88 	r0 = M[r4 + 400];
842005aa:	61 f0 93 88 	rMAC = M[r4 + 588];
842005ae:	06 f1 13 f0 	r1 = rMAC + 4294967;
842005b2:	37 31 
842005b4:	00 f3 72 c9 	r0 = r0 * r1 (frac);
842005b8:	82 f0 04 8e 	M[r6 + 16] = r0;

842005bc <Lc_aec_reference_buffer_details_10>:

#ifdef AEC_REFERENCE_SUPPORT_METADATA
            /* currently metadata is supported only for
             * speaker input channels.
             */
            L3_DBG_MSG("AEC_REFERENCE: metadata is supported for speaker inputs");
842005bc:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
842005c0:	c8 24       	Null = rMAC - 3;
842005c2:	07 68       	if LT jump (m) Lc_aec_reference_buffer_details_12;

842005c4 <Lc_aec_reference_buffer_details_11>:
842005c4:	55 f1 02 f0 	r0 = Null + 357564489;
842005c8:	49 40 
842005ca:	ff fd 01 f0 	call (m) 0x9a2;
842005ce:	39 ee 

842005d0 <Lc_aec_reference_buffer_details_12>:
            resp->metadata_buffer = op_extra_data->spkr_input_metadata_buffer;
842005d0:	61 f0 c9 88 	rMAC = M[r4 + 804];
842005d4:	81 f0 03 8e 	M[r6 + 12] = rMAC;

842005d8 <Lc_aec_reference_buffer_details_13>:
             */
            if(op_extra_data->mic_metadata_enable &&
               IsMicrophoneOutputTerminal(term_id))
            {
                resp->metadata_buffer = op_extra_data->mic_metadata_buffer;
                resp->supports_metadata = TRUE;
842005d8:	81 f0 08 82 	rMAC = MBU[r6 + 8];
842005dc:	11 ff ef 1f 	rMAC = rMAC AND 0xffffffef;
842005e0:	c9 c9       	rMAC = rMAC OR 0x10;
842005e2:	81 f0 08 8a 	MB[r6 + 8] = rMAC;

842005e6 <Lc_aec_reference_buffer_details_14>:
            }
#endif /* AEC_REFERENCE_GENERATE_MIC_TIMESTAMP */
        }
    }

    return TRUE;
842005e6:	42 20       	r0 = Null + 1;
842005e8:	4e 6e       	jump (m) Lc_aec_reference_buffer_details_30;

842005ea <Lc_aec_reference_buffer_details_15>:
842005ea:	b8 24       	Null = r5 - 2;
842005ec:	d3 61       	if EQ jump (m) Lc_aec_reference_buffer_details_8;

842005ee <Lc_aec_reference_buffer_details_16>:
842005ee:	f8 25       	Null = r5 - 7;
842005f0:	04 64       	if NC jump (m) Lc_aec_reference_buffer_details_18;

842005f2 <Lc_aec_reference_buffer_details_17>:
842005f2:	38 27       	Null = r5 - 12;
842005f4:	f9 ff 9f ef 	if LS jump (m) Lc_aec_reference_buffer_details_8;

842005f8 <Lc_aec_reference_buffer_details_18>:
            resp->needs_override = TRUE;
            resp->b.buffer_size  = 0;
        }
        else
        {
            if(op_extra_data->output_buffer_size != 0)
842005f8:	61 f0 d5 88 	rMAC = M[r4 + 852];
842005fc:	14 60       	if EQ jump (m) Lc_aec_reference_buffer_details_21;

842005fe <Lc_aec_reference_buffer_details_19>:
            {
                /* buffer size based on user configuration */
                resp->b.buffer_size = op_extra_data->output_buffer_size;
842005fe:	81 f0 04 8e 	M[r6 + 16] = rMAC;

                if(AEC_REF_REFERENCE_TERMINAL == term_id)
84200602:	38 04       	Null = r5 - Null;
84200604:	26 62       	if NE jump (m) Lc_aec_reference_buffer_details_23;

84200606 <Lc_aec_reference_buffer_details_20>:
                     * within [ref_delay, ref_delay+jitter] range. For that reason we add an extra
                     * for ref buffer so mic output can use full output_buffer_size
                     */
                    unsigned ref_extra =
                        frac_mult(op_extra_data->output_rate,
                                  op_extra_data->task_period_frac + FRACTIONAL(0.001));
84200606:	62 f0 65 88 	r0 = M[r4 + 404];
8420060a:	61 f0 93 88 	rMAC = M[r4 + 588];
8420060e:	83 f0 13 f0 	r1 = rMAC + 2147483;
84200612:	9b 28 
84200614:	00 f3 72 c9 	r0 = r0 * r1 (frac);

                    resp->b.buffer_size += ref_extra;
84200618:	81 f0 04 88 	rMAC = M[r6 + 16];
8420061c:	51 00       	rMAC = r0 + rMAC;
8420061e:	81 f0 04 8e 	M[r6 + 16] = rMAC;
84200622:	17 6e       	jump (m) Lc_aec_reference_buffer_details_23;

84200624 <Lc_aec_reference_buffer_details_21>:
                }
            }
            else
            {
                unsigned two_task_period_size = frac_mult(op_extra_data->output_rate,
                                                          2*op_extra_data->task_period_frac) + 1;
84200624:	62 f0 65 88 	r0 = M[r4 + 404];
84200628:	63 f0 93 88 	r1 = M[r4 + 588];
8420062c:	1b 54       	r1 = r1 LSHIFT 1;
8420062e:	00 f3 72 c9 	r0 = r0 * r1 (frac);
84200632:	51 20       	rMAC = r0 + 1;
                /* buffer size based on sample rate */
                resp->b.buffer_size  = frac_mult(op_extra_data->output_rate,FRACTIONAL(0.0087));
84200634:	62 f0 65 88 	r0 = M[r4 + 404];
84200638:	11 f0 83 f6 	r1 = Null + 18683107;
8420063c:	e3 68 
8420063e:	00 f3 72 c9 	r0 = r0 * r1 (frac);
84200642:	82 f0 04 8e 	M[r6 + 16] = r0;
                /* given that this is for cvc-like operators and limited task periods that the
				 * operator supports, 8.7ms would be adequate for all use cases. In case of very
				 * high task period is used make sure output has space for at least two task period.
                 */
                resp->b.buffer_size = MAX(resp->b.buffer_size,
                                          two_task_period_size);
84200646:	50 04       	Null = r0 - rMAC;
84200648:	02 f0 89 e0 	if C jump (m) Lc_aec_reference_buffer_details_23;

8420064c <Lc_aec_reference_buffer_details_22>:
8420064c:	81 f0 04 8e 	M[r6 + 16] = rMAC;

84200650 <Lc_aec_reference_buffer_details_23>:
#ifdef AEC_REFERENCE_GENERATE_MIC_TIMESTAMP
            /* Support metadta for microphone output channels (reference channel not included)
             * if enabled by the user.
             */
            if(op_extra_data->mic_metadata_enable &&
               IsMicrophoneOutputTerminal(term_id))
84200650:	60 f0 cd 88 	Null = M[r4 + 820];
84200654:	c9 61       	if EQ jump (m) Lc_aec_reference_buffer_details_14;

84200656 <Lc_aec_reference_buffer_details_24>:
{
    return ((AEC_REF_OUTPUT_TERMINAL1 <= term_idx &&
            AEC_REF_OUTPUT_TERMINAL4 >= term_idx) ||
            (AEC_REF_OUTPUT_TERMINAL5 <= term_idx &&
                         AEC_REF_OUTPUT_TERMINAL8 >= term_idx)
            );
84200656:	f8 24       	Null = r5 - 3;
84200658:	c7 65       	if NC jump (m) Lc_aec_reference_buffer_details_14;

8420065a <Lc_aec_reference_buffer_details_25>:
8420065a:	b8 25       	Null = r5 - 6;
8420065c:	09 f0 8b e0 	if LS jump (m) Lc_aec_reference_buffer_details_27;

84200660 <Lc_aec_reference_buffer_details_26>:
84200660:	38 2c       	Null = r5 - 16;
84200662:	f8 ff 85 ef 	if HI jump (m) Lc_aec_reference_buffer_details_14;

84200666 <Lc_aec_reference_buffer_details_27>:
            {
                resp->metadata_buffer = op_extra_data->mic_metadata_buffer;
84200666:	61 f0 ca 88 	rMAC = M[r4 + 808];
8420066a:	81 f0 03 8e 	M[r6 + 12] = rMAC;
8420066e:	b5 6f       	jump (m) Lc_aec_reference_buffer_details_13;

84200670 <Lc_aec_reference_buffer_details_28>:

    if(term_idx < AEC_REF_MIC_TERMINAL1)
    {
        return FALSE;
    }
    if(term_idx <= AEC_REF_MIC_TERMINAL4)
84200670:	48 25       	Null = rMAC - 5;
84200672:	f9 ff a1 ee 	if LS jump (m) Lc_aec_reference_buffer_details_8;

84200676 <Lc_aec_reference_buffer_details_29>:
    {
        return TRUE;
    }
    return (term_idx >= AEC_REF_MIC_TERMINAL5);
84200676:	02 00       	r0 = Null + Null;
84200678:	08 27       	Null = rMAC - 12;
8420067a:	22 f0 42 ce 	if C r0 = Null + 1;
    }
    resp = (OP_BUF_DETAILS_RSP*)*response_data;

    if ( term_id & TERMINAL_SINK_MASK)
    {
        if(IsMicrophoneTerminal(term_id))
8420067e:	10 04       	Null = r0 - Null;
84200680:	89 63       	if NE jump (m) Lc_aec_reference_buffer_details_8;

84200682 <Lc_16>:
84200682:	80 6f       	jump (m) Lc_aec_reference_buffer_details_5;

84200684 <Lc_aec_reference_buffer_details_30>:
#endif /* AEC_REFERENCE_GENERATE_MIC_TIMESTAMP */
        }
    }

    return TRUE;
}
84200684:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84200686:	d8 4c       	rts;

84200688 <$_aec_reference_timer_task>:
        op_extra_data->sync_block.frm_count = 0;
    }
}

void aec_reference_timer_task(void *kick_object)
{
84200688:	f6 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x20;
8420068a:	13 09       	r9 = r0 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
8420068c:	b6 f0 0c 88 	r4 = M[r9 + 48];
void aec_reference_timer_task(void *kick_object)
{
    OPERATOR_DATA         *op_data = (OPERATOR_DATA*) kick_object;
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    TIME next_fire_time;
    unsigned                 sink_kicks=0,source_kicks=0;
84200690:	40 de       	M[FP + 32] = Null;
84200692:	48 de       	M[FP + 36] = Null;
#ifdef PROFILER_ON
    if (op_data->profiler != NULL)
84200694:	b2 f0 08 88 	r0 = M[r9 + 32];
84200698:	04 60       	if EQ jump (m) Lc_aec_reference_timer_task_3;

8420069a <Lc_aec_reference_timer_task_2>:
    {
        PROFILER_START(op_data->profiler);
8420069a:	ff fd 64 f1 	call (m) 0x2d006;
8420069e:	2d eb 

842006a0 <Lc_aec_reference_timer_task_3>:
    }
#endif

    patch_fn_shared(aec_reference_run);

    if(op_extra_data->ReInitFlag==TRUE)
842006a0:	61 f0 5c 88 	rMAC = M[r4 + 368];
842006a4:	48 24       	Null = rMAC - 1;
842006a6:	0c 62       	if NE jump (m) Lc_aec_reference_timer_task_7;

842006a8 <Lc_aec_reference_timer_task_4>:
    {
        op_extra_data->ReInitFlag=FALSE;
842006a8:	60 f0 5c 8e 	M[r4 + 368] = Null;

        /* Handle Reinitialize */
        if(op_extra_data->mic_sidetone_op)
842006ac:	62 f0 6c 88 	r0 = M[r4 + 432];
842006b0:	04 60       	if EQ jump (m) Lc_aec_reference_timer_task_6;

842006b2 <Lc_aec_reference_timer_task_5>:
        {
            initialize_sidetone_filter_op(op_extra_data->mic_sidetone_op);
842006b2:	ff fd 58 f3 	call 0x6b82c;
842006b6:	3a eb 

842006b8 <Lc_aec_reference_timer_task_6>:
        }

        aec_reference_set_mic_gains(op_data);
842006b8:	5a 08       	r0 = r9 + Null;
842006ba:	05 f0 2b ea 	call (m) $_aec_reference_set_mic_gains;

842006be <Lc_aec_reference_timer_task_7>:
    }

    if(op_extra_data->mic_sidetone_op)
842006be:	62 f0 6c 88 	r0 = M[r4 + 432];
842006c2:	0a 60       	if EQ jump (m) Lc_aec_reference_timer_task_9;

842006c4 <Lc_aec_reference_timer_task_8>:
    {
        update_sidetone_filter_op(op_extra_data->mic_sidetone_op,
                                  op_extra_data->params.OFFSET_CONFIG & AEC_REFERENCE_CONFIG_SIDETONEENA,
                                  op_extra_data->shared_volume_ptr->ndvc_filter_sum_lpdnz);
842006c4:	61 f0 58 88 	rMAC = M[r4 + 352];
842006c8:	4c 88       	r2 = M[rMAC + 4];
842006ca:	61 f0 33 88 	rMAC = M[r4 + 204];
842006ce:	cb c1       	r1 = rMAC AND 0x10;
842006d0:	ff fd 58 f3 	call 0x6b7d4;
842006d4:	24 e8 

842006d6 <Lc_aec_reference_timer_task_9>:
        */
       && (0 != (op_extra_data->params.OFFSET_CONFIG & AEC_REFERENCE_CONFIG_SIDETONEENA))
       /* Also check that both speaker and mic still connected */
       && (NULL != op_extra_data->output_stream[AEC_REF_SPKR_TERMINAL1])
       && (NULL != op_extra_data->input_stream[AEC_REF_MIC_TERMINAL1])
       )
842006d6:	62 f0 99 88 	r0 = M[r4 + 612];
842006da:	0e 60       	if EQ jump (m) Lc_aec_reference_timer_task_14;

842006dc <Lc_aec_reference_timer_task_10>:
842006dc:	61 f0 33 88 	rMAC = M[r4 + 204];
842006e0:	c9 c1       	rMAC = rMAC AND 0x10;
842006e2:	0a 60       	if EQ jump (m) Lc_aec_reference_timer_task_14;

842006e4 <Lc_aec_reference_timer_task_11>:
842006e4:	71 a8       	rMAC = M[r4 + 68];
842006e6:	08 60       	if EQ jump (m) Lc_aec_reference_timer_task_14;

842006e8 <Lc_aec_reference_timer_task_12>:
842006e8:	b1 88       	rMAC = M[r4 + 8];
842006ea:	06 60       	if EQ jump (m) Lc_aec_reference_timer_task_14;

842006ec <Lc_aec_reference_timer_task_13>:
    {
        /* Run sidetone graph */
        cbops_process_data(op_extra_data->sidetone_graph, CBOPS_MAX_COPY_SIZE-1);
842006ec:	03 f0 ff 41 	r1 = Null + 511;
842006f0:	ff fd d9 f2 	call 0x5b9a4;
842006f4:	34 e5 

842006f6 <Lc_aec_reference_timer_task_14>:
    }

    op_extra_data->task_decim_counter++;
842006f6:	61 f0 98 88 	rMAC = M[r4 + 608];
842006fa:	49 20       	rMAC = rMAC + 1;
842006fc:	61 f0 98 8e 	M[r4 + 608] = rMAC;
    if(op_extra_data->task_decim_counter >= op_extra_data->task_decim_factor)
84200700:	62 f0 97 88 	r0 = M[r4 + 604];
84200704:	88 04       	Null = rMAC - r0;
84200706:	03 64       	if NC jump (m) Lc_aec_reference_timer_task_16;

84200708 <Lc_aec_reference_timer_task_15>:
    {
        op_extra_data->task_decim_counter = 0;
84200708:	60 f0 98 8e 	M[r4 + 608] = Null;

8420070c <Lc_aec_reference_timer_task_16>:
    }
    if(op_extra_data->task_decim_counter == 0)
8420070c:	60 f0 98 88 	Null = M[r4 + 608];
84200710:	01 f0 91 e5 	if NE jump (m) Lc_aec_reference_timer_task_80;

84200714 <Lc_aec_reference_timer_task_17>:
    {
        /* Process the speaker path if we have speaker graph and
         * speaker is still connected
         */
        bool spkr_graph_active = (NULL != op_extra_data->spkr_graph) &&
            (NULL != op_extra_data->output_stream[AEC_REF_SPKR_TERMINAL1]);
84200714:	61 f0 72 88 	rMAC = M[r4 + 456];
84200718:	07 60       	if EQ jump (m) Lc_aec_reference_timer_task_19;

8420071a <Lc_aec_reference_timer_task_18>:
8420071a:	72 a8       	r0 = M[r4 + 68];
8420071c:	01 00       	rMAC = Null + Null;
8420071e:	80 04       	Null = Null - r0;
84200720:	21 f0 41 ce 	if NE rMAC = Null + 1;
84200724:	02 6e       	jump (m) Lc_aec_reference_timer_task_20;

84200726 <Lc_aec_reference_timer_task_19>:
84200726:	01 00       	rMAC = Null + Null;

84200728 <Lc_aec_reference_timer_task_20>:
84200728:	51 de       	M[FP + 40] = rMAC;

        /* Process the mic path if we have mic graph and
         * mic is still connected
         */
        bool mic_graph_active = (NULL != op_extra_data->mic_graph) &&
            (NULL != op_extra_data->input_stream[AEC_REF_MIC_TERMINAL1]);
8420072a:	61 f0 6a 88 	rMAC = M[r4 + 424];
8420072e:	07 60       	if EQ jump (m) Lc_aec_reference_timer_task_22;

84200730 <Lc_aec_reference_timer_task_21>:
84200730:	b1 88       	rMAC = M[r4 + 8];
84200732:	07 00       	r5 = Null + Null;
84200734:	40 04       	Null = Null - rMAC;
84200736:	21 f0 47 ce 	if NE r5 = Null + 1;
8420073a:	02 6e       	jump (m) Lc_aec_reference_timer_task_23;

8420073c <Lc_aec_reference_timer_task_22>:
8420073c:	07 00       	r5 = Null + Null;

8420073e <Lc_aec_reference_timer_task_23>:
         * 1- we have a rate monitor op for speaker, and/or
         * 2- speaker hasn't started consuming (to detect start of flow)
         */
        if(spkr_graph_active &&
           (op_extra_data->spkr_rate_monitor_op != NULL ||
            !op_extra_data->spkr_flow_started))
8420073e:	51 d8       	rMAC = M[FP + 40];
84200740:	2f 60       	if EQ jump (m) Lc_aec_reference_timer_task_31;

84200742 <Lc_aec_reference_timer_task_24>:
84200742:	61 f0 73 88 	rMAC = M[r4 + 460];
84200746:	04 62       	if NE jump (m) Lc_aec_reference_timer_task_26;

84200748 <Lc_aec_reference_timer_task_25>:
84200748:	60 f0 d3 88 	Null = M[r4 + 844];
8420074c:	29 62       	if NE jump (m) Lc_aec_reference_timer_task_31;

8420074e <Lc_aec_reference_timer_task_26>:
             * since previous run and pass it to the rate monitor cbops op. The
             * op can use its transfer amount, however since speaker graph runs after mic
             * graph, the new amount will have bigger jitter which might affect
             * reference synchronisation.
             */
            tCbuffer *monbuf = op_extra_data->output_stream[AEC_REF_SPKR_TERMINAL1];
8420074e:	69 f0 11 88 	r7 = M[r4 + 68];
            unsigned new_offset = cbuffer_get_read_mmu_offset(monbuf);
84200752:	4a 08       	r0 = r7 + Null;
84200754:	ff fd 91 f0 	call (m) 0x12a28;
84200758:	35 e6 
8420075a:	10 09       	r6 = r0 + Null;
            if(new_offset >= op_extra_data->spkr_last_offset)
8420075c:	61 f0 d1 88 	rMAC = M[r4 + 836];
84200760:	1f f8 00 c2 	Null = r6 - rMAC;
84200764:	06 64       	if NC jump (m) Lc_aec_reference_timer_task_28;

84200766 <Lc_aec_reference_timer_task_27>:
            {
                op_extra_data->spkr_new_amount = new_offset - op_extra_data->spkr_last_offset;
84200766:	1f f8 01 c2 	rMAC = r6 - rMAC;
8420076a:	61 f0 d2 8e 	M[r4 + 840] = rMAC;
8420076e:	0c 6e       	jump (m) Lc_aec_reference_timer_task_29;

84200770 <Lc_aec_reference_timer_task_28>:
            }
            else
            {
                op_extra_data->spkr_new_amount = new_offset + cbuffer_get_size_in_words(monbuf) - op_extra_data->spkr_last_offset;
84200770:	4a 08       	r0 = r7 + Null;
84200772:	ff fd 90 f0 	call (m) 0x12858;
84200776:	27 e7 
84200778:	8f f2 01 c0 	rMAC = r0 + r6;
8420077c:	62 f0 d1 88 	r0 = M[r4 + 836];
84200780:	89 04       	rMAC = rMAC - r0;
84200782:	61 f0 d2 8e 	M[r4 + 840] = rMAC;

84200786 <Lc_aec_reference_timer_task_29>:
            }
            op_extra_data->spkr_last_offset = new_offset;
84200786:	68 f0 d1 8e 	M[r4 + 836] = r6;

            /* Set a flag showing that speaker output has started consuming samples. */
            if(!op_extra_data->spkr_flow_started)
8420078a:	60 f0 d3 88 	Null = M[r4 + 844];
8420078e:	08 62       	if NE jump (m) Lc_aec_reference_timer_task_31;

84200790 <Lc_aec_reference_timer_task_30>:
            {
                op_extra_data->spkr_flow_started = op_extra_data->spkr_new_amount != 0;
84200790:	01 00       	rMAC = Null + Null;
84200792:	60 f0 d2 88 	Null = M[r4 + 840];
84200796:	21 f0 41 ce 	if NE rMAC = Null + 1;
8420079a:	61 f0 d3 8e 	M[r4 + 844] = rMAC;

8420079e <Lc_aec_reference_timer_task_31>:
            }
        }
#endif /* AEC_REF_CALC_SPKR_RATE_MONITOR_AMOUNT */

        /*  - Run MIC cbops */
        if(mic_graph_active)
8420079e:	38 04       	Null = r5 - Null;
842007a0:	8a 60       	if EQ jump (m) Lc_aec_reference_timer_task_59;

842007a2 <Lc_aec_reference_timer_task_32>:
        {
            if(op_extra_data->spkr_ref_active
               || op_extra_data->mic_sync_enable)
842007a2:	60 f0 a0 88 	Null = M[r4 + 640];
842007a6:	04 62       	if NE jump (m) Lc_aec_reference_timer_task_34;

842007a8 <Lc_aec_reference_timer_task_33>:
842007a8:	60 f0 d4 88 	Null = M[r4 + 848];
842007ac:	04 60       	if EQ jump (m) Lc_aec_reference_timer_task_35;

842007ae <Lc_aec_reference_timer_task_34>:
            {
                /* keep REFERENCE path and MIC output synchronised */
                aec_reference_update_mic_reference_sync(op_extra_data);
842007ae:	32 00       	r0 = r4 + Null;
842007b0:	0d f0 2b e8 	call (m) $_aec_reference_update_mic_reference_sync;

842007b4 <Lc_aec_reference_timer_task_35>:
            }

            if(!op_extra_data->mic_graph_no_output)
842007b4:	60 f0 dd 88 	Null = M[r4 + 884];
842007b8:	77 62       	if NE jump (m) Lc_aec_reference_timer_task_58;

842007ba <Lc_aec_reference_timer_task_36>:
            {
                /* Mic graph with output */
                unsigned b4_space = 0;
                unsigned after_space;
                unsigned amount_produced;
                tCbuffer *mic_buf = op_extra_data->output_stream[AEC_REF_OUTPUT_TERMINAL1];
842007ba:	68 f0 13 88 	r6 = M[r4 + 76];
                b4_space = cbuffer_calc_amount_space_in_words(mic_buf);
842007be:	42 08       	r0 = r6 + Null;
842007c0:	ff fd 5c f1 	call (m) 0x2c1b6;
842007c4:	37 ef 
842007c6:	17 00       	r5 = r0 + Null;
                cbops_process_data(op_extra_data->mic_graph, CBOPS_MAX_COPY_SIZE-1);
842007c8:	03 f0 ff 41 	r1 = Null + 511;
842007cc:	62 f0 6a 88 	r0 = M[r4 + 424];
842007d0:	ff fd d8 f2 	call 0x5b9a4;
842007d4:	34 ee 
                after_space = cbuffer_calc_amount_space_in_words(mic_buf);
842007d6:	42 08       	r0 = r6 + Null;
842007d8:	ff fd 5c f1 	call (m) 0x2c1b6;
842007dc:	3f ee 

                /* Don't tolerate cbops writing more than available space */
                PL_ASSERT(b4_space >= after_space);
842007de:	b8 04       	Null = r5 - r0;
842007e0:	02 f0 95 e0 	if C jump (m) Lc_aec_reference_timer_task_38;

842007e4 <Lc_aec_reference_timer_task_37>:
842007e4:	03 f0 23 60 	r1 = Null + 4131;
842007e8:	02 f0 13 60 	r0 = Null + 4115;
842007ec:	ff fd 9b f0 	call (m) 0x13f12;
842007f0:	27 e9 
842007f2:	f4 6e       	jump (m) Lc_aec_reference_timer_task_83;

842007f4 <Lc_aec_reference_timer_task_38>:
                amount_produced = b4_space - after_space;
842007f4:	2f f7 0a c2 	r8 = r5 - r0;

#ifdef AEC_REFERENCE_GENERATE_MIC_TIMESTAMP
                if(op_extra_data->mic_metadata_buffer!= NULL
                   && buff_has_metadata(op_extra_data->mic_metadata_buffer))
842007f8:	61 f0 ca 88 	rMAC = M[r4 + 808];
842007fc:	08 60       	if EQ jump (m) Lc_aec_reference_timer_task_41;

842007fe <Lc_aec_reference_timer_task_39>:
842007fe:	49 89       	rMAC = M[rMAC + 20];
84200800:	49 c6       	rMAC = rMAC AND 0x8000;
84200802:	05 60       	if EQ jump (m) Lc_aec_reference_timer_task_41;

84200804 <Lc_aec_reference_timer_task_40>:
                {
                    aec_reference_mic_generate_metadata_with_ttp(op_extra_data, b4_space - after_space);
84200804:	53 08       	r1 = r8 + Null;
84200806:	32 00       	r0 = r4 + Null;
84200808:	04 f0 39 e8 	call (m) $_aec_reference_mic_generate_metadata_with_ttp;

8420080c <Lc_aec_reference_timer_task_41>:
                   !op_extra_data->spkr_flow_started
#else
                   /* insert silence until speaker graph hasn't started */
                   !op_extra_data->spkr_ref_active
#endif
                   )
8420080c:	31 a8       	rMAC = M[r4 + 64];
8420080e:	53 60       	if EQ jump (m) Lc_aec_reference_timer_task_59;

84200810 <Lc_aec_reference_timer_task_42>:
84200810:	60 f0 d3 88 	Null = M[r4 + 844];
84200814:	50 62       	if NE jump (m) Lc_aec_reference_timer_task_59;

84200816 <Lc_aec_reference_timer_task_43>:
                     * Note: The synchronisation is normally done by the speaker latency operator
                     * however we don't have a running speaker graph at this situation, so is done
                     * manually here.
                     */

                    unsigned mic_out_data = cbuffer_calc_amount_data_in_words(mic_buf);
84200816:	42 08       	r0 = r6 + Null;
84200818:	ff fd 5c f1 	call (m) 0x2c208;
8420081c:	31 ef 
8420081e:	17 00       	r5 = r0 + Null;
                    /* if we have more than one mic, get max amount amnong all */
                    unsigned idx;
                    for(idx = 1; idx < op_extra_data->num_mic_channels; ++idx)
84200820:	08 71       	r6 = Null + 1;
84200822:	0f 6e       	jump (m) Lc_aec_reference_timer_task_49;

84200824 <Lc_aec_reference_timer_task_44>:
                    {
                        tCbuffer *out_buf = op_extra_data->output_stream[MicrophoneOutputTerminalByIndex(idx)];
84200824:	82 f0 09 20 	r0 = r6 + 9;

84200828 <Lc_aec_reference_timer_task_45>:
84200828:	61 f0 40 20 	rMAC = r4 + 64;
8420082c:	52 54       	r0 = r0 LSHIFT 2;
                        if(NULL != out_buf)
8420082e:	8a e8       	r0 = M[rMAC + r0];
84200830:	07 60       	if EQ jump (m) Lc_aec_reference_timer_task_48;

84200832 <Lc_aec_reference_timer_task_46>:
                        {
                            unsigned out_data = cbuffer_calc_amount_data_in_words(out_buf);
84200832:	ff fd 5c f1 	call (m) 0x2c208;
84200836:	37 ee 
                            mic_out_data = MAX(out_data, mic_out_data);
84200838:	d0 05       	Null = r0 - r5;
8420083a:	02 64       	if NC jump (m) Lc_aec_reference_timer_task_48;

8420083c <Lc_aec_reference_timer_task_47>:
8420083c:	17 00       	r5 = r0 + Null;

8420083e <Lc_aec_reference_timer_task_48>:
                     */

                    unsigned mic_out_data = cbuffer_calc_amount_data_in_words(mic_buf);
                    /* if we have more than one mic, get max amount amnong all */
                    unsigned idx;
                    for(idx = 1; idx < op_extra_data->num_mic_channels; ++idx)
8420083e:	08 75       	r6 = r6 + 1;

84200840 <Lc_aec_reference_timer_task_49>:
84200840:	61 f0 78 88 	rMAC = M[r4 + 480];
84200844:	1f f8 00 c2 	Null = r6 - rMAC;
84200848:	02 f0 91 e0 	if C jump (m) Lc_aec_reference_timer_task_52;

8420084c <Lc_aec_reference_timer_task_50>:
                    {
                        tCbuffer *out_buf = op_extra_data->output_stream[MicrophoneOutputTerminalByIndex(idx)];
8420084c:	80 f0 02 24 	Null = r6 - 2;
84200850:	f2 ff d5 ef 	if C jump (m) Lc_aec_reference_timer_task_44;

84200854 <Lc_aec_reference_timer_task_51>:
84200854:	02 21       	r0 = Null + 4;
84200856:	e9 6f       	jump (m) Lc_aec_reference_timer_task_45;

84200858 <Lc_aec_reference_timer_task_52>:
                        {
                            unsigned out_data = cbuffer_calc_amount_data_in_words(out_buf);
                            mic_out_data = MAX(out_data, mic_out_data);
                        }
                    }
                    tCbuffer *ref_buf = op_extra_data->output_stream[AEC_REF_REFERENCE_TERMINAL];
84200858:	68 f0 10 88 	r6 = M[r4 + 64];
                    unsigned ref_data = cbuffer_calc_amount_data_in_words(ref_buf);
8420085c:	42 08       	r0 = r6 + Null;
8420085e:	ff fd 5c f1 	call (m) 0x2c208;
84200862:	2b ed 
84200864:	11 09       	r7 = r0 + Null;
                    unsigned ideal_amount = mic_out_data +
                        op_extra_data->sync_block.ref_delay +
                        (op_extra_data->sync_block.jitter/2);
84200866:	62 f0 85 88 	r0 = M[r4 + 532];
8420086a:	61 f0 8a 88 	rMAC = M[r4 + 552];
8420086e:	12 50       	r0 = r0 LSHIFT -1;
84200870:	51 00       	rMAC = r0 + rMAC;
84200872:	cf 01       	r5 = rMAC + r5;
                    /* We only insert, dropping is done via waiting for mic buffer to fill up */
                    unsigned amount_to_insert = 0;
                    if(ideal_amount > ref_data)
84200874:	9f f7 00 c2 	Null = r5 - r7;
84200878:	09 f0 bd e0 	if LS jump (m) Lc_aec_reference_timer_task_59;

8420087c <Lc_aec_reference_timer_task_53>:
                    {
                        unsigned ref_space = cbuffer_calc_amount_space_in_words(ref_buf);
8420087c:	42 08       	r0 = r6 + Null;
8420087e:	ff fd 5c f1 	call (m) 0x2c1b6;
84200882:	39 e9 
                        amount_to_insert = ideal_amount - ref_data;
84200884:	9f f7 03 c2 	r1 = r5 - r7;
                         * Note: limit to amount_produced*3/2, since we own only the write
                         * side of the buffer, although the read sides are syncronised by
                         * consumer but there is a chance the this operator preempt the consumer
                         * right at the middle of read pointer update. For that reason we apply this limit
                         */
                        amount_to_insert = MIN(amount_to_insert, amount_produced*3/2);
84200888:	01 fa 94 d9 	r2 = r8 * 3 (int);
8420088c:	24 50       	r2 = r2 LSHIFT -1;
8420088e:	18 05       	Null = r1 - r2;
84200890:	02 64       	if NC jump (m) Lc_aec_reference_timer_task_55;

84200892 <Lc_aec_reference_timer_task_54>:
84200892:	23 00       	r1 = r2 + Null;

84200894 <Lc_aec_reference_timer_task_55>:
                        amount_to_insert = MIN(amount_to_insert, ref_space);
84200894:	98 04       	Null = r1 - r0;
84200896:	02 64       	if NC jump (m) Lc_aec_reference_timer_task_57;

84200898 <Lc_aec_reference_timer_task_56>:
84200898:	13 00       	r1 = r0 + Null;

8420089a <Lc_aec_reference_timer_task_57>:

                        /* insert silence */
                        cbuffer_block_fill(ref_buf, amount_to_insert, 0);
8420089a:	04 00       	r2 = Null + Null;
8420089c:	42 08       	r0 = r6 + Null;
8420089e:	ff fd 5d f1 	call (m) 0x2c2e8;
842008a2:	2b e2 
842008a4:	08 6e       	jump (m) Lc_aec_reference_timer_task_59;

842008a6 <Lc_aec_reference_timer_task_58>:
                }
            }
            else /* if(!op_extra_data->mic_graph_no_output) */
            {
                /* run cbops process for mic graph without output */
                cbops_process_data(op_extra_data->mic_graph, CBOPS_MAX_COPY_SIZE-1);
842008a6:	03 f0 ff 41 	r1 = Null + 511;
842008aa:	62 f0 6a 88 	r0 = M[r4 + 424];
842008ae:	ff fd d8 f2 	call 0x5b9a4;
842008b2:	36 e7 

842008b4 <Lc_aec_reference_timer_task_59>:
            }
        }

        /*  - Run SPKR cbops */
        if(spkr_graph_active)
842008b4:	51 d8       	rMAC = M[FP + 40];
842008b6:	57 60       	if EQ jump (m) Lc_aec_reference_timer_task_73;

842008b8 <Lc_aec_reference_timer_task_60>:
        {
#ifdef AEC_REFERENCE_SUPPORT_METADATA
            unsigned max_to_process = CBOPS_MAX_COPY_SIZE-1;
842008b8:	01 f0 ff 41 	rMAC = Null + 511;
842008bc:	59 de       	M[FP + 44] = rMAC;
            tCbuffer *met_buf = op_extra_data->spkr_input_metadata_buffer;
            unsigned before_amount = 0;
842008be:	00 09       	r6 = Null + Null;
            if(met_buf!= NULL && buff_has_metadata(met_buf))
842008c0:	67 f0 c9 88 	r5 = M[r4 + 804];
842008c4:	19 60       	if EQ jump (m) Lc_aec_reference_timer_task_65;

842008c6 <Lc_aec_reference_timer_task_61>:
842008c6:	79 89       	rMAC = M[r5 + 20];
842008c8:	49 c6       	rMAC = rMAC AND 0x8000;
842008ca:	1f 60       	if EQ jump (m) Lc_aec_reference_timer_task_66;

842008cc <Lc_aec_reference_timer_task_62>:
            {
                /* amount of metadata available */
                unsigned meta_data_available = buff_metadata_available_octets(met_buf)/OCTETS_PER_SAMPLE;
842008cc:	3a 00       	r0 = r5 + Null;
842008ce:	ff fd 8a f0 	call (m) 0x11d04;
842008d2:	37 e1 
842008d4:	7f f2 d9 c8 	r7 = r0 LSHIFT -2;

                /* get amount in the buffer before running cbops */
                before_amount = cbuffer_calc_amount_data_in_words(met_buf);
842008d8:	3a 00       	r0 = r5 + Null;
842008da:	ff fd 5c f1 	call (m) 0x2c208;
842008de:	2f e9 
842008e0:	10 09       	r6 = r0 + Null;

                /* if we have metadata enabled then limit the amount to
                 * process to the amount of available metadata
                 */
                max_to_process = MIN(max_to_process, meta_data_available);
842008e2:	59 d8       	rMAC = M[FP + 44];
842008e4:	9f f1 00 c2 	Null = rMAC - r7;
842008e8:	03 64       	if NC jump (m) Lc_aec_reference_timer_task_64;

842008ea <Lc_aec_reference_timer_task_63>:
842008ea:	e9 f0 0b 8e 	M[FP + 44] = r7;

842008ee <Lc_aec_reference_timer_task_64>:
#ifdef AEC_REFERENCE_SPKR_TTP
                /* Run TTP error control for speaker graph */
                aec_reference_spkr_ttp_run(op_extra_data, &max_to_process);
842008ee:	c3 12       	r1 = FP + 44;
842008f0:	32 00       	r0 = r4 + Null;
842008f2:	0f f0 23 ed 	call (m) $_aec_reference_spkr_ttp_run;

842008f6 <Lc_aec_reference_timer_task_65>:
#endif
            }

            /* run cbops process */
            cbops_process_data(op_extra_data->spkr_graph, max_to_process);
842008f6:	5b d8       	r1 = M[FP + 44];
842008f8:	62 f0 72 88 	r0 = M[r4 + 456];
842008fc:	ff fd d8 f2 	call 0x5b9a4;
84200900:	28 e5 

            if(met_buf!= NULL && buff_has_metadata(met_buf))
84200902:	38 04       	Null = r5 - Null;
84200904:	09 62       	if NE jump (m) Lc_aec_reference_timer_task_67;

84200906 <Lc_17>:
84200906:	27 6e       	jump (m) Lc_aec_reference_timer_task_71;

84200908 <Lc_aec_reference_timer_task_66>:
                aec_reference_spkr_ttp_run(op_extra_data, &max_to_process);
#endif
            }

            /* run cbops process */
            cbops_process_data(op_extra_data->spkr_graph, max_to_process);
84200908:	03 f0 ff 41 	r1 = Null + 511;
8420090c:	62 f0 72 88 	r0 = M[r4 + 456];
84200910:	ff fd d8 f2 	call 0x5b9a4;
84200914:	34 e4 

84200916 <Lc_aec_reference_timer_task_67>:
84200916:	79 89       	rMAC = M[r5 + 20];
84200918:	49 c6       	rMAC = rMAC AND 0x8000;
8420091a:	1d 60       	if EQ jump (m) Lc_aec_reference_timer_task_71;

8420091c <Lc_aec_reference_timer_task_68>:
                 * The assumption is that the write pointer of
                 * input buffer isn't changed during cbops
                 * process.
                 */
                unsigned amount_processed;
                unsigned after_amount = cbuffer_calc_amount_data_in_words(met_buf);
8420091c:	3a 00       	r0 = r5 + Null;
8420091e:	ff fd 5c f1 	call (m) 0x2c208;
84200922:	2b e7 
#ifdef TODO_AEC_REFERENCE_TTP
                /* for the moment don't tolerate cbops doing anything wrong */
                PL_ASSERT(after_amount <= before_amount);
84200924:	8f f2 00 c2 	Null = r0 - r6;
84200928:	08 f0 a5 e1 	if HI jump (m) Lc_aec_reference_timer_task_82;

8420092c <Lc_aec_reference_timer_task_69>:
                amount_processed = before_amount - after_amount;
8420092c:	00 f2 38 c2 	r6 = r6 - r0;
                     */
                    unsigned buff_size = cbuffer_get_size_in_words(met_buf);
                    amount_processed = buff_size + before_amount - after_amount;
                }
#endif /* TODO_AEC_REFERENCE_TTP */
                if(amount_processed > 0)
84200930:	0f f8 00 c2 	Null = r6 - Null;
84200934:	10 60       	if EQ jump (m) Lc_aec_reference_timer_task_71;

84200936 <Lc_aec_reference_timer_task_70>:
                {
                    /* delete metadata tags for consumed input */
                    unsigned b4idx, afteridx;
                    buff_metadata_tag_list_delete(
                        buff_metadata_remove(met_buf, OCTETS_PER_SAMPLE * amount_processed, &b4idx, &afteridx));
84200936:	45 13       	r3 = FP + 52;
84200938:	04 13       	r2 = FP + 48;
8420093a:	01 f8 d3 c8 	r1 = r6 LSHIFT 2;
8420093e:	3a 00       	r0 = r5 + Null;
84200940:	ff fd 8a f0 	call (m) 0x11d7a;
84200944:	3b e1 
84200946:	ff fd 87 f0 	call (m) 0x11906;
8420094a:	21 ee 
                    /* update timestamp */
                    aec_reference_spkr_ttp_update_last_timestamp(op_extra_data, amount_processed);
8420094c:	43 08       	r1 = r6 + Null;
8420094e:	32 00       	r0 = r4 + Null;
84200950:	10 f0 25 e3 	call (m) $_aec_reference_spkr_ttp_update_last_timestamp;

84200954 <Lc_aec_reference_timer_task_71>:
            }
#else /* AEC_REFERENCE_SUPPORT_METADATA */
            cbops_process_data(op_extra_data->spkr_graph, CBOPS_MAX_COPY_SIZE-1);
#endif /* AEC_REFERENCE_SUPPORT_METADATA*/
#ifdef PROFILER_ON
            if (op_data->profiler != NULL)
84200954:	b1 f0 08 88 	rMAC = M[r9 + 32];
84200958:	06 60       	if EQ jump (m) Lc_aec_reference_timer_task_73;

8420095a <Lc_aec_reference_timer_task_72>:
            {
                op_data->profiler->kick_inc++;
8420095a:	12 f0 2a 88 	r0 = M[rMAC + 168];
8420095e:	52 20       	r0 = r0 + 1;
84200960:	12 f0 2a 8e 	M[rMAC + 168] = r0;

84200964 <Lc_aec_reference_timer_task_73>:
            }
#endif            
        }

        /* Check for Kicks (outputs).   Use Output 1 available data*/
        if(op_extra_data->sync_block.block_sync)
84200964:	60 f0 87 88 	Null = M[r4 + 540];
84200968:	06 60       	if EQ jump (m) Lc_aec_reference_timer_task_75;

8420096a <Lc_aec_reference_timer_task_74>:
        {
            source_kicks = op_extra_data->source_kicks;
8420096a:	61 f0 7b 88 	rMAC = M[r4 + 492];
8420096e:	49 de       	M[FP + 36] = rMAC;
            op_extra_data->sync_block.block_sync = 0;
84200970:	60 f0 87 8e 	M[r4 + 540] = Null;

84200974 <Lc_aec_reference_timer_task_75>:
        }

        /* Check for Kick (inputs).   Use Input 1 available space */
        if(op_extra_data->input_stream[AEC_REF_INPUT_TERMINAL1])
84200974:	32 e8       	r0 = M[r4 + Null];
84200976:	0d 60       	if EQ jump (m) Lc_aec_reference_timer_task_78;

84200978 <Lc_aec_reference_timer_task_76>:
        {
            int available_space = cbuffer_calc_amount_space_in_words(op_extra_data->input_stream[AEC_REF_INPUT_TERMINAL1]);
84200978:	ff fd 5c f1 	call (m) 0x2c1b6;
8420097c:	3f e1 

            if(available_space >= op_extra_data->spkr_kick_size)
8420097e:	61 f0 75 88 	rMAC = M[r4 + 468];
84200982:	50 04       	Null = r0 - rMAC;
84200984:	06 64       	if NC jump (m) Lc_aec_reference_timer_task_78;

84200986 <Lc_aec_reference_timer_task_77>:
            {
                sink_kicks = op_extra_data->sink_kicks;
84200986:	61 f0 7c 88 	rMAC = M[r4 + 496];
8420098a:	41 de       	M[FP + 32] = rMAC;
            }
        }


        if(sink_kicks || source_kicks)
8420098c:	08 04       	Null = rMAC - Null;
8420098e:	03 62       	if NE jump (m) Lc_aec_reference_timer_task_79;

84200990 <Lc_aec_reference_timer_task_78>:
84200990:	49 d8       	rMAC = M[FP + 36];
84200992:	07 60       	if EQ jump (m) Lc_aec_reference_timer_task_80;

84200994 <Lc_aec_reference_timer_task_79>:
        {
            opmgr_kick_from_operator(op_data,source_kicks,sink_kicks);
84200994:	5a 08       	r0 = r9 + Null;
84200996:	44 d8       	r2 = M[FP + 32];
84200998:	4b d8       	r1 = M[FP + 36];
8420099a:	ff fd 11 f0 	call (m) 0x2d10;
8420099e:	37 eb 

842009a0 <Lc_aec_reference_timer_task_80>:
        }
    }

/* Next Timer Event */
    next_fire_time = time_add(get_last_fire_time(), op_extra_data->kick_period);
842009a0:	ff fd 9c f0 	call (m) 0x14334;
842009a4:	35 ec 
842009a6:	61 f0 94 88 	rMAC = M[r4 + 592];
842009aa:	8a 00       	r0 = rMAC + r0;
    op_extra_data->kick_id = timer_schedule_event_at(next_fire_time,
                                                     aec_reference_timer_task, (void*)op_data);
842009ac:	42 f0 03 f0 	r1 = Null + 69207689;
842009b0:	89 4a 
INLINE_SECTION static inline tTimerId timer_schedule_event_at(
       TIME event_time,
       tTimerEventFunction TimerEventFunction,
       void *data_pointer)
{
    return create_add_strict_event(event_time, TimerEventFunction, data_pointer);
842009b2:	5c 08       	r2 = r9 + Null;
842009b4:	ff fd 9b f0 	call (m) 0x1402a;
842009b8:	37 e3 
}
842009ba:	62 f0 5d 8e 	M[r4 + 372] = r0;
#ifdef PROFILER_ON
    if (op_data->profiler != NULL)
842009be:	b2 f0 08 88 	r0 = M[r9 + 32];
842009c2:	0c 60       	if EQ jump (m) Lc_aec_reference_timer_task_83;

842009c4 <Lc_aec_reference_timer_task_81>:
    {
        PROFILER_STOP(op_data->profiler);
842009c4:	ff fd 63 f1 	call (m) 0x2d0d0;
842009c8:	2d e8 
842009ca:	08 6e       	jump (m) Lc_aec_reference_timer_task_83;

842009cc <Lc_aec_reference_timer_task_82>:
                 */
                unsigned amount_processed;
                unsigned after_amount = cbuffer_calc_amount_data_in_words(met_buf);
#ifdef TODO_AEC_REFERENCE_TTP
                /* for the moment don't tolerate cbops doing anything wrong */
                PL_ASSERT(after_amount <= before_amount);
842009cc:	03 f0 9e 60 	r1 = Null + 4254;
842009d0:	02 f0 13 60 	r0 = Null + 4115;
842009d4:	ff fd 9a f0 	call (m) 0x13f12;
842009d8:	3f e9 

842009da <Lc_aec_reference_timer_task_83>:
    if (op_data->profiler != NULL)
    {
        PROFILER_STOP(op_data->profiler);
    }
#endif
}
842009da:	f6 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
842009dc:	d8 4c       	rts;

842009de <$_aec_reference_opmsg_ep_get_config>:
    return;
}
#endif /* INSTALL_DELEGATE_RATE_ADJUST_SUPPORT */

bool aec_reference_opmsg_ep_get_config(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842009de:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
842009e0:	17 99       	r5 = M[r0 + 48];

bool aec_reference_opmsg_ep_get_config(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    OPMSG_GET_CONFIG *msg = message_data;
    OPMSG_GET_CONFIG_RESULT *result = msg->result;
842009e2:	1e 89       	r4 = M[r1 + 16];
    unsigned term_idx = msg->header.cmd_header.client_id;
842009e4:	19 e8       	rMAC = M[r1 + Null];

    /* msg->value - Pointer which will be populated with the asked configuration value
       msg->cmd_header.client_id - Terminal ID (includes TERMINAL_SINK_MASK for sinks)
       msg->key - Parameter Key to return value for */

    switch(msg->key)
842009e6:	da 88       	r0 = M[r1 + 12];
842009e8:	d0 24       	Null = r0 - 3;
842009ea:	62 64       	if NC jump (m) Lc_aec_reference_opmsg_ep_get_config_28;

842009ec <Lc_aec_reference_opmsg_ep_get_config_2>:
842009ec:	d0 26       	Null = r0 - 11;
842009ee:	08 f0 c1 e1 	if HI jump (m) Lc_aec_reference_opmsg_ep_get_config_28;

842009f2 <Lc_aec_reference_opmsg_ep_get_config_3>:
842009f2:	ea 7c       	r0 = r0 + -3;
842009f4:	52 54       	r0 = r0 LSHIFT 2;
842009f6:	e0 f0 22 f0 	r0 = M[r0 + 7340280];
842009fa:	3e 88 
842009fc:	da 4c       	jump r0;

842009fe <Lc_aec_reference_opmsg_ep_get_config_4>:
    {
        case OPMSG_OP_TERMINAL_DETAILS:
            /* Return a uint32 - Is Terminal emulating a real endpoint. Called at operator endpoint creation.
             */
            if(term_idx & TERMINAL_SINK_MASK)
842009fe:	40 f0 12 f0 	r0 = rMAC AND 0x800000;
84200a02:	00 00 
84200a04:	0e 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_get_config_8;

84200a06 <Lc_aec_reference_opmsg_ep_get_config_5>:
          || ( (term_idx>=AEC_REF_INPUT_TERMINAL3)
              && (term_idx<=AEC_REF_INPUT_TERMINAL8) ) );
}
inline static bool IsMicrophoneTerminal(unsigned term_idx)
{
    term_idx &= ~TERMINAL_SINK_MASK;
84200a06:	bf ff 11 ff 	rMAC = rMAC AND 0xff7fffff;
84200a0a:	ff 1f 

    if(term_idx < AEC_REF_MIC_TERMINAL1)
84200a0c:	88 24       	Null = rMAC - 2;
84200a0e:	02 f0 a5 e1 	if C jump (m) Lc_aec_reference_opmsg_ep_get_config_29;

84200a12 <Lc_aec_reference_opmsg_ep_get_config_6>:
    {
        return FALSE;
84200a12:	02 00       	r0 = Null + Null;

84200a14 <Lc_aec_reference_opmsg_ep_get_config_7>:
            {
                result->value = (uint32)(IsMicrophoneTerminal(term_idx)?
                                         OPMSG_GET_CONFIG_TERMINAL_DETAILS_NONE:
                                         OPMSG_GET_CONFIG_TERMINAL_DETAILS_REAL);
84200a14:	01 00       	rMAC = Null + Null;
84200a16:	10 04       	Null = r0 - Null;
84200a18:	20 f0 41 ce 	if EQ rMAC = Null + 1;
84200a1c:	31 ee       	M[r4 + Null] = rMAC;
84200a1e:	21 6e       	jump (m) Lc_aec_reference_opmsg_ep_get_config_20;

84200a20 <Lc_aec_reference_opmsg_ep_get_config_8>:
inline static bool IsSpeakerTerminal(unsigned term_idx)
{
    return ( (term_idx==AEC_REF_SPKR_TERMINAL1)
          || (term_idx==AEC_REF_SPKR_TERMINAL2)
          || ( (term_idx>=AEC_REF_SPKR_TERMINAL3)
              && (term_idx<=AEC_REF_SPKR_TERMINAL8) ) );
84200a20:	48 24       	Null = rMAC - 1;
84200a22:	08 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_get_config_12;

84200a24 <Lc_aec_reference_opmsg_ep_get_config_9>:
84200a24:	88 24       	Null = rMAC - 2;
84200a26:	06 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_get_config_12;

84200a28 <Lc_aec_reference_opmsg_ep_get_config_10>:
84200a28:	c8 25       	Null = rMAC - 7;
84200a2a:	4e 64       	if NC jump (m) Lc_aec_reference_opmsg_ep_get_config_32;

84200a2c <Lc_aec_reference_opmsg_ep_get_config_11>:
84200a2c:	08 27       	Null = rMAC - 12;
84200a2e:	08 f0 99 e1 	if HI jump (m) Lc_aec_reference_opmsg_ep_get_config_32;

84200a32 <Lc_aec_reference_opmsg_ep_get_config_12>:
84200a32:	41 20       	rMAC = Null + 1;
84200a34:	4a 6e       	jump (m) Lc_aec_reference_opmsg_ep_get_config_33;

84200a36 <Lc_aec_reference_opmsg_ep_get_config_13>:
                                         OPMSG_GET_CONFIG_TERMINAL_DETAILS_NONE:
                                         OPMSG_GET_CONFIG_TERMINAL_DETAILS_REAL);
            }
            break;
        case OPMSG_OP_TERMINAL_RATEMATCH_ABILITY: /* uint32 */
            if(term_idx == (AEC_REF_INPUT_TERMINAL1|TERMINAL_SINK_MASK) )
84200a36:	00 f2 10 f0 	Null = rMAC - 8388608;
84200a3a:	00 24 
84200a3c:	05 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_get_config_15;

84200a3e <Lc_aec_reference_opmsg_ep_get_config_14>:
            {
                result->value = (uint32)op_extra_data->spkr_rate_ability;
84200a3e:	71 f0 6f 88 	rMAC = M[r5 + 444];
84200a42:	31 ee       	M[r4 + Null] = rMAC;
84200a44:	09 6e       	jump (m) Lc_aec_reference_opmsg_ep_get_config_18;

84200a46 <Lc_aec_reference_opmsg_ep_get_config_15>:
                     */
                    result->value = RATEMATCHING_SUPPORT_HW;
                }
#endif
            }
            else if (term_idx == AEC_REF_OUTPUT_TERMINAL1)
84200a46:	c8 24       	Null = rMAC - 3;
84200a48:	0e 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_get_config_21;

84200a4a <Lc_aec_reference_opmsg_ep_get_config_16>:
            {

                if(op_extra_data->mic_sync_enable)
84200a4a:	70 f0 d4 88 	Null = M[r5 + 848];
84200a4e:	0b 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_get_config_21;

84200a50 <Lc_aec_reference_opmsg_ep_get_config_17>:
                    result->value = (uint32)RATEMATCHING_SUPPORT_AUTO;
                }
                else
                {

                    result->value = (uint32)op_extra_data->mic_rate_ability;
84200a50:	71 f0 67 88 	rMAC = M[r5 + 412];
84200a54:	31 ee       	M[r4 + Null] = rMAC;

84200a56 <Lc_aec_reference_opmsg_ep_get_config_18>:
        case OPMSG_OP_TERMINAL_RATEMATCH_ABILITY: /* uint32 */
            if(term_idx == (AEC_REF_INPUT_TERMINAL1|TERMINAL_SINK_MASK) )
            {
                result->value = (uint32)op_extra_data->spkr_rate_ability;
#ifdef ENABLE_FORCE_ENACTING_BY_AEC_REFERENCE
                if(RATEMATCHING_SUPPORT_SW == result->value)
84200a56:	31 e8       	rMAC = M[r4 + Null];
84200a58:	48 24       	Null = rMAC - 1;
84200a5a:	03 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_get_config_20;

84200a5c <Lc_aec_reference_opmsg_ep_get_config_19>:
                {
                    /* Advertise HW despite planning to do it in SW
                     * this will make sure that enacting will be granted
                     * to this end.
                     */
                    result->value = RATEMATCHING_SUPPORT_HW;
84200a5c:	81 20       	rMAC = Null + 2;
84200a5e:	31 ee       	M[r4 + Null] = rMAC;

84200a60 <Lc_aec_reference_opmsg_ep_get_config_20>:
        case OPMSG_OP_TERMINAL_PROC_TIME:         /* uint32 */
        default:
            return FALSE;
    }

    return TRUE;
84200a60:	42 20       	r0 = Null + 1;
84200a62:	39 6e       	jump (m) Lc_aec_reference_opmsg_ep_get_config_34;

84200a64 <Lc_aec_reference_opmsg_ep_get_config_21>:
                }

            }
            else
            {
                result->value = (uint32)RATEMATCHING_SUPPORT_AUTO;
84200a64:	c1 20       	rMAC = Null + 3;
84200a66:	31 ee       	M[r4 + Null] = rMAC;
84200a68:	fc 6f       	jump (m) Lc_aec_reference_opmsg_ep_get_config_20;

84200a6a <Lc_aec_reference_opmsg_ep_get_config_22>:
            break;
        case OPMSG_OP_TERMINAL_KICK_PERIOD:       /* uint32 */
            break;
        case OPMSG_OP_TERMINAL_RATEMATCH_RATE:    /* uint32 */

            if(term_idx == (AEC_REF_INPUT_TERMINAL1|TERMINAL_SINK_MASK) )
84200a6a:	00 f2 10 f0 	Null = rMAC - 8388608;
84200a6e:	00 24 
84200a70:	0b 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_get_config_24;

84200a72 <Lc_aec_reference_opmsg_ep_get_config_23>:
            {
                result->value = rate_monitor_op_get_rate(op_extra_data->spkr_rate_monitor_op,0);
84200a72:	72 f0 73 88 	r0 = M[r5 + 460];
84200a76:	03 00       	r1 = Null + Null;
84200a78:	ff fd 58 f3 	call 0x6bbf0;
84200a7c:	38 eb 
84200a7e:	32 ee       	M[r4 + Null] = r0;
                patch_fn_shared(aec_reference);

                op_extra_data->spkr_rate_meas = (unsigned)(result->value);
84200a80:	72 f0 83 8e 	M[r5 + 524] = r0;
84200a84:	ee 6f       	jump (m) Lc_aec_reference_opmsg_ep_get_config_20;

84200a86 <Lc_aec_reference_opmsg_ep_get_config_24>:

            }
            else if (term_idx == AEC_REF_OUTPUT_TERMINAL1)
84200a86:	c8 24       	Null = rMAC - 3;
84200a88:	0b 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_get_config_26;

84200a8a <Lc_aec_reference_opmsg_ep_get_config_25>:
            {
                result->value = rate_monitor_op_get_rate(op_extra_data->mic_rate_monitor_op,0);
84200a8a:	72 f0 6b 88 	r0 = M[r5 + 428];
84200a8e:	03 00       	r1 = Null + Null;
84200a90:	ff fd 58 f3 	call 0x6bbf0;
84200a94:	20 eb 
84200a96:	32 ee       	M[r4 + Null] = r0;
                patch_fn_shared(aec_reference);

                op_extra_data->mic_rate_meas = (unsigned)(result->value);
84200a98:	72 f0 84 8e 	M[r5 + 528] = r0;
84200a9c:	e2 6f       	jump (m) Lc_aec_reference_opmsg_ep_get_config_20;

84200a9e <Lc_aec_reference_opmsg_ep_get_config_26>:
            }
            else
            {
                /* 1.0 in Qx.22 independent of word width */
                result->value = 1<<STREAM_RATEMATCHING_FIX_POINT_SHIFT;
84200a9e:	04 f0 01 f0 	rMAC = Null + 4194304;
84200aa2:	00 40 
84200aa4:	31 ee       	M[r4 + Null] = rMAC;
84200aa6:	dd 6f       	jump (m) Lc_aec_reference_opmsg_ep_get_config_20;

84200aa8 <Lc_aec_reference_opmsg_ep_get_config_27>:
            }

            break;
        case OPMSG_OP_TERMINAL_RATEMATCH_MEASUREMENT:
            /* TODO */
            result->rm_measurement.sp_deviation = 0;
84200aa8:	30 ee       	M[r4 + Null] = Null;
            result->rm_measurement.measurement.valid = FALSE;
84200aaa:	30 8b       	MB[r4 + 4] = Null;
            break;
84200aac:	da 6f       	jump (m) Lc_aec_reference_opmsg_ep_get_config_20;

84200aae <Lc_aec_reference_opmsg_ep_get_config_28>:
        case OPMSG_OP_TERMINAL_BLOCK_SIZE:        /* uint32 */
        case OPMSG_OP_TERMINAL_PROC_TIME:         /* uint32 */
        default:
            return FALSE;
84200aae:	02 00       	r0 = Null + Null;
84200ab0:	12 6e       	jump (m) Lc_aec_reference_opmsg_ep_get_config_34;

84200ab2 <Lc_aec_reference_opmsg_ep_get_config_29>:

    if(term_idx < AEC_REF_MIC_TERMINAL1)
    {
        return FALSE;
    }
    if(term_idx <= AEC_REF_MIC_TERMINAL4)
84200ab2:	48 25       	Null = rMAC - 5;
84200ab4:	08 f0 89 e0 	if HI jump (m) Lc_aec_reference_opmsg_ep_get_config_31;

84200ab8 <Lc_aec_reference_opmsg_ep_get_config_30>:
    {
        return TRUE;
84200ab8:	42 20       	r0 = Null + 1;
84200aba:	ad 6f       	jump (m) Lc_aec_reference_opmsg_ep_get_config_7;

84200abc <Lc_aec_reference_opmsg_ep_get_config_31>:
    }
    return (term_idx >= AEC_REF_MIC_TERMINAL5);
84200abc:	02 00       	r0 = Null + Null;
84200abe:	08 27       	Null = rMAC - 12;
84200ac0:	22 f0 42 ce 	if C r0 = Null + 1;
84200ac4:	a8 6f       	jump (m) Lc_aec_reference_opmsg_ep_get_config_7;

84200ac6 <Lc_aec_reference_opmsg_ep_get_config_32>:
inline static bool IsSpeakerTerminal(unsigned term_idx)
{
    return ( (term_idx==AEC_REF_SPKR_TERMINAL1)
          || (term_idx==AEC_REF_SPKR_TERMINAL2)
          || ( (term_idx>=AEC_REF_SPKR_TERMINAL3)
              && (term_idx<=AEC_REF_SPKR_TERMINAL8) ) );
84200ac6:	01 00       	rMAC = Null + Null;

84200ac8 <Lc_aec_reference_opmsg_ep_get_config_33>:
            }
            else
            {
                result->value = (uint32)(IsSpeakerTerminal(term_idx)?
                                         OPMSG_GET_CONFIG_TERMINAL_DETAILS_NONE:
                                         OPMSG_GET_CONFIG_TERMINAL_DETAILS_REAL);
84200ac8:	02 00       	r0 = Null + Null;
84200aca:	08 04       	Null = rMAC - Null;
84200acc:	20 f0 42 ce 	if EQ r0 = Null + 1;
84200ad0:	32 ee       	M[r4 + Null] = r0;
84200ad2:	c7 6f       	jump (m) Lc_aec_reference_opmsg_ep_get_config_20;

84200ad4 <Lc_aec_reference_opmsg_ep_get_config_34>:
        default:
            return FALSE;
    }

    return TRUE;
}
84200ad4:	f2 48       	popm <FP, r4, r5, rLink>;
84200ad6:	d8 4c       	rts;

84200ad8 <$_aec_reference_opmsg_ep_configure>:


bool aec_reference_opmsg_ep_configure(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200ad8:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84200ada:	16 99       	r4 = M[r0 + 48];

bool aec_reference_opmsg_ep_configure(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    OPMSG_CONFIGURE  *msg = message_data;
    unsigned terminal_id = msg->header.cmd_header.client_id;
84200adc:	19 e8       	rMAC = M[r1 + Null];
    uint32      value = msg->value;
84200ade:	1f 89       	r5 = M[r1 + 16];

    /* msg->value - Pointer or Value for Key
       msg->cmd_header.client_id - Terminal ID (includes TERMINAL_SINK_MASK for sinks)
       msg->key - Parameter Key to return value for */

    switch(msg->key)
84200ae0:	da 88       	r0 = M[r1 + 12];
84200ae2:	0c 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_5;

84200ae4 <Lc_aec_reference_opmsg_ep_configure_2>:
84200ae4:	90 26       	Null = r0 - 10;
84200ae6:	08 f0 95 e0 	if HI jump (m) Lc_aec_reference_opmsg_ep_configure_5;

84200aea <Lc_aec_reference_opmsg_ep_configure_3>:
84200aea:	52 24       	r0 = r0 - 1;
84200aec:	52 54       	r0 = r0 LSHIFT 2;
84200aee:	e0 f0 22 f0 	r0 = M[r0 + 7340316];
84200af2:	47 88 
84200af4:	da 4c       	jump r0;

84200af6 <Lc_aec_reference_opmsg_ep_configure_4>:
    {
        case OPMSG_OP_TERMINAL_DATA_FORMAT:
            /* value is data type */
            if( ((AUDIO_DATA_FORMAT)msg->value)!=AUDIO_DATA_FORMAT_FIXP )
84200af6:	78 24       	Null = r5 - 1;
84200af8:	e7 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200afa <Lc_aec_reference_opmsg_ep_configure_5>:
            {
                return(FALSE);
84200afa:	02 00       	r0 = Null + Null;
84200afc:	e6 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_56;

84200afe <Lc_aec_reference_opmsg_ep_configure_6>:
               TODO - Really need to know type of endpoint: ADC/DAC, I2S, Digital MIC

               CBOPS_DC_REMOVE | CBOPS_SHIFT (set data format --> AUDIO_DATA_FORMAT_FIXP)
               CBOPS_RATEADJUST (EP_RATEMATCH_ENACTING) */

            if(terminal_id == (AEC_REF_MIC_TERMINAL1|TERMINAL_SINK_MASK) )
84200afe:	00 f2 10 f0 	Null = rMAC - 8388610;
84200b02:	02 24 
84200b04:	08 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_8;

84200b06 <Lc_aec_reference_opmsg_ep_configure_7>:
            {
                op_extra_data->mic_shift = get_shift_from_cbops_parameters((CBOPS_PARAMETERS *)(uintptr_t)value);
84200b06:	3a 00       	r0 = r5 + Null;
84200b08:	ff fd 1f f0 	call (m) 0x49da;
84200b0c:	33 e6 
84200b0e:	62 f0 6d 8e 	M[r4 + 436] = r0;
84200b12:	da 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200b14 <Lc_aec_reference_opmsg_ep_configure_8>:
            }
            else if (terminal_id == AEC_REF_SPKR_TERMINAL1)
84200b14:	48 24       	Null = rMAC - 1;
84200b16:	d8 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200b18 <Lc_aec_reference_opmsg_ep_configure_9>:
            {
                op_extra_data->spkr_shift = get_shift_from_cbops_parameters((CBOPS_PARAMETERS *)(uintptr_t)value);
84200b18:	3a 00       	r0 = r5 + Null;
84200b1a:	ff fd 1f f0 	call (m) 0x49da;
84200b1e:	21 e6 
84200b20:	62 f0 74 8e 	M[r4 + 464] = r0;
84200b24:	d1 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200b26 <Lc_aec_reference_opmsg_ep_configure_10>:
            /* uint32 expected block size per period

               endpoint->state.audio.block_size = (unsigned int)value;
               endpoint->state.audio.kick_period =  (unsigned int)(value * (unsigned long)STREAM_KICK_PERIOD_FROM_USECS(1000000UL) /
               endpoint->state.audio.sample_rate); */
            if(terminal_id == (AEC_REF_INPUT_TERMINAL1|TERMINAL_SINK_MASK) )
84200b26:	00 f2 10 f0 	Null = rMAC - 8388608;
84200b2a:	00 24 
84200b2c:	04 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_12;

84200b2e <Lc_aec_reference_opmsg_ep_configure_11>:
            {
                op_extra_data->spkr_kick_size = (unsigned)value;
84200b2e:	67 f0 75 8e 	M[r4 + 468] = r5;
84200b32:	ca 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200b34 <Lc_aec_reference_opmsg_ep_configure_12>:
            }
            else if (terminal_id == AEC_REF_OUTPUT_TERMINAL1)
84200b34:	c8 24       	Null = rMAC - 3;
84200b36:	c8 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200b38 <Lc_aec_reference_opmsg_ep_configure_13>:

                /* mic-ref block_size latency control only works for larger block sizes, it will fail
                 * if requested block size is small, so we apply a minimum block size, below
                 * that mic-ref latency control logic will be turned off.
                 */
                unsigned min_block_size = frac_mult(op_extra_data->output_rate, FRACTIONAL(0.006));
84200b38:	62 f0 65 88 	r0 = M[r4 + 404];
84200b3c:	0c f0 43 f2 	r1 = Null + 12884901;
84200b40:	a5 73 
84200b42:	00 f3 72 c9 	r0 = r0 * r1 (frac);

                /* Validate block size for sync logic.   Output buffers size will be at least 8.7 msec of data */
                if(block_size && (block_size < min_block_size) )
84200b46:	39 00       	rMAC = r5 + Null;
84200b48:	05 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_16;

84200b4a <Lc_aec_reference_opmsg_ep_configure_14>:
84200b4a:	b8 04       	Null = r5 - r0;
84200b4c:	02 f0 87 e0 	if C jump (m) Lc_aec_reference_opmsg_ep_configure_16;

84200b50 <Lc_aec_reference_opmsg_ep_configure_15>:
                {
                    /* Disable sync logic if block_size is to small */
                    block_size = 0;
84200b50:	01 00       	rMAC = Null + Null;

84200b52 <Lc_aec_reference_opmsg_ep_configure_16>:
                }
                op_extra_data->sync_block.block_size = block_size;
84200b52:	61 f0 86 8e 	M[r4 + 536] = rMAC;
#ifdef AEC_REFERENCE_GENERATE_MIC_TIMESTAMP
                {
                    /* update minimum len metadata tags for mic output */
                    op_extra_data->mic_metadata_min_tag_len =
                        MAX(op_extra_data->mic_metadata_min_tag_len,
                            op_extra_data->sync_block.block_size);
84200b56:	62 f0 cc 88 	r0 = M[r4 + 816];
84200b5a:	50 04       	Null = r0 - rMAC;
84200b5c:	02 f0 eb e2 	if C jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200b60 <Lc_aec_reference_opmsg_ep_configure_17>:
84200b60:	61 f0 cc 8e 	M[r4 + 816] = rMAC;
84200b64:	b1 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200b66 <Lc_aec_reference_opmsg_ep_configure_18>:
            }
            break;
        case OPMSG_OP_TERMINAL_RATEMATCH_ENACTING:
            /* uint32 TRUE or FALSE.   Operator should perform rate matching if TRUE  */

            if(terminal_id == (AEC_REF_INPUT_TERMINAL1|TERMINAL_SINK_MASK) )
84200b66:	00 f2 10 f0 	Null = rMAC - 8388608;
84200b6a:	00 24 
84200b6c:	2a 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_27;

84200b6e <Lc_aec_reference_opmsg_ep_configure_19>:
            {
                set_override_ep_ratematch_enacting(op_extra_data->spkr_endpoint,value);
84200b6e:	62 f0 80 88 	r0 = M[r4 + 512];
84200b72:	3b 00       	r1 = r5 + Null;
84200b74:	ff fd 1f f0 	call (m) 0x4a3e;
84200b78:	2b e6 
                if(value==(uint32)FALSE)
84200b7a:	38 04       	Null = r5 - Null;
84200b7c:	04 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_21;

84200b7e <Lc_aec_reference_opmsg_ep_configure_20>:
                {
                    op_extra_data->spkr_rate_enactment = RATEMATCHING_SUPPORT_NONE;
84200b7e:	60 f0 71 8e 	M[r4 + 452] = Null;
84200b82:	05 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_22;

84200b84 <Lc_aec_reference_opmsg_ep_configure_21>:
                }
                else
                {
                    op_extra_data->spkr_rate_enactment = op_extra_data->spkr_rate_ability;
84200b84:	61 f0 6f 88 	rMAC = M[r4 + 444];
84200b88:	61 f0 71 8e 	M[r4 + 452] = rMAC;

84200b8c <Lc_aec_reference_opmsg_ep_configure_22>:
                }

                if((op_extra_data->spkr_rate_enactment==RATEMATCHING_SUPPORT_HW) && (op_extra_data->spkr_rate_monitor_op))
84200b8c:	61 f0 71 88 	rMAC = M[r4 + 452];
84200b90:	88 24       	Null = rMAC - 2;
84200b92:	0b 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_25;

84200b94 <Lc_aec_reference_opmsg_ep_configure_23>:
84200b94:	62 f0 73 88 	r0 = M[r4 + 460];
84200b98:	08 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_25;

84200b9a <Lc_aec_reference_opmsg_ep_configure_24>:
                {
                    rate_monitor_op_initialise(op_extra_data->spkr_rate_monitor_op,op_extra_data->spkr_rate,TRUE,3*MS_PER_SEC);
84200b9a:	05 f0 b8 53 	r3 = Null + 3000;
84200b9e:	44 20       	r2 = Null + 1;
84200ba0:	63 f0 6e 88 	r1 = M[r4 + 440];
84200ba4:	fa ff 38 e3 	call $_rate_monitor_op_initialise;

84200ba8 <Lc_aec_reference_opmsg_ep_configure_25>:
                }

                if(op_extra_data->spkr_sw_rateadj_op)
84200ba8:	62 f0 7e 88 	r0 = M[r4 + 504];
84200bac:	8d 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200bae <Lc_aec_reference_opmsg_ep_configure_26>:
                {
                    cbops_rateadjust_passthrough_mode(op_extra_data->spkr_sw_rateadj_op,(op_extra_data->spkr_rate_enactment==RATEMATCHING_SUPPORT_NONE)?TRUE:FALSE);
84200bae:	03 00       	r1 = Null + Null;
84200bb0:	60 f0 71 88 	Null = M[r4 + 452];
84200bb4:	20 f0 43 ce 	if EQ r1 = Null + 1;
84200bb8:	ff fd b0 f0 	call (m) 0x16c96;
84200bbc:	3f e6 
84200bbe:	84 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200bc0 <Lc_aec_reference_opmsg_ep_configure_27>:

                }
            }
            else if (terminal_id == AEC_REF_OUTPUT_TERMINAL1
                     && !op_extra_data->mic_sync_enable)
84200bc0:	c8 24       	Null = rMAC - 3;
84200bc2:	82 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200bc4 <Lc_aec_reference_opmsg_ep_configure_28>:
84200bc4:	60 f0 d4 88 	Null = M[r4 + 848];
84200bc8:	7f 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200bca <Lc_aec_reference_opmsg_ep_configure_29>:
            {
                set_override_ep_ratematch_enacting(op_extra_data->mic_endpoint,value);
84200bca:	62 f0 7f 88 	r0 = M[r4 + 508];
84200bce:	3b 00       	r1 = r5 + Null;
84200bd0:	ff fd 1f f0 	call (m) 0x4a3e;
84200bd4:	2f e3 
                if(value==(uint32)FALSE)
84200bd6:	38 04       	Null = r5 - Null;
84200bd8:	04 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_31;

84200bda <Lc_aec_reference_opmsg_ep_configure_30>:
                {
                    op_extra_data->mic_rate_enactment = RATEMATCHING_SUPPORT_NONE;
84200bda:	60 f0 68 8e 	M[r4 + 416] = Null;
84200bde:	05 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_32;

84200be0 <Lc_aec_reference_opmsg_ep_configure_31>:
                }
                else
                {
                    op_extra_data->mic_rate_enactment = op_extra_data->mic_rate_ability;
84200be0:	61 f0 67 88 	rMAC = M[r4 + 412];
84200be4:	61 f0 68 8e 	M[r4 + 416] = rMAC;

84200be8 <Lc_aec_reference_opmsg_ep_configure_32>:
                }

                if((op_extra_data->mic_rate_enactment==RATEMATCHING_SUPPORT_HW) && (op_extra_data->mic_rate_monitor_op))
84200be8:	61 f0 68 88 	rMAC = M[r4 + 416];
84200bec:	88 24       	Null = rMAC - 2;
84200bee:	0b 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_35;

84200bf0 <Lc_aec_reference_opmsg_ep_configure_33>:
84200bf0:	62 f0 6b 88 	r0 = M[r4 + 428];
84200bf4:	08 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_35;

84200bf6 <Lc_aec_reference_opmsg_ep_configure_34>:
                {
                    rate_monitor_op_initialise(op_extra_data->mic_rate_monitor_op,op_extra_data->mic_rate,TRUE,3*MS_PER_SEC);
84200bf6:	05 f0 b8 53 	r3 = Null + 3000;
84200bfa:	44 20       	r2 = Null + 1;
84200bfc:	63 f0 66 88 	r1 = M[r4 + 408];
84200c00:	fa ff 3c e0 	call $_rate_monitor_op_initialise;

84200c04 <Lc_aec_reference_opmsg_ep_configure_35>:
                }

                if(op_extra_data->mic_sw_rateadj_op)
84200c04:	62 f0 7d 88 	r0 = M[r4 + 500];
84200c08:	5f 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200c0a <Lc_aec_reference_opmsg_ep_configure_36>:
                {
                    cbops_rateadjust_passthrough_mode(op_extra_data->mic_sw_rateadj_op,(op_extra_data->mic_rate_enactment==RATEMATCHING_SUPPORT_NONE)?TRUE:FALSE);
84200c0a:	03 00       	r1 = Null + Null;
84200c0c:	60 f0 68 88 	Null = M[r4 + 416];
84200c10:	20 f0 43 ce 	if EQ r1 = Null + 1;
84200c14:	ff fd b0 f0 	call (m) 0x16c96;
84200c18:	23 e4 
84200c1a:	56 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200c1c <Lc_aec_reference_opmsg_ep_configure_37>:
            break;
        case OPMSG_OP_TERMINAL_RATEMATCH_ADJUSTMENT:
        {
            int svalue = (int)value;
            /*  See BlueCore audio real endpoint function "adjust_audio_rate" for details */
            if(terminal_id == (AEC_REF_INPUT_TERMINAL1|TERMINAL_SINK_MASK) )
84200c1c:	00 f2 10 f0 	Null = rMAC - 8388608;
84200c20:	00 24 
84200c22:	29 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_46;

84200c24 <Lc_aec_reference_opmsg_ep_configure_38>:
            {
#ifdef AEC_REFERENCE_SPKR_TTP
                if(op_extra_data->spkr_timed_playback_mode)
84200c24:	60 f0 b2 88 	Null = M[r4 + 712];
84200c28:	4f 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200c2a <Lc_aec_reference_opmsg_ep_configure_39>:
                     * rate adjustment is managed by speaker ttp */
                    break;
                }
#endif /* AEC_REFERENCE_SPKR_TTP */
                /* Send Rate Adjustment to hardware */
                if(op_extra_data->spkr_rate_enactment==RATEMATCHING_SUPPORT_HW)
84200c2a:	61 f0 71 88 	rMAC = M[r4 + 452];
84200c2e:	88 24       	Null = rMAC - 2;
84200c30:	19 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_44;

84200c32 <Lc_aec_reference_opmsg_ep_configure_40>:
                {
                    if(op_extra_data->output_stream[AEC_REF_SPKR_TERMINAL1])
84200c32:	71 a8       	rMAC = M[r4 + 68];
84200c34:	49 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200c36 <Lc_aec_reference_opmsg_ep_configure_41>:
                    {
                        if((op_extra_data->spkr_rate_monitor_op) && (rate_monitor_op_is_complete(op_extra_data->spkr_rate_monitor_op)))
84200c36:	62 f0 73 88 	r0 = M[r4 + 460];
84200c3a:	46 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200c3c <Lc_aec_reference_opmsg_ep_configure_42>:
84200c3c:	ff fd 57 f3 	call 0x6bc28;
84200c40:	2c ef 
84200c42:	10 04       	Null = r0 - Null;
84200c44:	41 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200c46 <Lc_aec_reference_opmsg_ep_configure_43>:
                        {
                            op_extra_data->spkr_rate_adjustment = svalue;
84200c46:	3b 00       	r1 = r5 + Null;
84200c48:	63 f0 70 8e 	M[r4 + 448] = r1;
                            value = op_extra_data->spkr_rate_adjustment;
                            set_override_ep_ratematch_adjustment(op_extra_data->spkr_endpoint,value);
84200c4c:	62 f0 80 88 	r0 = M[r4 + 512];
84200c50:	ff fd 1f f0 	call (m) 0x4aa0;
84200c54:	31 e2 
                            rate_monitor_op_restart(op_extra_data->spkr_rate_monitor_op);
84200c56:	62 f0 73 88 	r0 = M[r4 + 460];
84200c5a:	ff fd 57 f3 	call 0x6bc14;
84200c5e:	3a ed 
84200c60:	33 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200c62 <Lc_aec_reference_opmsg_ep_configure_44>:
                        }
                    }
                }
                else
                {
                    op_extra_data->spkr_rate_adjustment = svalue;
84200c62:	3b 00       	r1 = r5 + Null;
84200c64:	63 f0 70 8e 	M[r4 + 448] = r1;
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
                    if(0 != op_extra_data->spkr_ext_rate_adjust_op)
84200c68:	62 f0 ae 88 	r0 = M[r4 + 696];
84200c6c:	2d 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200c6e <Lc_aec_reference_opmsg_ep_configure_45>:
                    {

                        /* set the target rate value, this will be ignored if speaker path is doing TTP. */
                        stream_delegate_rate_adjust_set_target_rate(op_extra_data->spkr_ext_rate_adjust_op,
                                                                    op_extra_data->spkr_rate_adjustment);
84200c6e:	11 f0 33 ef 	call (m) $_stream_delegate_rate_adjust_set_target_rate;
84200c72:	2a 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200c74 <Lc_aec_reference_opmsg_ep_configure_46>:
            }
            else if (terminal_id == AEC_REF_OUTPUT_TERMINAL1
                     /* if we are syncing mic to speaker input we shouldn't
                      * receive this message, but ignore it if we received.
                      */
                     && !op_extra_data->mic_sync_enable)
84200c74:	c8 24       	Null = rMAC - 3;
84200c76:	28 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200c78 <Lc_aec_reference_opmsg_ep_configure_47>:
84200c78:	60 f0 d4 88 	Null = M[r4 + 848];
84200c7c:	25 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200c7e <Lc_aec_reference_opmsg_ep_configure_48>:
            {
                /* Send Rate Adjustment to hardware */
                if(op_extra_data->mic_rate_enactment == RATEMATCHING_SUPPORT_HW)
84200c7e:	61 f0 68 88 	rMAC = M[r4 + 416];
84200c82:	88 24       	Null = rMAC - 2;
84200c84:	19 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_configure_53;

84200c86 <Lc_aec_reference_opmsg_ep_configure_49>:
                {
                    if(op_extra_data->input_stream[AEC_REF_MIC_TERMINAL1])
84200c86:	b1 88       	rMAC = M[r4 + 8];
84200c88:	1f 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200c8a <Lc_aec_reference_opmsg_ep_configure_50>:
                    {
                        if((op_extra_data->mic_rate_monitor_op) && (rate_monitor_op_is_complete(op_extra_data->mic_rate_monitor_op)))
84200c8a:	62 f0 6b 88 	r0 = M[r4 + 428];
84200c8e:	1c 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200c90 <Lc_aec_reference_opmsg_ep_configure_51>:
84200c90:	ff fd 57 f3 	call 0x6bc28;
84200c94:	38 ec 
84200c96:	10 04       	Null = r0 - Null;
84200c98:	17 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200c9a <Lc_aec_reference_opmsg_ep_configure_52>:
                        {
                            op_extra_data->mic_rate_adjustment = svalue;
84200c9a:	3b 00       	r1 = r5 + Null;
84200c9c:	63 f0 69 8e 	M[r4 + 420] = r1;
                            value = op_extra_data->mic_rate_adjustment;
                            set_override_ep_ratematch_adjustment(op_extra_data->mic_endpoint,value);
84200ca0:	62 f0 7f 88 	r0 = M[r4 + 508];
84200ca4:	ff fd 1e f0 	call (m) 0x4aa0;
84200ca8:	3d ef 
                            rate_monitor_op_restart(op_extra_data->mic_rate_monitor_op);
84200caa:	62 f0 6b 88 	r0 = M[r4 + 428];
84200cae:	ff fd 57 f3 	call 0x6bc14;
84200cb2:	26 eb 
84200cb4:	09 6e       	jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200cb6 <Lc_aec_reference_opmsg_ep_configure_53>:
                        }
                    }
                }
                else
                {
                    op_extra_data->mic_rate_adjustment = svalue;
84200cb6:	3b 00       	r1 = r5 + Null;
84200cb8:	63 f0 69 8e 	M[r4 + 420] = r1;
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
                    if(0 != op_extra_data->mic_ext_rate_adjust_op)
84200cbc:	62 f0 ad 88 	r0 = M[r4 + 692];
84200cc0:	03 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_configure_55;

84200cc2 <Lc_aec_reference_opmsg_ep_configure_54>:
                    {

                        /* set the target rate */
                        stream_delegate_rate_adjust_set_target_rate(op_extra_data->mic_ext_rate_adjust_op,
                                                                    op_extra_data->mic_rate_adjustment);
84200cc2:	11 f0 3f ec 	call (m) $_stream_delegate_rate_adjust_set_target_rate;

84200cc6 <Lc_aec_reference_opmsg_ep_configure_55>:
            /* break; */
        default:
            return(FALSE);
    }

    return(TRUE);
84200cc6:	42 20       	r0 = Null + 1;

84200cc8 <Lc_aec_reference_opmsg_ep_configure_56>:
}
84200cc8:	f2 48       	popm <FP, r4, r5, rLink>;
84200cca:	d8 4c       	rts;

84200ccc <$_aec_reference_opmsg_ep_clock_id>:

   TODO.  Remove OPMSG_COMMON_GET_CLOCK_ID from table and delete this function
*/

bool aec_reference_opmsg_ep_clock_id(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200ccc:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
84200cce:	16 00       	r4 = r0 + Null;
84200cd0:	23 09       	r9 = r2 + Null;
84200cd2:	2f 00       	r5 = r3 + Null;
    unsigned *resp;
    OP_MSG_REQ *msg = message_data;
    unsigned terminal_id = msg->header.cmd_header.client_id;
84200cd4:	3a f0 00 e8 	r8 = M[r1 + Null];
    INT_OP_ID int_id = op_data->id;
84200cd8:	69 f0 01 88 	r7 = M[r4 + 4];
     * If the Mic and Spkr share the same clock source then all real terminals
     * share the same rate.
     */

    /* Payload is a single word containing the clock ID */
    resp = xpmalloc(sizeof(unsigned));
84200cdc:	c3 20       	r1 = Null + 3;
84200cde:	02 21       	r0 = Null + 4;
84200ce0:	ff fd 20 f0 	call (m) 0x4e2e;
84200ce4:	2f ea 
84200ce6:	10 09       	r6 = r0 + Null;
    if (!resp)
84200ce8:	03 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_clock_id_3;

84200cea <Lc_aec_reference_opmsg_ep_clock_id_2>:
    {
        return FALSE;
84200cea:	02 00       	r0 = Null + Null;
84200cec:	20 6e       	jump (m) Lc_aec_reference_opmsg_ep_clock_id_10;

84200cee <Lc_aec_reference_opmsg_ep_clock_id_3>:
    }
    *resp_data = (OP_OPMSG_RSP_PAYLOAD*)resp;
84200cee:	78 f0 00 ee 	M[r5 + Null] = r6;
    *resp_length = 1;
84200cf2:	41 20       	rMAC = Null + 1;
84200cf4:	b1 f0 00 ee 	M[r9 + Null] = rMAC;
      clock ID will be reported as zero before this operation is called.

      If MIC and SPKR real endpoints are not connected then we report the same clock source.
    */

    if (terminal_id & TERMINAL_SINK_MASK)
84200cf8:	40 f0 a1 f0 	rMAC = r8 AND 0x800000;
84200cfc:	00 00 
84200cfe:	14 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_clock_id_8;

84200d00 <Lc_aec_reference_opmsg_ep_clock_id_4>:
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84200d00:	31 99       	rMAC = M[r4 + 48];
         * same clock source as the mic then report the same clock source of
         * the op id. If they differ then report op_id and 1 << 7 as the op id
         * is 7 bits long.
         */
        if (!op_extra_data->input_stream[AEC_REF_MIC_TERMINAL1] ||
            !op_extra_data->output_stream[AEC_REF_SPKR_TERMINAL1])
84200d02:	8a 88       	r0 = M[rMAC + 8];
84200d04:	11 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_clock_id_8;

84200d06 <Lc_aec_reference_opmsg_ep_clock_id_5>:
84200d06:	4a a8       	r0 = M[rMAC + 68];
84200d08:	0f 60       	if EQ jump (m) Lc_aec_reference_opmsg_ep_clock_id_8;

84200d0a <Lc_aec_reference_opmsg_ep_clock_id_6>:
        {
            *resp = int_id;
        }
        else if (override_endpoints_have_same_clock_source(op_extra_data->spkr_endpoint,
                                                           op_extra_data->mic_endpoint))
84200d0a:	13 f0 7f 88 	r1 = M[rMAC + 508];
84200d0e:	12 f0 80 88 	r0 = M[rMAC + 512];
84200d12:	ff fd 1e f0 	call (m) 0x4a96;
84200d16:	25 ec 
84200d18:	10 04       	Null = r0 - Null;
84200d1a:	06 62       	if NE jump (m) Lc_aec_reference_opmsg_ep_clock_id_8;

84200d1c <Lc_aec_reference_opmsg_ep_clock_id_7>:
        {
            *resp = int_id;
        }
        else
        {
            *resp = int_id | (1 << 7);
84200d1c:	40 f9 51 c8 	rMAC = r7 OR 0x80;
84200d20:	81 f0 00 ee 	M[r6 + Null] = rMAC;
84200d24:	03 6e       	jump (m) Lc_aec_reference_opmsg_ep_clock_id_9;

84200d26 <Lc_aec_reference_opmsg_ep_clock_id_8>:
    {
        /* The sources that this is relevant to is Outputs and Reference. These
         * all have the same clock source. Report default clock source as the
         * op id.
         */
        *resp = int_id;
84200d26:	89 f0 00 ee 	M[r6 + Null] = r7;

84200d2a <Lc_aec_reference_opmsg_ep_clock_id_9>:
    }

    return TRUE;
84200d2a:	42 20       	r0 = Null + 1;

84200d2c <Lc_aec_reference_opmsg_ep_clock_id_10>:
}
84200d2c:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84200d2e:	d8 4c       	rts;

84200d30 <$_aec_reference_set_rates>:

    return cpsGetUcidMsgHandler(&op_extra_data->parms_def,op_extra_data->cap_id,message_data,resp_length,resp_data);
}

bool aec_reference_set_rates(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200d30:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84200d32:	17 00       	r5 = r0 + Null;
    AEC_REFERENCE_OP_DATA   *op_extra_data = (AEC_REFERENCE_OP_DATA*)op_data->extra_op_data;
84200d34:	3e 99       	r4 = M[r5 + 48];
    unsigned irate,orate;
    bool rebuild = FALSE;
84200d36:	02 09       	r8 = Null + Null;

    patch_fn_shared(aec_reference);

    /* Rates needed for creating cbops and for "aec_reference_buffer_details" */
    irate  = OPMSG_FIELD_GET(message_data, OPMSG_AEC_SET_SAMPLE_RATES, INPUT_RATE);
84200d38:	d9 88       	rMAC = M[r1 + 12];
84200d3a:	19 f7 ff 1f 	r7 = rMAC AND 0xffff;
    orate  = OPMSG_FIELD_GET(message_data, OPMSG_AEC_SET_SAMPLE_RATES, OUTPUT_RATE);
84200d3e:	19 89       	rMAC = M[r1 + 16];
84200d40:	18 f7 ff 1f 	r6 = rMAC AND 0xffff;

    L2_DBG_MSG2("AEC REFERENCE: set rates = %d %d", irate, orate);
84200d44:	55 f1 02 f0 	r0 = Null + 357564799;
84200d48:	7f 41 
84200d4a:	44 08       	r2 = r6 + Null;
84200d4c:	4b 08       	r1 = r7 + Null;
84200d4e:	ef fd fe ff 	call (m) 0x9c8;
84200d52:	3b e3 

    if(op_extra_data->input_rate!=irate)
84200d54:	61 f0 64 88 	rMAC = M[r4 + 400];
84200d58:	9f f1 00 c2 	Null = rMAC - r7;
84200d5c:	0c 60       	if EQ jump (m) Lc_aec_reference_set_rates_4;

84200d5e <Lc_aec_reference_set_rates_2>:
    {
        op_extra_data->input_rate = irate;
84200d5e:	69 f0 64 8e 	M[r4 + 400] = r7;
        if(op_data->state == OP_RUNNING)
84200d62:	39 b0       	rMAC = MBS[r5 + 24];
84200d64:	08 62       	if NE jump (m) Lc_aec_reference_set_rates_4;

84200d66 <Lc_aec_reference_set_rates_3>:
        {
            /* if the operator is running, any change in input
             * rate should trigger a rebuild of speaker graph
             */
            SetSpkrChannelStatus(op_extra_data, 0);
84200d66:	61 f0 76 88 	rMAC = M[r4 + 472];
84200d6a:	11 fe 0f 00 	rMAC = rMAC AND 0xffffc00f;
84200d6e:	61 f0 76 8e 	M[r4 + 472] = rMAC;
            rebuild = TRUE;
84200d72:	0a 71       	r8 = Null + 1;

84200d74 <Lc_aec_reference_set_rates_4>:
        }
    }

#ifdef AEC_REFERENCE_GENERATE_MIC_TIMESTAMP
    /* configure sample rate for MIC ttp */
    ttp_configure_rate(op_extra_data->mic_time_to_play, orate);
84200d74:	62 f0 cf 88 	r0 = M[r4 + 828];
84200d78:	43 08       	r1 = r6 + Null;
84200d7a:	ff fd ad f0 	call (m) 0x1684c;
84200d7e:	33 e6 
#endif

    if(op_extra_data->output_rate!=orate)
84200d80:	61 f0 65 88 	rMAC = M[r4 + 404];
84200d84:	8f f1 00 c2 	Null = rMAC - r6;
84200d88:	17 60       	if EQ jump (m) Lc_aec_reference_set_rates_8;

84200d8a <Lc_aec_reference_set_rates_5>:
    {
        op_extra_data->output_rate = orate;
84200d8a:	68 f0 65 8e 	M[r4 + 404] = r6;
        if(op_data->state == OP_RUNNING)
84200d8e:	39 b0       	rMAC = MBS[r5 + 24];
84200d90:	13 62       	if NE jump (m) Lc_aec_reference_set_rates_8;

84200d92 <Lc_aec_reference_set_rates_6>:
        {
            /* if the operator is running, any change in output
             * rate should trigger a rebuild of microphone graph
             */
            SetMicChannelStatus(op_extra_data, 0);
84200d92:	61 f0 76 88 	rMAC = M[r4 + 472];
84200d96:	f0 ff 11 f7 	rMAC = rMAC AND 0xffe0fff0;
84200d9a:	f0 1f 
84200d9c:	61 f0 76 8e 	M[r4 + 472] = rMAC;

84200da0 <Lc_aec_reference_set_rates_7>:
        /* At least one of input or output rate has changed while the operator
         * is running. This will require fresh rebuild of the affected cbops graphs.
         * No need to do this when operator isn't running since this will be done
         * at start point.
         */
        if(!aec_reference_update_stream_and_validate_channels(op_data, NULL, NULL))
84200da0:	04 00       	r2 = Null + Null;
84200da2:	03 00       	r1 = Null + Null;
84200da4:	3a 00       	r0 = r5 + Null;
84200da6:	0b f0 3b e3 	call (m) $_aec_reference_update_stream_and_validate_channels;
        {
            /* Not the best way to indicate failure, but best we can do */
            return FALSE;
84200daa:	11 00       	rMAC = r0 + Null;
84200dac:	02 00       	r0 = Null + Null;
84200dae:	08 04       	Null = rMAC - Null;
84200db0:	21 f0 42 ce 	if NE r0 = Null + 1;
84200db4:	05 6e       	jump (m) Lc_aec_reference_set_rates_10;

84200db6 <Lc_aec_reference_set_rates_8>:
            SetMicChannelStatus(op_extra_data, 0);
            rebuild = TRUE;
        }
    }

    if(rebuild)
84200db6:	0f fa 00 c2 	Null = r8 - Null;
84200dba:	f3 63       	if NE jump (m) Lc_aec_reference_set_rates_7;

84200dbc <Lc_aec_reference_set_rates_9>:
            /* Not the best way to indicate failure, but best we can do */
            return FALSE;
        }
    }

    return TRUE;
84200dbc:	42 20       	r0 = Null + 1;

84200dbe <Lc_aec_reference_set_rates_10>:
}
84200dbe:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84200dc0:	d8 4c       	rts;

84200dc2 <$_aec_reference_opmsg_get_ps_id>:

    return TRUE;
}

bool aec_reference_opmsg_get_ps_id(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200dc2:	c8 1c       	pushm <FP(=SP), rLink>;
84200dc4:	19 00       	rMAC = r1 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84200dc6:	12 99       	r0 = M[r0 + 48];
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);

    patch_fn_shared(aec_reference);

    return cpsGetUcidMsgHandler(&op_extra_data->parms_def,op_extra_data->cap_id,message_data,resp_length,resp_data);
84200dc8:	29 1c       	pushm <r3>;
84200dca:	23 f0 59 88 	r1 = M[r0 + 356];
84200dce:	25 00       	r3 = r2 + Null;
84200dd0:	02 f0 78 45 	r0 = r0 + 376;
84200dd4:	0c 00       	r2 = rMAC + Null;
84200dd6:	ef fd fc ff 	call (m) 0x6d2;
84200dda:	3d e7 
84200ddc:	7f 4c       	SP = SP + -4;

84200dde <Lc_aec_reference_opmsg_get_ps_id_2>:
}
84200dde:	c8 48       	popm <FP, rLink>;
84200de0:	d8 4c       	rts;

84200de2 <$_aec_reference_opmsg_mute_mic_output>:

    return TRUE;
}

bool aec_reference_opmsg_mute_mic_output(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200de2:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84200de4:	16 99       	r4 = M[r0 + 48];
    bool mute_enable;

    patch_fn_shared(aec_reference);

    /* read the enable field */
    mute_enable  = (OPMSG_FIELD_GET(message_data, OPMSG_AEC_MUTE_MIC_OUTPUT, ENABLE)) != 0;
84200de6:	d9 88       	rMAC = M[r1 + 12];
84200de8:	07 00       	r5 = Null + Null;
84200dea:	89 c6       	rMAC = rMAC AND 0xffff;
84200dec:	21 f0 47 ce 	if NE r5 = Null + 1;
    L2_DBG_MSG1("ACE REFERENCE muting mic, mute=%d", mute_enable);
84200df0:	55 f1 02 f0 	r0 = Null + 357564765;
84200df4:	5d 41 
84200df6:	3b 00       	r1 = r5 + Null;
84200df8:	ef fd fd ff 	call (m) 0x9b4;
84200dfc:	3d ed 

    if(NULL != op_extra_data->mic_mute_op)
84200dfe:	62 f0 9d 88 	r0 = M[r4 + 628];
84200e02:	05 60       	if EQ jump (m) Lc_aec_reference_opmsg_mute_mic_output_3;

84200e04 <Lc_aec_reference_opmsg_mute_mic_output_2>:
    {
        /* configure already running mute operator with simple ramping */
        cbops_mute_enable(op_extra_data->mic_mute_op, mute_enable, FALSE);
84200e04:	04 00       	r2 = Null + Null;
84200e06:	3b 00       	r1 = r5 + Null;
84200e08:	10 f0 29 e4 	call (m) $_cbops_mute_enable;

84200e0c <Lc_aec_reference_opmsg_mute_mic_output_3>:
    }

    /* store the last mute config */
    op_extra_data->mic_mute_enable_config = mute_enable;
84200e0c:	67 f0 de 8e 	M[r4 + 888] = r5;

    return TRUE;
84200e10:	42 20       	r0 = Null + 1;

84200e12 <Lc_aec_reference_opmsg_mute_mic_output_4>:
}
84200e12:	f2 48       	popm <FP, r4, r5, rLink>;
84200e14:	d8 4c       	rts;

84200e16 <$_aec_reference_opmsg_set_task_period>:
 *
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool aec_reference_opmsg_set_task_period(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200e16:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84200e18:	1e 00       	r4 = r1 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84200e1a:	17 99       	r5 = M[r0 + 48];
bool aec_reference_opmsg_set_task_period(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);

    /* We cant change this setting while running */
    if (opmgr_op_is_running(op_data))
84200e1c:	10 f0 2b ef 	call (m) $_opmgr_op_is_running;
84200e20:	10 04       	Null = r0 - Null;
84200e22:	03 60       	if EQ jump (m) Lc_aec_reference_opmsg_set_task_period_3;

84200e24 <Lc_aec_reference_opmsg_set_task_period_2>:
    {
        return FALSE;
84200e24:	02 00       	r0 = Null + Null;
84200e26:	07 6e       	jump (m) Lc_aec_reference_opmsg_set_task_period_4;

84200e28 <Lc_aec_reference_opmsg_set_task_period_3>:
    }

    /* get the task period */
    unsigned task_period = OPMSG_FIELD_GET(message_data, OPMSG_AEC_SET_TASK_PERIOD, TASK_PERIOD);
84200e28:	f1 88       	rMAC = M[r4 + 12];
84200e2a:	8b c6       	r1 = rMAC AND 0xffff;

    /* get decimation factor */
    unsigned decim_factor = OPMSG_FIELD_GET(message_data, OPMSG_AEC_SET_TASK_PERIOD, DECIM_FACTOR);
84200e2c:	31 89       	rMAC = M[r4 + 16];
84200e2e:	8c c6       	r2 = rMAC AND 0xffff;

    return aec_reference_set_task_period(op_extra_data, task_period, decim_factor);
84200e30:	3a 00       	r0 = r5 + Null;
84200e32:	03 4e       	call (m) $_aec_reference_set_task_period;

84200e34 <Lc_aec_reference_opmsg_set_task_period_4>:
}
84200e34:	f2 48       	popm <FP, r4, r5, rLink>;
84200e36:	d8 4c       	rts;

84200e38 <$_aec_reference_set_task_period>:
 * \param decim_factor decimation factor for sidetone mixing task
 *
 * \return whether the task period update successfully
 */
bool aec_reference_set_task_period(AEC_REFERENCE_OP_DATA *op_extra_data, unsigned task_period, unsigned decim_factor)
{
84200e38:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
84200e3a:	17 00       	r5 = r0 + Null;
84200e3c:	1e 00       	r4 = r1 + Null;
84200e3e:	20 09       	r6 = r2 + Null;
    /* check the limits */
    if(task_period > AEC_REFERENCE_MAX_TASK_PERIOD ||
       task_period < AEC_REFERENCE_MIN_TASK_PERIOD)
84200e40:	60 f1 88 27 	Null = r4 - 5000;
84200e44:	08 f0 8d e0 	if HI jump (m) Lc_aec_reference_set_task_period_3;

84200e48 <Lc_aec_reference_set_task_period_2>:
84200e48:	60 f0 e8 27 	Null = r4 - 1000;
84200e4c:	02 f0 89 e0 	if C jump (m) Lc_aec_reference_set_task_period_4;

84200e50 <Lc_aec_reference_set_task_period_3>:
    {
        return FALSE;
84200e50:	02 00       	r0 = Null + Null;
84200e52:	5d 6e       	jump (m) Lc_aec_reference_set_task_period_12;

84200e54 <Lc_aec_reference_set_task_period_4>:
    }

    /* see if task period is an integer factor of a second */
    if(0 != (SECOND % task_period))
84200e54:	00 f0 a2 f7 	r0 = Null + 1000000;
84200e58:	40 42 
84200e5a:	ff fd b1 f0 	call (m) 0x171d6;
84200e5e:	3d eb 
84200e60:	10 04       	Null = r0 - Null;
84200e62:	f7 63       	if NE jump (m) Lc_aec_reference_set_task_period_3;

84200e64 <Lc_aec_reference_set_task_period_5>:
    }

    /* Also we don't expect AEC_REFERENCE task period becoms
     * larger than system kick period
     */
    if(task_period > (unsigned)stream_if_get_system_kick_period())
84200e64:	ff fd 2f f0 	call (m) 0x6dc0;
84200e68:	3d ea 
84200e6a:	b0 04       	Null = r4 - r0;
84200e6c:	f8 ff e5 ef 	if HI jump (m) Lc_aec_reference_set_task_period_3;

84200e70 <Lc_aec_reference_set_task_period_6>:

#ifdef AEC_REFERENCE_CAN_PERFORM_INPLACE_SIDETONE_MIXING
    /* if a decimation factor supplied it should be a factor of
     * task period
     */
    if(decim_factor > 1)
84200e70:	80 f0 01 24 	Null = r6 - 1;
84200e74:	09 f0 95 e0 	if LS jump (m) Lc_aec_reference_set_task_period_8;

84200e78 <Lc_aec_reference_set_task_period_7>:
    {
        if((task_period % decim_factor) != 0)
84200e78:	32 00       	r0 = r4 + Null;
84200e7a:	43 08       	r1 = r6 + Null;
84200e7c:	ff fd b1 f0 	call (m) 0x171d6;
84200e80:	3b ea 
84200e82:	10 04       	Null = r0 - Null;
84200e84:	e6 63       	if NE jump (m) Lc_aec_reference_set_task_period_3;

84200e86 <Lc_18>:
84200e86:	02 6e       	jump (m) Lc_aec_reference_set_task_period_9;

84200e88 <Lc_aec_reference_set_task_period_8>:
            return FALSE;
        }
    }
    else
    {
        decim_factor = 1;
84200e88:	08 71       	r6 = Null + 1;

84200e8a <Lc_aec_reference_set_task_period_9>:
    }
    op_extra_data->task_decim_factor = decim_factor;
84200e8a:	78 f0 97 8e 	M[r5 + 604] = r6;
    op_extra_data->task_decim_counter = 0;
84200e8e:	70 f0 98 8e 	M[r5 + 608] = Null;
    op_extra_data->kick_period = task_period / decim_factor;
84200e92:	32 00       	r0 = r4 + Null;
84200e94:	43 08       	r1 = r6 + Null;
84200e96:	ff fd b1 f0 	call (m) 0x171b8;
84200e9a:	23 e9 
84200e9c:	72 f0 94 8e 	M[r5 + 592] = r0;
    op_extra_data->kick_period_frac = frac_div(op_extra_data->kick_period, SECOND);
84200ea0:	00 f0 a1 f7 	rMAC = Null + 1000000;
84200ea4:	40 42 
84200ea6:	7f f2 1f d9 	rMACB = r0 ASHIFT -1 (56bit);
84200eaa:	00 f1 9f cd 	Div = rMACB / rMAC;
84200eae:	c2 4c       	r0 = DivResult;
84200eb0:	72 f0 96 8e 	M[r5 + 600] = r0;
    op_extra_data->kick_period = task_period;
    decim_factor = 1;
#endif /* AEC_REFERENCE_CAN_PERFORM_INPLACE_SIDETONE_MIXING */

    /* All are fine, set the task period*/
    op_extra_data->task_period = task_period;
84200eb4:	76 f0 63 8e 	M[r5 + 396] = r4;
    op_extra_data->task_frequency = (unsigned)SECOND/task_period;
84200eb8:	33 00       	r1 = r4 + Null;
84200eba:	0a 00       	r0 = rMAC + Null;
84200ebc:	ff fd b1 f0 	call (m) 0x171b8;
84200ec0:	3d e7 
84200ec2:	72 f0 92 8e 	M[r5 + 584] = r0;
    op_extra_data->task_period_frac = frac_div(task_period, SECOND);
84200ec6:	00 f0 a1 f7 	rMAC = Null + 1000000;
84200eca:	40 42 
84200ecc:	7f f6 1f d9 	rMACB = r4 ASHIFT -1 (56bit);
84200ed0:	00 f1 9f cd 	Div = rMACB / rMAC;
84200ed4:	c2 4c       	r0 = DivResult;
84200ed6:	72 f0 93 8e 	M[r5 + 588] = r0;
     * stage does an upsample by a factor of 2.1.
     * 48000.0 (fs in : 21/10) --> 100800.0 (fs internal : 7/16) --> 44100.0 (fs out)
     *
     * (2*task period) @100800
     */
    op_extra_data->resampler_temp_buffer_size = frac_mult(100800, 2*op_extra_data->task_period_frac) + 4;
84200eda:	c3 f0 c0 51 	r1 = Null + 100800;
84200ede:	12 54       	r0 = r0 LSHIFT 1;
84200ee0:	2f f3 42 c9 	r0 = r1 * r0 (frac);
84200ee4:	11 21       	rMAC = r0 + 4;
84200ee6:	71 f0 91 8e 	M[r5 + 580] = rMAC;
    op_extra_data->resampler_temp_buffer_size = MAX(op_extra_data->resampler_temp_buffer_size,
                                                        AEC_REF_RESAMPLER_TEMP_MIN_BUF_SIZE);
84200eea:	10 f0 cc 24 	Null = rMAC - 204;
84200eee:	02 f0 8d e0 	if C jump (m) Lc_aec_reference_set_task_period_11;

84200ef2 <Lc_aec_reference_set_task_period_10>:
84200ef2:	01 f0 cc 40 	rMAC = Null + 204;
84200ef6:	71 f0 91 8e 	M[r5 + 580] = rMAC;

84200efa <Lc_aec_reference_set_task_period_11>:

    L2_DBG_MSG2("AEC REFERENCE: task period set @%dus, decimation factor=%d", task_period, decim_factor);
84200efa:	55 f1 02 f0 	r0 = Null + 357564589;
84200efe:	ad 40 
84200f00:	44 08       	r2 = r6 + Null;
84200f02:	33 00       	r1 = r4 + Null;
84200f04:	ef fd fd ff 	call (m) 0x9c8;
84200f08:	25 e6 

    return TRUE;
84200f0a:	42 20       	r0 = Null + 1;

84200f0c <Lc_aec_reference_set_task_period_12>:
}
84200f0c:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84200f0e:	d8 4c       	rts;

84200f10 <$_aec_reference_opmsg_enable_mic_sync>:
 *             backend input and output are from same clock
 * Note: the msaage shall not be sent when any MIC/OUTPUT/REF
 *       terminal is connected.
 */
bool aec_reference_opmsg_enable_mic_sync(OPERATOR_DATA *op_data, void *message_data, unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200f10:	c8 1c       	pushm <FP(=SP), rLink>;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84200f12:	11 99       	rMAC = M[r0 + 48];
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    patch_fn_shared(aec_reference);

    if((NULL != op_extra_data->input_stream[AEC_REF_MIC_TERMINAL1]) ||
       (NULL != op_extra_data->output_stream[AEC_REF_REFERENCE_TERMINAL]) ||
       (NULL != op_extra_data->input_stream[AEC_REF_OUTPUT_TERMINAL1]))
84200f14:	8a 88       	r0 = M[rMAC + 8];
84200f16:	05 62       	if NE jump (m) Lc_aec_reference_opmsg_enable_mic_sync_4;

84200f18 <Lc_aec_reference_opmsg_enable_mic_sync_2>:
84200f18:	0a a8       	r0 = M[rMAC + 64];
84200f1a:	03 62       	if NE jump (m) Lc_aec_reference_opmsg_enable_mic_sync_4;

84200f1c <Lc_aec_reference_opmsg_enable_mic_sync_3>:
84200f1c:	ca 88       	r0 = M[rMAC + 12];
84200f1e:	03 60       	if EQ jump (m) Lc_aec_reference_opmsg_enable_mic_sync_5;

84200f20 <Lc_aec_reference_opmsg_enable_mic_sync_4>:
    {
        /* This message can be handled only if MIC and REF are disconnected */
        return FALSE;
84200f20:	02 00       	r0 = Null + Null;
84200f22:	0f 6e       	jump (m) Lc_aec_reference_opmsg_enable_mic_sync_6;

84200f24 <Lc_aec_reference_opmsg_enable_mic_sync_5>:
    }

    /* read the enable field */
    op_extra_data->mic_sync_enable = (OPMSG_FIELD_GET(message_data, OPMSG_AEC_SAME_INPUT_OUTPUT_CLOCK_SOURCE, SAME_CLK_SRC)) != 0;
84200f24:	da 88       	r0 = M[r1 + 12];
84200f26:	03 00       	r1 = Null + Null;
84200f28:	92 c6       	r0 = r0 AND 0xffff;
84200f2a:	21 f0 43 ce 	if NE r1 = Null + 1;
84200f2e:	13 f0 d4 8e 	M[rMAC + 848] = r1;
    L2_DBG_MSG1("ACE REFERENCE input-output use same clock: ", op_extra_data->mic_sync_enable);
84200f32:	55 f1 02 f0 	r0 = Null + 357564545;
84200f36:	81 40 
84200f38:	ef fd fd ff 	call (m) 0x9b4;
84200f3c:	3d e3 

    return TRUE;
84200f3e:	42 20       	r0 = Null + 1;

84200f40 <Lc_aec_reference_opmsg_enable_mic_sync_6>:
}
84200f40:	c8 48       	popm <FP, rLink>;
84200f42:	d8 4c       	rts;

84200f44 <$_aec_reference_opmsg_set_buffer_size>:
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool aec_reference_opmsg_set_buffer_size(OPERATOR_DATA *op_data, void *message_data,
                                         unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
84200f44:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84200f46:	28 f0 0c 88 	r6 = M[r0 + 48];
                                         unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{

    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    /* get the required buffer size */
    unsigned buffer_size = OPMSG_FIELD_GET(message_data, OPMSG_COMMON_SET_TERMINAL_BUFFER_SIZE, BUFFER_SIZE);
84200f4a:	d9 88       	rMAC = M[r1 + 12];
84200f4c:	8e c6       	r4 = rMAC AND 0xffff;
    /* get the sink terminals that need configuration */
    unsigned sinks = OPMSG_FIELD_GET(message_data, OPMSG_COMMON_SET_TERMINAL_BUFFER_SIZE,
                                     SINKS);
84200f4e:	19 89       	rMAC = M[r1 + 16];
    /* get the source terminals that need configuration */
    unsigned sources = OPMSG_FIELD_GET(message_data, OPMSG_COMMON_SET_TERMINAL_BUFFER_SIZE,
                                       SOURCES);
84200f50:	0f c0       	r5 = rMAC AND 0x1;
84200f52:	59 89       	rMAC = M[r1 + 20];

    /* Output buffer size is allowd to change if none of outputs are connected,
     * Note: We allow buffer size change while the operator is running, only the
     * relevant path must be not running.
     */
    if(sources != 0)
84200f54:	49 c1       	rMAC = rMAC AND 0x8;
84200f56:	16 60       	if EQ jump (m) Lc_aec_reference_opmsg_set_buffer_size_10;

84200f58 <Lc_aec_reference_opmsg_set_buffer_size_2>:
    {
        unsigned idx;

        /* No output must be connected */
        for(idx = 0; idx<MAX_NUMBER_MICS; idx++)
84200f58:	02 00       	r0 = Null + Null;
84200f5a:	04 6e       	jump (m) Lc_aec_reference_opmsg_set_buffer_size_4;

84200f5c <Lc_aec_reference_opmsg_set_buffer_size_3>:
    }
}

inline static unsigned OutputTerminalByIndex(unsigned i)
{
    if(i<4)
84200f5c:	10 25       	Null = r0 - 4;
84200f5e:	02 f0 89 e0 	if C jump (m) Lc_aec_reference_opmsg_set_buffer_size_5;

84200f62 <Lc_aec_reference_opmsg_set_buffer_size_4>:
    {
        return (i + AEC_REF_OUTPUT_TERMINAL1);
84200f62:	d3 20       	r1 = r0 + 3;
84200f64:	02 6e       	jump (m) Lc_aec_reference_opmsg_set_buffer_size_6;

84200f66 <Lc_aec_reference_opmsg_set_buffer_size_5>:
    }
    else
    {
        return ((i-4) + AEC_REF_OUTPUT_TERMINAL5);
84200f66:	53 22       	r1 = r0 + 9;

84200f68 <Lc_aec_reference_opmsg_set_buffer_size_6>:
        {
            if(NULL != op_extra_data->output_stream[OutputTerminalByIndex(idx)])
84200f68:	84 f0 40 20 	r2 = r6 + 64;
84200f6c:	5b 54       	r1 = r1 LSHIFT 2;
84200f6e:	e3 e8       	r1 = M[r2 + r1];
84200f70:	03 60       	if EQ jump (m) Lc_aec_reference_opmsg_set_buffer_size_8;

84200f72 <Lc_aec_reference_opmsg_set_buffer_size_7>:
            {
                return FALSE;
84200f72:	02 00       	r0 = Null + Null;
84200f74:	2f 6e       	jump (m) Lc_aec_reference_opmsg_set_buffer_size_22;

84200f76 <Lc_aec_reference_opmsg_set_buffer_size_8>:
    if(sources != 0)
    {
        unsigned idx;

        /* No output must be connected */
        for(idx = 0; idx<MAX_NUMBER_MICS; idx++)
84200f76:	52 20       	r0 = r0 + 1;
84200f78:	10 26       	Null = r0 - 8;
84200f7a:	f1 65       	if NC jump (m) Lc_aec_reference_opmsg_set_buffer_size_3;

84200f7c <Lc_aec_reference_opmsg_set_buffer_size_9>:
            {
                return FALSE;
            }
        }
        /* Also REFERENCE must also be disconnected */
        if(NULL != op_extra_data->output_stream[AEC_REF_REFERENCE_TERMINAL])
84200f7c:	82 f0 10 88 	r0 = M[r6 + 64];
84200f80:	f9 63       	if NE jump (m) Lc_aec_reference_opmsg_set_buffer_size_7;

84200f82 <Lc_aec_reference_opmsg_set_buffer_size_10>:

    /* Input buffer size is allowd to change if none of inputs are connected,
     * Note: We allow buffer size change while the operator is running, only the
     * relevant path must be not running.
     */
    if(sinks != 0)
84200f82:	38 04       	Null = r5 - Null;
84200f84:	10 60       	if EQ jump (m) Lc_aec_reference_opmsg_set_buffer_size_17;

84200f86 <Lc_aec_reference_opmsg_set_buffer_size_11>:
    {
        unsigned idx;

        /* No input must be connected */
        for(idx = 0; idx < MAX_NUMBER_SPEAKERS; idx++)
84200f86:	02 00       	r0 = Null + Null;
84200f88:	04 6e       	jump (m) Lc_aec_reference_opmsg_set_buffer_size_13;

84200f8a <Lc_aec_reference_opmsg_set_buffer_size_12>:
        {
            if(NULL != op_extra_data->input_stream[SpeakerInputTerminalByIndex(idx)])
84200f8a:	90 24       	Null = r0 - 2;
84200f8c:	02 f0 89 e0 	if C jump (m) Lc_aec_reference_opmsg_set_buffer_size_14;

84200f90 <Lc_aec_reference_opmsg_set_buffer_size_13>:
84200f90:	13 00       	r1 = r0 + Null;
84200f92:	02 6e       	jump (m) Lc_aec_reference_opmsg_set_buffer_size_15;

84200f94 <Lc_aec_reference_opmsg_set_buffer_size_14>:
84200f94:	13 21       	r1 = r0 + 4;

84200f96 <Lc_aec_reference_opmsg_set_buffer_size_15>:
84200f96:	5b 54       	r1 = r1 LSHIFT 2;
84200f98:	83 f0 03 e8 	r1 = M[r6 + r1];
84200f9c:	eb 63       	if NE jump (m) Lc_aec_reference_opmsg_set_buffer_size_7;

84200f9e <Lc_aec_reference_opmsg_set_buffer_size_16>:
    if(sinks != 0)
    {
        unsigned idx;

        /* No input must be connected */
        for(idx = 0; idx < MAX_NUMBER_SPEAKERS; idx++)
84200f9e:	52 20       	r0 = r0 + 1;
84200fa0:	10 26       	Null = r0 - 8;
84200fa2:	f4 65       	if NC jump (m) Lc_aec_reference_opmsg_set_buffer_size_12;

84200fa4 <Lc_aec_reference_opmsg_set_buffer_size_17>:
                return FALSE;
            }
        }
    }

    if(sources != 0)
84200fa4:	08 04       	Null = rMAC - Null;
84200fa6:	0a 60       	if EQ jump (m) Lc_aec_reference_opmsg_set_buffer_size_19;

84200fa8 <Lc_aec_reference_opmsg_set_buffer_size_18>:
    {
        /* set the output buffer size */
        op_extra_data->output_buffer_size = buffer_size;
84200fa8:	86 f0 d5 8e 	M[r6 + 852] = r4;
        L2_DBG_MSG1("AEC_REFERENCE: minimum output buffer size set to %d words ", buffer_size);
84200fac:	55 f1 02 f0 	r0 = Null + 357564648;
84200fb0:	e8 40 
84200fb2:	33 00       	r1 = r4 + Null;
84200fb4:	ef fd fd ff 	call (m) 0x9b4;
84200fb8:	21 e0 

84200fba <Lc_aec_reference_opmsg_set_buffer_size_19>:
    }

    if(sinks != 0)
84200fba:	38 04       	Null = r5 - Null;
84200fbc:	0a 60       	if EQ jump (m) Lc_aec_reference_opmsg_set_buffer_size_21;

84200fbe <Lc_aec_reference_opmsg_set_buffer_size_20>:
    {
        op_extra_data->input_buffer_size = buffer_size;
84200fbe:	86 f0 d6 8e 	M[r6 + 856] = r4;
        L2_DBG_MSG1("AEC_REFERENCE: minimum input buffer size set to %d words ", buffer_size);
84200fc2:	55 f1 02 f0 	r0 = Null + 357564707;
84200fc6:	23 41 
84200fc8:	33 00       	r1 = r4 + Null;
84200fca:	ef fd fc ff 	call (m) 0x9b4;
84200fce:	2b ef 

84200fd0 <Lc_aec_reference_opmsg_set_buffer_size_21>:
    }

    return TRUE;
84200fd0:	42 20       	r0 = Null + 1;

84200fd2 <Lc_aec_reference_opmsg_set_buffer_size_22>:
}
84200fd2:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84200fd4:	d8 4c       	rts;

84200fd6 <$_aec_reference_update_sidetone_status>:
    if((op_extra_data->params.OFFSET_CONFIG & AEC_REFERENCE_CONFIG_SIDETONE_DISABLE) == 0)
    {
        /* a sidetone path will be formed whenever
         * we have both speaker and mic paths
         */
        op_extra_data->using_sidetone = SIDETONE_ENABLE_FLAG;
84200fd6:	21 f0 33 88 	rMAC = M[r0 + 204];
84200fda:	03 00       	r1 = Null + Null;
84200fdc:	49 c1       	rMAC = rMAC AND 0x8;
84200fde:	a0 f0 43 ce 	if EQ r1 = Null + 2;
84200fe2:	23 f0 7a 8e 	M[r0 + 488] = r1;
        /* User doesn't want sidetone at all */
        op_extra_data->using_sidetone = 0;
    }

    /* see if we need sidetone */
    if((op_extra_data->num_mic_channels > 0) && (op_extra_data->num_spkr_channels > 0))
84200fe6:	20 f0 78 88 	Null = M[r0 + 480];
84200fea:	0a 60       	if EQ jump (m) Lc_aec_reference_update_sidetone_status_4;

84200fec <Lc_aec_reference_update_sidetone_status_2>:
84200fec:	20 f0 77 88 	Null = M[r0 + 476];
84200ff0:	07 60       	if EQ jump (m) Lc_aec_reference_update_sidetone_status_4;

84200ff2 <Lc_aec_reference_update_sidetone_status_3>:
    {
        op_extra_data->using_sidetone |= SIDETONE_MIC_SPKR_FLAG;
84200ff2:	21 f0 7a 88 	rMAC = M[r0 + 488];
84200ff6:	09 c8       	rMAC = rMAC OR 0x1;
84200ff8:	21 f0 7a 8e 	M[r0 + 488] = rMAC;
84200ffc:	06 6e       	jump (m) Lc_aec_reference_update_sidetone_status_5;

84200ffe <Lc_aec_reference_update_sidetone_status_4>:
    }
    else
    {
        op_extra_data->using_sidetone &= SIDETONE_ENABLE_FLAG;
84200ffe:	21 f0 7a 88 	rMAC = M[r0 + 488];
84201002:	49 c0       	rMAC = rMAC AND 0x2;
84201004:	21 f0 7a 8e 	M[r0 + 488] = rMAC;

84201008 <Lc_aec_reference_update_sidetone_status_5>:
84201008:	d8 4c       	rts;

8420100a <$_aec_reference_spkr_check_external_rate_adjust_op>:
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 *
 */
void aec_reference_spkr_check_external_rate_adjust_op(AEC_REFERENCE_OP_DATA *op_extra_data)
{
8420100a:	f1 1d       	pushm <FP(=SP), r4, rLink>, SP = SP + 0x10;
8420100c:	16 00       	r4 = r0 + Null;
    uint32 val;
    if(get_override_ep_rate_adjust_op(op_extra_data->spkr_endpoint, &val) && val != 0)
8420100e:	c3 10       	r1 = FP + 12;
84201010:	62 f0 80 88 	r0 = M[r4 + 512];
84201014:	0f f0 3f ef 	call (m) $_get_override_ep_rate_adjust_op;
84201018:	10 04       	Null = r0 - Null;
8420101a:	13 60       	if EQ jump (m) Lc_aec_reference_spkr_check_external_rate_adjust_op_4;

8420101c <Lc_aec_reference_spkr_check_external_rate_adjust_op_2>:
8420101c:	1a d8       	r0 = M[FP + 12];
8420101e:	11 60       	if EQ jump (m) Lc_aec_reference_spkr_check_external_rate_adjust_op_4;

84201020 <Lc_aec_reference_spkr_check_external_rate_adjust_op_3>:
    {
        /* Speaker graph will use an external RATE_ADJUST operator for
         * performing rate adjustment.
         */
        op_extra_data->spkr_ext_rate_adjust_op = val;
84201020:	62 f0 ae 8e 	M[r4 + 696] = r0;

        /* if we have standalone rate adjust, we will use it, even
         * if spkr is able to use HW warping */
        op_extra_data->spkr_rate_ability = RATEMATCHING_SUPPORT_SW;
84201024:	41 20       	rMAC = Null + 1;
84201026:	61 f0 6f 8e 	M[r4 + 444] = rMAC;

        /* Speaker path will use this, so not in pass-through mode */
        stream_delegate_rate_adjust_set_passthrough_mode(op_extra_data->spkr_ext_rate_adjust_op, FALSE);
8420102a:	03 00       	r1 = Null + Null;
8420102c:	10 f0 21 e3 	call (m) $_stream_delegate_rate_adjust_set_passthrough_mode;

        L2_DBG_MSG1("AEC_REFERENCE: Speaker path will use standalone rate adjust: opid=0x%x", val);
84201030:	1b d8       	r1 = M[FP + 12];
84201032:	55 f1 02 f0 	r0 = Null + 357564832;
84201036:	a0 41 
84201038:	ef fd fc ff 	call (m) 0x9b4;
8420103c:	3d eb 
8420103e:	03 6e       	jump (m) Lc_aec_reference_spkr_check_external_rate_adjust_op_5;

84201040 <Lc_aec_reference_spkr_check_external_rate_adjust_op_4>:

        return;
    }

    /* No external operator found or needed */
    op_extra_data->spkr_ext_rate_adjust_op = 0;
84201040:	60 f0 ae 8e 	M[r4 + 696] = Null;

84201044 <Lc_aec_reference_spkr_check_external_rate_adjust_op_5>:

    return;
}
84201044:	f1 49       	SP = SP - 0x10, popm <FP, r4, rLink>;
84201046:	d8 4c       	rts;

84201048 <$_aec_reference_mic_check_external_rate_adjust_op>:
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 *
 * \return TRUE if there is a standalone rate adjust operator linked to the microphne path
 */
void aec_reference_mic_check_external_rate_adjust_op(AEC_REFERENCE_OP_DATA *op_extra_data)
{
84201048:	f1 1d       	pushm <FP(=SP), r4, rLink>, SP = SP + 0x10;
8420104a:	16 00       	r4 = r0 + Null;
    uint32 val;
    if(get_override_ep_rate_adjust_op(op_extra_data->mic_endpoint, &val) && val != 0)
8420104c:	c3 10       	r1 = FP + 12;
8420104e:	62 f0 7f 88 	r0 = M[r4 + 508];
84201052:	0f f0 21 ee 	call (m) $_get_override_ep_rate_adjust_op;
84201056:	10 04       	Null = r0 - Null;
84201058:	1e 60       	if EQ jump (m) Lc_aec_reference_mic_check_external_rate_adjust_op_6;

8420105a <Lc_aec_reference_mic_check_external_rate_adjust_op_2>:
8420105a:	1a d8       	r0 = M[FP + 12];
8420105c:	1c 60       	if EQ jump (m) Lc_aec_reference_mic_check_external_rate_adjust_op_6;

8420105e <Lc_aec_reference_mic_check_external_rate_adjust_op_3>:
    {
        /* If we have been told to synchronise mic to speaker input then
         * we shouldn't have been told to use standalone rate adjust.
         */
        PL_ASSERT(!op_extra_data->mic_sync_enable);
8420105e:	60 f0 d4 88 	Null = M[r4 + 848];
84201062:	09 60       	if EQ jump (m) Lc_aec_reference_mic_check_external_rate_adjust_op_5;

84201064 <Lc_aec_reference_mic_check_external_rate_adjust_op_4>:
84201064:	03 f0 23 61 	r1 = Null + 4387;
84201068:	02 f0 13 60 	r0 = Null + 4115;
8420106c:	ff fd 97 f0 	call (m) 0x13f12;
84201070:	27 e5 
84201072:	13 6e       	jump (m) Lc_aec_reference_mic_check_external_rate_adjust_op_7;

84201074 <Lc_aec_reference_mic_check_external_rate_adjust_op_5>:

        /* Microphone graph will use an external RATE_ADJUST operator for
         * performing rate adjustment.
         */
        op_extra_data->mic_ext_rate_adjust_op = val;
84201074:	62 f0 ad 8e 	M[r4 + 692] = r0;

        /* if we have standalone rate adjust, we will use it, even
         * if mic is able to use HW warping */
        op_extra_data->mic_rate_ability = RATEMATCHING_SUPPORT_SW;
84201078:	41 20       	rMAC = Null + 1;
8420107a:	61 f0 67 8e 	M[r4 + 412] = rMAC;

        /* Microphone path will use this, so not in pass-through mode */
        stream_delegate_rate_adjust_set_passthrough_mode(op_extra_data->mic_ext_rate_adjust_op, FALSE);
8420107e:	03 00       	r1 = Null + Null;
84201080:	10 f0 2d e0 	call (m) $_stream_delegate_rate_adjust_set_passthrough_mode;

        L2_DBG_MSG1("AEC_REFERENCE: Microphone path will use standalone rate adjust: opid=0x%x", val);
84201084:	1b d8       	r1 = M[FP + 12];
84201086:	55 f1 02 f0 	r0 = Null + 357564903;
8420108a:	e7 41 
8420108c:	ef fd fc ff 	call (m) 0x9b4;
84201090:	29 e9 
84201092:	03 6e       	jump (m) Lc_aec_reference_mic_check_external_rate_adjust_op_7;

84201094 <Lc_aec_reference_mic_check_external_rate_adjust_op_6>:

        return;
    }

    /* No external operator found or needed */
    op_extra_data->mic_ext_rate_adjust_op = 0;
84201094:	60 f0 ad 8e 	M[r4 + 692] = Null;

84201098 <Lc_aec_reference_mic_check_external_rate_adjust_op_7>:

    return;
}
84201098:	f1 49       	SP = SP - 0x10, popm <FP, r4, rLink>;
8420109a:	d8 4c       	rts;

8420109c <$_aec_reference_opmsg_set_ttp_latency>:
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool aec_reference_opmsg_set_ttp_latency(OPERATOR_DATA *op_data, void *message_data,
                                     unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
8420109c:	f1 1c       	pushm <FP(=SP), r4, rLink>;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
8420109e:	16 99       	r4 = M[r0 + 48];
                                     unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);

    /* We cant change this setting while running */
    if(op_data->state == OP_RUNNING)
842010a0:	11 b0       	rMAC = MBS[r0 + 24];
842010a2:	03 62       	if NE jump (m) Lc_aec_reference_opmsg_set_ttp_latency_3;

842010a4 <Lc_aec_reference_opmsg_set_ttp_latency_2>:

    {
        return FALSE;
842010a4:	02 00       	r0 = Null + Null;
842010a6:	15 6e       	jump (m) Lc_aec_reference_opmsg_set_ttp_latency_4;

842010a8 <Lc_aec_reference_opmsg_set_ttp_latency_3>:
    }

    /* get the latency from payload */
    op_extra_data->mic_target_latency = ttp_get_msg_latency(message_data);
842010a8:	1a 00       	r0 = r1 + Null;
842010aa:	ff fd ab f0 	call (m) 0x16706;
842010ae:	3d e2 
842010b0:	13 00       	r1 = r0 + Null;
842010b2:	63 f0 ce 8e 	M[r4 + 824] = r1;

    /* configure latency */
    ttp_configure_latency(op_extra_data->mic_time_to_play, op_extra_data->mic_target_latency);
842010b6:	62 f0 cf 88 	r0 = M[r4 + 828];
842010ba:	ff fd ab f0 	call (m) 0x167da;
842010be:	21 e9 

    /* receiving this message (with latenct != 0) will enable metadata generation */
    op_extra_data->mic_metadata_enable = op_extra_data->mic_target_latency != 0;
842010c0:	01 00       	rMAC = Null + Null;
842010c2:	60 f0 ce 88 	Null = M[r4 + 824];
842010c6:	21 f0 41 ce 	if NE rMAC = Null + 1;
842010ca:	61 f0 cd 8e 	M[r4 + 820] = rMAC;

    return TRUE;
842010ce:	42 20       	r0 = Null + 1;

842010d0 <Lc_aec_reference_opmsg_set_ttp_latency_4>:
}
842010d0:	f1 48       	popm <FP, r4, rLink>;
842010d2:	d8 4c       	rts;

842010d4 <$_aec_reference_opmsg_set_ttp_params>:
 * \return Whether the response_data field has been populated with a valid
 * response
 */
bool aec_reference_opmsg_set_ttp_params(OPERATOR_DATA *op_data, void *message_data,
                                    unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842010d4:	f1 1d       	pushm <FP(=SP), r4, rLink>, SP = SP + 0x10;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
842010d6:	16 99       	r4 = M[r0 + 48];

    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    ttp_params params;

    /* We cant change this setting while running */
    if(op_data->state == OP_RUNNING)
842010d8:	11 b0       	rMAC = MBS[r0 + 24];
842010da:	03 62       	if NE jump (m) Lc_aec_reference_opmsg_set_ttp_params_3;

842010dc <Lc_aec_reference_opmsg_set_ttp_params_2>:
    {
        return FALSE;
842010dc:	02 00       	r0 = Null + Null;
842010de:	0c 6e       	jump (m) Lc_aec_reference_opmsg_set_ttp_params_4;

842010e0 <Lc_aec_reference_opmsg_set_ttp_params_3>:
    }

    /* configure ttp params */
    ttp_get_msg_params(&params, message_data);
842010e0:	c2 10       	r0 = FP + 12;
842010e2:	ff fd ab f0 	call (m) 0x16786;
842010e6:	25 e5 
    ttp_configure_params(op_extra_data->mic_time_to_play, &params);
842010e8:	c3 10       	r1 = FP + 12;
842010ea:	62 f0 cf 88 	r0 = M[r4 + 828];
842010ee:	ff fd ab f0 	call (m) 0x16822;
842010f2:	35 e9 

    return TRUE;
842010f4:	42 20       	r0 = Null + 1;

842010f6 <Lc_aec_reference_opmsg_set_ttp_params_4>:
}
842010f6:	f1 49       	SP = SP - 0x10, popm <FP, r4, rLink>;
842010f8:	d8 4c       	rts;

842010fa <$_aec_reference_opmsg_set_latency_limits>:
 * aec_reference_opmsg_set_latency_limits
 * \brief message handler to set ttp latency limits for mic output channels
 */
bool aec_reference_opmsg_set_latency_limits(OPERATOR_DATA *op_data, void *message_data,
                                        unsigned *resp_length, OP_OPMSG_RSP_PAYLOAD **resp_data)
{
842010fa:	f1 1d       	pushm <FP(=SP), r4, rLink>, SP = SP + 0x10;
842010fc:	19 00       	rMAC = r1 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
842010fe:	16 99       	r4 = M[r0 + 48];
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    TIME_INTERVAL min_latency, max_latency;

    /* get the limits from the message payload and configure the time to play limits */
    ttp_get_msg_latency_limits(message_data, &min_latency, &max_latency);
84201100:	04 11       	r2 = FP + 16;
84201102:	c3 10       	r1 = FP + 12;
84201104:	0a 00       	r0 = rMAC + Null;
84201106:	ff fd ab f0 	call (m) 0x1673c;
8420110a:	37 e1 
    ttp_configure_latency_limits(op_extra_data->mic_time_to_play, min_latency, max_latency);
8420110c:	24 d8       	r2 = M[FP + 16];
8420110e:	1b d8       	r1 = M[FP + 12];
84201110:	62 f0 cf 88 	r0 = M[r4 + 828];
84201114:	ff fd ab f0 	call (m) 0x167fa;
84201118:	27 e7 

    return TRUE;
8420111a:	42 20       	r0 = Null + 1;

8420111c <Lc_aec_reference_opmsg_set_latency_limits_2>:
}
8420111c:	f1 49       	SP = SP - 0x10, popm <FP, r4, rLink>;
8420111e:	d8 4c       	rts;

84201120 <$_aec_reference_mic_generate_metadata_with_ttp>:
 * \brief generates metadata for microphone output channels
 * \param op_extra_data Pointer to AEC_REFERENCE operator specific data
 * \param samples number of samples in the to-be-copied chunk
 */
void aec_reference_mic_generate_metadata_with_ttp(AEC_REFERENCE_OP_DATA *op_extra_data, unsigned samples)
{
84201120:	f6 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x20;
84201122:	10 09       	r6 = r0 + Null;
84201124:	8b f0 ca 88 	r9 = M[r6 + 808];
84201128:	1f 00       	r5 = r1 + Null;
    metadata_tag *mtag;
    unsigned b4idx, afteridx;
    tCbuffer *met_buf = op_extra_data->mic_metadata_buffer;

    /* no update needed if no new samples arrived */
    if(samples == 0)
8420112a:	6b 60       	if EQ jump (m) Lc_aec_reference_mic_generate_metadata_with_ttp_12;

8420112c <Lc_aec_reference_mic_generate_metadata_with_ttp_2>:
    {
        return;
    }

    /* if previous tag was incomplete, we need first to complete the tag */
    if(op_extra_data->mic_metadata_tag_left_words > 0)
8420112c:	81 f0 cb 88 	rMAC = M[r6 + 812];
84201130:	15 60       	if EQ jump (m) Lc_aec_reference_mic_generate_metadata_with_ttp_6;

84201132 <Lc_aec_reference_mic_generate_metadata_with_ttp_3>:
    {
        /* last written tag was incomplete, we keep adding
         * Null tag until full length of incomplete tag is
         * covered.
         */
        unsigned null_tag_len = op_extra_data->mic_metadata_tag_left_words;
84201132:	0e 00       	r4 = rMAC + Null;
        if(null_tag_len > samples)
84201134:	c8 05       	Null = rMAC - r5;
84201136:	09 f0 87 e0 	if LS jump (m) Lc_aec_reference_mic_generate_metadata_with_ttp_5;

8420113a <Lc_aec_reference_mic_generate_metadata_with_ttp_4>:
        {
            null_tag_len = samples;
8420113a:	3e 00       	r4 = r5 + Null;

8420113c <Lc_aec_reference_mic_generate_metadata_with_ttp_5>:
        }

        /* append Null tag, with length = null_tag_len */
        b4idx = 0;
        afteridx = null_tag_len*OCTETS_PER_SAMPLE;
8420113c:	75 54       	r3 = r4 LSHIFT 2;
        buff_metadata_append(met_buf, NULL, b4idx, afteridx);
8420113e:	04 00       	r2 = Null + Null;
84201140:	03 00       	r1 = Null + Null;
84201142:	5a 08       	r0 = r9 + Null;
84201144:	ff fd 84 f0 	call (m) 0x11adc;
84201148:	39 ec 

        /* update amount left */
        op_extra_data->mic_metadata_tag_left_words -= null_tag_len;
8420114a:	81 f0 cb 88 	rMAC = M[r6 + 812];
8420114e:	89 05       	rMAC = rMAC - r4;
84201150:	81 f0 cb 8e 	M[r6 + 812] = rMAC;
        samples -= null_tag_len;
84201154:	bf 05       	r5 = r5 - r4;
        if(samples == 0)
84201156:	38 04       	Null = r5 - Null;
84201158:	54 60       	if EQ jump (m) Lc_aec_reference_mic_generate_metadata_with_ttp_12;

8420115a <Lc_aec_reference_mic_generate_metadata_with_ttp_6>:
        }
    }

    /* create a new tag to append */
    b4idx = 0;
    afteridx = samples*OCTETS_PER_SAMPLE;
8420115a:	7a 54       	r0 = r5 LSHIFT 2;
8420115c:	42 de       	M[FP + 32] = r0;
    mtag = buff_metadata_new_tag();
8420115e:	ff fd 83 f0 	call (m) 0x11862;
84201162:	25 e8 
84201164:	16 00       	r4 = r0 + Null;
    if (mtag != NULL)
84201166:	46 60       	if EQ jump (m) Lc_aec_reference_mic_generate_metadata_with_ttp_11;

84201168 <Lc_aec_reference_mic_generate_metadata_with_ttp_7>:
    {
        /* calculating time of arrival for first sample of the tag,
         * we do that by looking how many samples are in the mic buffer,
         * this could be short by up to 1 sample as our reading isn't aligned.
         */
        TIME current_time = hal_get_time();
84201168:	ff fd 83 f1 	call (m) 0x317e8;
8420116c:	21 e4 
8420116e:	12 09       	r8 = r0 + Null;

        /* amount of data in the mic buffer */
        unsigned amount_in_buffer =
            cbuffer_calc_amount_data_in_words(op_extra_data->input_stream[AEC_REF_MIC_TERMINAL1]);
84201170:	82 f0 02 88 	r0 = M[r6 + 8];
84201174:	ff fd 58 f1 	call (m) 0x2c208;
84201178:	35 e4 

        /* convert samples to time,
         * Note: some inaccuracies because of rate adjustment, but jitter will be filtered by ttp filter */
        INTERVAL time_passed = (INTERVAL) (((uint48)(amount_in_buffer)*SECOND)/op_extra_data->mic_rate) +
            (INTERVAL) (((uint48)(samples)*SECOND)/op_extra_data->output_rate);
8420117a:	00 f0 42 ff 	rMAC = r0 * 0.00023283064365386962890625 (UU);
8420117e:	40 f2 11 cc 
84201182:	84 f0 66 88 	r2 = M[r6 + 408];
84201186:	05 00       	r3 = Null + Null;
84201188:	09 50       	rMAC = rMAC LSHIFT -1 (56bit);
8420118a:	00 f1 d3 c8 	r1 = rMAC LSHIFT 0;
8420118e:	ca 57       	r0 = rMAC LSHIFT 32;
84201190:	ff fd af f0 	call (m) 0x17130;
84201194:	21 ed 
84201196:	11 09       	r7 = r0 + Null;
84201198:	00 f0 42 ff 	rMAC = r5 * 0.00023283064365386962890625 (UU);
8420119c:	40 f7 11 cc 
842011a0:	84 f0 65 88 	r2 = M[r6 + 404];
842011a4:	05 00       	r3 = Null + Null;
842011a6:	09 50       	rMAC = rMAC LSHIFT -1 (56bit);
842011a8:	00 f1 d3 c8 	r1 = rMAC LSHIFT 0;
842011ac:	ca 57       	r0 = rMAC LSHIFT 32;
842011ae:	ff fd af f0 	call (m) 0x17130;
842011b2:	23 ec 
842011b4:	11 00       	rMAC = r0 + Null;
842011b6:	49 0c       	rMAC = r7 + rMAC;

        TIME time_of_arrival = time_sub(current_time, time_passed);
842011b8:	1f fa 03 c2 	r1 = r8 - rMAC;

        /* see if we have minimum amount for tag */
        if(samples >= op_extra_data->mic_metadata_min_tag_len)
842011bc:	82 f0 cc 88 	r0 = M[r6 + 816];
842011c0:	b8 04       	Null = r5 - r0;
842011c2:	04 64       	if NC jump (m) Lc_aec_reference_mic_generate_metadata_with_ttp_9;

842011c4 <Lc_aec_reference_mic_generate_metadata_with_ttp_8>:
        {
            /* we have enough new samples to append a complete tag */
            mtag->length = samples*OCTETS_PER_SAMPLE;
842011c4:	7a 54       	r0 = r5 LSHIFT 2;
842011c6:	f2 8e       	M[r4 + 12] = r0;
842011c8:	08 6e       	jump (m) Lc_aec_reference_mic_generate_metadata_with_ttp_10;

842011ca <Lc_aec_reference_mic_generate_metadata_with_ttp_9>:
             * new complete tag, we append a new tag with
             * minimum length, this tag is incomplete and
             * will be completed in next calls when we receive
             * new samples by appending Null tags.
             */
            mtag->length = op_extra_data->mic_metadata_min_tag_len*OCTETS_PER_SAMPLE;
842011ca:	52 54       	r0 = r0 LSHIFT 2;
842011cc:	f2 8e       	M[r4 + 12] = r0;
            op_extra_data->mic_metadata_tag_left_words = op_extra_data->mic_metadata_min_tag_len - samples;
842011ce:	81 f0 cc 88 	rMAC = M[r6 + 816];
842011d2:	c9 05       	rMAC = rMAC - r5;
842011d4:	81 f0 cb 8e 	M[r6 + 812] = rMAC;

842011d8 <Lc_aec_reference_mic_generate_metadata_with_ttp_10>:
        }

        ttp_status status;
        ttp_update_ttp(op_extra_data->mic_time_to_play, time_of_arrival,
                       mtag->length/OCTETS_PER_SAMPLE, &status);
842011d8:	45 12       	r3 = FP + 36;
842011da:	f2 88       	r0 = M[r4 + 12];
842011dc:	54 50       	r2 = r0 LSHIFT -2;
842011de:	82 f0 cf 88 	r0 = M[r6 + 828];
842011e2:	ff fd ab f0 	call (m) 0x16860;
842011e6:	3f e3 
        /* Populate the metadata tag from the TTP status */
        ttp_utils_populate_tag(mtag, &status);
842011e8:	43 12       	r1 = FP + 36;
842011ea:	32 00       	r0 = r4 + Null;
842011ec:	ef fd fb ff 	call (m) 0x8d0;
842011f0:	25 e7 

842011f2 <Lc_aec_reference_mic_generate_metadata_with_ttp_11>:
    }
    /* append generated metadata to the output buffer */
    buff_metadata_append(met_buf, mtag, b4idx, afteridx);
842011f2:	04 00       	r2 = Null + Null;
842011f4:	33 00       	r1 = r4 + Null;
842011f6:	5a 08       	r0 = r9 + Null;
842011f8:	45 d8       	r3 = M[FP + 32];
842011fa:	ff fd 84 f0 	call (m) 0x11adc;
842011fe:	23 e7 

84201200 <Lc_aec_reference_mic_generate_metadata_with_ttp_12>:
}
84201200:	f6 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84201202:	d8 4c       	rts;

84201204 <$_aec_reference_set_mic_gains>:
    return TRUE;
}


void aec_reference_set_mic_gains(OPERATOR_DATA *op_data)
{
84201204:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84201206:	12 09       	r8 = r0 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84201208:	a9 f0 0c 88 	r7 = M[r8 + 48];


void aec_reference_set_mic_gains(OPERATOR_DATA *op_data)
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    unsigned i, *lpadcgains = (unsigned*)&op_extra_data->params.OFFSET_ADC_GAIN1;
8420120c:	97 f0 d0 20 	r5 = r7 + 208;

    patch_fn_shared(aec_reference);

    for(i=0;i<MAX_NUMBER_MICS;i++)
84201210:	06 00       	r4 = Null + Null;
84201212:	17 6e       	jump (m) Lc_aec_reference_set_mic_gains_6;

84201214 <Lc_aec_reference_set_mic_gains_2>:
    {
        return (i + AEC_REF_MIC_TERMINAL1);
    }
    else
    {
        return ((i-4)+ AEC_REF_MIC_TERMINAL5);
84201214:	31 22       	rMAC = r4 + 8;

84201216 <Lc_aec_reference_set_mic_gains_3>:
        if(op_extra_data->input_stream[MicrophoneTerminalByIndex(i)])
        {
            uint32 config_value = (uint32)(lpadcgains[i]);
            set_override_ep_gain(get_overriden_endpoint(op_data->id,
                                 MicrophoneTerminalByIndex(i) | TERMINAL_SINK_MASK),
                                 config_value);
84201216:	08 f0 00 f0 	r1 = rMAC OR 0x800000;
8420121a:	00 f1 53 c8 
8420121e:	a2 f0 01 88 	r0 = M[r8 + 4];
84201222:	ff fd 1c f0 	call (m) 0x4ab0;
84201226:	2f e4 
84201228:	43 08       	r1 = r6 + Null;
8420122a:	ff fd 1b f0 	call (m) 0x4a1c;
8420122e:	33 ef 

84201230 <Lc_aec_reference_set_mic_gains_4>:
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);
    unsigned i, *lpadcgains = (unsigned*)&op_extra_data->params.OFFSET_ADC_GAIN1;

    patch_fn_shared(aec_reference);

    for(i=0;i<MAX_NUMBER_MICS;i++)
84201230:	76 20       	r4 = r4 + 1;
84201232:	3f 21       	r5 = r5 + 4;
84201234:	30 26       	Null = r4 - 8;
84201236:	02 f0 a7 e0 	if C jump (m) Lc_aec_reference_set_mic_gains_11;

8420123a <Lc_aec_reference_set_mic_gains_5>:
}


inline static unsigned MicrophoneTerminalByIndex(unsigned i)
{
    if(i<4)
8420123a:	30 25       	Null = r4 - 4;
8420123c:	02 f0 89 e0 	if C jump (m) Lc_aec_reference_set_mic_gains_7;

84201240 <Lc_aec_reference_set_mic_gains_6>:
    {
        return (i + AEC_REF_MIC_TERMINAL1);
84201240:	b2 20       	r0 = r4 + 2;
84201242:	02 6e       	jump (m) Lc_aec_reference_set_mic_gains_8;

84201244 <Lc_aec_reference_set_mic_gains_7>:
    }
    else
    {
        return ((i-4)+ AEC_REF_MIC_TERMINAL5);
84201244:	32 22       	r0 = r4 + 8;

84201246 <Lc_aec_reference_set_mic_gains_8>:
    {
        if(op_extra_data->input_stream[MicrophoneTerminalByIndex(i)])
84201246:	52 54       	r0 = r0 LSHIFT 2;
84201248:	91 f0 02 e8 	rMAC = M[r7 + r0];
8420124c:	f2 61       	if EQ jump (m) Lc_aec_reference_set_mic_gains_4;

8420124e <Lc_aec_reference_set_mic_gains_9>:
        {
            uint32 config_value = (uint32)(lpadcgains[i]);
8420124e:	78 f0 00 e8 	r6 = M[r5 + Null];
}


inline static unsigned MicrophoneTerminalByIndex(unsigned i)
{
    if(i<4)
84201252:	30 25       	Null = r4 - 4;
84201254:	f2 ff c1 ef 	if C jump (m) Lc_aec_reference_set_mic_gains_2;

84201258 <Lc_aec_reference_set_mic_gains_10>:
    {
        return (i + AEC_REF_MIC_TERMINAL1);
84201258:	b1 20       	rMAC = r4 + 2;
8420125a:	de 6f       	jump (m) Lc_aec_reference_set_mic_gains_3;

8420125c <Lc_aec_reference_set_mic_gains_11>:
            set_override_ep_gain(get_overriden_endpoint(op_data->id,
                                 MicrophoneTerminalByIndex(i) | TERMINAL_SINK_MASK),
                                 config_value);
        }
    }
}
8420125c:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
8420125e:	d8 4c       	rts;

84201260 <$_aec_reference_cleanup>:
 * Note: This function is the same as aec_reference_cleanup_graphs
 *       except that it will reset the entire channel status so any new attempt
 *       to build the graphs will rebuild everything from scratch.
 */
void aec_reference_cleanup(OPERATOR_DATA *op_data)
{
84201260:	f1 1c       	pushm <FP(=SP), r4, rLink>;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84201262:	16 99       	r4 = M[r0 + 48];
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);

    patch_fn_shared(aec_reference);

    /* cleanup all the graphs */
    aec_reference_cleanup_graphs(op_extra_data);
84201264:	32 00       	r0 = r4 + Null;
84201266:	06 f0 33 ed 	call (m) $_aec_reference_cleanup_graphs;

    /* reset channel status, so any new trying
     * of building graphs will rebuild every thing
     * from scratch
     */
    op_extra_data->channel_status = 0;
8420126a:	60 f0 76 8e 	M[r4 + 472] = Null;

8420126e <Lc_aec_reference_cleanup_2>:
}
8420126e:	f1 48       	popm <FP, r4, rLink>;
84201270:	d8 4c       	rts;

84201272 <$_build_mic_graph>:
 *        whenever there is a change in microphone channel status.
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 */
bool build_mic_graph(AEC_REFERENCE_OP_DATA *op_extra_data)
{
84201272:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
84201274:	10 09       	r6 = r0 + Null;
    cbops_graph *mic_graph;
    cbops_op *op_ptr;
    unsigned i, num_mics = op_extra_data->num_mic_channels,j,num_io;
84201276:	8a f0 78 88 	r8 = M[r6 + 480];
    unsigned* idxs;
    unsigned  out_idx,intern_idx;
    bool sidetone_enabled = (op_extra_data->using_sidetone&SIDETONE_ENABLE_FLAG) != 0;
8420127a:	81 f0 7a 88 	rMAC = M[r6 + 488];
8420127e:	02 00       	r0 = Null + Null;
84201280:	49 c0       	rMAC = rMAC AND 0x2;
84201282:	21 f0 42 ce 	if NE r0 = Null + 1;
84201286:	42 de       	M[FP + 32] = r0;
84201288:	13 00       	r1 = r0 + Null;
       aec_reference_mic_spkr_include_sidetone.

    **********************************************************************/

    /* see if we need a MIC path */
    if(!build_mic_graph_is_required(op_extra_data, sidetone_enabled))
8420128a:	42 08       	r0 = r6 + Null;
8420128c:	0a f0 3b e1 	call (m) Lc_build_mic_graph_is_required_1;
84201290:	10 04       	Null = r0 - Null;
84201292:	7d 60       	if EQ jump (m) Lc_build_mic_graph_19;

84201294 <Lc_build_mic_graph_2>:
       MIC Internal
       SIDETONE OUT
    */

    out_idx    = num_mics;
    intern_idx = out_idx;
84201294:	51 09       	r7 = r8 + Null;
    num_io     = 2*num_mics;
84201296:	00 fa d6 d8 	r4 = r8 LSHIFT 1;

    /* if sidetone enabled reserve indexes for mic sidetone process,
     * the process will insert later if required.
     */
    if(sidetone_enabled)
8420129a:	41 d8       	rMAC = M[FP + 32];
8420129c:	7a 60       	if EQ jump (m) Lc_build_mic_graph_20;

8420129e <Lc_build_mic_graph_3>:
    {
        /* Need internal buffer between input and output */
        intern_idx = num_io;
8420129e:	31 09       	r7 = r4 + Null;
        num_io    += num_mics;
842012a0:	56 0c       	r4 = r8 + r4;

        /* sidetone path input */
        op_extra_data->mic_st_input_idx = intern_idx;
842012a2:	89 f0 da 8e 	M[r6 + 872] = r7;

        /* sidetone output */
        op_extra_data->mic_st_idx = num_io;
842012a6:	86 f0 d8 8e 	M[r6 + 864] = r4;

        /* one extra io for sidetone, could be unused*/
        num_io++;
842012aa:	76 20       	r4 = r4 + 1;
842012ac:	86 6e       	jump (m) Lc_build_mic_graph_25;

842012ae <Lc_build_mic_graph_4>:
                goto aFailed;
            }
            rate_monitor_op_initialise(op_ptr,op_extra_data->mic_rate,TRUE,3*MS_PER_SEC);
        }
    }
    else if(!is_override_ep_locally_clocked(op_extra_data->mic_endpoint))
842012ae:	82 f0 7f 88 	r0 = M[r6 + 508];
842012b2:	ff fd 1b f0 	call (m) 0x4a8c;
842012b6:	3b ee 
842012b8:	10 04       	Null = r0 - Null;
842012ba:	16 62       	if NE jump (m) Lc_build_mic_graph_8;

842012bc <Lc_build_mic_graph_5>:
    {
        /* With SW rate adjustment we need rate monitor if mic isn't locally clocked */
        op_ptr = create_rate_monitor_operator(op_extra_data->task_frequency, 0);
842012bc:	82 f0 92 88 	r0 = M[r6 + 584];
842012c0:	03 00       	r1 = Null + Null;
842012c2:	0d f0 39 e7 	call (m) $_create_rate_monitor_operator;
842012c6:	16 00       	r4 = r0 + Null;
        if(!op_ptr)
842012c8:	9a 60       	if EQ jump (m) Lc_build_mic_graph_30;

842012ca <Lc_build_mic_graph_6>:
        {
            goto aFailed;
        }
        rate_monitor_op_initialise(op_ptr,op_extra_data->mic_rate, FALSE,
                                   100*MILLISECOND/MILLISECOND);
842012ca:	05 f0 64 40 	r3 = Null + 100;
842012ce:	83 f0 66 88 	r1 = M[r6 + 408];
842012d2:	04 00       	r2 = Null + Null;
842012d4:	f6 ff 28 ea 	call $_rate_monitor_op_initialise;

842012d8 <Lc_build_mic_graph_7>:
    }
    if(NULL != op_ptr)
    {
        /* insert rate monitor op into the graph */
        op_extra_data->mic_rate_monitor_op = op_ptr;
842012d8:	86 f0 6b 8e 	M[r6 + 428] = r4;
        cbops_append_operator_to_graph(mic_graph,op_ptr);
842012dc:	33 00       	r1 = r4 + Null;
842012de:	5a 08       	r0 = r9 + Null;
842012e0:	ff fd ad f0 	call (m) 0x16e96;
842012e4:	37 ed 

842012e6 <Lc_build_mic_graph_8>:
    /* Handle input */
    if(op_extra_data->mic_rate_ability == RATEMATCHING_SUPPORT_SW
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
        && (0 == op_extra_data->mic_ext_rate_adjust_op)
#endif
        )
842012e6:	81 f0 67 88 	rMAC = M[r6 + 412];
842012ea:	48 24       	Null = rMAC - 1;
842012ec:	78 62       	if NE jump (m) Lc_build_mic_graph_28;

842012ee <Lc_build_mic_graph_9>:
842012ee:	80 f0 ad 88 	Null = M[r6 + 692];
842012f2:	75 62       	if NE jump (m) Lc_build_mic_graph_28;

842012f4 <Lc_build_mic_graph_10>:
    {
        /* Apply Software Rate Adjustment */
        op_ptr = create_sw_rate_adj_op(num_mics, idxs, &idxs[intern_idx],
                                       CBOPS_RATEADJUST_COEFFS,
                                       &op_extra_data->mic_rate_adjustment, op_extra_data->mic_shift);
842012f4:	81 f0 6d 88 	rMAC = M[r6 + 436];
842012f8:	09 1c       	pushm <rMAC>;
842012fa:	01 f0 a4 ff 	push r6 + 420;
842012fe:	18 cf 
84201300:	85 2a       	r3 = Null + 26;
84201302:	01 f9 d2 c8 	r0 = r7 LSHIFT 2;
84201306:	4c d8       	r2 = M[FP + 36];
84201308:	23 00       	r1 = r2 + Null;
8420130a:	14 01       	r2 = r0 + r2;
8420130c:	52 08       	r0 = r8 + Null;
8420130e:	ff fd ac f0 	call (m) 0x16bea;
84201312:	3d e6 
84201314:	7e 4c       	SP = SP + -8;
84201316:	16 00       	r4 = r0 + Null;
        if(!op_ptr)
84201318:	72 60       	if EQ jump (m) Lc_build_mic_graph_30;

8420131a <Lc_build_mic_graph_11>:
        {
            goto aFailed;
        }

        op_extra_data->mic_sw_rateadj_op=op_ptr;
8420131a:	86 f0 7d 8e 	M[r6 + 500] = r4;
        cbops_rateadjust_passthrough_mode(op_ptr,(op_extra_data->mic_rate_enactment==RATEMATCHING_SUPPORT_NONE)?TRUE:FALSE);
8420131e:	03 00       	r1 = Null + Null;
84201320:	80 f0 68 88 	Null = M[r6 + 416];
84201324:	20 f0 43 ce 	if EQ r1 = Null + 1;
84201328:	ff fd ac f0 	call (m) 0x16c96;
8420132c:	2f eb 

8420132e <Lc_build_mic_graph_12>:

        cbops_append_operator_to_graph(mic_graph,op_ptr);
8420132e:	33 00       	r1 = r4 + Null;
84201330:	5a 08       	r0 = r9 + Null;
84201332:	ff fd ad f0 	call (m) 0x16e96;
84201336:	25 eb 

        /* Early DC remove on mic path. Before Sidetone split so the signal split
           to the speaker doesn't have DC */
        op_ptr = create_dc_remove_op(num_mics, &idxs[intern_idx], &idxs[intern_idx]);
84201338:	01 f9 d2 c8 	r0 = r7 LSHIFT 2;
8420133c:	4b d8       	r1 = M[FP + 36];
8420133e:	d3 00       	r1 = r0 + r1;
84201340:	1c 00       	r2 = r1 + Null;
84201342:	52 08       	r0 = r8 + Null;
84201344:	ff fd 25 f1 	call (m) 0x25e40;
84201348:	3d e7 
8420134a:	16 00       	r4 = r0 + Null;
        if(!op_ptr)
8420134c:	58 60       	if EQ jump (m) Lc_build_mic_graph_30;

8420134e <Lc_build_mic_graph_13>:
        {
            goto aFailed;
        }
        cbops_append_operator_to_graph(mic_graph,op_ptr);
8420134e:	33 00       	r1 = r4 + Null;
84201350:	5a 08       	r0 = r9 + Null;
84201352:	ff fd ad f0 	call (m) 0x16e96;
84201356:	25 ea 

84201358 <Lc_build_mic_graph_14>:
            goto aFailed;
        }
        cbops_append_operator_to_graph(mic_graph,op_ptr);
    }

	if(sidetone_enabled)
84201358:	41 d8       	rMAC = M[FP + 32];
8420135a:	03 60       	if EQ jump (m) Lc_build_mic_graph_16;

8420135c <Lc_build_mic_graph_15>:
	{
        /* mic sidetone path will be inserted after last operator in inputsubgraph.*/
        op_extra_data->mic_st_point = op_ptr;
8420135c:	86 f0 dc 8e 	M[r6 + 880] = r4;

84201360 <Lc_build_mic_graph_16>:
	}

    /* check if output subgraph is needed */
    if(!op_extra_data->mic_graph_no_output)
84201360:	80 f0 dd 88 	Null = M[r6 + 884];
84201364:	0c 62       	if NE jump (m) Lc_build_mic_graph_18;

84201366 <Lc_build_mic_graph_17>:
        /* append mic output subgraph */
        if(!build_mic_graph_add_output_subgraph(op_extra_data,
                                                idxs,
                                                intern_idx,
                                                out_idx,
                                                sidetone_enabled))
84201366:	41 d8       	rMAC = M[FP + 32];
84201368:	09 1c       	pushm <rMAC>;
8420136a:	55 08       	r3 = r8 + Null;
8420136c:	4c 08       	r2 = r7 + Null;
8420136e:	42 08       	r0 = r6 + Null;
84201370:	4b d8       	r1 = M[FP + 36];
84201372:	09 f0 29 ec 	call (m) Lc_build_mic_graph_add_output_subgraph_1;
84201376:	7f 4c       	SP = SP + -4;
84201378:	10 04       	Null = r0 - Null;
8420137a:	41 60       	if EQ jump (m) Lc_build_mic_graph_30;

8420137c <Lc_build_mic_graph_18>:
        {
            goto aFailed;
        }
    }

    pfree(idxs);
8420137c:	4a d8       	r0 = M[FP + 36];
8420137e:	ff fd 1d f0 	call (m) 0x4f62;
84201382:	25 ef 

    /* Each mic input has a corresponding output,
     * so it's safe to purge all channels now
     */
    aec_ref_purge_mics(mic_graph,num_mics);
84201384:	53 08       	r1 = r8 + Null;
84201386:	5a 08       	r0 = r9 + Null;
84201388:	0f f0 3f ec 	call (m) $_aec_ref_purge_mics;

8420138c <Lc_build_mic_graph_19>:

    /* see if we need a MIC path */
    if(!build_mic_graph_is_required(op_extra_data, sidetone_enabled))
    {
        /* No need to build mic graph */
        return TRUE;
8420138c:	42 20       	r0 = Null + 1;
8420138e:	8f 6e       	jump (m) Lc_build_mic_graph_50;

84201390 <Lc_build_mic_graph_20>:

        /* one extra io for sidetone, could be unused*/
        num_io++;
    }
    else if( (op_extra_data->mic_rate_ability==RATEMATCHING_SUPPORT_SW) &&
             (op_extra_data->mic_rate!=op_extra_data->output_rate))
84201390:	81 f0 67 88 	rMAC = M[r6 + 412];
84201394:	48 24       	Null = rMAC - 1;
84201396:	0a 62       	if NE jump (m) Lc_build_mic_graph_23;

84201398 <Lc_build_mic_graph_21>:
84201398:	81 f0 66 88 	rMAC = M[r6 + 408];
8420139c:	82 f0 65 88 	r0 = M[r6 + 404];
842013a0:	88 04       	Null = rMAC - r0;
842013a2:	0b 60       	if EQ jump (m) Lc_build_mic_graph_25;

842013a4 <Lc_build_mic_graph_22>:
    {
        /* Need internal buffer between input and output */
        intern_idx = num_io;
842013a4:	31 09       	r7 = r4 + Null;
        num_io    += num_mics;
842013a6:	56 0c       	r4 = r8 + r4;
842013a8:	08 6e       	jump (m) Lc_build_mic_graph_25;

842013aa <Lc_build_mic_graph_23>:
    }
    else if (op_extra_data->mic_rate!=op_extra_data->output_rate)
842013aa:	81 f0 66 88 	rMAC = M[r6 + 408];
842013ae:	82 f0 65 88 	r0 = M[r6 + 404];
842013b2:	88 04       	Null = rMAC - r0;
842013b4:	02 60       	if EQ jump (m) Lc_build_mic_graph_25;

842013b6 <Lc_build_mic_graph_24>:
    {
        /* No ratematching or sidetone.  Just resampling  */
        intern_idx = 0;
842013b6:	01 09       	r7 = Null + Null;

842013b8 <Lc_build_mic_graph_25>:
    }

    idxs = create_default_indexes(num_io);
842013b8:	32 00       	r0 = r4 + Null;
842013ba:	ff fd ad f0 	call (m) 0x16f08;
842013be:	2f ea 
842013c0:	4a de       	M[FP + 36] = r0;
    if(idxs == NULL)
842013c2:	11 00       	rMAC = r0 + Null;
842013c4:	20 60       	if EQ jump (m) Lc_build_mic_graph_31;

842013c6 <Lc_build_mic_graph_26>:
    {
        return(FALSE);
    }

    /* Allocate mic graph */
    mic_graph = cbops_alloc_graph(num_io);
842013c6:	32 00       	r0 = r4 + Null;
842013c8:	ff fd ac f0 	call (m) 0x16d76;
842013cc:	2f ed 
842013ce:	13 09       	r9 = r0 + Null;
    if(!mic_graph)
842013d0:	16 60       	if EQ jump (m) Lc_build_mic_graph_30;

842013d2 <Lc_build_mic_graph_27>:
    {
        goto aFailed;
    }
    op_extra_data->mic_graph = mic_graph;
842013d2:	8b f0 6a 8e 	M[r6 + 424] = r9;

    /* Setup MIC input Buffers*/
    for(j=0,i=0;(j<MAX_NUMBER_MICS);j++)
842013d6:	07 00       	r5 = Null + Null;
842013d8:	06 00       	r4 = Null + Null;
842013da:	1a 6e       	jump (m) Lc_build_mic_graph_33;

842013dc <Lc_build_mic_graph_28>:
            goto aFailed;
        }
        cbops_append_operator_to_graph(mic_graph,op_ptr);

    }
    else if(intern_idx != 0)
842013dc:	0f f9 00 c2 	Null = r7 - Null;
842013e0:	bc 61       	if EQ jump (m) Lc_build_mic_graph_14;

842013e2 <Lc_build_mic_graph_29>:
    {
        /* Otherwise, just copy data to next section */
        op_ptr = create_shift_op(num_mics, idxs, &idxs[intern_idx], op_extra_data->mic_shift);
842013e2:	85 f0 6d 88 	r3 = M[r6 + 436];
842013e6:	01 f9 d2 c8 	r0 = r7 LSHIFT 2;
842013ea:	4c d8       	r2 = M[FP + 36];
842013ec:	23 00       	r1 = r2 + Null;
842013ee:	14 01       	r2 = r0 + r2;
842013f0:	52 08       	r0 = r8 + Null;
842013f2:	ff fd 25 f1 	call (m) 0x25e08;
842013f6:	37 e0 
842013f8:	16 00       	r4 = r0 + Null;
        if(!op_ptr)
842013fa:	9a 63       	if NE jump (m) Lc_build_mic_graph_12;

842013fc <Lc_build_mic_graph_30>:

    return(TRUE);
  aFailed:
    DEBUG_GRAPHS("AEC REFERENCE: Building mic graph, Failed!");

    pfree(idxs);
842013fc:	4a d8       	r0 = M[FP + 36];
842013fe:	ff fd 1d f0 	call (m) 0x4f62;
84201402:	25 eb 

84201404 <Lc_build_mic_graph_31>:
    }

    idxs = create_default_indexes(num_io);
    if(idxs == NULL)
    {
        return(FALSE);
84201404:	02 00       	r0 = Null + Null;
84201406:	53 6e       	jump (m) Lc_build_mic_graph_50;

84201408 <Lc_build_mic_graph_32>:
}


inline static unsigned MicrophoneTerminalByIndex(unsigned i)
{
    if(i<4)
84201408:	30 25       	Null = r4 - 4;
8420140a:	02 f0 89 e0 	if C jump (m) Lc_build_mic_graph_34;

8420140e <Lc_build_mic_graph_33>:
    {
        return (i + AEC_REF_MIC_TERMINAL1);
8420140e:	b2 20       	r0 = r4 + 2;
84201410:	02 6e       	jump (m) Lc_build_mic_graph_35;

84201412 <Lc_build_mic_graph_34>:
    }
    else
    {
        return ((i-4)+ AEC_REF_MIC_TERMINAL5);
84201412:	32 22       	r0 = r4 + 8;

84201414 <Lc_build_mic_graph_35>:

    /* Setup MIC input Buffers*/
    for(j=0,i=0;(j<MAX_NUMBER_MICS);j++)
    {
        /* MIC inputs may not be consecutive */
        tCbuffer *buffer_ptr_src = op_extra_data->input_stream[MicrophoneTerminalByIndex(j)];
84201414:	52 54       	r0 = r0 LSHIFT 2;

        if(buffer_ptr_src != NULL)
84201416:	85 f0 02 e8 	r3 = M[r6 + r0];
8420141a:	0c 60       	if EQ jump (m) Lc_build_mic_graph_39;

8420141c <Lc_build_mic_graph_36>:
        {
            if(i < num_mics)
8420141c:	af f7 00 c2 	Null = r5 - r8;
84201420:	02 f0 91 e0 	if C jump (m) Lc_build_mic_graph_38;

84201424 <Lc_build_mic_graph_37>:
            {
                /* Inputs */
                cbops_set_input_io_buffer(mic_graph, i, 0, buffer_ptr_src);
84201424:	04 00       	r2 = Null + Null;
84201426:	3b 00       	r1 = r5 + Null;
84201428:	5a 08       	r0 = r9 + Null;
8420142a:	ff fd ac f0 	call (m) 0x16e02;
8420142e:	39 ee 

84201430 <Lc_build_mic_graph_38>:
            }
            i++;
84201430:	7f 20       	r5 = r5 + 1;

84201432 <Lc_build_mic_graph_39>:
        goto aFailed;
    }
    op_extra_data->mic_graph = mic_graph;

    /* Setup MIC input Buffers*/
    for(j=0,i=0;(j<MAX_NUMBER_MICS);j++)
84201432:	76 20       	r4 = r4 + 1;
84201434:	30 26       	Null = r4 - 8;
84201436:	e9 65       	if NC jump (m) Lc_build_mic_graph_32;

84201438 <Lc_build_mic_graph_40>:
            }
            i++;
        }
    }
    /* expect to have exactly num_mics mics connected */
    PL_ASSERT(i==num_mics);
84201438:	af f7 00 c2 	Null = r5 - r8;
8420143c:	09 60       	if EQ jump (m) Lc_build_mic_graph_42;

8420143e <Lc_build_mic_graph_41>:
8420143e:	03 f0 7e 43 	r1 = Null + 894;
84201442:	02 f0 13 60 	r0 = Null + 4115;
84201446:	ff fd 95 f0 	call (m) 0x13f12;
8420144a:	2d e6 
8420144c:	30 6e       	jump (m) Lc_build_mic_graph_50;

8420144e <Lc_build_mic_graph_42>:

    if(intern_idx > out_idx)
8420144e:	af f9 00 c2 	Null = r7 - r8;
84201452:	09 f0 a9 e0 	if LS jump (m) Lc_build_mic_graph_46;

84201456 <Lc_build_mic_graph_43>:
    {
        for(i=0;i<num_mics;i++)
84201456:	06 00       	r4 = Null + Null;
84201458:	87 f0 84 20 	r5 = r6 + 132;

8420145c <Lc_build_mic_graph_44>:
8420145c:	af f6 00 c2 	Null = r4 - r8;
84201460:	02 f0 9b e0 	if C jump (m) Lc_build_mic_graph_46;

84201464 <Lc_build_mic_graph_45>:
        {
            cbops_set_internal_io_buffer(mic_graph,intern_idx+i,intern_idx,op_extra_data->scratch_bufs[i]);
84201464:	3d e8       	r3 = M[r5 + Null];
84201466:	9f f6 03 c0 	r1 = r4 + r7;
8420146a:	4c 08       	r2 = r7 + Null;
8420146c:	5a 08       	r0 = r9 + Null;
8420146e:	ff fd ac f0 	call (m) 0x16e66;
84201472:	39 ef 
    /* expect to have exactly num_mics mics connected */
    PL_ASSERT(i==num_mics);

    if(intern_idx > out_idx)
    {
        for(i=0;i<num_mics;i++)
84201474:	76 20       	r4 = r4 + 1;
84201476:	3f 21       	r5 = r5 + 4;
84201478:	f2 6f       	jump (m) Lc_build_mic_graph_44;

8420147a <Lc_build_mic_graph_46>:
        {
            cbops_set_internal_io_buffer(mic_graph,intern_idx+i,intern_idx,op_extra_data->scratch_bufs[i]);
        }
    }

    op_extra_data->mic_rate_adjustment = 0;
8420147a:	80 f0 69 8e 	M[r6 + 420] = Null;

    /* create rate monitor op if required */
    op_ptr = NULL;
8420147e:	06 00       	r4 = Null + Null;
    if(op_extra_data->mic_rate_ability == RATEMATCHING_SUPPORT_HW)
84201480:	81 f0 67 88 	rMAC = M[r6 + 412];
84201484:	88 24       	Null = rMAC - 2;
84201486:	14 63       	if NE jump (m) Lc_build_mic_graph_4;

84201488 <Lc_build_mic_graph_47>:
    {
        /* With HW rate adjustmen we always need rate monitor,
         * except when we are syncing MIC to REF.
         */
        if(!op_extra_data->mic_sync_enable)
84201488:	80 f0 d4 88 	Null = M[r6 + 848];
8420148c:	2d 63       	if NE jump (m) Lc_build_mic_graph_8;

8420148e <Lc_build_mic_graph_48>:
        {
            op_ptr = create_rate_monitor_operator(op_extra_data->task_frequency, 0);
8420148e:	82 f0 92 88 	r0 = M[r6 + 584];
84201492:	03 00       	r1 = Null + Null;
84201494:	0c f0 27 e9 	call (m) $_create_rate_monitor_operator;
84201498:	16 00       	r4 = r0 + Null;
            if(!op_ptr)
8420149a:	b1 61       	if EQ jump (m) Lc_build_mic_graph_30;

8420149c <Lc_build_mic_graph_49>:
            {
                goto aFailed;
            }
            rate_monitor_op_initialise(op_ptr,op_extra_data->mic_rate,TRUE,3*MS_PER_SEC);
8420149c:	05 f0 b8 53 	r3 = Null + 3000;
842014a0:	44 20       	r2 = Null + 1;
842014a2:	83 f0 66 88 	r1 = M[r6 + 408];
842014a6:	f5 ff 36 eb 	call $_rate_monitor_op_initialise;
842014aa:	17 6f       	jump (m) Lc_build_mic_graph_7;

842014ac <Lc_build_mic_graph_50>:
  aFailed:
    DEBUG_GRAPHS("AEC REFERENCE: Building mic graph, Failed!");

    pfree(idxs);
    return(FALSE);
}
842014ac:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
842014ae:	d8 4c       	rts;

842014b0 <$_build_spkr_graph>:
 *       depending on the connections and microphone state, however they
 *       aren't included by this function, instead they are added to the
 *       speaker graph later.
 */
bool build_spkr_graph(AEC_REFERENCE_OP_DATA *op_extra_data)
{
842014b0:	f6 1e       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x20;
842014b2:	42 de       	M[FP + 32] = r0;
842014b4:	11 00       	rMAC = r0 + Null;
    cbops_op    *overrid_op_ptr;
    unsigned    num_io;
    tCbuffer    *buffer_ptr;
    unsigned    *idxs;
    unsigned    out_indx,intern_ins_idx,intern_rs_idx,intern_rm_idx;
    unsigned    spkr_channel_status = GetSpkrChannelStatus(op_extra_data);
842014b6:	12 f0 76 88 	r0 = M[rMAC + 472];
842014ba:	21 f1 f0 1f 	rMAC = r0 AND 0x3ff0;
         "Sidetone Mix" is added/removed to/from the graph by aec_reference_mic_spkr_include_sidetone function.
         "Reference sub-path" is added/removed to/from the graph by aec_reference_spkr_include_ref_path function.

    **********************************************************************/
    /* Is there a Speaker path */
    if(!(op_extra_data->channel_status&CHAN_STATE_SPKR_MASK))
842014be:	22 f0 f0 0f 	r0 = r0 AND 0xff0;
842014c2:	4a 60       	if EQ jump (m) Lc_build_spkr_graph_10;

842014c4 <Lc_build_spkr_graph_2>:
    {
        return(TRUE);
    }

    /* Determine IO configuration */
    num_spkrs  = op_extra_data->num_spkr_channels;
842014c4:	42 d8       	r0 = M[FP + 32];
842014c6:	2a f0 77 88 	r8 = M[r0 + 476];
842014ca:	ea f0 09 8e 	M[FP + 36] = r8;
    num_inputs = op_extra_data->num_spkr_channels;
    if(!(spkr_channel_status&AEC_REFERENCE_CONSTANT_CONN_TYPE_PARA))
842014ce:	ca c5       	r0 = rMAC AND 0x1000;
842014d0:	47 62       	if NE jump (m) Lc_build_spkr_graph_12;

842014d2 <Lc_build_spkr_graph_3>:
    {
        if(spkr_channel_status&AEC_REFERENCE_CONSTANT_CONN_TYPE_MIX)
842014d2:	11 f1 00 00 	rMAC = rMAC AND 0x2000;
842014d6:	43 60       	if EQ jump (m) Lc_build_spkr_graph_11;

842014d8 <Lc_build_spkr_graph_4>:
        {
            /* Multiple inputs, mono output */
            num_spkrs=1;
842014d8:	41 20       	rMAC = Null + 1;
842014da:	49 de       	M[FP + 36] = rMAC;
842014dc:	41 6e       	jump (m) Lc_build_spkr_graph_12;

842014de <Lc_build_spkr_graph_5>:
        {
            goto aFailed;
        }
        rate_monitor_op_initialise(op_ptr,op_extra_data->spkr_rate, TRUE, 3*MS_PER_SEC);
    }
    else if(!is_override_ep_locally_clocked(op_extra_data->spkr_endpoint))
842014de:	41 d8       	rMAC = M[FP + 32];
842014e0:	12 f0 80 88 	r0 = M[rMAC + 512];
842014e4:	ff fd 1a f0 	call (m) 0x4a8c;
842014e8:	29 ed 
842014ea:	10 04       	Null = r0 - Null;
842014ec:	26 62       	if NE jump (m) Lc_build_spkr_graph_9;

842014ee <Lc_build_spkr_graph_6>:
    {
        /* With SW rate adjustment we need rate monitor if speaker isn't locally clocked */
        op_ptr = create_rate_monitor_operator(op_extra_data->task_frequency, 0);
842014ee:	41 d8       	rMAC = M[FP + 32];
842014f0:	12 f0 92 88 	r0 = M[rMAC + 584];
842014f4:	03 00       	r1 = Null + Null;
842014f6:	0c f0 25 e6 	call (m) $_create_rate_monitor_operator;
842014fa:	16 00       	r4 = r0 + Null;
        if(!op_ptr)
842014fc:	9a 60       	if EQ jump (m) Lc_build_spkr_graph_27;

842014fe <Lc_build_spkr_graph_7>:
        {
            goto aFailed;
        }
        rate_monitor_op_initialise(op_ptr,op_extra_data->spkr_rate, FALSE,
                                    100*MILLISECOND/MILLISECOND);
842014fe:	05 f0 64 40 	r3 = Null + 100;
84201502:	41 d8       	rMAC = M[FP + 32];
84201504:	13 f0 6e 88 	r1 = M[rMAC + 440];
84201508:	04 00       	r2 = Null + Null;
8420150a:	f5 ff 32 e8 	call $_rate_monitor_op_initialise;

8420150e <Lc_build_spkr_graph_8>:
    if(NULL != op_ptr)
    {
#ifdef AEC_REF_CALC_SPKR_RATE_MONITOR_AMOUNT
    /*  directly pass new amount read by speaker to the operator */
    op_extra_data->spkr_last_offset =
        cbuffer_get_read_mmu_offset(op_extra_data->output_stream[AEC_REF_SPKR_TERMINAL1]);
8420150e:	41 d8       	rMAC = M[FP + 32];
84201510:	4a a8       	r0 = M[rMAC + 68];
84201512:	ff fd 8a f0 	call (m) 0x12a28;
84201516:	37 e8 
84201518:	41 d8       	rMAC = M[FP + 32];
8420151a:	12 f0 d1 8e 	M[rMAC + 836] = r0;
    set_rate_monitor_new_amount_ptr(op_ptr, &op_extra_data->spkr_new_amount);
8420151e:	13 f0 48 23 	r1 = rMAC + 840;
84201522:	32 00       	r0 = r4 + Null;
84201524:	f5 ff 3c e6 	call $_set_rate_monitor_new_amount_ptr;
#endif
        /* insert rate monitor op into the graph */
        op_extra_data->spkr_rate_monitor_op = op_ptr;
84201528:	41 d8       	rMAC = M[FP + 32];
8420152a:	16 f0 73 8e 	M[rMAC + 460] = r4;
        cbops_append_operator_to_graph(spkr_graph, op_ptr);
8420152e:	33 00       	r1 = r4 + Null;
84201530:	5a 08       	r0 = r9 + Null;
84201532:	ff fd ac f0 	call (m) 0x16e96;
84201536:	25 eb 

84201538 <Lc_build_spkr_graph_9>:
    }

#ifdef AEC_REF_CALC_SPKR_RATE_MONITOR_AMOUNT
    /* Reset flag showing speaker started to consume data */
    op_extra_data->spkr_flow_started = FALSE;
84201538:	41 d8       	rMAC = M[FP + 32];
8420153a:	10 f0 d3 8e 	M[rMAC + 844] = Null;

#ifdef ENABLE_SW_DAC_DC_OFFSET_COMPENSATION
#ifndef RUNNING_ON_KALSIM    
    /* compensate for HW dc offset addition */
    op_extra_data->spkr_dc_offset_op =
        setup_cbops_dc_offset_compensation(spkr_graph, op_extra_data->task_frequency);
8420153e:	13 f0 92 88 	r1 = M[rMAC + 584];
84201542:	5a 08       	r0 = r9 + Null;
84201544:	10 f0 35 ea 	call (m) $_setup_cbops_dc_offset_compensation;
84201548:	41 d8       	rMAC = M[FP + 32];
8420154a:	12 f0 9e 8e 	M[rMAC + 632] = r0;
#endif    
#endif
    pfree(idxs);
8420154e:	52 d8       	r0 = M[FP + 40];
84201550:	ff fd 1d f0 	call (m) 0x4f62;
84201554:	33 e0 

84201556 <Lc_build_spkr_graph_10>:

    **********************************************************************/
    /* Is there a Speaker path */
    if(!(op_extra_data->channel_status&CHAN_STATE_SPKR_MASK))
    {
        return(TRUE);
84201556:	42 20       	r0 = Null + 1;
84201558:	0f f0 8f e8 	jump (m) Lc_build_spkr_graph_79;

8420155c <Lc_build_spkr_graph_11>:
            num_spkrs=1;
        }
        else
        {
            /* Mono input, multiple outputs */
            num_inputs=1;
8420155c:	0a 71       	r8 = Null + 1;

8420155e <Lc_build_spkr_graph_12>:
        }
    }

    /* outputs follow inputs */
    /* Internal buffers for output of insert follow outputs */
    out_indx       = num_inputs;
8420155e:	ea f0 0b 8e 	M[FP + 44] = r8;

    /* Count the buffers needed */
    num_io         = num_inputs+num_spkrs;
84201562:	49 d8       	rMAC = M[FP + 36];
84201564:	51 0c       	rMAC = r8 + rMAC;
84201566:	0a 00       	r0 = rMAC + Null;

    /* reserve one index for sidetone input buffer */
    op_extra_data->spkr_st_in_idx = num_io;
84201568:	41 d8       	rMAC = M[FP + 32];
8420156a:	12 f0 a5 8e 	M[rMAC + 660] = r0;
8420156e:	11 00       	rMAC = r0 + Null;
    num_io++;
84201570:	49 20       	rMAC = rMAC + 1;
84201572:	09 09       	r7 = rMAC + Null;

    /* Assume no resampler or rate matching */
    intern_rs_idx = 0;
84201574:	60 de       	M[FP + 48] = Null;
    intern_rm_idx = 0;
84201576:	68 de       	M[FP + 52] = Null;
    intern_ins_idx = num_io;

    /* speaker inputs are copied to interm buffers immediately,
	   reserve indexes for num_inputs buffers.
	 */
    num_io += num_inputs;
84201578:	51 0c       	rMAC = r8 + rMAC;
8420157a:	71 de       	M[FP + 56] = rMAC;
     * scratch buffer for both inputs and outputs.
     */
    usable_scratch_idx = 0;

    /* Check if resampler is required */
    if(op_extra_data->input_rate!=op_extra_data->spkr_rate)
8420157c:	41 d8       	rMAC = M[FP + 32];
8420157e:	0a 00       	r0 = rMAC + Null;
84201580:	11 f0 64 88 	rMAC = M[rMAC + 400];
84201584:	22 f0 6e 88 	r0 = M[r0 + 440];
84201588:	88 04       	Null = rMAC - r0;
8420158a:	39 60       	if EQ jump (m) Lc_build_spkr_graph_22;

8420158c <Lc_build_spkr_graph_13>:
    {
        intern_rs_idx = out_indx;
8420158c:	ea f0 0c 8e 	M[FP + 48] = r8;

        if(op_extra_data->spkr_rate_ability==RATEMATCHING_SUPPORT_SW)
84201590:	41 d8       	rMAC = M[FP + 32];
84201592:	11 f0 6f 88 	rMAC = M[rMAC + 444];
84201596:	48 24       	Null = rMAC - 1;
84201598:	1a 62       	if NE jump (m) Lc_build_spkr_graph_19;

8420159a <Lc_build_spkr_graph_14>:
        {
            /* Need buffers following resampler */
            intern_rs_idx    = num_io;
8420159a:	71 d8       	rMAC = M[FP + 56];
8420159c:	61 de       	M[FP + 48] = rMAC;
            if(num_spkrs>num_inputs)
8420159e:	49 d8       	rMAC = M[FP + 36];
842015a0:	af f1 00 c2 	Null = rMAC - r8;
842015a4:	09 f0 d1 e0 	if LS jump (m) Lc_build_spkr_graph_21;

842015a8 <Lc_build_spkr_graph_15>:
            {
                /* Resampler is Mono.  Feeds shift */
                num_io++;
842015a8:	71 d8       	rMAC = M[FP + 56];
842015aa:	49 20       	rMAC = rMAC + 1;
842015ac:	71 de       	M[FP + 56] = rMAC;

842015ae <Lc_build_spkr_graph_16>:
    if(op_extra_data->spkr_rate_ability == RATEMATCHING_SUPPORT_SW
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
       /* not required if having access to external rate adjust op */
       && (0 == op_extra_data->spkr_ext_rate_adjust_op)
#endif
       )
842015ae:	41 d8       	rMAC = M[FP + 32];
842015b0:	10 f0 ae 88 	Null = M[rMAC + 696];
842015b4:	0c 62       	if NE jump (m) Lc_build_spkr_graph_19;

842015b6 <Lc_build_spkr_graph_17>:
    {
        intern_rm_idx = out_indx;
842015b6:	ea f0 0d 8e 	M[FP + 52] = r8;
        /* Split needs buffer following rate matching (Mono)*/
        if(num_spkrs>num_inputs)
842015ba:	49 d8       	rMAC = M[FP + 36];
842015bc:	af f1 00 c2 	Null = rMAC - r8;
842015c0:	09 f0 8d e0 	if LS jump (m) Lc_build_spkr_graph_19;

842015c4 <Lc_build_spkr_graph_18>:
        {
            intern_rm_idx = num_io;
842015c4:	71 d8       	rMAC = M[FP + 56];
842015c6:	69 de       	M[FP + 52] = rMAC;
            num_io++;
842015c8:	49 20       	rMAC = rMAC + 1;
842015ca:	71 de       	M[FP + 56] = rMAC;

842015cc <Lc_build_spkr_graph_19>:
    /* reserve 2 indexes for reference sub-path,
     * one is for reference output buffer, the
     * other one for scratch buffer for possible
     * resampler in the sub-path.
     */
    op_extra_data->spkr_ref_idx  = num_io;
842015cc:	72 d8       	r0 = M[FP + 56];
842015ce:	41 d8       	rMAC = M[FP + 32];
842015d0:	12 f0 a4 8e 	M[rMAC + 656] = r0;
842015d4:	11 00       	rMAC = r0 + Null;
    num_io +=2;
842015d6:	89 20       	rMAC = rMAC + 2;
842015d8:	71 de       	M[FP + 56] = rMAC;

    /* Allocate buffer index array for easy setup */
    if(num_inputs<num_spkrs)
842015da:	49 d8       	rMAC = M[FP + 36];
842015dc:	1f fa 00 c2 	Null = r8 - rMAC;
842015e0:	02 f0 a9 e0 	if C jump (m) Lc_build_spkr_graph_23;

842015e4 <Lc_build_spkr_graph_20>:
    {
        idxs = create_default_indexes(num_io+num_spkrs);
842015e4:	72 d8       	r0 = M[FP + 56];
842015e6:	49 d8       	rMAC = M[FP + 36];
842015e8:	8a 00       	r0 = rMAC + r0;
842015ea:	ff fd ac f0 	call (m) 0x16f08;
842015ee:	3f e8 
842015f0:	52 de       	M[FP + 40] = r0;
842015f2:	10 6e       	jump (m) Lc_build_spkr_graph_24;

842015f4 <Lc_build_spkr_graph_21>:
                num_io++;
            }
            else
            {
                /* Resampler is multi channel */
                num_io += num_inputs;
842015f4:	71 d8       	rMAC = M[FP + 56];
842015f6:	51 0c       	rMAC = r8 + rMAC;
842015f8:	71 de       	M[FP + 56] = rMAC;
842015fa:	da 6f       	jump (m) Lc_build_spkr_graph_16;

842015fc <Lc_build_spkr_graph_22>:
    if(op_extra_data->spkr_rate_ability == RATEMATCHING_SUPPORT_SW
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
       /* not required if having access to external rate adjust op */
       && (0 == op_extra_data->spkr_ext_rate_adjust_op)
#endif
       )
842015fc:	41 d8       	rMAC = M[FP + 32];
842015fe:	11 f0 6f 88 	rMAC = M[rMAC + 444];
84201602:	48 24       	Null = rMAC - 1;
84201604:	d5 61       	if EQ jump (m) Lc_build_spkr_graph_16;

84201606 <Lc_19>:
84201606:	e3 6f       	jump (m) Lc_build_spkr_graph_19;

84201608 <Lc_build_spkr_graph_23>:
    {
        idxs = create_default_indexes(num_io+num_spkrs);
    }
    else
    {
        idxs = create_default_indexes(num_io);
84201608:	72 d8       	r0 = M[FP + 56];
8420160a:	ff fd ac f0 	call (m) 0x16f08;
8420160e:	3f e7 
84201610:	52 de       	M[FP + 40] = r0;

84201612 <Lc_build_spkr_graph_24>:
    }
    if(idxs == NULL)
84201612:	51 d8       	rMAC = M[FP + 40];
84201614:	12 60       	if EQ jump (m) Lc_build_spkr_graph_28;

84201616 <Lc_build_spkr_graph_25>:
    {
        return(FALSE);
    }

    /* Allocate num_io buffers in spkr graph */
    spkr_graph = cbops_alloc_graph(num_io);
84201616:	72 d8       	r0 = M[FP + 56];
84201618:	ff fd ab f0 	call (m) 0x16d76;
8420161c:	3f ea 
8420161e:	13 09       	r9 = r0 + Null;
    if(!spkr_graph)
84201620:	08 60       	if EQ jump (m) Lc_build_spkr_graph_27;

84201622 <Lc_build_spkr_graph_26>:
    {
        goto aFailed;
    }
    op_extra_data->spkr_graph = spkr_graph;
84201622:	41 d8       	rMAC = M[FP + 32];
84201624:	1b f0 72 8e 	M[rMAC + 456] = r9;
       Internal (after ref resample)    : scratch[num_inputs]
       REF OUT
    */

    /* Input, Output, and insert_op buffers */
    for(j=0,i=0,k=0;j<MAX_NUMBER_SPEAKERS;j++)
84201628:	07 00       	r5 = Null + Null;
8420162a:	00 09       	r6 = Null + Null;
8420162c:	06 00       	r4 = Null + Null;
8420162e:	0b 6e       	jump (m) Lc_build_spkr_graph_30;

84201630 <Lc_build_spkr_graph_27>:

    DEBUG_GRAPHS("AEC REFERENCE: Building speaker graph, Done!" );
    return TRUE;
  aFailed:
    DEBUG_GRAPHS("AEC REFERENCE: Building speaker graph, Failed!" );
    pfree(idxs);
84201630:	52 d8       	r0 = M[FP + 40];
84201632:	ff fd 1c f0 	call (m) 0x4f62;
84201636:	31 e9 

84201638 <Lc_build_spkr_graph_28>:
    {
        idxs = create_default_indexes(num_io);
    }
    if(idxs == NULL)
    {
        return(FALSE);
84201638:	02 00       	r0 = Null + Null;
8420163a:	0f f0 ad e6 	jump (m) Lc_build_spkr_graph_79;

8420163e <Lc_build_spkr_graph_29>:

    /* Input, Output, and insert_op buffers */
    for(j=0,i=0,k=0;j<MAX_NUMBER_SPEAKERS;j++)
    {
        /* Inputs may not be contiguous */
        buffer_ptr =  op_extra_data->input_stream[SpeakerInputTerminalByIndex(j)];
8420163e:	b0 24       	Null = r4 - 2;
84201640:	02 f0 89 e0 	if C jump (m) Lc_build_spkr_graph_31;

84201644 <Lc_build_spkr_graph_30>:
84201644:	32 00       	r0 = r4 + Null;
84201646:	02 6e       	jump (m) Lc_build_spkr_graph_32;

84201648 <Lc_build_spkr_graph_31>:
84201648:	32 21       	r0 = r4 + 4;

8420164a <Lc_build_spkr_graph_32>:
8420164a:	52 54       	r0 = r0 LSHIFT 2;
8420164c:	41 d8       	rMAC = M[FP + 32];
        if(buffer_ptr)
8420164e:	8d e8       	r3 = M[rMAC + r0];
84201650:	08 60       	if EQ jump (m) Lc_build_spkr_graph_34;

84201652 <Lc_build_spkr_graph_33>:
        {
            /* Inputs */
            cbops_set_input_io_buffer(spkr_graph,i,0,buffer_ptr);
84201652:	04 00       	r2 = Null + Null;
84201654:	3b 00       	r1 = r5 + Null;
84201656:	5a 08       	r0 = r9 + Null;
84201658:	ff fd ab f0 	call (m) 0x16e02;
8420165c:	2b ed 
            i++;
8420165e:	7f 20       	r5 = r5 + 1;

84201660 <Lc_build_spkr_graph_34>:
        }
        /* Outputs may not be contiguous */
        buffer_ptr =  op_extra_data->output_stream[SpeakerTerminalByIndex(j)];
84201660:	b0 24       	Null = r4 - 2;
84201662:	02 f0 89 e0 	if C jump (m) Lc_build_spkr_graph_36;

84201666 <Lc_build_spkr_graph_35>:
84201666:	72 20       	r0 = r4 + 1;
84201668:	02 6e       	jump (m) Lc_build_spkr_graph_37;

8420166a <Lc_build_spkr_graph_36>:
8420166a:	72 21       	r0 = r4 + 5;

8420166c <Lc_build_spkr_graph_37>:
8420166c:	41 d8       	rMAC = M[FP + 32];
8420166e:	52 54       	r0 = r0 LSHIFT 2;
84201670:	01 f0 40 44 	rMAC = rMAC + 64;
        if(buffer_ptr)
84201674:	8d e8       	r3 = M[rMAC + r0];
84201676:	09 60       	if EQ jump (m) Lc_build_spkr_graph_39;

84201678 <Lc_build_spkr_graph_38>:
        {
            cbops_set_output_io_buffer(spkr_graph,out_indx + k,out_indx,buffer_ptr);
84201678:	8f fa 03 c0 	r1 = r8 + r6;
8420167c:	54 08       	r2 = r8 + Null;
8420167e:	5a 08       	r0 = r9 + Null;
84201680:	ff fd ab f0 	call (m) 0x16e34;
84201684:	35 ed 
            k++;
84201686:	08 75       	r6 = r6 + 1;

84201688 <Lc_build_spkr_graph_39>:
       Internal (after ref resample)    : scratch[num_inputs]
       REF OUT
    */

    /* Input, Output, and insert_op buffers */
    for(j=0,i=0,k=0;j<MAX_NUMBER_SPEAKERS;j++)
84201688:	76 20       	r4 = r4 + 1;
8420168a:	30 26       	Null = r4 - 8;
8420168c:	d9 65       	if NC jump (m) Lc_build_spkr_graph_29;

8420168e <Lc_build_spkr_graph_40>:
        }
    }


    /* Buffers for transfer from inputs to interm buffers */
    for(i=0; i < num_inputs ; i++)
8420168e:	06 00       	r4 = Null + Null;
84201690:	41 d8       	rMAC = M[FP + 32];
84201692:	17 f0 84 20 	r5 = rMAC + 132;

84201696 <Lc_build_spkr_graph_41>:
84201696:	af f6 00 c2 	Null = r4 - r8;
8420169a:	02 f0 9b e0 	if C jump (m) Lc_build_spkr_graph_43;

8420169e <Lc_build_spkr_graph_42>:
    {
         cbops_set_internal_io_buffer(spkr_graph,
                                      intern_ins_idx + i,
                                      intern_ins_idx,
                                      op_extra_data->scratch_bufs[usable_scratch_idx + i]);
8420169e:	3d e8       	r3 = M[r5 + Null];
842016a0:	9f f6 03 c0 	r1 = r4 + r7;
842016a4:	4c 08       	r2 = r7 + Null;
842016a6:	5a 08       	r0 = r9 + Null;
842016a8:	ff fd ab f0 	call (m) 0x16e66;
842016ac:	3f ed 
        }
    }


    /* Buffers for transfer from inputs to interm buffers */
    for(i=0; i < num_inputs ; i++)
842016ae:	76 20       	r4 = r4 + 1;
842016b0:	3f 21       	r5 = r5 + 4;
842016b2:	f2 6f       	jump (m) Lc_build_spkr_graph_41;

842016b4 <Lc_build_spkr_graph_43>:
                                      intern_ins_idx + i,
                                      intern_ins_idx,
                                      op_extra_data->scratch_bufs[usable_scratch_idx + i]);
    }
    /* update usable_scratch_idx for next use */
    usable_scratch_idx = usable_scratch_idx==0? num_inputs:0;
842016b4:	ea f0 0f 8e 	M[FP + 60] = r8;
    /* Building override operator, this operator will transfer speaker
     * inputs to inerim buufers as well as any silence insertion required.
     * This way AEC_REFERERNCE will not write into its input buffer.
     */
    /* Thresholds for Insertion, keep a copy in main structure */
    op_extra_data->spkr_in_threshold  = frac_mult(op_extra_data->input_rate,op_extra_data->task_period_frac) + 1;
842016b8:	41 d8       	rMAC = M[FP + 32];
842016ba:	12 f0 64 88 	r0 = M[rMAC + 400];
842016be:	13 f0 93 88 	r1 = M[rMAC + 588];
842016c2:	00 f3 72 c9 	r0 = r0 * r1 (frac);
842016c6:	51 20       	rMAC = r0 + 1;
842016c8:	42 d8       	r0 = M[FP + 32];
842016ca:	21 f0 af 8e 	M[r0 + 700] = rMAC;
842016ce:	11 00       	rMAC = r0 + Null;
    op_extra_data->spkr_out_threshold = frac_mult(op_extra_data->spkr_rate,op_extra_data->task_period_frac) + 1;
842016d0:	12 f0 6e 88 	r0 = M[rMAC + 440];
842016d4:	13 f0 93 88 	r1 = M[rMAC + 588];
842016d8:	00 f3 72 c9 	r0 = r0 * r1 (frac);
842016dc:	51 20       	rMAC = r0 + 1;
842016de:	42 d8       	r0 = M[FP + 32];
842016e0:	21 f0 b0 8e 	M[r0 + 704] = rMAC;
842016e4:	11 00       	rMAC = r0 + Null;
     * task period there will be ~(spkr_out_threshold + max_jitter) in the output buffer,
     * this is to cover a full task period plus possible scheduling uncertainties.
     * 1ms max_jitter might be enough, 0.5ms added in case sidetone mixing will run
     * in decimated task period.
     */
    unsigned max_jitter = frac_mult(op_extra_data->spkr_rate, FRACTIONAL(0.0015));
842016e6:	12 f0 6e 88 	r0 = M[rMAC + 440];
842016ea:	03 f0 93 f0 	r1 = Null + 3221225;
842016ee:	e9 4a 
842016f0:	00 f3 72 c9 	r0 = r0 * r1 (frac);

    overrid_op_ptr = create_aec_ref_spkr_op(num_inputs,idxs,&idxs[intern_ins_idx],
                                            op_extra_data->spkr_in_threshold,
                                            num_spkrs,&idxs[out_indx],
                                            op_extra_data->spkr_out_threshold,
                                            max_jitter);
842016f4:	01 f9 d3 c8 	r1 = r7 LSHIFT 2;
842016f8:	e8 f0 0a 88 	r6 = M[FP + 40];
842016fc:	18 0d       	r6 = r1 + r6;
842016fe:	11 1c       	pushm <r0>;
84201700:	11 f0 b0 88 	rMAC = M[rMAC + 704];
84201704:	09 1c       	pushm <rMAC>;
84201706:	01 fa d2 c8 	r0 = r8 LSHIFT 2;
8420170a:	51 d8       	rMAC = M[FP + 40];
8420170c:	0b 00       	r1 = rMAC + Null;
8420170e:	51 00       	rMAC = r0 + rMAC;
84201710:	09 1c       	pushm <rMAC>;
84201712:	49 d8       	rMAC = M[FP + 36];
84201714:	09 1c       	pushm <rMAC>;
84201716:	41 d8       	rMAC = M[FP + 32];
84201718:	44 08       	r2 = r6 + Null;
8420171a:	15 f0 af 88 	r3 = M[rMAC + 700];
8420171e:	52 08       	r0 = r8 + Null;
84201720:	08 f0 33 e8 	call (m) $_create_aec_ref_spkr_op;
84201724:	7c 4c       	SP = SP + -16;
#if defined(IO_DEBUG)
    insert_op  = overrid_op_ptr;
84201726:	e0 f0 02 f0 	M[Null + $_insert_op] = r0;
8420172a:	5c 8e 
#endif
    if(!overrid_op_ptr)
8420172c:	10 04       	Null = r0 - Null;
8420172e:	81 61       	if EQ jump (m) Lc_build_spkr_graph_27;

84201730 <Lc_build_spkr_graph_44>:
    {
        goto aFailed;
    }

    cbops_set_override_operator(spkr_graph,overrid_op_ptr);
84201730:	13 00       	r1 = r0 + Null;
84201732:	5a 08       	r0 = r9 + Null;
84201734:	ff fd ab f0 	call (m) 0x16ec2;
84201738:	2f ec 

    /* DC remove before reference tap */
    op_ptr = create_dc_remove_op(num_inputs, &idxs[intern_ins_idx], &idxs[intern_ins_idx]);
8420173a:	44 08       	r2 = r6 + Null;
8420173c:	43 08       	r1 = r6 + Null;
8420173e:	52 08       	r0 = r8 + Null;
84201740:	ff fd 23 f1 	call (m) 0x25e40;
84201744:	21 e8 
84201746:	17 00       	r5 = r0 + Null;
    if(!op_ptr)
84201748:	74 61       	if EQ jump (m) Lc_build_spkr_graph_27;

8420174a <Lc_build_spkr_graph_45>:
    {
        goto aFailed;
    }
    cbops_append_operator_to_graph(spkr_graph,op_ptr);
8420174a:	3b 00       	r1 = r5 + Null;
8420174c:	5a 08       	r0 = r9 + Null;
8420174e:	ff fd ab f0 	call (m) 0x16e96;
84201752:	29 ea 


    /* Add Mixer to section #1 if needed*/
    if(num_inputs > num_spkrs)
84201754:	49 d8       	rMAC = M[FP + 36];
84201756:	1f fa 00 c2 	Null = r8 - rMAC;
8420175a:	09 f0 bb e0 	if LS jump (m) Lc_build_spkr_graph_51;

8420175e <Lc_build_spkr_graph_46>:
    {
        for(i=1;i<num_inputs;i++)
8420175e:	46 20       	r4 = Null + 1;

84201760 <Lc_build_spkr_graph_47>:
84201760:	af f6 00 c2 	Null = r4 - r8;
84201764:	02 f0 af e0 	if C jump (m) Lc_build_spkr_graph_50;

84201768 <Lc_build_spkr_graph_48>:
        {
            /* NOTE: left scratch input reused for output (inplace) */
            /*  - Add Mix Operator - stereo to mono (left = (left+right)/2 */
            op_ptr = create_mixer_op(intern_ins_idx, intern_ins_idx+i, intern_ins_idx, 0, FRACTIONAL(0.5));
84201768:	ff f3 ff ff 	push Null + 1073741823;
8420176c:	5f ef 
8420176e:	9f f6 03 c0 	r1 = r4 + r7;
84201772:	05 00       	r3 = Null + Null;
84201774:	4c 08       	r2 = r7 + Null;
84201776:	4a 08       	r0 = r7 + Null;
84201778:	ff fd 52 f1 	call (m) 0x2bcbc;
8420177c:	25 ea 
8420177e:	7f 4c       	SP = SP + -4;
84201780:	17 00       	r5 = r0 + Null;
            if(!op_ptr)
84201782:	57 61       	if EQ jump (m) Lc_build_spkr_graph_27;

84201784 <Lc_build_spkr_graph_49>:
            {
                goto aFailed;
            }
            cbops_append_operator_to_graph(spkr_graph,op_ptr);
84201784:	3b 00       	r1 = r5 + Null;
84201786:	5a 08       	r0 = r9 + Null;
84201788:	ff fd ab f0 	call (m) 0x16e96;
8420178c:	2f e8 


    /* Add Mixer to section #1 if needed*/
    if(num_inputs > num_spkrs)
    {
        for(i=1;i<num_inputs;i++)
8420178e:	76 20       	r4 = r4 + 1;
84201790:	e8 6f       	jump (m) Lc_build_spkr_graph_47;

84201792 <Lc_build_spkr_graph_50>:
                goto aFailed;
            }
            cbops_append_operator_to_graph(spkr_graph,op_ptr);
        }
        /* Input is now mono */
        num_inputs = 1;
84201792:	0a 71       	r8 = Null + 1;

84201794 <Lc_build_spkr_graph_51>:
    /* This is the point where we take input for the
     * reference sub-path, store information about
     * where in the graph the reference sub-path
     * should be inserted to.
     */
    op_extra_data->spkr_ref_input_idx = intern_ins_idx;
84201794:	41 d8       	rMAC = M[FP + 32];
84201796:	19 f0 a1 8e 	M[rMAC + 644] = r7;
    op_extra_data->spkr_ref_point_op = op_ptr;
8420179a:	17 f0 a8 8e 	M[rMAC + 672] = r5;
    op_extra_data->spkr_ref_scratch_idx = usable_scratch_idx;
8420179e:	7a d8       	r0 = M[FP + 60];
842017a0:	12 f0 a2 8e 	M[rMAC + 648] = r0;

    /* Add sample rate conversion per channel [num_inputs] (input_rate --> spkr_rate) */
    if(intern_rs_idx!=0)
842017a4:	61 d8       	rMAC = M[FP + 48];
842017a6:	4b 60       	if EQ jump (m) Lc_build_spkr_graph_61;

842017a8 <Lc_build_spkr_graph_52>:
    {
        int shift_amount = op_extra_data->spkr_shift;
842017a8:	41 d8       	rMAC = M[FP + 32];
842017aa:	11 f0 74 88 	rMAC = M[rMAC + 464];

        if(intern_rs_idx!=out_indx)
842017ae:	63 d8       	r1 = M[FP + 48];
842017b0:	5a d8       	r0 = M[FP + 44];
842017b2:	98 04       	Null = r1 - r0;
842017b4:	1e 60       	if EQ jump (m) Lc_build_spkr_graph_59;

842017b6 <Lc_build_spkr_graph_53>:
        {
            /* Buffers for output of resampler. */
            for(i=0; i < num_inputs ; i++)
842017b6:	06 00       	r4 = Null + Null;
842017b8:	7a d8       	r0 = M[FP + 60];
842017ba:	41 d8       	rMAC = M[FP + 32];
842017bc:	52 54       	r0 = r0 LSHIFT 2;
842017be:	51 00       	rMAC = r0 + rMAC;
842017c0:	17 f0 84 20 	r5 = rMAC + 132;

842017c4 <Lc_build_spkr_graph_54>:
842017c4:	af f6 00 c2 	Null = r4 - r8;
842017c8:	02 f0 9b e0 	if C jump (m) Lc_build_spkr_graph_56;

842017cc <Lc_build_spkr_graph_55>:
            {
                cbops_set_internal_io_buffer(spkr_graph,intern_rs_idx+i,intern_rs_idx,
                                             op_extra_data->scratch_bufs[usable_scratch_idx+i]);
842017cc:	3d e8       	r3 = M[r5 + Null];
842017ce:	61 d8       	rMAC = M[FP + 48];
842017d0:	0c 00       	r2 = rMAC + Null;
842017d2:	73 00       	r1 = r4 + rMAC;
842017d4:	5a 08       	r0 = r9 + Null;
842017d6:	ff fd ab f0 	call (m) 0x16e66;
842017da:	31 e4 
        int shift_amount = op_extra_data->spkr_shift;

        if(intern_rs_idx!=out_indx)
        {
            /* Buffers for output of resampler. */
            for(i=0; i < num_inputs ; i++)
842017dc:	76 20       	r4 = r4 + 1;
842017de:	3f 21       	r5 = r5 + 4;
842017e0:	f2 6f       	jump (m) Lc_build_spkr_graph_54;

842017e2 <Lc_build_spkr_graph_56>:
            {
                cbops_set_internal_io_buffer(spkr_graph,intern_rs_idx+i,intern_rs_idx,
                                             op_extra_data->scratch_bufs[usable_scratch_idx+i]);
            }
            shift_amount=0;
842017e2:	01 00       	rMAC = Null + Null;
            /* update usable_scratch_idx for next use */
            usable_scratch_idx = usable_scratch_idx==0?num_inputs:0;
842017e4:	7a d8       	r0 = M[FP + 60];
842017e6:	04 62       	if NE jump (m) Lc_build_spkr_graph_58;

842017e8 <Lc_build_spkr_graph_57>:
842017e8:	ea f0 0f 8e 	M[FP + 60] = r8;
842017ec:	02 6e       	jump (m) Lc_build_spkr_graph_59;

842017ee <Lc_build_spkr_graph_58>:
842017ee:	78 de       	M[FP + 60] = Null;

842017f0 <Lc_build_spkr_graph_59>:
        }

        op_ptr = create_iir_resamplerv2_op(num_inputs, &idxs[intern_ins_idx], &idxs[intern_rs_idx],
                                           op_extra_data->input_rate, op_extra_data->spkr_rate,
                                           op_extra_data->resampler_temp_buffer_size,
                                           op_extra_data->resampler_temp_buffer, shift_amount, 0, 0);
842017f0:	00 f0 30 cf 	push Null;
842017f4:	00 f0 30 cf 	push Null;
842017f8:	09 1c       	pushm <rMAC>;
842017fa:	41 d8       	rMAC = M[FP + 32];
842017fc:	11 f0 32 88 	rMAC = M[rMAC + 200];
84201800:	09 1c       	pushm <rMAC>;
84201802:	41 d8       	rMAC = M[FP + 32];
84201804:	11 f0 91 88 	rMAC = M[rMAC + 580];
84201808:	09 1c       	pushm <rMAC>;
8420180a:	41 d8       	rMAC = M[FP + 32];
8420180c:	11 f0 6e 88 	rMAC = M[rMAC + 440];
84201810:	09 1c       	pushm <rMAC>;
84201812:	41 d8       	rMAC = M[FP + 32];
84201814:	62 d8       	r0 = M[FP + 48];
84201816:	54 d8       	r2 = M[FP + 40];
84201818:	43 08       	r1 = r6 + Null;
8420181a:	15 f0 64 88 	r3 = M[rMAC + 400];
8420181e:	52 54       	r0 = r0 LSHIFT 2;
84201820:	14 01       	r2 = r0 + r2;
84201822:	52 08       	r0 = r8 + Null;
84201824:	0b f0 23 e1 	call (m) $_create_iir_resamplerv2_op;
84201828:	7a 4c       	SP = SP + -24;
8420182a:	17 00       	r5 = r0 + Null;
        if(!op_ptr)
8420182c:	02 61       	if EQ jump (m) Lc_build_spkr_graph_27;

8420182e <Lc_build_spkr_graph_60>:
        {
            goto aFailed;
        }
        cbops_append_operator_to_graph(spkr_graph,op_ptr);
8420182e:	3b 00       	r1 = r5 + Null;
84201830:	5a 08       	r0 = r9 + Null;
84201832:	ff fd ab f0 	call (m) 0x16e96;
84201836:	25 e3 

        /* Move next input to output of resampler */
        intern_ins_idx = intern_rs_idx;
84201838:	e9 f0 0c 88 	r7 = M[FP + 48];

8420183c <Lc_build_spkr_graph_61>:
    /* This is the point where we insert possible sidetone
     * mix operator, store both the operator and the input
     * buffer index for the operator. Sidetone mixing
     * will always be done in-place.
     */
    op_extra_data->spkr_st_point_op = op_ptr;
8420183c:	41 d8       	rMAC = M[FP + 32];
8420183e:	17 f0 a9 8e 	M[rMAC + 676] = r5;
    op_extra_data->spkr_stmix_in_idx = intern_ins_idx;
84201842:	19 f0 a3 8e 	M[rMAC + 652] = r7;

    /* Optional section for SW rate matching */
    if(intern_rm_idx != 0)
84201846:	69 d8       	rMAC = M[FP + 52];
84201848:	47 60       	if EQ jump (m) Lc_build_spkr_graph_69;

8420184a <Lc_build_spkr_graph_62>:
    {
        int shift_amount =  op_extra_data->spkr_shift;
8420184a:	41 d8       	rMAC = M[FP + 32];
8420184c:	11 f0 74 88 	rMAC = M[rMAC + 464];

        if(intern_rm_idx!=out_indx)
84201850:	6b d8       	r1 = M[FP + 52];
84201852:	5a d8       	r0 = M[FP + 44];
84201854:	98 04       	Null = r1 - r0;
84201856:	18 60       	if EQ jump (m) Lc_build_spkr_graph_67;

84201858 <Lc_build_spkr_graph_63>:
        {
            /* Buffers for output of ratematch if it exists */
            for(i=0; i < num_inputs; i++)
84201858:	06 00       	r4 = Null + Null;
8420185a:	7a d8       	r0 = M[FP + 60];
8420185c:	41 d8       	rMAC = M[FP + 32];
8420185e:	52 54       	r0 = r0 LSHIFT 2;
84201860:	51 00       	rMAC = r0 + rMAC;
84201862:	17 f0 84 20 	r5 = rMAC + 132;

84201866 <Lc_build_spkr_graph_64>:
84201866:	af f6 00 c2 	Null = r4 - r8;
8420186a:	02 f0 9b e0 	if C jump (m) Lc_build_spkr_graph_66;

8420186e <Lc_build_spkr_graph_65>:
            {
                cbops_set_internal_io_buffer(spkr_graph,intern_rm_idx+i,intern_rm_idx,
                                             op_extra_data->scratch_bufs[usable_scratch_idx+i]);
8420186e:	3d e8       	r3 = M[r5 + Null];
84201870:	69 d8       	rMAC = M[FP + 52];
84201872:	0c 00       	r2 = rMAC + Null;
84201874:	73 00       	r1 = r4 + rMAC;
84201876:	5a 08       	r0 = r9 + Null;
84201878:	ff fd aa f0 	call (m) 0x16e66;
8420187c:	2f ef 
        int shift_amount =  op_extra_data->spkr_shift;

        if(intern_rm_idx!=out_indx)
        {
            /* Buffers for output of ratematch if it exists */
            for(i=0; i < num_inputs; i++)
8420187e:	76 20       	r4 = r4 + 1;
84201880:	3f 21       	r5 = r5 + 4;
84201882:	f2 6f       	jump (m) Lc_build_spkr_graph_64;

84201884 <Lc_build_spkr_graph_66>:
            {
                cbops_set_internal_io_buffer(spkr_graph,intern_rm_idx+i,intern_rm_idx,
                                             op_extra_data->scratch_bufs[usable_scratch_idx+i]);
            }
            shift_amount=0;
84201884:	01 00       	rMAC = Null + Null;

84201886 <Lc_build_spkr_graph_67>:
        }

        /*  SW rate adjustment per channel [num_inputs] */
        op_ptr = create_sw_rate_adj_op(num_inputs, &idxs[intern_ins_idx], &idxs[intern_rm_idx],
                                       CBOPS_RATEADJUST_COEFFS,
                                       &op_extra_data->spkr_rate_adjustment,shift_amount);
84201886:	09 1c       	pushm <rMAC>;
84201888:	41 d8       	rMAC = M[FP + 32];
8420188a:	85 2a       	r3 = Null + 26;
8420188c:	01 f0 c0 ff 	push rMAC + 448;
84201890:	11 cf 
84201892:	6a d8       	r0 = M[FP + 52];
84201894:	54 d8       	r2 = M[FP + 40];
84201896:	52 54       	r0 = r0 LSHIFT 2;
84201898:	23 00       	r1 = r2 + Null;
8420189a:	14 01       	r2 = r0 + r2;
8420189c:	01 f9 d2 c8 	r0 = r7 LSHIFT 2;
842018a0:	d3 00       	r1 = r0 + r1;
842018a2:	52 08       	r0 = r8 + Null;
842018a4:	ff fd a9 f0 	call (m) 0x16bea;
842018a8:	27 ea 
842018aa:	7e 4c       	SP = SP + -8;
842018ac:	16 00       	r4 = r0 + Null;
        if(!op_ptr)
842018ae:	f0 ff 83 eb 	if EQ jump (m) Lc_build_spkr_graph_27;

842018b2 <Lc_build_spkr_graph_68>:
        {
            goto aFailed;
        }

        op_extra_data->spkr_sw_rateadj_op=op_ptr;
842018b2:	41 d8       	rMAC = M[FP + 32];
842018b4:	16 f0 7e 8e 	M[rMAC + 504] = r4;
        cbops_rateadjust_passthrough_mode(op_ptr,(op_extra_data->spkr_rate_enactment==RATEMATCHING_SUPPORT_NONE)?TRUE:FALSE);
842018b8:	03 00       	r1 = Null + Null;
842018ba:	10 f0 71 88 	Null = M[rMAC + 452];
842018be:	20 f0 43 ce 	if EQ r1 = Null + 1;
842018c2:	ff fd a9 f0 	call (m) 0x16c96;
842018c6:	35 ee 

        cbops_append_operator_to_graph(spkr_graph,op_ptr);
842018c8:	33 00       	r1 = r4 + Null;
842018ca:	5a 08       	r0 = r9 + Null;
842018cc:	ff fd aa f0 	call (m) 0x16e96;
842018d0:	2b ee 

        /* Move next input to output of ratematch */
        intern_ins_idx = intern_rm_idx;
842018d2:	e9 f0 0d 88 	r7 = M[FP + 52];

842018d6 <Lc_build_spkr_graph_69>:
    }


    /* Did previous operator terminate route? */
    if(intern_ins_idx!=out_indx)
842018d6:	59 d8       	rMAC = M[FP + 44];
842018d8:	1f f9 00 c2 	Null = r7 - rMAC;
842018dc:	2a 60       	if EQ jump (m) Lc_build_spkr_graph_76;

842018de <Lc_build_spkr_graph_70>:
    {
        /* Check for Mono to multi-channel */
        if(num_inputs<num_spkrs)
842018de:	49 d8       	rMAC = M[FP + 36];
842018e0:	1f fa 00 c2 	Null = r8 - rMAC;
842018e4:	02 f0 9f e0 	if C jump (m) Lc_build_spkr_graph_74;

842018e8 <Lc_build_spkr_graph_71>:
        {
            for(i=0; i < num_spkrs; i++)
842018e8:	01 00       	rMAC = Null + Null;
842018ea:	72 d8       	r0 = M[FP + 56];
842018ec:	51 d8       	rMAC = M[FP + 40];
842018ee:	52 54       	r0 = r0 LSHIFT 2;
842018f0:	51 00       	rMAC = r0 + rMAC;
842018f2:	4a d8       	r0 = M[FP + 36];
842018f4:	14 09       	r10 = r0 + Null;
842018f6:	04 4c       	do (m) Lc__loop0;

842018f8 <Lc_build_spkr_graph_72>:
            {
                idxs[num_io+i] = intern_ins_idx;
842018f8:	19 f0 00 ee 	M[rMAC + Null] = r7;
842018fc:	09 21       	rMAC = rMAC + 4;

842018fe <Lc__loop0>:
    if(intern_ins_idx!=out_indx)
    {
        /* Check for Mono to multi-channel */
        if(num_inputs<num_spkrs)
        {
            for(i=0; i < num_spkrs; i++)
842018fe:	e9 f0 0e 88 	r7 = M[FP + 56];

84201902 <Lc_build_spkr_graph_74>:
                idxs[num_io+i] = intern_ins_idx;
            }
            intern_ins_idx = num_io;
        }

        op_ptr = create_shift_op(num_spkrs, &idxs[intern_ins_idx], &idxs[out_indx], op_extra_data->spkr_shift);
84201902:	41 d8       	rMAC = M[FP + 32];
84201904:	5a d8       	r0 = M[FP + 44];
84201906:	54 d8       	r2 = M[FP + 40];
84201908:	15 f0 74 88 	r3 = M[rMAC + 464];
8420190c:	52 54       	r0 = r0 LSHIFT 2;
8420190e:	23 00       	r1 = r2 + Null;
84201910:	14 01       	r2 = r0 + r2;
84201912:	01 f9 d2 c8 	r0 = r7 LSHIFT 2;
84201916:	d3 00       	r1 = r0 + r1;
84201918:	4a d8       	r0 = M[FP + 36];
8420191a:	ff fd 22 f1 	call (m) 0x25e08;
8420191e:	2f e7 
        if(!op_ptr)
84201920:	10 04       	Null = r0 - Null;
84201922:	f0 ff 8f ea 	if EQ jump (m) Lc_build_spkr_graph_27;

84201926 <Lc_build_spkr_graph_75>:
        {
            goto aFailed;
        }
        cbops_append_operator_to_graph(spkr_graph,op_ptr);
84201926:	13 00       	r1 = r0 + Null;
84201928:	5a 08       	r0 = r9 + Null;
8420192a:	ff fd aa f0 	call (m) 0x16e96;
8420192e:	2d eb 

84201930 <Lc_build_spkr_graph_76>:
    }

    op_extra_data->spkr_rate_adjustment=0;
84201930:	41 d8       	rMAC = M[FP + 32];
84201932:	10 f0 70 8e 	M[rMAC + 448] = Null;

    /* create rate monitor op if required */
    op_ptr = NULL;
    if(op_extra_data->spkr_rate_ability == RATEMATCHING_SUPPORT_HW)
84201936:	11 f0 6f 88 	rMAC = M[rMAC + 444];
8420193a:	88 24       	Null = rMAC - 2;
8420193c:	f1 ff a3 e7 	if NE jump (m) Lc_build_spkr_graph_5;

84201940 <Lc_build_spkr_graph_77>:
    {
        /* With HW rate adjustmen we always need rate monitor */
        op_ptr = create_rate_monitor_operator(op_extra_data->task_frequency, out_indx);
84201940:	41 d8       	rMAC = M[FP + 32];
84201942:	12 f0 92 88 	r0 = M[rMAC + 584];
84201946:	5b d8       	r1 = M[FP + 44];
84201948:	0a f0 33 e3 	call (m) $_create_rate_monitor_operator;
8420194c:	16 00       	r4 = r0 + Null;
        if(!op_ptr)
8420194e:	f0 ff e3 e9 	if EQ jump (m) Lc_build_spkr_graph_27;

84201952 <Lc_build_spkr_graph_78>:
        {
            goto aFailed;
        }
        rate_monitor_op_initialise(op_ptr,op_extra_data->spkr_rate, TRUE, 3*MS_PER_SEC);
84201952:	05 f0 b8 53 	r3 = Null + 3000;
84201956:	44 20       	r2 = Null + 1;
84201958:	41 d8       	rMAC = M[FP + 32];
8420195a:	13 f0 6e 88 	r1 = M[rMAC + 440];
8420195e:	f3 ff 3e e5 	call $_rate_monitor_op_initialise;
84201962:	ff ff ad e7 	jump (m) Lc_build_spkr_graph_8;

84201966 <Lc_build_spkr_graph_79>:
    return TRUE;
  aFailed:
    DEBUG_GRAPHS("AEC REFERENCE: Building speaker graph, Failed!" );
    pfree(idxs);
    return FALSE;
}
84201966:	f6 4a       	SP = SP - 0x20, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84201968:	d8 4c       	rts;

8420196a <$_validate_channels_and_build>:
 *        paths and rebuild the cbops graphs for each path when needed.
 *
 * \param op_data Pointer to the AEC reference operator data.
 */
bool validate_channels_and_build(OPERATOR_DATA *op_data)
{
8420196a:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
8420196c:	12 09       	r8 = r0 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
8420196e:	a6 f0 0c 88 	r4 = M[r8 + 48];
bool validate_channels_and_build(OPERATOR_DATA *op_data)
{
    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);

    /* check changes in speaker, microphone and reference paths */
    bool spkr_changed = aec_reference_update_spkr_channel_status(op_extra_data);
84201972:	32 00       	r0 = r4 + Null;
84201974:	ce 4e       	call (m) $_aec_reference_update_spkr_channel_status;
84201976:	17 00       	r5 = r0 + Null;
    bool mic_changed = aec_reference_update_mic_channel_status(op_extra_data);
84201978:	32 00       	r0 = r4 + Null;
8420197a:	50 4e       	call (m) $_aec_reference_update_mic_channel_status;
8420197c:	10 09       	r6 = r0 + Null;
    bool ref_changed = aec_reference_update_ref_channel_status(op_extra_data);
8420197e:	32 00       	r0 = r4 + Null;
84201980:	01 f0 3f e2 	call (m) $_aec_reference_update_ref_channel_status;
84201984:	11 09       	r7 = r0 + Null;


    patch_fn_shared(aec_reference);

    /* update sidetone method */
    aec_reference_update_sidetone_method(op_extra_data);
84201986:	32 00       	r0 = r4 + Null;
84201988:	01 f0 31 e4 	call (m) $_aec_reference_update_sidetone_method;

    /* rebuild graphs if there is change in
     * speaker or microphone path
     */
    if(!aec_reference_build_graphs(op_extra_data, spkr_changed, mic_changed))
8420198c:	44 08       	r2 = r6 + Null;
8420198e:	3b 00       	r1 = r5 + Null;
84201990:	32 00       	r0 = r4 + Null;
84201992:	01 f0 37 e5 	call (m) $_aec_reference_build_graphs;
84201996:	10 04       	Null = r0 - Null;
84201998:	3b 60       	if EQ jump (m) Lc_validate_channels_and_build_13;

8420199a <Lc_validate_channels_and_build_2>:
    }

    /* also if there is changes in reference path, then
     * apply that change to speaker graph
     */
    if(ref_changed || spkr_changed)
8420199a:	0f f9 00 c2 	Null = r7 - Null;
8420199e:	03 62       	if NE jump (m) Lc_validate_channels_and_build_4;

842019a0 <Lc_validate_channels_and_build_3>:
842019a0:	38 04       	Null = r5 - Null;
842019a2:	0a 60       	if EQ jump (m) Lc_validate_channels_and_build_5;

842019a4 <Lc_validate_channels_and_build_4>:
    {
        if(!aec_reference_spkr_include_ref_path(op_extra_data, GetRefChannelStatus(op_extra_data)))
842019a4:	61 f0 76 88 	rMAC = M[r4 + 472];
842019a8:	13 f2 00 00 	r1 = rMAC AND 0x4000;
842019ac:	32 00       	r0 = r4 + Null;
842019ae:	03 f0 33 e9 	call (m) $_aec_reference_spkr_include_ref_path;
842019b2:	10 04       	Null = r0 - Null;
842019b4:	2d 60       	if EQ jump (m) Lc_validate_channels_and_build_13;

842019b6 <Lc_validate_channels_and_build_5>:
            goto aFailed;
        }
    }

    if(op_extra_data->mic_graph != NULL ||
       op_extra_data->spkr_graph!= NULL)
842019b6:	61 f0 6a 88 	rMAC = M[r4 + 424];
842019ba:	04 62       	if NE jump (m) Lc_validate_channels_and_build_7;

842019bc <Lc_validate_channels_and_build_6>:
842019bc:	61 f0 72 88 	rMAC = M[r4 + 456];
842019c0:	16 60       	if EQ jump (m) Lc_validate_channels_and_build_10;

842019c2 <Lc_validate_channels_and_build_7>:
    {
        /* start running the graphs if not already running
         */
        if(op_extra_data->kick_id == TIMER_ID_INVALID)
842019c2:	60 f0 5d 88 	Null = M[r4 + 372];
842019c6:	11 62       	if NE jump (m) Lc_validate_channels_and_build_9;

842019c8 <Lc_validate_channels_and_build_8>:
        {
            op_extra_data->kick_id = timer_schedule_event_in(op_extra_data->kick_period, aec_reference_timer_task,(void*)op_data);
842019c8:	42 f0 07 f0 	r5 = Null + 69207689;
842019cc:	89 4a 
842019ce:	68 f0 94 88 	r6 = M[r4 + 592];
        INTERVAL time_in,
        tTimerEventFunction TimerEventFunction,
        void *data_pointer)
{
    return create_add_strict_event(
            time_add(hal_get_time(), time_in), TimerEventFunction, data_pointer);
842019d2:	ff fd 7f f1 	call (m) 0x317e8;
842019d6:	37 e0 
842019d8:	42 0c       	r0 = r6 + r0;
842019da:	54 08       	r2 = r8 + Null;
842019dc:	3b 00       	r1 = r5 + Null;
842019de:	ff fd 93 f0 	call (m) 0x1402a;
842019e2:	2d e2 
}
842019e4:	62 f0 5d 8e 	M[r4 + 372] = r0;

842019e8 <Lc_validate_channels_and_build_9>:
    else
    {
        timer_cancel_event_atomic(&op_extra_data->kick_id);
    }

    return TRUE;
842019e8:	42 20       	r0 = Null + 1;
842019ea:	16 6e       	jump (m) Lc_validate_channels_and_build_14;

842019ec <Lc_validate_channels_and_build_10>:
            op_extra_data->kick_id = timer_schedule_event_in(op_extra_data->kick_period, aec_reference_timer_task,(void*)op_data);
        }
    }
    else
    {
        timer_cancel_event_atomic(&op_extra_data->kick_id);
842019ec:	06 f0 74 45 	r4 = r4 + 372;
                    ((void)timer_cancel_event_ret(timer_id, NULL, NULL))


INLINE_SECTION static inline void timer_cancel_event_atomic(tTimerId *timer_id)
{
    interrupt_block();
842019f0:	ff fd 59 f1 	call (m) 0x2cc9c;
842019f4:	2d e5 
    if (*timer_id != TIMER_ID_INVALID)
842019f6:	32 e8       	r0 = M[r4 + Null];
842019f8:	07 60       	if EQ jump (m) Lc_validate_channels_and_build_12;

842019fa <Lc_validate_channels_and_build_11>:
    {
        (void) timer_cancel_event_ret(*timer_id, NULL, NULL);
842019fa:	04 00       	r2 = Null + Null;
842019fc:	03 00       	r1 = Null + Null;
842019fe:	ff fd 93 f0 	call (m) 0x141bc;
84201a02:	3f ed 
        *timer_id = TIMER_ID_INVALID;
84201a04:	30 ee       	M[r4 + Null] = Null;

84201a06 <Lc_validate_channels_and_build_12>:
    }
    interrupt_unblock();
84201a06:	ff fd 59 f1 	call (m) 0x2ccb8;
84201a0a:	33 e5 
84201a0c:	ee 6f       	jump (m) Lc_validate_channels_and_build_9;

84201a0e <Lc_validate_channels_and_build_13>:

  aFailed:
    /* it failed to complete the build for some reason,
     * clean up all the graphs.
     */
    aec_reference_cleanup(op_data);
84201a0e:	52 08       	r0 = r8 + Null;
84201a10:	fc ff 31 e2 	call (m) $_aec_reference_cleanup;
    return FALSE;
84201a14:	02 00       	r0 = Null + Null;

84201a16 <Lc_validate_channels_and_build_14>:
}
84201a16:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84201a18:	d8 4c       	rts;

84201a1a <$_aec_reference_update_mic_channel_status>:
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 * \return whether there is a change in speaker channel status that requires
 *         rebuilding of the speaker graph.
 */
bool aec_reference_update_mic_channel_status(AEC_REFERENCE_OP_DATA *op_extra_data)
{
84201a1a:	72 1c       	pushm <FP(=SP), r4, r5>;
    patch_fn_shared(aec_reference);
    unsigned i;
    unsigned mic_channel_status=0;
84201a1c:	03 00       	r1 = Null + Null;
    unsigned number_mics=0;
84201a1e:	04 00       	r2 = Null + Null;
    tCbuffer *inputBuf,*outputBuf;

    patch_fn_shared(aec_reference);

    /* Microphones are connected */
    op_extra_data->source_kicks = 0;
84201a20:	20 f0 7b 8e 	M[r0 + 492] = Null;
    if(op_extra_data->input_stream[AEC_REF_MIC_TERMINAL1] && op_extra_data->output_stream[AEC_REF_OUTPUT_TERMINAL1])
84201a24:	91 88       	rMAC = M[r0 + 8];
84201a26:	3c 60       	if EQ jump (m) Lc_aec_reference_update_mic_channel_status_17;

84201a28 <Lc_aec_reference_update_mic_channel_status_2>:
84201a28:	d1 a8       	rMAC = M[r0 + 76];
84201a2a:	3a 60       	if EQ jump (m) Lc_aec_reference_update_mic_channel_status_17;

84201a2c <Lc_aec_reference_update_mic_channel_status_3>:
    {
        bool all_mic_channels = TRUE;
        for(i=0;i<MAX_NUMBER_MICS;i++)
84201a2c:	01 00       	rMAC = Null + Null;
84201a2e:	04 6e       	jump (m) Lc_aec_reference_update_mic_channel_status_5;

84201a30 <Lc_aec_reference_update_mic_channel_status_4>:
}


inline static unsigned MicrophoneTerminalByIndex(unsigned i)
{
    if(i<4)
84201a30:	08 25       	Null = rMAC - 4;
84201a32:	02 f0 8f e0 	if C jump (m) Lc_aec_reference_update_mic_channel_status_6;

84201a36 <Lc_aec_reference_update_mic_channel_status_5>:
    {
        return (i + AEC_REF_MIC_TERMINAL1);
84201a36:	8d 20       	r3 = rMAC + 2;
        {
            inputBuf  = op_extra_data->input_stream[MicrophoneTerminalByIndex(i)];
84201a38:	6d 54       	r3 = r3 LSHIFT 2;
84201a3a:	56 e9       	r4 = M[r0 + r3];

inline static unsigned OutputTerminalByIndex(unsigned i)
{
    if(i<4)
    {
        return (i + AEC_REF_OUTPUT_TERMINAL1);
84201a3c:	cd 20       	r3 = rMAC + 3;
84201a3e:	05 6e       	jump (m) Lc_aec_reference_update_mic_channel_status_7;

84201a40 <Lc_aec_reference_update_mic_channel_status_6>:
    {
        return (i + AEC_REF_MIC_TERMINAL1);
    }
    else
    {
        return ((i-4)+ AEC_REF_MIC_TERMINAL5);
84201a40:	0d 22       	r3 = rMAC + 8;
84201a42:	6d 54       	r3 = r3 LSHIFT 2;
84201a44:	56 e9       	r4 = M[r0 + r3];
    {
        return (i + AEC_REF_OUTPUT_TERMINAL1);
    }
    else
    {
        return ((i-4) + AEC_REF_OUTPUT_TERMINAL5);
84201a46:	4d 22       	r3 = rMAC + 9;

84201a48 <Lc_aec_reference_update_mic_channel_status_7>:
            outputBuf = op_extra_data->output_stream[OutputTerminalByIndex(i)];
84201a48:	27 f0 40 20 	r5 = r0 + 64;
84201a4c:	6d 54       	r3 = r3 LSHIFT 2;
84201a4e:	7d e9       	r3 = M[r5 + r3];

            if(inputBuf && outputBuf)
84201a50:	30 04       	Null = r4 - Null;
84201a52:	20 60       	if EQ jump (m) Lc_aec_reference_update_mic_channel_status_15;

84201a54 <Lc_aec_reference_update_mic_channel_status_8>:
84201a54:	28 04       	Null = r3 - Null;
84201a56:	20 60       	if EQ jump (m) Lc_aec_reference_update_mic_channel_status_16;

84201a58 <Lc_aec_reference_update_mic_channel_status_9>:
            {
                number_mics++;
84201a58:	64 20       	r2 = r2 + 1;

                if(i<4)
84201a5a:	08 25       	Null = rMAC - 4;
84201a5c:	02 f0 a9 e0 	if C jump (m) Lc_aec_reference_update_mic_channel_status_14;

84201a60 <Lc_aec_reference_update_mic_channel_status_10>:
                {
                    mic_channel_status |= (AEC_REFERENCE_CONSTANT_CONN_MIKE_1<<i);
84201a60:	0d 00       	r3 = rMAC + Null;
84201a62:	00 f5 95 de 	r3 = 0x1 LSHIFT r3;
84201a66:	5b 13       	r1 = r1 OR r3;

inline static unsigned OutputTerminalByIndex(unsigned i)
{
    if(i<4)
    {
        return (i + AEC_REF_OUTPUT_TERMINAL1);
84201a68:	cd 20       	r3 = rMAC + 3;

84201a6a <Lc_aec_reference_update_mic_channel_status_11>:
                }
                else
                {
                    mic_channel_status |= ((AEC_REFERENCE_CONSTANT_CONN_MIKE_5>>4)<<i);
                }
                op_extra_data->source_kicks |= (1 << OutputTerminalByIndex(i) );
84201a6a:	00 f5 95 de 	r3 = 0x1 LSHIFT r3;
84201a6e:	26 f0 7b 88 	r4 = M[r0 + 492];
84201a72:	ad 13       	r3 = r3 OR r4;
84201a74:	25 f0 7b 8e 	M[r0 + 492] = r3;

84201a78 <Lc_aec_reference_update_mic_channel_status_12>:
    /* Microphones are connected */
    op_extra_data->source_kicks = 0;
    if(op_extra_data->input_stream[AEC_REF_MIC_TERMINAL1] && op_extra_data->output_stream[AEC_REF_OUTPUT_TERMINAL1])
    {
        bool all_mic_channels = TRUE;
        for(i=0;i<MAX_NUMBER_MICS;i++)
84201a78:	49 20       	rMAC = rMAC + 1;
84201a7a:	08 26       	Null = rMAC - 8;
84201a7c:	da 65       	if NC jump (m) Lc_aec_reference_update_mic_channel_status_4;

84201a7e <Lc_aec_reference_update_mic_channel_status_13>:
            mic_channel_status = 0;
            op_extra_data->source_kicks = 0;
        }
    }

    if(mic_channel_status == 0)
84201a7e:	18 04       	Null = r1 - Null;
84201a80:	0f 60       	if EQ jump (m) Lc_aec_reference_update_mic_channel_status_17;

84201a82 <Lc_20>:
84201a82:	33 6e       	jump (m) Lc_aec_reference_update_mic_channel_status_27;

84201a84 <Lc_aec_reference_update_mic_channel_status_14>:
                {
                    mic_channel_status |= (AEC_REFERENCE_CONSTANT_CONN_MIKE_1<<i);
                }
                else
                {
                    mic_channel_status |= ((AEC_REFERENCE_CONSTANT_CONN_MIKE_5>>4)<<i);
84201a84:	0d 00       	r3 = rMAC + Null;
84201a86:	10 f0 00 f5 	r3 = 0x1000 LSHIFT r3;
84201a8a:	95 ce 
84201a8c:	5b 13       	r1 = r1 OR r3;
    }
    else
    {
        return ((i-4) + AEC_REF_OUTPUT_TERMINAL5);
84201a8e:	4d 22       	r3 = rMAC + 9;
84201a90:	ed 6f       	jump (m) Lc_aec_reference_update_mic_channel_status_11;

84201a92 <Lc_aec_reference_update_mic_channel_status_15>:
                }
                op_extra_data->source_kicks |= (1 << OutputTerminalByIndex(i) );
            }
            else if(inputBuf || outputBuf)
84201a92:	28 04       	Null = r3 - Null;
84201a94:	f2 61       	if EQ jump (m) Lc_aec_reference_update_mic_channel_status_12;

84201a96 <Lc_aec_reference_update_mic_channel_status_16>:
                break;
            }
        }
        if(!all_mic_channels)
        {
            number_mics=0;
84201a96:	04 00       	r2 = Null + Null;
            mic_channel_status = 0;
84201a98:	03 00       	r1 = Null + Null;
            op_extra_data->source_kicks = 0;
84201a9a:	20 f0 7b 8e 	M[r0 + 492] = Null;

84201a9e <Lc_aec_reference_update_mic_channel_status_17>:
        /* we cannot form N->N mic path, see if we
         * can form 1->0 mic path, the latter would enable
         * supporting sidetone without microphone output.
         */
        inputBuf  = op_extra_data->input_stream[MicrophoneTerminalByIndex(0)];
        outputBuf = op_extra_data->output_stream[OutputTerminalByIndex(0)];
84201a9e:	d5 a8       	r3 = M[r0 + 76];
        if(inputBuf != NULL && outputBuf == NULL)
84201aa0:	91 88       	rMAC = M[r0 + 8];
84201aa2:	23 60       	if EQ jump (m) Lc_aec_reference_update_mic_channel_status_27;

84201aa4 <Lc_aec_reference_update_mic_channel_status_18>:
84201aa4:	28 04       	Null = r3 - Null;
84201aa6:	21 62       	if NE jump (m) Lc_aec_reference_update_mic_channel_status_27;

84201aa8 <Lc_aec_reference_update_mic_channel_status_19>:
        {
            /* mic0 connected, out0 disconnected, we can have 1->0 config */
            mic_channel_status = AEC_REFERENCE_CONSTANT_CONN_MIKE_1_INPUT_ONLY;
84201aa8:	01 f0 03 f0 	r1 = Null + 1048576;
84201aac:	00 40 
            number_mics = 1;
84201aae:	44 20       	r2 = Null + 1;

            /* However check that all other mics/outs are disconnected */
            for(i=1;i<MAX_NUMBER_MICS;i++)
84201ab0:	21 00       	rMAC = r2 + Null;
84201ab2:	04 6e       	jump (m) Lc_aec_reference_update_mic_channel_status_21;

84201ab4 <Lc_aec_reference_update_mic_channel_status_20>:
}


inline static unsigned MicrophoneTerminalByIndex(unsigned i)
{
    if(i<4)
84201ab4:	08 25       	Null = rMAC - 4;
84201ab6:	02 f0 8f e0 	if C jump (m) Lc_aec_reference_update_mic_channel_status_22;

84201aba <Lc_aec_reference_update_mic_channel_status_21>:
    {
        return (i + AEC_REF_MIC_TERMINAL1);
84201aba:	8d 20       	r3 = rMAC + 2;
            {
                inputBuf  = op_extra_data->input_stream[MicrophoneTerminalByIndex(i)];
84201abc:	6d 54       	r3 = r3 LSHIFT 2;
84201abe:	56 e9       	r4 = M[r0 + r3];

inline static unsigned OutputTerminalByIndex(unsigned i)
{
    if(i<4)
    {
        return (i + AEC_REF_OUTPUT_TERMINAL1);
84201ac0:	cd 20       	r3 = rMAC + 3;
84201ac2:	05 6e       	jump (m) Lc_aec_reference_update_mic_channel_status_23;

84201ac4 <Lc_aec_reference_update_mic_channel_status_22>:
    {
        return (i + AEC_REF_MIC_TERMINAL1);
    }
    else
    {
        return ((i-4)+ AEC_REF_MIC_TERMINAL5);
84201ac4:	0d 22       	r3 = rMAC + 8;
84201ac6:	6d 54       	r3 = r3 LSHIFT 2;
84201ac8:	56 e9       	r4 = M[r0 + r3];
    {
        return (i + AEC_REF_OUTPUT_TERMINAL1);
    }
    else
    {
        return ((i-4) + AEC_REF_OUTPUT_TERMINAL5);
84201aca:	4d 22       	r3 = rMAC + 9;

84201acc <Lc_aec_reference_update_mic_channel_status_23>:
                outputBuf = op_extra_data->output_stream[OutputTerminalByIndex(i)];
84201acc:	27 f0 40 20 	r5 = r0 + 64;
84201ad0:	6d 54       	r3 = r3 LSHIFT 2;
84201ad2:	7d e9       	r3 = M[r5 + r3];
                if(inputBuf != NULL || outputBuf != NULL)
84201ad4:	30 04       	Null = r4 - Null;
84201ad6:	03 62       	if NE jump (m) Lc_aec_reference_update_mic_channel_status_25;

84201ad8 <Lc_aec_reference_update_mic_channel_status_24>:
84201ad8:	28 04       	Null = r3 - Null;
84201ada:	04 60       	if EQ jump (m) Lc_aec_reference_update_mic_channel_status_26;

84201adc <Lc_aec_reference_update_mic_channel_status_25>:
                {
                    /* Another mic input and/or output is connected,
                     * we cannot have 1->0 mic path either.
                     */
                    mic_channel_status = 0;
84201adc:	03 00       	r1 = Null + Null;
                    number_mics = 0;
84201ade:	04 00       	r2 = Null + Null;
                    break;
84201ae0:	04 6e       	jump (m) Lc_aec_reference_update_mic_channel_status_27;

84201ae2 <Lc_aec_reference_update_mic_channel_status_26>:
            /* mic0 connected, out0 disconnected, we can have 1->0 config */
            mic_channel_status = AEC_REFERENCE_CONSTANT_CONN_MIKE_1_INPUT_ONLY;
            number_mics = 1;

            /* However check that all other mics/outs are disconnected */
            for(i=1;i<MAX_NUMBER_MICS;i++)
84201ae2:	49 20       	rMAC = rMAC + 1;
84201ae4:	08 26       	Null = rMAC - 8;
84201ae6:	e7 65       	if NC jump (m) Lc_aec_reference_update_mic_channel_status_20;

84201ae8 <Lc_aec_reference_update_mic_channel_status_27>:
                }
            }
        }
    }

    if((GetMicChannelStatus(op_extra_data)) == mic_channel_status)
84201ae8:	21 f0 76 88 	rMAC = M[r0 + 472];
84201aec:	0f f0 15 f8 	r3 = rMAC AND 0x1f000f;
84201af0:	0f 00 
84201af2:	e8 04       	Null = r3 - r1;
84201af4:	03 62       	if NE jump (m) Lc_aec_reference_update_mic_channel_status_29;

84201af6 <Lc_aec_reference_update_mic_channel_status_28>:
    {
        /* No change in the mic path */
        return FALSE;
84201af6:	02 00       	r0 = Null + Null;
84201af8:	0a 6e       	jump (m) Lc_aec_reference_update_mic_channel_status_30;

84201afa <Lc_aec_reference_update_mic_channel_status_29>:
    }

    /* update number of mics */
    op_extra_data->num_mic_channels = number_mics;
84201afa:	24 f0 78 8e 	M[r0 + 480] = r2;

    /* update mic channel status */
    SetMicChannelStatus(op_extra_data, mic_channel_status);
84201afe:	f0 ff 11 f7 	rMAC = rMAC AND 0xffe0fff0;
84201b02:	f0 1f 
84201b04:	c9 12       	rMAC = rMAC OR r1;
84201b06:	21 f0 76 8e 	M[r0 + 472] = rMAC;

    return TRUE;
84201b0a:	42 20       	r0 = Null + 1;

84201b0c <Lc_aec_reference_update_mic_channel_status_30>:
}
84201b0c:	72 48       	popm <FP, r4, r5>;
84201b0e:	d8 4c       	rts;

84201b10 <$_aec_reference_update_spkr_channel_status>:
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 * \return whether there is a change in speaker channel status that requires
 *         rebuilding of the speaker graph.
 */
bool aec_reference_update_spkr_channel_status(AEC_REFERENCE_OP_DATA *op_extra_data)
{
84201b10:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
    unsigned i;
    unsigned spkr_channel_status=0;
84201b12:	03 00       	r1 = Null + Null;
    unsigned number_spkrs=0;
84201b14:	01 00       	rMAC = Null + Null;
    tCbuffer *inputBuf,*outputBuf;

    patch_fn_shared(aec_reference);

    /* Speakers are connected */
    op_extra_data->sink_kicks   = 0;
84201b16:	20 f0 7c 8e 	M[r0 + 496] = Null;
    if(op_extra_data->input_stream[AEC_REF_INPUT_TERMINAL1] && op_extra_data->output_stream[AEC_REF_SPKR_TERMINAL1])
84201b1a:	14 e8       	r2 = M[r0 + Null];
84201b1c:	39 60       	if EQ jump (m) Lc_aec_reference_update_spkr_channel_status_16;

84201b1e <Lc_aec_reference_update_spkr_channel_status_2>:
84201b1e:	54 a8       	r2 = M[r0 + 68];
84201b20:	37 60       	if EQ jump (m) Lc_aec_reference_update_spkr_channel_status_16;

84201b22 <Lc_aec_reference_update_spkr_channel_status_3>:
    {
        int in_count=1;
84201b22:	45 20       	r3 = Null + 1;
        int out_count=1;
84201b24:	2e 00       	r4 = r3 + Null;

        /* Master Channel is connected */
        spkr_channel_status |= AEC_REFERENCE_CONSTANT_CONN_SPKR_1;
84201b26:	03 28       	r1 = Null + 16;

        /* Primary sink is connected */
        op_extra_data->sink_kicks = (1<<AEC_REF_INPUT_TERMINAL1);
84201b28:	29 00       	rMAC = r3 + Null;
84201b2a:	21 f0 7c 8e 	M[r0 + 496] = rMAC;

        for(i=1;i<MAX_NUMBER_SPEAKERS;i++)
84201b2e:	04 6e       	jump (m) Lc_aec_reference_update_spkr_channel_status_5;

84201b30 <Lc_aec_reference_update_spkr_channel_status_4>:
        {
            int sink_idx = SpeakerInputTerminalByIndex(i);
84201b30:	88 24       	Null = rMAC - 2;
84201b32:	02 f0 8b e0 	if C jump (m) Lc_aec_reference_update_spkr_channel_status_6;

84201b36 <Lc_aec_reference_update_spkr_channel_status_5>:
84201b36:	47 20       	r5 = Null + 1;

            /* Old terminals kept for backwards compatibility */
            outputBuf = op_extra_data->output_stream[SpeakerTerminalByIndex(i)];
84201b38:	84 20       	r2 = Null + 2;
84201b3a:	03 6e       	jump (m) Lc_aec_reference_update_spkr_channel_status_7;

84201b3c <Lc_aec_reference_update_spkr_channel_status_6>:
        /* Primary sink is connected */
        op_extra_data->sink_kicks = (1<<AEC_REF_INPUT_TERMINAL1);

        for(i=1;i<MAX_NUMBER_SPEAKERS;i++)
        {
            int sink_idx = SpeakerInputTerminalByIndex(i);
84201b3c:	0f 21       	r5 = rMAC + 4;

            /* Old terminals kept for backwards compatibility */
            outputBuf = op_extra_data->output_stream[SpeakerTerminalByIndex(i)];
84201b3e:	4c 21       	r2 = rMAC + 5;

84201b40 <Lc_aec_reference_update_spkr_channel_status_7>:
84201b40:	28 f0 40 20 	r6 = r0 + 64;
84201b44:	64 54       	r2 = r2 LSHIFT 2;
84201b46:	84 f0 04 e8 	r2 = M[r6 + r2];
            inputBuf  = op_extra_data->input_stream[sink_idx];
84201b4a:	01 f7 d8 c8 	r6 = r5 LSHIFT 2;

            if(inputBuf || outputBuf)
84201b4e:	28 f0 08 e8 	r6 = M[r0 + r6];
84201b52:	03 62       	if NE jump (m) Lc_aec_reference_update_spkr_channel_status_9;

84201b54 <Lc_aec_reference_update_spkr_channel_status_8>:
84201b54:	20 04       	Null = r2 - Null;
84201b56:	15 60       	if EQ jump (m) Lc_aec_reference_update_spkr_channel_status_13;

84201b58 <Lc_aec_reference_update_spkr_channel_status_9>:
            {
                spkr_channel_status |= (AEC_REFERENCE_CONSTANT_CONN_SPKR_1<<i);
84201b58:	09 09       	r7 = rMAC + Null;
84201b5a:	08 f9 99 ce 	r7 = 0x10 LSHIFT r7;
84201b5e:	00 f9 73 c8 	r1 = r1 OR r7;

                if(inputBuf)
84201b62:	0f f8 00 c2 	Null = r6 - Null;
84201b66:	23 60       	if EQ jump (m) Lc_aec_reference_update_spkr_channel_status_18;

84201b68 <Lc_aec_reference_update_spkr_channel_status_10>:
                {
                    op_extra_data->sink_kicks |= (1<<sink_idx);
84201b68:	00 f7 97 de 	r5 = 0x1 LSHIFT r5;
84201b6c:	28 f0 7c 88 	r6 = M[r0 + 496];
84201b70:	00 f8 77 c8 	r5 = r5 OR r6;
84201b74:	27 f0 7c 8e 	M[r0 + 496] = r5;
                    in_count++;
84201b78:	6d 20       	r3 = r3 + 1;

84201b7a <Lc_aec_reference_update_spkr_channel_status_11>:
                {
                    /* Special case allows mono input split to multiple outputs*/
                    return(FALSE);
                }

                if(outputBuf)
84201b7a:	20 04       	Null = r2 - Null;
84201b7c:	1c 60       	if EQ jump (m) Lc_aec_reference_update_spkr_channel_status_20;

84201b7e <Lc_aec_reference_update_spkr_channel_status_12>:
                {
                    out_count++;
84201b7e:	76 20       	r4 = r4 + 1;

84201b80 <Lc_aec_reference_update_spkr_channel_status_13>:
        spkr_channel_status |= AEC_REFERENCE_CONSTANT_CONN_SPKR_1;

        /* Primary sink is connected */
        op_extra_data->sink_kicks = (1<<AEC_REF_INPUT_TERMINAL1);

        for(i=1;i<MAX_NUMBER_SPEAKERS;i++)
84201b80:	49 20       	rMAC = rMAC + 1;
84201b82:	08 26       	Null = rMAC - 8;
84201b84:	d6 65       	if NC jump (m) Lc_aec_reference_update_spkr_channel_status_4;

84201b86 <Lc_aec_reference_update_spkr_channel_status_14>:
                    return(FALSE);
                }
            }
        }
        /* Verify complete channel setup */
        number_spkrs = out_count;
84201b86:	31 00       	rMAC = r4 + Null;
        if(in_count==out_count)
84201b88:	a8 05       	Null = r3 - r4;
84201b8a:	18 62       	if NE jump (m) Lc_aec_reference_update_spkr_channel_status_21;

84201b8c <Lc_aec_reference_update_spkr_channel_status_15>:
        {
            /* Parallel channels */
            spkr_channel_status |= AEC_REFERENCE_CONSTANT_CONN_TYPE_PARA;
84201b8c:	db cd       	r1 = r1 OR 0x1000;

84201b8e <Lc_aec_reference_update_spkr_channel_status_16>:
            /* Mono Input.  Split outputs */
            PL_ASSERT(in_count==1);
        }
    }

    if((GetSpkrChannelStatus(op_extra_data)) == spkr_channel_status)
84201b8e:	24 f0 76 88 	r2 = M[r0 + 472];
84201b92:	45 f1 f0 1f 	r3 = r2 AND 0x3ff0;
84201b96:	e8 04       	Null = r3 - r1;
84201b98:	0c 60       	if EQ jump (m) Lc_aec_reference_update_spkr_channel_status_19;

84201b9a <Lc_aec_reference_update_spkr_channel_status_17>:
        /* No change in the speaker channel status */
        return FALSE;
    }

    /* update number of speaker channels */
    op_extra_data->num_spkr_channels = number_spkrs;
84201b9a:	21 f0 77 8e 	M[r0 + 476] = rMAC;

    /* update speaker channel status */
    SetSpkrChannelStatus(op_extra_data, spkr_channel_status);
84201b9e:	41 fe 0f 00 	rMAC = r2 AND 0xffffc00f;
84201ba2:	c9 12       	rMAC = rMAC OR r1;
84201ba4:	21 f0 76 8e 	M[r0 + 472] = rMAC;
    return TRUE;
84201ba8:	42 20       	r0 = Null + 1;
84201baa:	18 6e       	jump (m) Lc_aec_reference_update_spkr_channel_status_25;

84201bac <Lc_aec_reference_update_spkr_channel_status_18>:
                if(inputBuf)
                {
                    op_extra_data->sink_kicks |= (1<<sink_idx);
                    in_count++;
                }
                else if(in_count>1)
84201bac:	68 24       	Null = r3 - 1;
84201bae:	e6 6d       	if LE jump (m) Lc_aec_reference_update_spkr_channel_status_11;

84201bb0 <Lc_aec_reference_update_spkr_channel_status_19>:
                {
                    /* Special case allows mono input split to multiple outputs*/
                    return(FALSE);
84201bb0:	02 00       	r0 = Null + Null;
84201bb2:	14 6e       	jump (m) Lc_aec_reference_update_spkr_channel_status_25;

84201bb4 <Lc_aec_reference_update_spkr_channel_status_20>:

                if(outputBuf)
                {
                    out_count++;
                }
                else if(out_count>1)
84201bb4:	70 24       	Null = r4 - 1;
84201bb6:	fd 6b       	if GT jump (m) Lc_aec_reference_update_spkr_channel_status_19;

84201bb8 <Lc_21>:
84201bb8:	e4 6f       	jump (m) Lc_aec_reference_update_spkr_channel_status_13;

84201bba <Lc_aec_reference_update_spkr_channel_status_21>:
        if(in_count==out_count)
        {
            /* Parallel channels */
            spkr_channel_status |= AEC_REFERENCE_CONSTANT_CONN_TYPE_PARA;
        }
        else if(out_count==1)
84201bba:	70 24       	Null = r4 - 1;
84201bbc:	06 62       	if NE jump (m) Lc_aec_reference_update_spkr_channel_status_23;

84201bbe <Lc_aec_reference_update_spkr_channel_status_22>:
        {
            /* Mono Output.  Mix inputs */
            spkr_channel_status |= AEC_REFERENCE_CONSTANT_CONN_TYPE_MIX;
84201bbe:	20 f0 00 f3 	r1 = r1 OR 0x2000;
84201bc2:	53 d8 
            number_spkrs = in_count;
84201bc4:	29 00       	rMAC = r3 + Null;
84201bc6:	e4 6f       	jump (m) Lc_aec_reference_update_spkr_channel_status_16;

84201bc8 <Lc_aec_reference_update_spkr_channel_status_23>:
        }
        else
        {
            /* Mono Input.  Split outputs */
            PL_ASSERT(in_count==1);
84201bc8:	68 24       	Null = r3 - 1;
84201bca:	e2 61       	if EQ jump (m) Lc_aec_reference_update_spkr_channel_status_16;

84201bcc <Lc_aec_reference_update_spkr_channel_status_24>:
84201bcc:	03 f0 4c 4a 	r1 = Null + 1612;
84201bd0:	02 f0 13 60 	r0 = Null + 4115;
84201bd4:	ff fd 91 f0 	call (m) 0x13f12;
84201bd8:	3f e9 

84201bda <Lc_aec_reference_update_spkr_channel_status_25>:

    /* update speaker channel status */
    SetSpkrChannelStatus(op_extra_data, spkr_channel_status);
    return TRUE;

}
84201bda:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84201bdc:	d8 4c       	rts;

84201bde <$_aec_reference_update_ref_channel_status>:
 *         insertion/deletion of the reference sub-path into/from speaker graph.
 */
bool aec_reference_update_ref_channel_status(AEC_REFERENCE_OP_DATA *op_extra_data)
{

    unsigned ref_channel_status = 0;
84201bde:	01 00       	rMAC = Null + Null;
    patch_fn_shared(aec_reference);

    /* Check AEC reference */
    if(op_extra_data->output_stream[AEC_REF_REFERENCE_TERMINAL] && (op_extra_data->channel_status&AEC_REFERENCE_CONSTANT_CONN_MIKE_1))
84201be0:	13 a8       	r1 = M[r0 + 64];
84201be2:	0c 60       	if EQ jump (m) Lc_aec_reference_update_ref_channel_status_4;

84201be4 <Lc_aec_reference_update_ref_channel_status_2>:
84201be4:	23 f0 76 88 	r1 = M[r0 + 472];
84201be8:	1b c0       	r1 = r1 AND 0x1;
84201bea:	08 60       	if EQ jump (m) Lc_aec_reference_update_ref_channel_status_4;

84201bec <Lc_aec_reference_update_ref_channel_status_3>:
    {
        op_extra_data->source_kicks |= 1<<AEC_REF_REFERENCE_TERMINAL;
84201bec:	21 f0 7b 88 	rMAC = M[r0 + 492];
84201bf0:	09 c8       	rMAC = rMAC OR 0x1;
84201bf2:	21 f0 7b 8e 	M[r0 + 492] = rMAC;
        ref_channel_status = AEC_REFERENCE_CONSTANT_CONN_TYPE_REF;
84201bf6:	21 f0 00 40 	rMAC = Null + 16384;

84201bfa <Lc_aec_reference_update_ref_channel_status_4>:
    }

    if(ref_channel_status == (GetRefChannelStatus(op_extra_data)))
84201bfa:	23 f0 76 88 	r1 = M[r0 + 472];
84201bfe:	34 f2 00 00 	r2 = r1 AND 0x4000;
84201c02:	08 05       	Null = rMAC - r2;
84201c04:	03 62       	if NE jump (m) Lc_aec_reference_update_ref_channel_status_6;

84201c06 <Lc_aec_reference_update_ref_channel_status_5>:
    {
        /* No change in reference path */
        return FALSE;
84201c06:	02 00       	r0 = Null + Null;
84201c08:	07 6e       	jump (m) Lc_aec_reference_update_ref_channel_status_7;

84201c0a <Lc_aec_reference_update_ref_channel_status_6>:
    }

    /* reference path has changed, update
     * channel status.
     */
    SetRefChannelStatus(op_extra_data, ref_channel_status);
84201c0a:	33 fd ff 1f 	r1 = r1 AND 0xffffbfff;
84201c0e:	c9 12       	rMAC = rMAC OR r1;
84201c10:	21 f0 76 8e 	M[r0 + 472] = rMAC;
    return TRUE;
84201c14:	42 20       	r0 = Null + 1;

84201c16 <Lc_aec_reference_update_ref_channel_status_7>:
84201c16:	d8 4c       	rts;

84201c18 <$_aec_reference_update_sidetone_method>:
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 * \return whether there is a change in sidetone mixing method
 */
void aec_reference_update_sidetone_method(AEC_REFERENCE_OP_DATA *op_extra_data)
{
84201c18:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84201c1a:	16 00       	r4 = r0 + Null;
    AEC_REFERENCE_SIDETONE_METHOD sidetone_method = AEC_SIDETONE_NOT_REQUIRED;
84201c1c:	07 00       	r5 = Null + Null;
    patch_fn_shared(aec_reference);

    /* reset state of sidetone */
    aec_reference_update_sidetone_status(op_extra_data);
84201c1e:	f9 ff 39 ed 	call (m) $_aec_reference_update_sidetone_status;

    /* If the config needs sidetone, decide which method it should use */
    if(op_extra_data->using_sidetone == USE_SIDETONE_FLAG)
84201c22:	61 f0 7a 88 	rMAC = M[r4 + 488];
84201c26:	c8 24       	Null = rMAC - 3;
84201c28:	0c 62       	if NE jump (m) Lc_aec_reference_update_sidetone_method_5;

84201c2a <Lc_aec_reference_update_sidetone_method_2>:
    {
        if(op_extra_data->hw_sidetone_available)
84201c2a:	60 f0 9b 88 	Null = M[r4 + 620];
84201c2e:	03 60       	if EQ jump (m) Lc_aec_reference_update_sidetone_method_4;

84201c30 <Lc_aec_reference_update_sidetone_method_3>:
        {
            /* if the config can have sidetone mixing in Hw then use that method */
            sidetone_method = AEC_SIDETONE_IN_HW;
84201c30:	47 20       	r5 = Null + 1;
84201c32:	07 6e       	jump (m) Lc_aec_reference_update_sidetone_method_5;

84201c34 <Lc_aec_reference_update_sidetone_method_4>:
        {
            /* HW side tone isn't supported, and speaker and mic are
             * running at high task period, use separate graph for sidetone
             * mixing which will run at decimated task period.
             */
            sidetone_method = AEC_SIDETONE_IN_SW_USING_SEPARATE_GRAPH;
84201c34:	61 f0 97 88 	rMAC = M[r4 + 604];
84201c38:	c7 20       	r5 = Null + 3;
84201c3a:	48 24       	Null = rMAC - 1;
84201c3c:	a9 f0 47 ce 	if LS r5 = Null + 2;

84201c40 <Lc_aec_reference_update_sidetone_method_5>:
            sidetone_method = AEC_SIDETONE_IN_SW_BY_MIC_SPKR_GRAPH;
        }
    }

    /* update sidetone mixing method */
    op_extra_data->sidetone_method = sidetone_method;
84201c40:	67 f0 70 9a 	MB[r4 + 624] = r5;

84201c44 <Lc_aec_reference_update_sidetone_method_6>:

}
84201c44:	f2 48       	popm <FP, r4, r5, rLink>;
84201c46:	d8 4c       	rts;

84201c48 <$_aec_reference_build_graphs>:
 * \brief clean up speaker graph
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 */
bool aec_reference_build_graphs(AEC_REFERENCE_OP_DATA *op_extra_data, bool spkr_changed, bool mic_changed)
{
84201c48:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
84201c4a:	16 00       	r4 = r0 + Null;
84201c4c:	44 de       	M[FP + 32] = r2;
84201c4e:	1b 09       	r9 = r1 + Null;
    unsigned max_sample_rate;

    patch_fn_shared(aec_reference);

    /* nothing to do if neither speaker nor mic has changed */
    if(!spkr_changed && !mic_changed)
84201c50:	03 62       	if NE jump (m) Lc_aec_reference_build_graphs_3;

84201c52 <Lc_aec_reference_build_graphs_2>:
84201c52:	41 d8       	rMAC = M[FP + 32];
84201c54:	71 60       	if EQ jump (m) Lc_aec_reference_build_graphs_21;

84201c56 <Lc_aec_reference_build_graphs_3>:
    {
        return TRUE;
    }

    max_sample_rate = op_extra_data->mic_rate;
84201c56:	62 f0 66 88 	r0 = M[r4 + 408];
    max_sample_rate = MAX(max_sample_rate, op_extra_data->spkr_rate);
84201c5a:	61 f0 6e 88 	rMAC = M[r4 + 440];
84201c5e:	50 04       	Null = r0 - rMAC;
84201c60:	02 f0 87 e0 	if C jump (m) Lc_aec_reference_build_graphs_5;

84201c64 <Lc_aec_reference_build_graphs_4>:
84201c64:	0a 00       	r0 = rMAC + Null;

84201c66 <Lc_aec_reference_build_graphs_5>:
    max_sample_rate = MAX(max_sample_rate, op_extra_data->input_rate);
84201c66:	61 f0 64 88 	rMAC = M[r4 + 400];
84201c6a:	50 04       	Null = r0 - rMAC;
84201c6c:	02 f0 87 e0 	if C jump (m) Lc_aec_reference_build_graphs_7;

84201c70 <Lc_aec_reference_build_graphs_6>:
84201c70:	0a 00       	r0 = rMAC + Null;

84201c72 <Lc_aec_reference_build_graphs_7>:
    max_sample_rate = MAX(max_sample_rate, op_extra_data->output_rate);
84201c72:	61 f0 65 88 	rMAC = M[r4 + 404];
84201c76:	50 04       	Null = r0 - rMAC;
84201c78:	02 f0 87 e0 	if C jump (m) Lc_aec_reference_build_graphs_9;

84201c7c <Lc_aec_reference_build_graphs_8>:
84201c7c:	0a 00       	r0 = rMAC + Null;

84201c7e <Lc_aec_reference_build_graphs_9>:
    op_extra_data->max_io_rate = max_sample_rate;
84201c7e:	62 f0 95 8e 	M[r4 + 596] = r0;

    /* 1ms more than a task period for max sample rate in all corners,
     * few samples more for considering resampling extra outputs.
     */
    size = frac_mult(max_sample_rate, op_extra_data->task_period_frac) + 4;
84201c82:	63 f0 93 88 	r1 = M[r4 + 588];
84201c86:	00 f3 72 c9 	r0 = r0 * r1 (frac);
84201c8a:	29 f0 04 20 	r7 = r0 + 4;

    /* Min size, was constant size of 100 words before introducing,
     * configurable task period, don't go below that tested value.
     */
    size = MAX(size, 100);
84201c8e:	90 f0 64 24 	Null = r7 - 100;
84201c92:	02 f0 89 e0 	if C jump (m) Lc_aec_reference_build_graphs_11;

84201c96 <Lc_aec_reference_build_graphs_10>:
84201c96:	09 f0 64 40 	r7 = Null + 100;

84201c9a <Lc_aec_reference_build_graphs_11>:

    /* allocate buffer needed for resampler */
    if(op_extra_data->resampler_temp_buffer == NULL)
84201c9a:	61 f0 32 88 	rMAC = M[r4 + 200];
84201c9e:	58 62       	if NE jump (m) Lc_aec_reference_build_graphs_24;

84201ca0 <Lc_aec_reference_build_graphs_12>:
    {
        /* resampler_temp_buffer_size must already have been calculated */
        PL_ASSERT(0 != op_extra_data->resampler_temp_buffer_size);
84201ca0:	62 f0 91 88 	r0 = M[r4 + 580];
84201ca4:	4b 62       	if NE jump (m) Lc_aec_reference_build_graphs_22;

84201ca6 <Lc_aec_reference_build_graphs_13>:
84201ca6:	03 f0 90 51 	r1 = Null + 2448;
84201caa:	02 f0 13 60 	r0 = Null + 4115;
84201cae:	ff fd 91 f0 	call (m) 0x13f12;
84201cb2:	25 e3 
84201cb4:	6f 6e       	jump (m) Lc_aec_reference_build_graphs_32;

84201cb6 <Lc_aec_reference_build_graphs_14>:
        }
    }

    /** Setup Latency Control */
    {
    	unsigned jitter = frac_mult(op_extra_data->output_rate,op_extra_data->task_period_frac);
84201cb6:	62 f0 65 88 	r0 = M[r4 + 404];
84201cba:	63 f0 93 88 	r1 = M[r4 + 588];
84201cbe:	00 f3 72 c9 	r0 = r0 * r1 (frac);

	    op_extra_data->sync_block.jitter     = 	jitter + (jitter>>1);				/* 1.5 times task period */
84201cc2:	13 50       	r1 = r0 LSHIFT -1;
84201cc4:	99 00       	rMAC = r1 + r0;
84201cc6:	61 f0 85 8e 	M[r4 + 532] = rMAC;
	    op_extra_data->sync_block.ref_delay  = frac_mult(op_extra_data->output_rate,FRACTIONAL(0.001)); 	 /* 1.0 msec */
84201cca:	62 f0 65 88 	r0 = M[r4 + 404];
84201cce:	02 f0 63 f0 	r1 = Null + 2147483;
84201cd2:	9b 48 
84201cd4:	00 f3 72 c9 	r0 = r0 * r1 (frac);
84201cd8:	62 f0 8a 8e 	M[r4 + 552] = r0;
	    op_extra_data->sync_block.block_sync = 0;
84201cdc:	60 f0 87 8e 	M[r4 + 540] = Null;
	    op_extra_data->sync_block.rm_adjustment = 0;
84201ce0:	60 f0 8c 8e 	M[r4 + 560] = Null;
        op_extra_data->sync_block.frm_count = 0;
84201ce4:	60 f0 8b 8e 	M[r4 + 556] = Null;
    }

    if(spkr_changed)
84201ce8:	0f fb 00 c2 	Null = r9 - Null;
84201cec:	09 60       	if EQ jump (m) Lc_aec_reference_build_graphs_16;

84201cee <Lc_aec_reference_build_graphs_15>:
    {
        /* any change in main speaker path will cause full
         * rebuild of every thing from scratch
         */
        aec_reference_cleanup_spkr_graph(op_extra_data);
84201cee:	32 00       	r0 = r4 + Null;
84201cf0:	01 f0 33 ec 	call (m) $_aec_reference_cleanup_spkr_graph;
        /* rebuild speaker graph */
        if(!build_spkr_graph(op_extra_data))
84201cf4:	32 00       	r0 = r4 + Null;
84201cf6:	fb ff 3b ed 	call (m) $_build_spkr_graph;
84201cfa:	10 04       	Null = r0 - Null;
84201cfc:	27 60       	if EQ jump (m) Lc_aec_reference_build_graphs_23;

84201cfe <Lc_aec_reference_build_graphs_16>:
        {
            return FALSE;
        }
    }

    if(mic_changed)
84201cfe:	41 d8       	rMAC = M[FP + 32];
84201d00:	09 60       	if EQ jump (m) Lc_aec_reference_build_graphs_18;

84201d02 <Lc_aec_reference_build_graphs_17>:
    {
        /* if only mic has changed, then only mic graph will be rebuilt */
        aec_reference_cleanup_mic_graph(op_extra_data);
84201d02:	32 00       	r0 = r4 + Null;
84201d04:	01 f0 3b e6 	call (m) $_aec_reference_cleanup_mic_graph;

        /* mic graph is rebuilt if there is a change
         * in either mic path or speaker path */
        if(!build_mic_graph(op_extra_data))
84201d08:	32 00       	r0 = r4 + Null;
84201d0a:	fa ff 29 eb 	call (m) $_build_mic_graph;
84201d0e:	10 04       	Null = r0 - Null;
84201d10:	1d 60       	if EQ jump (m) Lc_aec_reference_build_graphs_23;

84201d12 <Lc_aec_reference_build_graphs_18>:
        }
    }

    /* update mic and speaker graphs to include sidetone mix if required */
    if(!aec_reference_mic_spkr_include_sidetone(
           op_extra_data, op_extra_data->sidetone_method == AEC_SIDETONE_IN_SW_BY_MIC_SPKR_GRAPH))
84201d12:	61 f0 70 90 	rMAC = MBS[r4 + 624];
84201d16:	03 00       	r1 = Null + Null;
84201d18:	88 24       	Null = rMAC - 2;
84201d1a:	20 f0 43 ce 	if EQ r1 = Null + 1;
84201d1e:	32 00       	r0 = r4 + Null;
84201d20:	3b 4e       	call (m) $_aec_reference_mic_spkr_include_sidetone;
84201d22:	10 04       	Null = r0 - Null;
84201d24:	13 60       	if EQ jump (m) Lc_aec_reference_build_graphs_23;

84201d26 <Lc_aec_reference_build_graphs_19>:
        return FALSE;
    }

#ifdef AEC_REFERENCE_CAN_PERFORM_INPLACE_SIDETONE_MIXING
    /* build separate sidetone graph if required */
    if(!build_sidetone_graph(op_extra_data))
84201d26:	32 00       	r0 = r4 + Null;
84201d28:	03 f0 23 ea 	call (m) $_build_sidetone_graph;
84201d2c:	10 04       	Null = r0 - Null;
84201d2e:	0e 60       	if EQ jump (m) Lc_aec_reference_build_graphs_23;

84201d30 <Lc_aec_reference_build_graphs_20>:
        return FALSE;
    }
#endif /* AEC_REFERENCE_CAN_PERFORM_INPLACE_SIDETONE_MIXING */

    /*  Re-init */
    op_extra_data->ReInitFlag = TRUE;
84201d30:	41 20       	rMAC = Null + 1;
84201d32:	61 f0 5c 8e 	M[r4 + 368] = rMAC;

84201d36 <Lc_aec_reference_build_graphs_21>:
    patch_fn_shared(aec_reference);

    /* nothing to do if neither speaker nor mic has changed */
    if(!spkr_changed && !mic_changed)
    {
        return TRUE;
84201d36:	42 20       	r0 = Null + 1;
84201d38:	2d 6e       	jump (m) Lc_aec_reference_build_graphs_32;

84201d3a <Lc_aec_reference_build_graphs_22>:
    {
        /* resampler_temp_buffer_size must already have been calculated */
        PL_ASSERT(0 != op_extra_data->resampler_temp_buffer_size);

        op_extra_data->resampler_temp_buffer =
            (unsigned*)xzpmalloc(op_extra_data->resampler_temp_buffer_size*sizeof(unsigned));
84201d3a:	c3 20       	r1 = Null + 3;
84201d3c:	52 54       	r0 = r0 LSHIFT 2;
84201d3e:	ff fd 18 f0 	call (m) 0x4f2a;
84201d42:	2d ef 
        if(op_extra_data->resampler_temp_buffer == NULL)
84201d44:	62 f0 32 8e 	M[r4 + 200] = r0;
84201d48:	03 62       	if NE jump (m) Lc_aec_reference_build_graphs_24;

84201d4a <Lc_aec_reference_build_graphs_23>:
        {
            return FALSE;
84201d4a:	02 00       	r0 = Null + Null;
84201d4c:	23 6e       	jump (m) Lc_aec_reference_build_graphs_32;

84201d4e <Lc_aec_reference_build_graphs_24>:

    /* get the number of required scratch buffers based
     * on the number of speakers and mics that we have.
     */
    num_scratch_buffs = (MAX(op_extra_data->num_spkr_channels,
                             op_extra_data->num_mic_channels))*2;
84201d4e:	61 f0 77 88 	rMAC = M[r4 + 476];
84201d52:	62 f0 78 88 	r0 = M[r4 + 480];
84201d56:	88 04       	Null = rMAC - r0;
84201d58:	02 f0 87 e0 	if C jump (m) Lc_aec_reference_build_graphs_26;

84201d5c <Lc_aec_reference_build_graphs_25>:
84201d5c:	02 6e       	jump (m) Lc_aec_reference_build_graphs_27;

84201d5e <Lc_aec_reference_build_graphs_26>:
84201d5e:	0a 00       	r0 = rMAC + Null;

84201d60 <Lc_aec_reference_build_graphs_27>:
84201d60:	00 f2 da d8 	r8 = r0 LSHIFT 1;

    /* create scratch buffers, some of them might
     * already have been created */
    for(i=0;i<num_scratch_buffs;i++)
84201d64:	07 00       	r5 = Null + Null;
84201d66:	68 f0 84 20 	r6 = r4 + 132;

84201d6a <Lc_aec_reference_build_graphs_28>:
84201d6a:	af f7 00 c2 	Null = r5 - r8;
84201d6e:	f2 ff c9 ee 	if C jump (m) Lc_aec_reference_build_graphs_14;

84201d72 <Lc_aec_reference_build_graphs_29>:
    {
        if(NULL == op_extra_data->scratch_bufs[i])
84201d72:	81 f0 00 e8 	rMAC = M[r6 + Null];
84201d76:	0b 62       	if NE jump (m) Lc_aec_reference_build_graphs_31;

84201d78 <Lc_aec_reference_build_graphs_30>:
        {
            op_extra_data->scratch_bufs[i] = cbuffer_create_with_malloc_fast(size, BUF_DESC_SW_BUFFER);
84201d78:	03 00       	r1 = Null + Null;
84201d7a:	4a 08       	r0 = r7 + Null;
84201d7c:	ff fd 85 f0 	call (m) 0x1279c;
84201d80:	21 e1 
84201d82:	82 f0 00 ee 	M[r6 + Null] = r0;
            if(!op_extra_data->scratch_bufs[i])
84201d86:	81 f0 00 e8 	rMAC = M[r6 + Null];
84201d8a:	e0 61       	if EQ jump (m) Lc_aec_reference_build_graphs_23;

84201d8c <Lc_aec_reference_build_graphs_31>:
    num_scratch_buffs = (MAX(op_extra_data->num_spkr_channels,
                             op_extra_data->num_mic_channels))*2;

    /* create scratch buffers, some of them might
     * already have been created */
    for(i=0;i<num_scratch_buffs;i++)
84201d8c:	7f 20       	r5 = r5 + 1;
84201d8e:	20 75       	r6 = r6 + 4;
84201d90:	ed 6f       	jump (m) Lc_aec_reference_build_graphs_28;

84201d92 <Lc_aec_reference_build_graphs_32>:

    /*  Re-init */
    op_extra_data->ReInitFlag = TRUE;

    return TRUE;
}
84201d92:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84201d94:	d8 4c       	rts;

84201d96 <$_aec_reference_mic_spkr_include_sidetone>:
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 * \param include_sidetone whether to add or remove sidetone from graphs
 */
bool aec_reference_mic_spkr_include_sidetone(AEC_REFERENCE_OP_DATA* op_extra_data, bool include_sidetone)
{
84201d96:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
84201d98:	16 00       	r4 = r0 + Null;
    cbops_graph *spkr_graph = op_extra_data->spkr_graph;
    cbops_graph *mic_graph = op_extra_data->mic_graph;
84201d9a:	68 f0 6a 88 	r6 = M[r4 + 424];

    /* we need to have a speaker graph */
    if(NULL == spkr_graph || NULL == mic_graph)
84201d9e:	6b f0 72 88 	r9 = M[r4 + 456];
84201da2:	04 60       	if EQ jump (m) Lc_aec_reference_mic_spkr_include_sidetone_3;

84201da4 <Lc_aec_reference_mic_spkr_include_sidetone_2>:
84201da4:	0f f8 00 c2 	Null = r6 - Null;
84201da8:	9e 62       	if NE jump (m) Lc_aec_reference_mic_spkr_include_sidetone_16;

84201daa <Lc_aec_reference_mic_spkr_include_sidetone_3>:
    {
        /* No action if we don't have a speaker graph
         * however in that case we expect the sidetone is
         * not active.
         */
        PL_ASSERT(op_extra_data->spkr_sidetone_active == FALSE);
84201daa:	60 f0 9f 88 	Null = M[r4 + 636];
84201dae:	99 60       	if EQ jump (m) Lc_aec_reference_mic_spkr_include_sidetone_15;

84201db0 <Lc_aec_reference_mic_spkr_include_sidetone_4>:
84201db0:	03 f0 50 4b 	r1 = Null + 1872;
84201db4:	02 f0 13 60 	r0 = Null + 4115;
84201db8:	ff fd 90 f0 	call (m) 0x13f12;
84201dbc:	3b ea 
84201dbe:	0f f0 9d e4 	jump (m) Lc_aec_reference_mic_spkr_include_sidetone_31;

84201dc2 <Lc_aec_reference_mic_spkr_include_sidetone_5>:
            mic_st_rs_idx = op_extra_data->mic_st_input_idx;
        }
        else
        {
            /* no resampler, sidetone filter will transfer from internal buffer to output */
            mic_st_rs_idx = op_extra_data->mic_st_idx;
84201dc2:	61 f0 d8 88 	rMAC = M[r4 + 864];
84201dc6:	49 de       	M[FP + 36] = rMAC;

84201dc8 <Lc_aec_reference_mic_spkr_include_sidetone_6>:
        }

        /* set sidetone output buffer */
        cbops_set_output_io_buffer(mic_graph, op_extra_data->mic_st_idx, op_extra_data->mic_st_idx, op_extra_data->sidetone_buf);
84201dc8:	63 f0 d8 88 	r1 = M[r4 + 864];
84201dcc:	65 f0 31 88 	r3 = M[r4 + 196];
84201dd0:	1c 00       	r2 = r1 + Null;
84201dd2:	42 08       	r0 = r6 + Null;
84201dd4:	ff fd a8 f0 	call (m) 0x16e34;
84201dd8:	21 e3 
            Note:  Sidetone is before resampler.
            Better solution is to place it at lowest sample rate */

        op_ptr = create_sidetone_filter_op(op_extra_data->mic_st_input_idx, mic_st_rs_idx, 3,
                                           (cbops_sidetone_params*)&op_extra_data->params.OFFSET_ST_CLIP_POINT,
                                           (void*)&op_extra_data->params.OFFSET_ST_PEQ_CONFIG);
84201dda:	01 f0 0c ff 	push r4 + 268;
84201dde:	16 cf 
84201de0:	65 f0 f0 20 	r3 = r4 + 240;
84201de4:	c4 20       	r2 = Null + 3;
84201de6:	4b d8       	r1 = M[FP + 36];
84201de8:	62 f0 da 88 	r0 = M[r4 + 872];
84201dec:	08 f0 2d e0 	call (m) $_create_sidetone_filter_op;
84201df0:	7f 4c       	SP = SP + -4;
84201df2:	17 00       	r5 = r0 + Null;

        op_extra_data->mic_sidetone_op = op_ptr;
        if(!op_ptr)
84201df4:	67 f0 6c 8e 	M[r4 + 432] = r5;
84201df8:	a2 60       	if EQ jump (m) Lc_aec_reference_mic_spkr_include_sidetone_21;

84201dfa <Lc_aec_reference_mic_spkr_include_sidetone_7>:
        {
            return FALSE;
        }

        /* insert resamler op into mic cbops graph */
        cbops_insert_operator_into_graph(mic_graph, op_ptr, after);
84201dfa:	4c 08       	r2 = r7 + Null;
84201dfc:	3b 00       	r1 = r5 + Null;
84201dfe:	42 08       	r0 = r6 + Null;
84201e00:	07 f0 3b ea 	call (m) $_cbops_insert_operator_into_graph;
        after = op_ptr;
84201e04:	3a 09       	r8 = r5 + Null;
        mic_num_st_ops++;
84201e06:	09 71       	r7 = Null + 1;

        if(mic_st_rs_idx != op_extra_data->mic_st_idx)
84201e08:	49 d8       	rMAC = M[FP + 36];
84201e0a:	62 f0 d8 88 	r0 = M[r4 + 864];
84201e0e:	88 04       	Null = rMAC - r0;
84201e10:	22 60       	if EQ jump (m) Lc_aec_reference_mic_spkr_include_sidetone_10;

84201e12 <Lc_aec_reference_mic_spkr_include_sidetone_8>:
                                               &mic_st_rs_idx,
                                               &op_extra_data->mic_st_idx,
                                               op_extra_data->mic_rate,
                                               op_extra_data->spkr_rate,
                                               op_extra_data->resampler_temp_buffer_size,
                                               op_extra_data->resampler_temp_buffer, 0, 0, 0);
84201e12:	00 f0 30 cf 	push Null;
84201e16:	00 f0 30 cf 	push Null;
84201e1a:	00 f0 30 cf 	push Null;
84201e1e:	61 f0 32 88 	rMAC = M[r4 + 200];
84201e22:	09 1c       	pushm <rMAC>;
84201e24:	61 f0 91 88 	rMAC = M[r4 + 580];
84201e28:	09 1c       	pushm <rMAC>;
84201e2a:	61 f0 6e 88 	rMAC = M[r4 + 440];
84201e2e:	09 1c       	pushm <rMAC>;
84201e30:	65 f0 66 88 	r3 = M[r4 + 408];
84201e34:	64 f0 60 23 	r2 = r4 + 864;
84201e38:	43 12       	r1 = FP + 36;
84201e3a:	4a 08       	r0 = r7 + Null;
84201e3c:	08 f0 2b e0 	call (m) $_create_iir_resamplerv2_op;
84201e40:	7a 4c       	SP = SP + -24;
84201e42:	11 09       	r7 = r0 + Null;
            if(!op_ptr)
84201e44:	7c 60       	if EQ jump (m) Lc_aec_reference_mic_spkr_include_sidetone_21;

84201e46 <Lc_aec_reference_mic_spkr_include_sidetone_9>:
            {
                return FALSE;
            }
            cbops_insert_operator_into_graph(mic_graph, op_ptr, after);
84201e46:	3c 00       	r2 = r5 + Null;
84201e48:	4b 08       	r1 = r7 + Null;
84201e4a:	42 08       	r0 = r6 + Null;
84201e4c:	07 f0 2f e8 	call (m) $_cbops_insert_operator_into_graph;
            after = op_ptr;
84201e50:	4a 09       	r8 = r7 + Null;
            mic_num_st_ops++;
84201e52:	11 71       	r7 = Null + 2;

84201e54 <Lc_aec_reference_mic_spkr_include_sidetone_10>:
        }

        /* Add in disgard on sidetone */

        op_ptr = create_sink_overflow_disgard_op(1,&op_extra_data->mic_st_idx,threshold);
84201e54:	63 f0 60 23 	r1 = r4 + 864;
84201e58:	42 20       	r0 = Null + 1;
84201e5a:	44 d8       	r2 = M[FP + 32];
84201e5c:	ff fd 4f f1 	call (m) 0x2bdc4;
84201e60:	29 eb 
84201e62:	17 00       	r5 = r0 + Null;
#if defined(IO_DEBUG)
        st_disgard_op = op_ptr;
84201e64:	e0 f0 07 f0 	M[Null + $_st_disgard_op] = r5;
84201e68:	5d 8e 
#endif
        if(!op_ptr)
84201e6a:	38 04       	Null = r5 - Null;
84201e6c:	68 60       	if EQ jump (m) Lc_aec_reference_mic_spkr_include_sidetone_21;

84201e6e <Lc_aec_reference_mic_spkr_include_sidetone_11>:
        {
            return FALSE;
        }
        cbops_insert_operator_into_graph(mic_graph,op_ptr, after);
84201e6e:	54 08       	r2 = r8 + Null;
84201e70:	3b 00       	r1 = r5 + Null;
84201e72:	42 08       	r0 = r6 + Null;
84201e74:	07 f0 27 e7 	call (m) $_cbops_insert_operator_into_graph;
        mic_num_st_ops++;
84201e78:	09 75       	r7 = r7 + 1;

        /* save last operator in sidetone sub-path,
         * will be needed when removing the graph
         */
        op_extra_data->mic_st_last_op = op_ptr;
84201e7a:	67 f0 db 8e 	M[r4 + 876] = r5;
        op_extra_data->mic_num_st_ops = mic_num_st_ops;
84201e7e:	69 f0 d9 8e 	M[r4 + 868] = r7;
        /** -------------------- SPKR SIDETONE SUB PATH ---------------------- **/
        /* Add sidetone mixer to resampler section,  Master channel only */
        cbops_set_input_io_buffer(spkr_graph,
                                  op_extra_data->spkr_st_in_idx,
                                  op_extra_data->spkr_st_in_idx,
                                  op_extra_data->sidetone_buf);
84201e82:	63 f0 a5 88 	r1 = M[r4 + 660];
84201e86:	65 f0 31 88 	r3 = M[r4 + 196];
84201e8a:	1c 00       	r2 = r1 + Null;
84201e8c:	5a 08       	r0 = r9 + Null;
84201e8e:	ff fd a7 f0 	call (m) 0x16e02;
84201e92:	35 eb 

        /* create a multi-channel sidetone mix operator,
         * number of main channels = number of speakers
         * number of sidetone channels = 1
         */
        unsigned num_st_mix_channels  = op_extra_data->num_spkr_channels;
84201e94:	62 f0 77 88 	r0 = M[r4 + 476];
        unsigned spkr_channel_status = GetSpkrChannelStatus(op_extra_data);
84201e98:	61 f0 76 88 	rMAC = M[r4 + 472];
84201e9c:	11 f1 f0 1f 	rMAC = rMAC AND 0x3ff0;
        if((spkr_channel_status&AEC_REFERENCE_CONSTANT_CONN_TYPE_PARA) == 0)
84201ea0:	c9 c5       	rMAC = rMAC AND 0x1000;
84201ea2:	02 62       	if NE jump (m) Lc_aec_reference_mic_spkr_include_sidetone_13;

84201ea4 <Lc_aec_reference_mic_spkr_include_sidetone_12>:
        {
            /* speaker path isn't parallel channels,
             * sidetone mix has only one main channel
             */
            num_st_mix_channels = 1;
84201ea4:	42 20       	r0 = Null + 1;

84201ea6 <Lc_aec_reference_mic_spkr_include_sidetone_13>:
            num_st_mix_channels,                /* number of main channels */
            op_extra_data->spkr_stmix_in_idx,   /* idx for first input channel */
            op_extra_data->spkr_stmix_in_idx,   /* idx for first output channel */
            1,                                  /* number of sidetone channels */
            op_extra_data->spkr_st_in_idx,      /* idx for first sidetone input */
            op_extra_data->spkr_out_threshold); /* threshold for latency control */
84201ea6:	63 f0 a3 88 	r1 = M[r4 + 652];
84201eaa:	61 f0 b0 88 	rMAC = M[r4 + 704];
84201eae:	09 1c       	pushm <rMAC>;
84201eb0:	61 f0 a5 88 	rMAC = M[r4 + 660];
84201eb4:	09 1c       	pushm <rMAC>;
84201eb6:	45 20       	r3 = Null + 1;
84201eb8:	1c 00       	r2 = r1 + Null;
84201eba:	08 f0 29 e7 	call (m) $_create_multichan_sidetone_mix_op;
84201ebe:	7e 4c       	SP = SP + -8;
84201ec0:	17 00       	r5 = r0 + Null;
        if(op_ptr == NULL)
84201ec2:	3d 60       	if EQ jump (m) Lc_aec_reference_mic_spkr_include_sidetone_21;

84201ec4 <Lc_aec_reference_mic_spkr_include_sidetone_14>:
        {
            return FALSE;
        }
        /* configure op to mix the sidetone input into all main channels */
        cbops_sidetone_mix_map_one_to_all(op_ptr, 0);
84201ec4:	03 00       	r1 = Null + Null;
84201ec6:	08 f0 3f e4 	call (m) $_cbops_sidetone_mix_map_one_to_all;

        /* insert sidetone mix operator into speaker graph */
        cbops_insert_operator_into_graph(spkr_graph, op_ptr, op_extra_data->spkr_st_point_op);
84201eca:	64 f0 a9 88 	r2 = M[r4 + 676];
84201ece:	3b 00       	r1 = r5 + Null;
84201ed0:	5a 08       	r0 = r9 + Null;
84201ed2:	07 f0 29 e4 	call (m) $_cbops_insert_operator_into_graph;

        /* save the sidetone mix operator */
        op_extra_data->spkr_stmix_op = op_ptr;
84201ed6:	67 f0 ab 8e 	M[r4 + 684] = r5;

        /* now speaker graph has sidetone mix operator */
        op_extra_data->spkr_sidetone_active = TRUE;
84201eda:	41 20       	rMAC = Null + 1;
84201edc:	61 f0 9f 8e 	M[r4 + 636] = rMAC;

84201ee0 <Lc_aec_reference_mic_spkr_include_sidetone_15>:
        /* No action if we don't have a speaker graph
         * however in that case we expect the sidetone is
         * not active.
         */
        PL_ASSERT(op_extra_data->spkr_sidetone_active == FALSE);
        return TRUE;
84201ee0:	42 20       	r0 = Null + 1;
84201ee2:	7c 6e       	jump (m) Lc_aec_reference_mic_spkr_include_sidetone_31;

84201ee4 <Lc_aec_reference_mic_spkr_include_sidetone_16>:
    }

    if(!include_sidetone == !op_extra_data->spkr_sidetone_active)
84201ee4:	01 00       	rMAC = Null + Null;
84201ee6:	18 04       	Null = r1 - Null;
84201ee8:	20 f0 41 ce 	if EQ rMAC = Null + 1;
84201eec:	02 00       	r0 = Null + Null;
84201eee:	60 f0 9f 88 	Null = M[r4 + 636];
84201ef2:	20 f0 42 ce 	if EQ r0 = Null + 1;
84201ef6:	88 04       	Null = rMAC - r0;
84201ef8:	f4 61       	if EQ jump (m) Lc_aec_reference_mic_spkr_include_sidetone_15;

84201efa <Lc_aec_reference_mic_spkr_include_sidetone_17>:
         * as current state.
         */
        return TRUE;
    }

    if(include_sidetone)
84201efa:	18 04       	Null = r1 - Null;
84201efc:	34 60       	if EQ jump (m) Lc_aec_reference_mic_spkr_include_sidetone_24;

84201efe <Lc_aec_reference_mic_spkr_include_sidetone_18>:
    {
        /** -------------------- MIC SIDETONE SUB PATH ---------------------- **/
        /* side tone buffer size, 2ms more than task period */
        unsigned sidetone_buf_size = frac_mult(op_extra_data->spkr_rate,
                                               op_extra_data->task_period_frac + FRACTIONAL(0.002));
84201efe:	62 f0 6e 88 	r0 = M[r4 + 440];
84201f02:	61 f0 93 88 	rMAC = M[r4 + 588];
84201f06:	06 f1 13 f0 	r1 = rMAC + 4294967;
84201f0a:	37 31 
84201f0c:	00 f3 72 c9 	r0 = r0 * r1 (frac);
        cbops_op *after = op_extra_data->mic_st_point;
84201f10:	69 f0 dc 88 	r7 = M[r4 + 880];
        unsigned mic_num_st_ops = 0;
        unsigned  mic_st_rs_idx;
        cbops_op    *op_ptr;

        /* we don't expect SidetoneOA buffer already existing at this point */
        PL_ASSERT(op_extra_data->sidetone_buf == NULL);
84201f14:	61 f0 31 88 	rMAC = M[r4 + 196];
84201f18:	09 60       	if EQ jump (m) Lc_aec_reference_mic_spkr_include_sidetone_20;

84201f1a <Lc_aec_reference_mic_spkr_include_sidetone_19>:
84201f1a:	03 f0 6a 4b 	r1 = Null + 1898;
84201f1e:	02 f0 13 60 	r0 = Null + 4115;
84201f22:	ff fd 8f f0 	call (m) 0x13f12;
84201f26:	31 ef 
84201f28:	59 6e       	jump (m) Lc_aec_reference_mic_spkr_include_sidetone_31;

84201f2a <Lc_aec_reference_mic_spkr_include_sidetone_20>:

        /* Allocate Buffer between cbops Graphs */
        op_extra_data->sidetone_buf = cbuffer_create_with_malloc_fast(sidetone_buf_size, BUF_DESC_SW_BUFFER);
84201f2a:	03 00       	r1 = Null + Null;
84201f2c:	ff fd 84 f0 	call (m) 0x1279c;
84201f30:	31 e3 
84201f32:	62 f0 31 8e 	M[r4 + 196] = r0;

        if(!op_extra_data->sidetone_buf)
84201f36:	61 f0 31 88 	rMAC = M[r4 + 196];
84201f3a:	03 62       	if NE jump (m) Lc_aec_reference_mic_spkr_include_sidetone_22;

84201f3c <Lc_aec_reference_mic_spkr_include_sidetone_21>:
        {
            /* Not going ahead with creating mic sub path if we
             * cannot create shared buffer for sidetone path.
             */
            return FALSE;
84201f3c:	02 00       	r0 = Null + Null;
84201f3e:	4e 6e       	jump (m) Lc_aec_reference_mic_spkr_include_sidetone_31;

84201f40 <Lc_aec_reference_mic_spkr_include_sidetone_22>:
        }

        /* Minimum space needed in buffer */
        unsigned threshold = frac_mult(op_extra_data->spkr_rate,op_extra_data->task_period_frac) + 1;
84201f40:	62 f0 6e 88 	r0 = M[r4 + 440];
84201f44:	63 f0 93 88 	r1 = M[r4 + 588];
84201f48:	00 f3 72 c9 	r0 = r0 * r1 (frac);
84201f4c:	51 20       	rMAC = r0 + 1;
84201f4e:	41 de       	M[FP + 32] = rMAC;

        if(op_extra_data->mic_rate != op_extra_data->spkr_rate)
84201f50:	61 f0 66 88 	rMAC = M[r4 + 408];
84201f54:	62 f0 6e 88 	r0 = M[r4 + 440];
84201f58:	88 04       	Null = rMAC - r0;
84201f5a:	34 61       	if EQ jump (m) Lc_aec_reference_mic_spkr_include_sidetone_5;

84201f5c <Lc_aec_reference_mic_spkr_include_sidetone_23>:
        {
            /* Sidetone filter is inplace */
            mic_st_rs_idx = op_extra_data->mic_st_input_idx;
84201f5c:	61 f0 da 88 	rMAC = M[r4 + 872];
84201f60:	49 de       	M[FP + 36] = rMAC;
84201f62:	33 6f       	jump (m) Lc_aec_reference_mic_spkr_include_sidetone_6;

84201f64 <Lc_aec_reference_mic_spkr_include_sidetone_24>:
    }
    else
    {
        /** -------------------- REMOVING MIC SIDETONE SUB PATH ---------------------- **/
        /* removing sub-graph starts from its last operator */
        cbops_op *op = op_extra_data->mic_st_last_op;
84201f64:	63 f0 db 88 	r1 = M[r4 + 876];
        unsigned i;

        /* remove all the ops in the sidetone sub-path */
        for (i=0; i < op_extra_data->mic_num_st_ops; ++i)
84201f68:	07 00       	r5 = Null + Null;

84201f6a <Lc_aec_reference_mic_spkr_include_sidetone_25>:
84201f6a:	61 f0 d9 88 	rMAC = M[r4 + 868];
84201f6e:	78 04       	Null = r5 - rMAC;
84201f70:	02 f0 95 e0 	if C jump (m) Lc_aec_reference_mic_spkr_include_sidetone_27;

84201f74 <Lc_aec_reference_mic_spkr_include_sidetone_26>:
        {
            cbops_op *prev_op = op->prev_operator_addr;
84201f74:	39 f0 00 e8 	r7 = M[r1 + Null];
            cbops_remove_operator_from_graph(mic_graph, op);
84201f78:	42 08       	r0 = r6 + Null;
84201f7a:	06 f0 33 ed 	call (m) $_cbops_remove_operator_from_graph;
            op = prev_op;
84201f7e:	4b 08       	r1 = r7 + Null;
        /* removing sub-graph starts from its last operator */
        cbops_op *op = op_extra_data->mic_st_last_op;
        unsigned i;

        /* remove all the ops in the sidetone sub-path */
        for (i=0; i < op_extra_data->mic_num_st_ops; ++i)
84201f80:	7f 20       	r5 = r5 + 1;
84201f82:	f4 6f       	jump (m) Lc_aec_reference_mic_spkr_include_sidetone_25;

84201f84 <Lc_aec_reference_mic_spkr_include_sidetone_27>:
            cbops_remove_operator_from_graph(mic_graph, op);
            op = prev_op;
        }

        /*  tell the cbops not to care about sidetone buffer any more */
        cbops_unset_buffer(mic_graph, op_extra_data->mic_st_idx);
84201f84:	63 f0 d8 88 	r1 = M[r4 + 864];
84201f88:	42 08       	r0 = r6 + Null;
84201f8a:	06 f0 2f ef 	call (m) $_cbops_unset_buffer;

        op_extra_data->mic_st_last_op = NULL;
84201f8e:	60 f0 db 8e 	M[r4 + 876] = Null;
        op_extra_data->mic_num_st_ops = 0;
84201f92:	60 f0 d9 8e 	M[r4 + 868] = Null;
        op_extra_data->mic_sidetone_op = NULL;
84201f96:	60 f0 6c 8e 	M[r4 + 432] = Null;

        /** -------------------- REMOVING SPKR SIDETONE SUB PATH ---------------------- **/
        /* remove the sidetone mix operator from speaker graph */
        PL_ASSERT(NULL != op_extra_data->spkr_stmix_op);
84201f9a:	63 f0 ab 88 	r1 = M[r4 + 684];
84201f9e:	09 62       	if NE jump (m) Lc_aec_reference_mic_spkr_include_sidetone_29;

84201fa0 <Lc_aec_reference_mic_spkr_include_sidetone_28>:
84201fa0:	03 f0 07 50 	r1 = Null + 2055;
84201fa4:	02 f0 13 60 	r0 = Null + 4115;
84201fa8:	ff fd 8f f0 	call (m) 0x13f12;
84201fac:	2b eb 
84201fae:	16 6e       	jump (m) Lc_aec_reference_mic_spkr_include_sidetone_31;

84201fb0 <Lc_aec_reference_mic_spkr_include_sidetone_29>:
        cbops_remove_operator_from_graph(spkr_graph, op_extra_data->spkr_stmix_op);
84201fb0:	5a 08       	r0 = r9 + Null;
84201fb2:	06 f0 3b eb 	call (m) $_cbops_remove_operator_from_graph;
        op_extra_data->spkr_stmix_op = NULL;
84201fb6:	60 f0 ab 8e 	M[r4 + 684] = Null;

        /* also tell the cbops not to care about sidetone buffer any more */
        cbops_unset_buffer(spkr_graph, op_extra_data->spkr_st_in_idx);
84201fba:	63 f0 a5 88 	r1 = M[r4 + 660];
84201fbe:	5a 08       	r0 = r9 + Null;
84201fc0:	06 f0 39 ed 	call (m) $_cbops_unset_buffer;

        /* speaker graph no longer has sidetone mix operator*/
        op_extra_data->spkr_sidetone_active = FALSE;
84201fc4:	60 f0 9f 8e 	M[r4 + 636] = Null;

        /* Free Sidetone buffers, this must be
         * done after removing sidetone mix from
         * speaker graph.
         */
        if(op_extra_data->sidetone_buf != NULL)
84201fc8:	62 f0 31 88 	r0 = M[r4 + 196];
84201fcc:	8a 61       	if EQ jump (m) Lc_aec_reference_mic_spkr_include_sidetone_15;

84201fce <Lc_aec_reference_mic_spkr_include_sidetone_30>:
        {
            cbuffer_destroy(op_extra_data->sidetone_buf);
84201fce:	ff fd 84 f0 	call (m) 0x12802;
84201fd2:	35 e1 
            op_extra_data->sidetone_buf = NULL;
84201fd4:	60 f0 31 8e 	M[r4 + 196] = Null;
84201fd8:	84 6f       	jump (m) Lc_aec_reference_mic_spkr_include_sidetone_15;

84201fda <Lc_aec_reference_mic_spkr_include_sidetone_31>:

        DEBUG_GRAPHS("AEC REFERENCE: Side tone path removed!" );
    }

    return TRUE;
}
84201fda:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84201fdc:	d8 4c       	rts;

84201fde <$_aec_reference_cleanup_mic_graph>:
 * \brief clean up mic graph
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 */
void aec_reference_cleanup_mic_graph(AEC_REFERENCE_OP_DATA *op_extra_data)
{
84201fde:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84201fe0:	16 00       	r4 = r0 + Null;
    patch_fn_shared(aec_reference);

    /* Clear links to graphs */
    op_extra_data->mic_rate_monitor_op = NULL;
84201fe2:	60 f0 6b 8e 	M[r4 + 428] = Null;
    op_extra_data->mic_sw_rateadj_op = NULL;
84201fe6:	60 f0 7d 8e 	M[r4 + 500] = Null;
    op_extra_data->mic_mute_op = NULL;
84201fea:	60 f0 9d 8e 	M[r4 + 628] = Null;

    /* if we have active sidetone path then remove
     * it from speaker graph
     */
    if(op_extra_data->spkr_sidetone_active)
84201fee:	60 f0 9f 88 	Null = M[r4 + 636];
84201ff2:	04 60       	if EQ jump (m) Lc_aec_reference_cleanup_mic_graph_3;

84201ff4 <Lc_aec_reference_cleanup_mic_graph_2>:
    {
        aec_reference_mic_spkr_include_sidetone(op_extra_data, FALSE);
84201ff4:	03 00       	r1 = Null + Null;
84201ff6:	fe ff 21 ed 	call (m) $_aec_reference_mic_spkr_include_sidetone;

84201ffa <Lc_aec_reference_cleanup_mic_graph_3>:
    }

    /* Free cbops mic graph */
    if(op_extra_data->mic_graph != NULL)
84201ffa:	62 f0 6a 88 	r0 = M[r4 + 424];
84201ffe:	06 60       	if EQ jump (m) Lc_aec_reference_cleanup_mic_graph_5;

84202000 <Lc_aec_reference_cleanup_mic_graph_4>:
    {
        destroy_graph(op_extra_data->mic_graph);
84202000:	ff fd a6 f0 	call (m) 0x16daa;
84202004:	2b ed 
        op_extra_data->mic_graph = NULL;
84202006:	60 f0 6a 8e 	M[r4 + 424] = Null;

8420200a <Lc_aec_reference_cleanup_mic_graph_5>:
    }

    /* update the state of sidetone */
    aec_reference_update_sidetone_status(op_extra_data);
8420200a:	32 00       	r0 = r4 + Null;
8420200c:	f7 ff 2b ee 	call (m) $_aec_reference_update_sidetone_status;

#ifdef AEC_REFERENCE_GENERATE_MIC_TIMESTAMP
    op_extra_data->mic_metadata_tag_left_words = 0;
84202010:	60 f0 cb 8e 	M[r4 + 812] = Null;

84202014 <Lc_aec_reference_cleanup_mic_graph_6>:
#endif

    DEBUG_GRAPHS("AEC REFERENCE: MIC graph's cleanup done!" );
}
84202014:	f1 48       	popm <FP, r4, rLink>;
84202016:	d8 4c       	rts;

84202018 <$_aec_reference_cleanup_graphs>:
 * \brief clean up all the cbops graphs
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 */
void aec_reference_cleanup_graphs(AEC_REFERENCE_OP_DATA *op_extra_data)
{
84202018:	f3 1c       	pushm <FP(=SP), r4, r5, r6, rLink>;
8420201a:	16 00       	r4 = r0 + Null;

    patch_fn_shared(aec_reference);

    /* Kill timer Task */
    /* This needs to be atomic, to make sure the right timer gets cancelled */
    LOCK_INTERRUPTS;
8420201c:	ff fd 56 f1 	call (m) 0x2cc9c;
84202020:	21 e4 
    if(op_extra_data->kick_id!=TIMER_ID_INVALID)
84202022:	62 f0 5d 88 	r0 = M[r4 + 372];
84202026:	08 60       	if EQ jump (m) Lc_aec_reference_cleanup_graphs_3;

84202028 <Lc_aec_reference_cleanup_graphs_2>:
    {
        timer_cancel_event(op_extra_data->kick_id);
84202028:	04 00       	r2 = Null + Null;
8420202a:	03 00       	r1 = Null + Null;
8420202c:	ff fd 90 f0 	call (m) 0x141bc;
84202030:	31 ec 
        op_extra_data->kick_id=TIMER_ID_INVALID;
84202032:	60 f0 5d 8e 	M[r4 + 372] = Null;

84202036 <Lc_aec_reference_cleanup_graphs_3>:
    }
    UNLOCK_INTERRUPTS;
84202036:	ff fd 56 f1 	call (m) 0x2ccb8;
8420203a:	23 e4 

#ifdef AEC_REFERENCE_CAN_PERFORM_INPLACE_SIDETONE_MIXING
    /* cleanup sidetone graph if we have one */
    if(NULL != op_extra_data->sidetone_graph)
8420203c:	61 f0 99 88 	rMAC = M[r4 + 612];
84202040:	04 60       	if EQ jump (m) Lc_aec_reference_cleanup_graphs_5;

84202042 <Lc_aec_reference_cleanup_graphs_4>:
    {
        /* clean sidetone graph */
        aec_reference_cleanup_sidetone_graph(op_extra_data);
84202042:	32 00       	r0 = r4 + Null;
84202044:	03 f0 27 e2 	call (m) $_aec_reference_cleanup_sidetone_graph;

84202048 <Lc_aec_reference_cleanup_graphs_5>:
    }
#endif
    /* clean mic graph */
    aec_reference_cleanup_mic_graph(op_extra_data);
84202048:	32 00       	r0 = r4 + Null;
8420204a:	ca 4f       	call (m) $_aec_reference_cleanup_mic_graph;

    /* clean speaker graph */
    aec_reference_cleanup_spkr_graph(op_extra_data);
8420204c:	32 00       	r0 = r4 + Null;
8420204e:	1a 4e       	call (m) $_aec_reference_cleanup_spkr_graph;

    /* Free Internal buffers */
    for(i=0;i<AEC_NUM_SCRATCH_BUFFERS;i++)
84202050:	07 00       	r5 = Null + Null;
84202052:	68 f0 84 20 	r6 = r4 + 132;

84202056 <Lc_aec_reference_cleanup_graphs_6>:
    {
        if(op_extra_data->scratch_bufs[i] != NULL)
84202056:	82 f0 00 e8 	r0 = M[r6 + Null];
8420205a:	06 60       	if EQ jump (m) Lc_aec_reference_cleanup_graphs_8;

8420205c <Lc_aec_reference_cleanup_graphs_7>:
        {
            cbuffer_destroy(op_extra_data->scratch_bufs[i]);
8420205c:	ff fd 83 f0 	call (m) 0x12802;
84202060:	27 ed 
            op_extra_data->scratch_bufs[i] = NULL;
84202062:	80 f0 00 ee 	M[r6 + Null] = Null;

84202066 <Lc_aec_reference_cleanup_graphs_8>:

    /* clean speaker graph */
    aec_reference_cleanup_spkr_graph(op_extra_data);

    /* Free Internal buffers */
    for(i=0;i<AEC_NUM_SCRATCH_BUFFERS;i++)
84202066:	7f 20       	r5 = r5 + 1;
84202068:	20 75       	r6 = r6 + 4;
8420206a:	38 2c       	Null = r5 - 16;
8420206c:	f5 65       	if NC jump (m) Lc_aec_reference_cleanup_graphs_6;

8420206e <Lc_aec_reference_cleanup_graphs_9>:
            op_extra_data->scratch_bufs[i] = NULL;
        }
    }

    /* clear scratch buffer used by resampler operator */
    if(op_extra_data->resampler_temp_buffer != NULL)
8420206e:	62 f0 32 88 	r0 = M[r4 + 200];
84202072:	06 60       	if EQ jump (m) Lc_aec_reference_cleanup_graphs_11;

84202074 <Lc_aec_reference_cleanup_graphs_10>:
    {
        pfree(op_extra_data->resampler_temp_buffer);
84202074:	ff fd 17 f0 	call (m) 0x4f62;
84202078:	2f e7 
        op_extra_data->resampler_temp_buffer = NULL;
8420207a:	60 f0 32 8e 	M[r4 + 200] = Null;

8420207e <Lc_aec_reference_cleanup_graphs_11>:
    }

    DEBUG_GRAPHS("AEC REFERENCE: Full graphs cleanup done!" );
}
8420207e:	f3 48       	popm <FP, r4, r5, r6, rLink>;
84202080:	d8 4c       	rts;

84202082 <$_aec_reference_cleanup_spkr_graph>:
 * \brief clean up speaker graph
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 */
void aec_reference_cleanup_spkr_graph(AEC_REFERENCE_OP_DATA *op_extra_data)
{
84202082:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84202084:	16 00       	r4 = r0 + Null;
    patch_fn_shared(aec_reference);

#if defined(IO_DEBUG)
    insert_op  = NULL;
84202086:	e0 f0 00 f0 	M[Null + $_insert_op] = Null;
8420208a:	5c 8e 
    st_disgard_op = NULL;
8420208c:	e0 f0 00 f0 	M[Null + $_st_disgard_op] = Null;
84202090:	5d 8e 
#endif

    /* Clear links to graphs */
    op_extra_data->spkr_rate_monitor_op = NULL;
84202092:	60 f0 73 8e 	M[r4 + 460] = Null;
    op_extra_data->spkr_sw_rateadj_op = NULL;
84202096:	60 f0 7e 8e 	M[r4 + 504] = Null;
    op_extra_data->spkr_ref_point_op = NULL;
8420209a:	60 f0 a8 8e 	M[r4 + 672] = Null;
    op_extra_data->spkr_st_point_op = NULL;
8420209e:	60 f0 a9 8e 	M[r4 + 676] = Null;
    op_extra_data->spkr_ref_last_op = NULL;
842020a2:	60 f0 aa 8e 	M[r4 + 680] = Null;
    op_extra_data->spkr_ref_rs_op = NULL;
842020a6:	60 f0 ac 8e 	M[r4 + 688] = Null;
    op_extra_data->ref_sw_rateadj_op = NULL;
842020aa:	60 f0 90 8e 	M[r4 + 576] = Null;

    /* if we have active sidetone path then remove
     * it from speaker graph
     */
    if(op_extra_data->spkr_sidetone_active)
842020ae:	60 f0 9f 88 	Null = M[r4 + 636];
842020b2:	04 60       	if EQ jump (m) Lc_aec_reference_cleanup_spkr_graph_3;

842020b4 <Lc_aec_reference_cleanup_spkr_graph_2>:
    {
        aec_reference_mic_spkr_include_sidetone(op_extra_data, FALSE);
842020b4:	03 00       	r1 = Null + Null;
842020b6:	fe ff 21 e7 	call (m) $_aec_reference_mic_spkr_include_sidetone;

842020ba <Lc_aec_reference_cleanup_spkr_graph_3>:
    }

    /* destroy speaker graph */
    if(op_extra_data->spkr_graph != NULL)
842020ba:	62 f0 72 88 	r0 = M[r4 + 456];
842020be:	06 60       	if EQ jump (m) Lc_aec_reference_cleanup_spkr_graph_5;

842020c0 <Lc_aec_reference_cleanup_spkr_graph_4>:
    {
        destroy_graph(op_extra_data->spkr_graph);
842020c0:	ff fd a6 f0 	call (m) 0x16daa;
842020c4:	2b e7 
        op_extra_data->spkr_graph = NULL;
842020c6:	60 f0 72 8e 	M[r4 + 456] = Null;

842020ca <Lc_aec_reference_cleanup_spkr_graph_5>:
    }

    /* clear flag for reference path */
    op_extra_data->spkr_ref_active = FALSE;
842020ca:	60 f0 a0 8e 	M[r4 + 640] = Null;

    /* clear flag for sidetone path */
    op_extra_data->spkr_sidetone_active = FALSE;
842020ce:	60 f0 9f 8e 	M[r4 + 636] = Null;

#ifdef AEC_REFERENCE_SPKR_TTP
    /* destroy any structure allocated for ttp playback */
    aec_reference_spkr_ttp_terminate(op_extra_data);
842020d2:	32 00       	r0 = r4 + Null;
842020d4:	04 f0 25 e8 	call (m) $_aec_reference_spkr_ttp_terminate;
#endif /* AEC_REFERENCE_SPKR_TTP */

#ifdef AEC_REF_CALC_SPKR_RATE_MONITOR_AMOUNT
    /* Reset flag showing speaker started to consume data */
    op_extra_data->spkr_flow_started = FALSE;
842020d8:	60 f0 d3 8e 	M[r4 + 844] = Null;

842020dc <Lc_aec_reference_cleanup_spkr_graph_6>:
#endif

    /* TODO - Fill speakers with silence */

    DEBUG_GRAPHS("AEC REFERENCE: Speaker graph's cleanup done!" );
}
842020dc:	f1 48       	popm <FP, r4, rLink>;
842020de:	d8 4c       	rts;

842020e0 <$_aec_reference_spkr_include_ref_path>:
 * \brief updates speaker graph to include/exclude path for reference output
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 */
bool aec_reference_spkr_include_ref_path(AEC_REFERENCE_OP_DATA* op_extra_data, bool include_ref_path)
{
842020e0:	f5 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>, SP = SP + 0x10;
842020e2:	16 00       	r4 = r0 + Null;
842020e4:	19 00       	rMAC = r1 + Null;
    cbops_graph *spkr_graph = op_extra_data->spkr_graph;
842020e6:	68 f0 72 88 	r6 = M[r4 + 456];
    cbops_op    *op_ptr;
    unsigned ref_idx = op_extra_data->spkr_ref_idx;
842020ea:	63 f0 a4 88 	r1 = M[r4 + 656];
842020ee:	3b de       	M[FP + 28] = r1;

    /* No action if no speaker graph */
    if(NULL == spkr_graph)
842020f0:	0f f8 00 c2 	Null = r6 - Null;
842020f4:	56 62       	if NE jump (m) Lc_aec_reference_spkr_include_ref_path_11;

842020f6 <Lc_aec_reference_spkr_include_ref_path_2>:
    {
        /* nothing to do but we expect no reference output */
        PL_ASSERT(op_extra_data->spkr_ref_active == FALSE);
842020f6:	60 f0 a0 88 	Null = M[r4 + 640];
842020fa:	51 60       	if EQ jump (m) Lc_aec_reference_spkr_include_ref_path_10;

842020fc <Lc_aec_reference_spkr_include_ref_path_3>:
842020fc:	03 f0 31 50 	r1 = Null + 2097;
84202100:	02 f0 13 60 	r0 = Null + 4115;
84202104:	ff fd 8f f0 	call (m) 0x13f12;
84202108:	2f e0 
8420210a:	bc 6e       	jump (m) Lc_aec_reference_spkr_include_ref_path_22;

8420210c <Lc_aec_reference_spkr_include_ref_path_4>:
            {
                return FALSE;
            }

            /* save the resampler op and it's scratch buffer index */
            op_extra_data->spkr_ref_rs_op = op_ptr;
8420210c:	67 f0 ac 8e 	M[r4 + 688] = r5;
            op_extra_data->spkr_ref_rs_idx = ref_rm_in_idx;
84202110:	49 d8       	rMAC = M[FP + 36];
84202112:	61 f0 a7 8e 	M[r4 + 668] = rMAC;

            /* insert resamler op into speaker cbops graph */
            cbops_insert_operator_into_graph(spkr_graph,op_ptr, after);
84202116:	4c 08       	r2 = r7 + Null;
84202118:	3b 00       	r1 = r5 + Null;
8420211a:	42 08       	r0 = r6 + Null;
8420211c:	06 f0 3f e1 	call (m) $_cbops_insert_operator_into_graph;
            after = op_ptr;
84202120:	39 09       	r7 = r5 + Null;
            spkr_num_ref_ops++;
84202122:	0a 71       	r8 = Null + 1;

84202124 <Lc_aec_reference_spkr_include_ref_path_5>:
        }

        /*  SW rate adjustment for reference */
        op_ptr = create_sw_rate_adj_op(1, &ref_rm_in_idx, &ref_idx,
                                       CBOPS_RATEADJUST_COEFFS,
                                       &op_extra_data->sync_block.rm_adjustment, 0);
84202124:	00 f0 30 cf 	push Null;
84202128:	85 2a       	r3 = Null + 26;
8420212a:	c4 11       	r2 = FP + 28;
8420212c:	43 12       	r1 = FP + 36;
8420212e:	02 f0 30 ff 	push r4 + 560;
84202132:	16 cf 
84202134:	42 20       	r0 = Null + 1;
84202136:	ff fd a5 f0 	call (m) 0x16bea;
8420213a:	35 e5 
8420213c:	7e 4c       	SP = SP + -8;
8420213e:	17 00       	r5 = r0 + Null;
        if(op_ptr == NULL)
84202140:	78 60       	if EQ jump (m) Lc_aec_reference_spkr_include_ref_path_15;

84202142 <Lc_aec_reference_spkr_include_ref_path_6>:
        {
            return FALSE;
        }

		/* store reference rate adjust operator */
        op_extra_data->ref_sw_rateadj_op = op_ptr;
84202142:	67 f0 90 8e 	M[r4 + 576] = r5;
        if(op_extra_data->mic_sync_enable)
84202146:	60 f0 d4 88 	Null = M[r4 + 848];
8420214a:	05 60       	if EQ jump (m) Lc_aec_reference_spkr_include_ref_path_8;

8420214c <Lc_aec_reference_spkr_include_ref_path_7>:
        {
            /* if input and output are in the same clock, then mic output
             * can get sychronised to ref, and ref won't need rate adjustment.
             * The operator will be doing simple copy here.
             */
            cbops_rateadjust_passthrough_mode(op_ptr, TRUE);
8420214c:	43 20       	r1 = Null + 1;
8420214e:	ff fd a5 f0 	call (m) 0x16c96;
84202152:	29 ea 

84202154 <Lc_aec_reference_spkr_include_ref_path_8>:
        }

        /* insert rate adjust op into speaker cbops graph*/
        cbops_insert_operator_into_graph(spkr_graph, op_ptr, after);
84202154:	4c 08       	r2 = r7 + Null;
84202156:	3b 00       	r1 = r5 + Null;
84202158:	42 08       	r0 = r6 + Null;
8420215a:	06 f0 21 e0 	call (m) $_cbops_insert_operator_into_graph;
        after = op_ptr;
        spkr_num_ref_ops++;
8420215e:	0a 75       	r8 = r8 + 1;

        /* speaker latency cbops operator */
        op_ptr = create_speaker_latency_op(ref_idx, &op_extra_data->sync_block);
84202160:	63 f0 14 22 	r1 = r4 + 532;
84202164:	3a d8       	r0 = M[FP + 28];
84202166:	ff fd 30 f1 	call (m) 0x28250;
8420216a:	2b e7 
8420216c:	11 09       	r7 = r0 + Null;
        if(op_ptr == NULL)
8420216e:	61 60       	if EQ jump (m) Lc_aec_reference_spkr_include_ref_path_15;

84202170 <Lc_aec_reference_spkr_include_ref_path_9>:
        {
            return FALSE;
        }
        /* insert speaker latency op into speaker cbops graph*/
        cbops_insert_operator_into_graph(spkr_graph, op_ptr, after);
84202170:	3c 00       	r2 = r5 + Null;
84202172:	4b 08       	r1 = r7 + Null;
84202174:	42 08       	r0 = r6 + Null;
84202176:	05 f0 25 ef 	call (m) $_cbops_insert_operator_into_graph;
        spkr_num_ref_ops++;
8420217a:	0a 75       	r8 = r8 + 1;
        /* save last operator in the reference sub-path and
         * also the number of operator in the sub-path,
         * these will be required when removing the
         * reference path
         */
        op_extra_data->spkr_ref_last_op = op_ptr;
8420217c:	69 f0 aa 8e 	M[r4 + 680] = r7;
        op_extra_data->spkr_num_ref_ops = spkr_num_ref_ops;
84202180:	6a f0 a6 8e 	M[r4 + 664] = r8;

        /* Now speaker graph includes reference sub path */
        op_extra_data->spkr_ref_active = TRUE;
84202184:	47 20       	r5 = Null + 1;
84202186:	67 f0 a0 8e 	M[r4 + 640] = r5;

        /* have reasonable distance between MIC and REF at the beginning,
		 * assumes MIC buffer is empty now.
		 */
        cbuffer_move_write_to_read_point(op_extra_data->output_stream[AEC_REF_REFERENCE_TERMINAL],
                                         op_extra_data->sync_block.jitter/2);
8420218a:	62 f0 85 88 	r0 = M[r4 + 532];
8420218e:	13 50       	r1 = r0 LSHIFT -1;
84202190:	32 a8       	r0 = M[r4 + 64];
84202192:	ff fd 51 f1 	call (m) 0x2c57a;
84202196:	29 ef 
 *
 * \param op pointer to cbop
 */
static inline void cbops_reshresh_buffers(cbops_graph *graph)
{
   graph->refresh_buffers = TRUE;
84202198:	87 f0 07 8e 	M[r6 + 28] = r5;

8420219c <Lc_aec_reference_spkr_include_ref_path_10>:
    /* No action if no speaker graph */
    if(NULL == spkr_graph)
    {
        /* nothing to do but we expect no reference output */
        PL_ASSERT(op_extra_data->spkr_ref_active == FALSE);
        return TRUE;
8420219c:	42 20       	r0 = Null + 1;
8420219e:	72 6e       	jump (m) Lc_aec_reference_spkr_include_ref_path_22;

842021a0 <Lc_aec_reference_spkr_include_ref_path_11>:
    }

    if(!include_ref_path == !op_extra_data->spkr_ref_active)
842021a0:	02 00       	r0 = Null + Null;
842021a2:	08 04       	Null = rMAC - Null;
842021a4:	20 f0 42 ce 	if EQ r0 = Null + 1;
842021a8:	04 00       	r2 = Null + Null;
842021aa:	60 f0 a0 88 	Null = M[r4 + 640];
842021ae:	20 f0 44 ce 	if EQ r2 = Null + 1;
842021b2:	10 05       	Null = r0 - r2;
842021b4:	f4 61       	if EQ jump (m) Lc_aec_reference_spkr_include_ref_path_10;

842021b6 <Lc_aec_reference_spkr_include_ref_path_12>:
         * as current state.
         */
        return TRUE;
    }

    if(include_ref_path)
842021b6:	08 04       	Null = rMAC - Null;
842021b8:	3e 60       	if EQ jump (m) Lc_aec_reference_spkr_include_ref_path_16;

842021ba <Lc_aec_reference_spkr_include_ref_path_13>:
    {
        /* Adding Reference path to speaker graph */

        unsigned ref_input_idx = op_extra_data->spkr_ref_input_idx;
842021ba:	61 f0 a1 88 	rMAC = M[r4 + 644];
842021be:	41 de       	M[FP + 32] = rMAC;
        unsigned ref_rm_in_idx = ref_input_idx;
842021c0:	49 de       	M[FP + 36] = rMAC;
        cbops_op *after = op_extra_data->spkr_ref_point_op;
842021c2:	69 f0 a8 88 	r7 = M[r4 + 672];
        unsigned spkr_num_ref_ops = 0;
842021c6:	02 09       	r8 = Null + Null;

        /* set buffer index for reference output in cbops graph */
        cbops_set_output_io_buffer(spkr_graph,
                                   ref_idx,
                                   ref_idx,
                                   op_extra_data->output_stream[AEC_REF_REFERENCE_TERMINAL]);
842021c8:	35 a8       	r3 = M[r4 + 64];
842021ca:	1c 00       	r2 = r1 + Null;
842021cc:	42 08       	r0 = r6 + Null;
842021ce:	ff fd a6 f0 	call (m) 0x16e34;
842021d2:	27 e3 

        /* see if resampler is needed in reference path */
        if(op_extra_data->input_rate != op_extra_data->output_rate)
842021d4:	61 f0 64 88 	rMAC = M[r4 + 400];
842021d8:	62 f0 65 88 	r0 = M[r4 + 404];
842021dc:	88 04       	Null = rMAC - r0;
842021de:	a3 61       	if EQ jump (m) Lc_aec_reference_spkr_include_ref_path_5;

842021e0 <Lc_aec_reference_spkr_include_ref_path_14>:
        {
            /* resampler outputs into internal buffer */
            ref_rm_in_idx = ref_idx+1;
842021e0:	39 d8       	rMAC = M[FP + 28];
842021e2:	4b 20       	r1 = rMAC + 1;
842021e4:	4b de       	M[FP + 36] = r1;
            /* NOTE: left scratch input is input to resampler */

            cbops_set_internal_io_buffer(spkr_graph,
                                         ref_rm_in_idx,
                                         ref_rm_in_idx,
                                         op_extra_data->scratch_bufs[op_extra_data->spkr_ref_scratch_idx]);
842021e6:	62 f0 a2 88 	r0 = M[r4 + 648];
842021ea:	31 00       	rMAC = r4 + Null;
842021ec:	1c 00       	r2 = r1 + Null;
842021ee:	52 54       	r0 = r0 LSHIFT 2;
842021f0:	51 00       	rMAC = r0 + rMAC;
842021f2:	15 f0 21 88 	r3 = M[rMAC + 132];
842021f6:	42 08       	r0 = r6 + Null;
842021f8:	ff fd a6 f0 	call (m) 0x16e66;
842021fc:	2f e3 

            /* Add reference sample rate conversion (input_rate --> output_rate) - for 1 channel only */
            op_ptr = create_iir_resamplerv2_op(1, &ref_input_idx, &ref_rm_in_idx,
                                               op_extra_data->input_rate, op_extra_data->output_rate,
                                               op_extra_data->resampler_temp_buffer_size,
                                               op_extra_data->resampler_temp_buffer, 0, 0, 0);
842021fe:	00 f0 30 cf 	push Null;
84202202:	00 f0 30 cf 	push Null;
84202206:	00 f0 30 cf 	push Null;
8420220a:	61 f0 32 88 	rMAC = M[r4 + 200];
8420220e:	09 1c       	pushm <rMAC>;
84202210:	61 f0 91 88 	rMAC = M[r4 + 580];
84202214:	09 1c       	pushm <rMAC>;
84202216:	61 f0 65 88 	rMAC = M[r4 + 404];
8420221a:	09 1c       	pushm <rMAC>;
8420221c:	65 f0 64 88 	r3 = M[r4 + 400];
84202220:	44 12       	r2 = FP + 36;
84202222:	03 12       	r1 = FP + 32;
84202224:	42 20       	r0 = Null + 1;
84202226:	06 f0 21 e1 	call (m) $_create_iir_resamplerv2_op;
8420222a:	7a 4c       	SP = SP + -24;
8420222c:	17 00       	r5 = r0 + Null;

            if(op_ptr == NULL)
8420222e:	6f 63       	if NE jump (m) Lc_aec_reference_spkr_include_ref_path_4;

84202230 <Lc_aec_reference_spkr_include_ref_path_15>:
            {
                return FALSE;
84202230:	02 00       	r0 = Null + Null;
84202232:	28 6e       	jump (m) Lc_aec_reference_spkr_include_ref_path_22;

84202234 <Lc_aec_reference_spkr_include_ref_path_16>:
        DEBUG_GRAPHS("AEC REFERENCE: Reference path added!" );
    }
    else
    {
        /* removing sub-graph starts from its last operator */
        cbops_op *op = op_extra_data->spkr_ref_last_op;
84202234:	63 f0 aa 88 	r1 = M[r4 + 680];
        unsigned i;

        /* remove all the ops in the reference sub-path */
        for (i=0; i < op_extra_data->spkr_num_ref_ops; ++i)
84202238:	07 00       	r5 = Null + Null;

8420223a <Lc_aec_reference_spkr_include_ref_path_17>:
8420223a:	61 f0 a6 88 	rMAC = M[r4 + 664];
8420223e:	78 04       	Null = r5 - rMAC;
84202240:	02 f0 95 e0 	if C jump (m) Lc_aec_reference_spkr_include_ref_path_19;

84202244 <Lc_aec_reference_spkr_include_ref_path_18>:
        {
            cbops_op *prev_op = op->prev_operator_addr;
84202244:	39 f0 00 e8 	r7 = M[r1 + Null];
            cbops_remove_operator_from_graph(spkr_graph, op);
84202248:	42 08       	r0 = r6 + Null;
8420224a:	05 f0 23 e7 	call (m) $_cbops_remove_operator_from_graph;
            op = prev_op;
8420224e:	4b 08       	r1 = r7 + Null;
        /* removing sub-graph starts from its last operator */
        cbops_op *op = op_extra_data->spkr_ref_last_op;
        unsigned i;

        /* remove all the ops in the reference sub-path */
        for (i=0; i < op_extra_data->spkr_num_ref_ops; ++i)
84202250:	7f 20       	r5 = r5 + 1;
84202252:	f4 6f       	jump (m) Lc_aec_reference_spkr_include_ref_path_17;

84202254 <Lc_aec_reference_spkr_include_ref_path_19>:
            cbops_remove_operator_from_graph(spkr_graph, op);
            op = prev_op;
        }

        /*  tell the cbops not to care about reference buffer any more */
        cbops_unset_buffer(spkr_graph, ref_idx);
84202254:	3b d8       	r1 = M[FP + 28];
84202256:	42 08       	r0 = r6 + Null;
84202258:	05 f0 21 e9 	call (m) $_cbops_unset_buffer;

        if(op_extra_data->spkr_ref_rs_op != NULL)
8420225c:	61 f0 ac 88 	rMAC = M[r4 + 688];
84202260:	08 60       	if EQ jump (m) Lc_aec_reference_spkr_include_ref_path_21;

84202262 <Lc_aec_reference_spkr_include_ref_path_20>:
        {
            /* if we have resampler in the reference path
             * then also the reserved index buffer should
             * get unset.
             */
            cbops_unset_buffer(spkr_graph, op_extra_data->spkr_ref_rs_idx);
84202262:	63 f0 a7 88 	r1 = M[r4 + 668];
84202266:	42 08       	r0 = r6 + Null;
84202268:	05 f0 31 e8 	call (m) $_cbops_unset_buffer;
            op_extra_data->spkr_ref_rs_op = NULL;
8420226c:	60 f0 ac 8e 	M[r4 + 688] = Null;

84202270 <Lc_aec_reference_spkr_include_ref_path_21>:
        }

        op_extra_data->spkr_num_ref_ops = 0;
84202270:	60 f0 a6 8e 	M[r4 + 664] = Null;
        op_extra_data->spkr_ref_last_op = NULL;
84202274:	60 f0 aa 8e 	M[r4 + 680] = Null;
        op_extra_data->ref_sw_rateadj_op = NULL;
84202278:	60 f0 90 8e 	M[r4 + 576] = Null;

        /* speaker graph no longer has reference sub-path */
        op_extra_data->spkr_ref_active = FALSE;
8420227c:	60 f0 a0 8e 	M[r4 + 640] = Null;
84202280:	8e 6f       	jump (m) Lc_aec_reference_spkr_include_ref_path_10;

84202282 <Lc_aec_reference_spkr_include_ref_path_22>:
        DEBUG_GRAPHS("AEC REFERENCE: Reference path removed!" );
    }
    return TRUE;
}
84202282:	f5 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, rLink>;
84202284:	d8 4c       	rts;

84202286 <$_aec_reference_stop_reset>:
    base_op_change_response_status(response_data,STATUS_OK);
    return TRUE;
}

bool aec_reference_stop_reset(OPERATOR_DATA *op_data,void **response_data)
{
84202286:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84202288:	16 00       	r4 = r0 + Null;
8420228a:	1f 00       	r5 = r1 + Null;
    patch_fn_shared(aec_reference);

    if(!base_op_build_std_response(STATUS_CMD_FAILED,op_data->id,response_data))
8420228c:	73 88       	r1 = M[r4 + 4];
8420228e:	02 f0 00 60 	r0 = Null + 4096;
84202292:	3c 00       	r2 = r5 + Null;
84202294:	ef fd ef ff 	call (m) 0x204;
84202298:	31 eb 
8420229a:	10 04       	Null = r0 - Null;
8420229c:	03 62       	if NE jump (m) Lc_aec_reference_stop_reset_3;

8420229e <Lc_aec_reference_stop_reset_2>:
    {
        return(FALSE);
8420229e:	02 00       	r0 = Null + Null;
842022a0:	0b 6e       	jump (m) Lc_aec_reference_stop_reset_6;

842022a2 <Lc_aec_reference_stop_reset_3>:
    }
    /* do something only if the current state is "running" */
    if(op_data->state == OP_RUNNING)
842022a2:	31 b0       	rMAC = MBS[r4 + 24];
842022a4:	04 62       	if NE jump (m) Lc_aec_reference_stop_reset_5;

842022a6 <Lc_aec_reference_stop_reset_4>:
    {
        aec_reference_cleanup(op_data);
842022a6:	32 00       	r0 = r4 + Null;
842022a8:	f7 ff 39 ed 	call (m) $_aec_reference_cleanup;

842022ac <Lc_aec_reference_stop_reset_5>:
    }

    /* operator state variable set to not running state. based on base_op.c */
    op_data->state = OP_NOT_RUNNING;
842022ac:	41 20       	rMAC = Null + 1;
842022ae:	31 ba       	MB[r4 + 24] = rMAC;
842022b0:	39 e8       	rMAC = M[r5 + Null];
842022b2:	48 8e       	M[rMAC + 4] = Null;
    base_op_change_response_status(response_data,STATUS_OK);
    return TRUE;
842022b4:	42 20       	r0 = Null + 1;

842022b6 <Lc_aec_reference_stop_reset_6>:
}
842022b6:	f2 48       	popm <FP, r4, r5, rLink>;
842022b8:	d8 4c       	rts;

842022ba <$_aec_reference_update_mic_reference_sync>:
 * aec_reference_update_mic_reference_sync
 * \brief keeps mic and ref syncronised by updatin mic or reference path warp value
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 */
void aec_reference_update_mic_reference_sync( AEC_REFERENCE_OP_DATA * op_extra_data)
{
842022ba:	f5 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>, SP = SP + 0x10;
842022bc:	16 00       	r4 = r0 + Null;
    int mic_ra = 0;
842022be:	02 09       	r8 = Null + Null;
    int spkr_ra = 0;
842022c0:	01 09       	r7 = Null + Null;
    uint32 val;

    /* This is run in main loop, decimate update as it won't be
     * needed to get updated that often
     */
    op_extra_data->ref_update_counter++;
842022c2:	61 f0 d0 88 	rMAC = M[r4 + 832];
842022c6:	49 20       	rMAC = rMAC + 1;
842022c8:	61 f0 d0 8e 	M[r4 + 832] = rMAC;
    if(op_extra_data->ref_update_counter >= AEC_REFERENCE_REF_RATE_UPDATE_PERIOD)
842022cc:	48 26       	Null = rMAC - 9;
842022ce:	a7 64       	if NC jump (m) Lc_aec_reference_update_mic_reference_sync_27;

842022d0 <Lc_aec_reference_update_mic_reference_sync_2>:
    {
        op_extra_data->ref_update_counter = 0;
842022d0:	60 f0 d0 8e 	M[r4 + 832] = Null;
        if(op_extra_data->spkr_rate_enactment == RATEMATCHING_SUPPORT_HW)
842022d4:	61 f0 71 88 	rMAC = M[r4 + 452];
842022d8:	88 24       	Null = rMAC - 2;
842022da:	0e 62       	if NE jump (m) Lc_aec_reference_update_mic_reference_sync_6;

842022dc <Lc_aec_reference_update_mic_reference_sync_3>:
            /* speaker is using HW rate adjustment, read the latest HW warp rate,
             * when using HW rate adjust pretend it is applied in SW and speaker rate
             * itself is perfect.
             * TODO: might need a constant offset for 44.1kHz-like speaker rates
             */
            if(get_override_ep_current_hw_warp(op_extra_data->spkr_endpoint, &val))
842022dc:	c3 11       	r1 = FP + 28;
842022de:	62 f0 80 88 	r0 = M[r4 + 512];
842022e2:	06 f0 21 eb 	call (m) $_get_override_ep_current_hw_warp;
842022e6:	10 04       	Null = r0 - Null;
842022e8:	03 60       	if EQ jump (m) Lc_aec_reference_update_mic_reference_sync_5;

842022ea <Lc_aec_reference_update_mic_reference_sync_4>:
            {
                spkr_ra = (int)val;
842022ea:	e9 f0 07 88 	r7 = M[FP + 28];

842022ee <Lc_aec_reference_update_mic_reference_sync_5>:
            }
            spkr_rt = (1<<STREAM_RATEMATCHING_FIX_POINT_SHIFT);
842022ee:	04 f0 08 f0 	r6 = Null + 4194304;
842022f2:	00 40 
842022f4:	15 6e       	jump (m) Lc_aec_reference_update_mic_reference_sync_9;

842022f6 <Lc_aec_reference_update_mic_reference_sync_6>:
        }
        else
        {
            /* get the latest speaker rate measurement */
            spkr_rt = rate_monitor_op_get_rate(op_extra_data->spkr_rate_monitor_op,0);
842022f6:	62 f0 73 88 	r0 = M[r4 + 460];
842022fa:	03 00       	r1 = Null + Null;
842022fc:	ff fd 4c f3 	call 0x6bbf0;
84202300:	34 e7 
84202302:	10 09       	r6 = r0 + Null;
            if(op_extra_data->spkr_rate_enactment == RATEMATCHING_SUPPORT_SW
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
               /* if using standalone operator, no built-in adjust rate is applied */
               &&(0 == op_extra_data->spkr_ext_rate_adjust_op)
#endif
               )
84202304:	61 f0 71 88 	rMAC = M[r4 + 452];
84202308:	48 24       	Null = rMAC - 1;
8420230a:	0a 62       	if NE jump (m) Lc_aec_reference_update_mic_reference_sync_9;

8420230c <Lc_aec_reference_update_mic_reference_sync_7>:
8420230c:	60 f0 ae 88 	Null = M[r4 + 696];
84202310:	07 62       	if NE jump (m) Lc_aec_reference_update_mic_reference_sync_9;

84202312 <Lc_aec_reference_update_mic_reference_sync_8>:
            {
                /* if SW rate adjustment is used, get the current value */
                spkr_ra = cbops_sra_get_current_rate_adjust(op_extra_data->spkr_sw_rateadj_op);
84202312:	62 f0 7e 88 	r0 = M[r4 + 504];
84202316:	ff fd a4 f0 	call (m) 0x16cba;
8420231a:	25 ed 
8420231c:	11 09       	r7 = r0 + Null;

8420231e <Lc_aec_reference_update_mic_reference_sync_9>:
            }
        }
        if(op_extra_data->mic_rate_enactment == RATEMATCHING_SUPPORT_HW)
8420231e:	61 f0 68 88 	rMAC = M[r4 + 416];
84202322:	88 24       	Null = rMAC - 2;
84202324:	0f 62       	if NE jump (m) Lc_aec_reference_update_mic_reference_sync_13;

84202326 <Lc_aec_reference_update_mic_reference_sync_10>:
            /* MIC is using HW rate adjustment, read the latest HW warp rate,
             * when using HW rate adjust pretend it is applied in SW and mic rate
             * itself is perfect.
             * TODO: might need a constant offset for 44.1khz-like mic rates
             */
            if(get_override_ep_current_hw_warp(op_extra_data->mic_endpoint, &val))
84202326:	c3 11       	r1 = FP + 28;
84202328:	62 f0 7f 88 	r0 = M[r4 + 508];
8420232c:	06 f0 37 e8 	call (m) $_get_override_ep_current_hw_warp;
84202330:	10 04       	Null = r0 - Null;
84202332:	04 60       	if EQ jump (m) Lc_aec_reference_update_mic_reference_sync_12;

84202334 <Lc_aec_reference_update_mic_reference_sync_11>:
            {
                mic_ra = -(int)val;
84202334:	39 d8       	rMAC = M[FP + 28];
84202336:	1f f0 0a c2 	r8 = Null - rMAC;

8420233a <Lc_aec_reference_update_mic_reference_sync_12>:
            }
            mic_rt = (1<<STREAM_RATEMATCHING_FIX_POINT_SHIFT);
8420233a:	04 f0 07 f0 	r5 = Null + 4194304;
8420233e:	00 40 
84202340:	15 6e       	jump (m) Lc_aec_reference_update_mic_reference_sync_16;

84202342 <Lc_aec_reference_update_mic_reference_sync_13>:
        }
        else
        {
            /* get the latest speaker rate measurement */
            mic_rt = rate_monitor_op_get_rate(op_extra_data->mic_rate_monitor_op,0);
84202342:	62 f0 6b 88 	r0 = M[r4 + 428];
84202346:	03 00       	r1 = Null + Null;
84202348:	ff fd 4c f3 	call 0x6bbf0;
8420234c:	28 e5 
8420234e:	17 00       	r5 = r0 + Null;
            if(op_extra_data->mic_rate_enactment == RATEMATCHING_SUPPORT_SW
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
               /* if using standalone operator, no built-in adjust rate is applied */
               &&(0 == op_extra_data->mic_ext_rate_adjust_op)
#endif
               )
84202350:	61 f0 68 88 	rMAC = M[r4 + 416];
84202354:	48 24       	Null = rMAC - 1;
84202356:	0a 62       	if NE jump (m) Lc_aec_reference_update_mic_reference_sync_16;

84202358 <Lc_aec_reference_update_mic_reference_sync_14>:
84202358:	60 f0 ad 88 	Null = M[r4 + 692];
8420235c:	07 62       	if NE jump (m) Lc_aec_reference_update_mic_reference_sync_16;

8420235e <Lc_aec_reference_update_mic_reference_sync_15>:
            {
                mic_ra = cbops_sra_get_current_rate_adjust(op_extra_data->mic_sw_rateadj_op);
8420235e:	62 f0 7d 88 	r0 = M[r4 + 500];
84202362:	ff fd a4 f0 	call (m) 0x16cba;
84202366:	39 ea 
84202368:	12 09       	r8 = r0 + Null;

8420236a <Lc_aec_reference_update_mic_reference_sync_16>:
         *   However to avoid any need to discard/insert in long runs (will cause echo canceller
         *   re-adaptation) we make sure that latency is always tending towards the centre of the
         *   desired range.
         */

        if(op_extra_data->sync_block.block_size != 0)
8420236a:	60 f0 86 88 	Null = M[r4 + 536];
8420236e:	1e 60       	if EQ jump (m) Lc_aec_reference_update_mic_reference_sync_18;

84202370 <Lc_aec_reference_update_mic_reference_sync_17>:
        {
            int ref_mic_delay_to_centre =
                (int) op_extra_data->sync_block.ref_delay +
                (int) (op_extra_data->sync_block.jitter/2) -
                (int) op_extra_data->sync_block.speaker_delay;
84202370:	62 f0 85 88 	r0 = M[r4 + 532];
84202374:	61 f0 8a 88 	rMAC = M[r4 + 552];
84202378:	12 50       	r0 = r0 LSHIFT -1;
8420237a:	51 00       	rMAC = r0 + rMAC;
8420237c:	62 f0 8f 88 	r0 = M[r4 + 572];
84202380:	89 04       	rMAC = rMAC - r0;
            op_extra_data->ref_mic_adj_fix += ref_mic_delay_to_centre * AEC_REFERENCE_REF_MIC_ADJ_COEFF;
84202382:	62 f0 d7 88 	r0 = M[r4 + 860];
84202386:	53 00       	r1 = r0 + rMAC;
84202388:	63 f0 d7 8e 	M[r4 + 860] = r1;
            op_extra_data->ref_mic_adj_fix = pl_min(op_extra_data->ref_mic_adj_fix, AEC_REFERENCE_REF_MIC_ADJ_MAX);
8420238c:	02 f0 d6 40 	r0 = Null + 214;
84202390:	5f f2 43 ce 	r1 = MIN r0;
84202394:	63 f0 d7 8e 	M[r4 + 860] = r1;
            op_extra_data->ref_mic_adj_fix = pl_max(op_extra_data->ref_mic_adj_fix, -AEC_REFERENCE_REF_MIC_ADJ_MAX);
84202398:	63 f0 d7 88 	r1 = M[r4 + 860];
8420239c:	f2 f7 2a 7b 	r0 = Null + -214;
842023a0:	6f f2 43 ce 	r1 = MAX r0;
842023a4:	63 f0 d7 8e 	M[r4 + 860] = r1;
842023a8:	03 6e       	jump (m) Lc_aec_reference_update_mic_reference_sync_19;

842023aa <Lc_aec_reference_update_mic_reference_sync_18>:
        }
        else
        {
            /* Note: REF-MIC latency control is disabled for block_size == 0 */
            op_extra_data->ref_mic_adj_fix = 0;
842023aa:	60 f0 d7 8e 	M[r4 + 860] = Null;

842023ae <Lc_aec_reference_update_mic_reference_sync_19>:
        }

        if(op_extra_data->mic_sync_enable)
842023ae:	60 f0 d4 88 	Null = M[r4 + 848];
842023b2:	22 60       	if EQ jump (m) Lc_aec_reference_update_mic_reference_sync_25;

842023b4 <Lc_aec_reference_update_mic_reference_sync_20>:
        {
            /* if we are syncronising MIC to REF then calculate the rate needs
             * to be applied to the mic path, so it will be syncronised to
             * REFERENCE output(i.e. speaker input)*/
            int new_mic_ra = (int) aecref_calc_sync_mic_rate(spkr_ra,spkr_rt,mic_rt) - op_extra_data->ref_mic_adj_fix;
842023b4:	3c 00       	r2 = r5 + Null;
842023b6:	43 08       	r1 = r6 + Null;
842023b8:	4a 08       	r0 = r7 + Null;
842023ba:	08 f0 23 e1 	call (m) $_aecref_calc_sync_mic_rate;
842023be:	61 f0 d7 88 	rMAC = M[r4 + 860];
842023c2:	57 04       	r5 = r0 - rMAC;
            int diff = new_mic_ra - mic_ra;
842023c4:	af f7 03 c2 	r1 = r5 - r8;
            if(diff != 0)
842023c8:	18 04       	Null = r1 - Null;
842023ca:	13 60       	if EQ jump (m) Lc_aec_reference_update_mic_reference_sync_24;

842023cc <Lc_aec_reference_update_mic_reference_sync_21>:
            {
                if(op_extra_data->mic_rate_enactment == RATEMATCHING_SUPPORT_HW)
842023cc:	61 f0 68 88 	rMAC = M[r4 + 416];
842023d0:	88 24       	Null = rMAC - 2;
842023d2:	07 62       	if NE jump (m) Lc_aec_reference_update_mic_reference_sync_23;

842023d4 <Lc_aec_reference_update_mic_reference_sync_22>:
                {
                    /* HW rate adjustment, apply the change only */
                    set_override_ep_ratematch_adjustment(op_extra_data->mic_endpoint, diff);
842023d4:	62 f0 7f 88 	r0 = M[r4 + 508];
842023d8:	ff fd 13 f0 	call (m) 0x4aa0;
842023dc:	29 e6 
842023de:	09 6e       	jump (m) Lc_aec_reference_update_mic_reference_sync_24;

842023e0 <Lc_aec_reference_update_mic_reference_sync_23>:
                else
                {
                    /* apply new SW rate adjustment */
                    cbops_sra_set_rate_adjust(op_extra_data->mic_sw_rateadj_op,
                                              op_extra_data->num_mic_channels,
                                              new_mic_ra);
842023e0:	63 f0 78 88 	r1 = M[r4 + 480];
842023e4:	62 f0 7d 88 	r0 = M[r4 + 500];
842023e8:	3c 00       	r2 = r5 + Null;
842023ea:	ff fd a4 f0 	call (m) 0x16c9c;
842023ee:	33 e5 

842023f0 <Lc_aec_reference_update_mic_reference_sync_24>:
                }
            }
            op_extra_data->mic_rate_adjustment = new_mic_ra;
842023f0:	67 f0 69 8e 	M[r4 + 420] = r5;
842023f4:	12 6e       	jump (m) Lc_aec_reference_update_mic_reference_sync_26;

842023f6 <Lc_aec_reference_update_mic_reference_sync_25>:
        {

            /* We are synchronising REFERENCE to MIC output,
             * Update reference SW rate adjustment.
             */
            op_extra_data->sync_block.rm_adjustment = (int) aecref_calc_ref_rate(mic_rt,mic_ra,spkr_rt,spkr_ra) + op_extra_data->ref_mic_adj_fix;
842023f6:	4d 08       	r3 = r7 + Null;
842023f8:	44 08       	r2 = r6 + Null;
842023fa:	53 08       	r1 = r8 + Null;
842023fc:	3a 00       	r0 = r5 + Null;
842023fe:	07 f0 37 ed 	call (m) $_aecref_calc_ref_rate;
84202402:	61 f0 d7 88 	rMAC = M[r4 + 860];
84202406:	8c 00       	r2 = rMAC + r0;
84202408:	64 f0 8c 8e 	M[r4 + 560] = r2;

            /* update rate adjust for reference path */
            cbops_sra_set_rate_adjust(op_extra_data->ref_sw_rateadj_op,
                                      1,
                                      op_extra_data->sync_block.rm_adjustment);
8420240c:	43 20       	r1 = Null + 1;
8420240e:	62 f0 90 88 	r0 = M[r4 + 576];
84202412:	ff fd a4 f0 	call (m) 0x16c9c;
84202416:	2b e4 

84202418 <Lc_aec_reference_update_mic_reference_sync_26>:

        }
        /* Clear frm_count to disable backup rate adjustment
         *  when rate adjustment is enacted
         */
        op_extra_data->sync_block.frm_count = 0;
84202418:	60 f0 8b 8e 	M[r4 + 556] = Null;

8420241c <Lc_aec_reference_update_mic_reference_sync_27>:
    }
}
8420241c:	f5 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, rLink>;
8420241e:	d8 4c       	rts;

84202420 <$_aec_reference_update_stream_and_validate_channels>:
 * \param bufval, cbuffer buffer pointer for new connection (NULL for disconnection)
 *
 * \return whether re-validation carried out successfully
 */
bool aec_reference_update_stream_and_validate_channels(OPERATOR_DATA *op_data, tCbuffer **bufp, tCbuffer *bufval)
{
84202420:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
84202422:	16 00       	r4 = r0 + Null;
84202424:	1f 00       	r5 = r1 + Null;
84202426:	20 09       	r6 = r2 + Null;
/****************************************************************************
Private Function Declarations
*/
static inline AEC_REFERENCE_OP_DATA *get_instance_data(OPERATOR_DATA *op_data)
{
    return (AEC_REFERENCE_OP_DATA *) op_data->extra_op_data;
84202428:	31 99       	rMAC = M[r4 + 48];
    patch_fn_shared(aec_reference);

    AEC_REFERENCE_OP_DATA *op_extra_data = get_instance_data(op_data);

    /* if operator isn't running just set the stream buffer and exit */
    if (op_data->state != OP_RUNNING)
8420242a:	32 b0       	r0 = MBS[r4 + 24];
8420242c:	07 60       	if EQ jump (m) Lc_aec_reference_update_stream_and_validate_channels_5;

8420242e <Lc_aec_reference_update_stream_and_validate_channels_2>:
    {
        if(bufp != NULL)
8420242e:	38 04       	Null = r5 - Null;
84202430:	03 60       	if EQ jump (m) Lc_aec_reference_update_stream_and_validate_channels_4;

84202432 <Lc_aec_reference_update_stream_and_validate_channels_3>:
        {
            *bufp = bufval;
84202432:	78 f0 00 ee 	M[r5 + Null] = r6;

84202436 <Lc_aec_reference_update_stream_and_validate_channels_4>:
        }

        return TRUE;
84202436:	42 20       	r0 = Null + 1;
84202438:	17 6e       	jump (m) Lc_aec_reference_update_stream_and_validate_channels_10;

8420243a <Lc_aec_reference_update_stream_and_validate_channels_5>:
    }

    /* block interrupts if the op has a runnig task */
    bool interrupts_blocked = FALSE;
8420243a:	01 09       	r7 = Null + Null;
    if(op_extra_data->kick_id != TIMER_ID_INVALID)
8420243c:	10 f0 5d 88 	Null = M[rMAC + 372];
84202440:	05 60       	if EQ jump (m) Lc_aec_reference_update_stream_and_validate_channels_7;

84202442 <Lc_aec_reference_update_stream_and_validate_channels_6>:
    {
        LOCK_INTERRUPTS;
84202442:	ff fd 54 f1 	call (m) 0x2cc9c;
84202446:	3b e2 
        interrupts_blocked = TRUE;
84202448:	09 71       	r7 = Null + 1;

8420244a <Lc_aec_reference_update_stream_and_validate_channels_7>:
    }

    /* set the stream buffer */
    if(bufp != NULL)
8420244a:	38 04       	Null = r5 - Null;
8420244c:	03 60       	if EQ jump (m) Lc_aec_reference_update_stream_and_validate_channels_9;

8420244e <Lc_aec_reference_update_stream_and_validate_channels_8>:
    {
        *bufp = bufval;
8420244e:	78 f0 00 ee 	M[r5 + Null] = r6;

84202452 <Lc_aec_reference_update_stream_and_validate_channels_9>:
    }

    /* revisit the graphs based on latest connections */
    bool retval = validate_channels_and_build(op_data);
84202452:	32 00       	r0 = r4 + Null;
84202454:	fa ff 37 e8 	call (m) $_validate_channels_and_build;
84202458:	16 00       	r4 = r0 + Null;
8420245a:	0f f9 00 c2 	Null = r7 - Null;
8420245e:	f1 fd 54 f1 	if NE call (m) 0x2ccb8;
84202462:	3b e2 
    if(interrupts_blocked)
    {
        UNLOCK_INTERRUPTS;
    }

    return retval;
84202464:	32 00       	r0 = r4 + Null;

84202466 <Lc_aec_reference_update_stream_and_validate_channels_10>:
}
84202466:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84202468:	d8 4c       	rts;

8420246a <$_build_sidetone_graph>:
 * \brief updates speaker graph to include/exclude side tone mixing
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 */
bool build_sidetone_graph(AEC_REFERENCE_OP_DATA* op_extra_data)
{
8420246a:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
8420246c:	16 00       	r4 = r0 + Null;
    tCbuffer *mic_buf = op_extra_data->input_stream[AEC_REF_MIC_TERMINAL1];
8420246e:	b7 88       	r5 = M[r4 + 8];
    unsigned* idxs;
    unsigned num_io = 2;
84202470:	10 71       	r6 = Null + 2;
    cbops_graph *sidetone_graph;
    cbops_op *op_ptr;
    cbops_op *override_op_ptr;
    unsigned st_mic_idx = 0;          /* buffer index for mic input */
    unsigned st_filter_out_idx = 1;   /* buffer index for sidetone filter output */
    unsigned resampler_out_idx = 0;   /* buffer index for output of possible resampler */
84202472:	40 de       	M[FP + 32] = Null;
    unsigned sidetone_idx = st_filter_out_idx; /* buffer index for sidetone buffer */
84202474:	0a 71       	r8 = Null + 1;
    unsigned sidetone_buf_size;
    unsigned spkr_threshold = frac_mult(op_extra_data->spkr_rate, op_extra_data->kick_period_frac)+1;
84202476:	62 f0 6e 88 	r0 = M[r4 + 440];
8420247a:	63 f0 96 88 	r1 = M[r4 + 600];
8420247e:	00 f3 72 c9 	r0 = r0 * r1 (frac);
84202482:	51 20       	rMAC = r0 + 1;
84202484:	49 de       	M[FP + 36] = rMAC;
    unsigned safety_threshold;
    unsigned spkr_channel_status = GetSpkrChannelStatus(op_extra_data);
84202486:	61 f0 76 88 	rMAC = M[r4 + 472];
8420248a:	19 f1 f0 1f 	r7 = rMAC AND 0x3ff0;
    unsigned num_sidetone_spkrs = 1;
8420248e:	53 09       	r9 = r8 + Null;
     * --------------------------------------------------------------------------------------------------*/

    patch_fn_shared(aec_reference);

    /* destroy cbops graph if already running */
    if(NULL != op_extra_data->sidetone_graph)
84202490:	61 f0 99 88 	rMAC = M[r4 + 612];
84202494:	03 60       	if EQ jump (m) Lc_build_sidetone_graph_3;

84202496 <Lc_build_sidetone_graph_2>:
    {
        aec_reference_cleanup_sidetone_graph(op_extra_data);
84202496:	32 00       	r0 = r4 + Null;
84202498:	f9 4e       	call (m) $_aec_reference_cleanup_sidetone_graph;

8420249a <Lc_build_sidetone_graph_3>:
    }

    /* see if we need to setup a separate graph for sidetone mixing */
    if(op_extra_data->sidetone_method != AEC_SIDETONE_IN_SW_USING_SEPARATE_GRAPH)
8420249a:	61 f0 70 90 	rMAC = MBS[r4 + 624];
8420249e:	c8 24       	Null = rMAC - 3;
842024a0:	e1 62       	if NE jump (m) Lc_build_sidetone_graph_25;

842024a2 <Lc_build_sidetone_graph_4>:
    }

    DEBUG_GRAPHS("AEC_REFERENCE: Building sidetone graph ...");

    /* Determine number of speakers to have sidetone */
    if((spkr_channel_status&AEC_REFERENCE_CONSTANT_CONN_TYPE_PARA) == 0)
842024a2:	91 f0 00 10 	rMAC = r7 AND 0x1000;
842024a6:	05 62       	if NE jump (m) Lc_build_sidetone_graph_7;

842024a8 <Lc_build_sidetone_graph_5>:
    {
        if((spkr_channel_status&AEC_REFERENCE_CONSTANT_CONN_TYPE_MIX) == 0)
842024a8:	91 f1 00 00 	rMAC = r7 AND 0x2000;
842024ac:	02 62       	if NE jump (m) Lc_build_sidetone_graph_7;

842024ae <Lc_build_sidetone_graph_6>:
        {
            /* mono to stereo, mix to both */
            num_sidetone_spkrs = 2;
842024ae:	43 09       	r9 = r6 + Null;

842024b0 <Lc_build_sidetone_graph_7>:
        }
    }

    /* limit to available speakers */
    num_sidetone_spkrs = MIN(num_sidetone_spkrs, op_extra_data->num_spkr_channels);
842024b0:	61 f0 77 88 	rMAC = M[r4 + 476];
842024b4:	1f fb 00 c2 	Null = r9 - rMAC;
842024b8:	02 64       	if NC jump (m) Lc_build_sidetone_graph_9;

842024ba <Lc_build_sidetone_graph_8>:
842024ba:	0b 09       	r9 = rMAC + Null;

842024bc <Lc_build_sidetone_graph_9>:

    /* we don't expect Sidetone buffer already existing at this point */
    PL_ASSERT(op_extra_data->sidetone_buf == NULL);
842024bc:	61 f0 31 88 	rMAC = M[r4 + 196];
842024c0:	d3 60       	if EQ jump (m) Lc_build_sidetone_graph_26;

842024c2 <Lc_build_sidetone_graph_10>:
842024c2:	03 f0 bb 41 	r1 = Null + 443;
842024c6:	02 f0 13 60 	r0 = Null + 4115;
842024ca:	ff fd 8d f0 	call (m) 0x13f12;
842024ce:	29 e2 
842024d0:	db 6e       	jump (m) Lc_build_sidetone_graph_30;

842024d2 <Lc_build_sidetone_graph_11>:
    /* Allocate Buffer for sidetone samples,
     * size = sidetone_task_period + 1ms for latency control
     */
    sidetone_buf_size = frac_mult(op_extra_data->spkr_rate,
                                  op_extra_data->kick_period_frac +
                                  FRACTIONAL(0.001));
842024d2:	62 f0 6e 88 	r0 = M[r4 + 440];
842024d6:	61 f0 96 88 	rMAC = M[r4 + 600];
842024da:	83 f0 13 f0 	r1 = rMAC + 2147483;
842024de:	9b 28 
842024e0:	00 f3 72 c9 	r0 = r0 * r1 (frac);

    op_extra_data->sidetone_buf = cbuffer_create_with_malloc_fast(sidetone_buf_size, BUF_DESC_SW_BUFFER);
842024e4:	03 00       	r1 = Null + Null;
842024e6:	ff fd 81 f0 	call (m) 0x1279c;
842024ea:	37 e5 
842024ec:	62 f0 31 8e 	M[r4 + 196] = r0;
    if(!op_extra_data->sidetone_buf)
842024f0:	61 f0 31 88 	rMAC = M[r4 + 196];
842024f4:	c8 60       	if EQ jump (m) Lc_build_sidetone_graph_29;

842024f6 <Lc_build_sidetone_graph_12>:
    }

    /* create clone cbuffers for mic buffer */
    op_extra_data->sidetone_mic_buf = cbuffer_create(mic_buf->base_addr,
                                                     cbuffer_get_size_in_words(mic_buf),
                                                     BUF_DESC_SW_BUFFER);
842024f6:	3a 00       	r0 = r5 + Null;
842024f8:	ff fd 81 f0 	call (m) 0x12858;
842024fc:	21 eb 
842024fe:	13 00       	r1 = r0 + Null;
84202500:	fa 88       	r0 = M[r5 + 12];
84202502:	04 00       	r2 = Null + Null;
84202504:	ff fd 81 f0 	call (m) 0x12762;
84202508:	3f e2 
8420250a:	62 f0 9a 8e 	M[r4 + 616] = r0;
    if(op_extra_data->sidetone_mic_buf == NULL)
8420250e:	61 f0 9a 88 	rMAC = M[r4 + 616];
84202512:	b9 60       	if EQ jump (m) Lc_build_sidetone_graph_29;

84202514 <Lc_build_sidetone_graph_13>:
        return FALSE;
    }


    /* do we need resampler for side tone generation */
    if(op_extra_data->spkr_rate != op_extra_data->mic_rate)
84202514:	61 f0 6e 88 	rMAC = M[r4 + 440];
84202518:	62 f0 66 88 	r0 = M[r4 + 408];
8420251c:	88 04       	Null = rMAC - r0;
8420251e:	05 60       	if EQ jump (m) Lc_build_sidetone_graph_15;

84202520 <Lc_build_sidetone_graph_14>:
    {
        /* Extra buffer needed between sidetone filter and resampler,
         * as resampler can't work in-place
         */
        num_io++;
84202520:	18 71       	r6 = Null + 3;
        resampler_out_idx = st_filter_out_idx + 1;
84202522:	81 20       	rMAC = Null + 2;
84202524:	41 de       	M[FP + 32] = rMAC;
        sidetone_idx++;
84202526:	0a 09       	r8 = rMAC + Null;

84202528 <Lc_build_sidetone_graph_15>:

    /* create indexes for cbops buffers,
     * this needs to be deleted before leaving
     * this function.
     */
    idxs = create_default_indexes(num_io);
84202528:	42 08       	r0 = r6 + Null;
8420252a:	ff fd a4 f0 	call (m) 0x16f08;
8420252e:	3f ee 
84202530:	11 09       	r7 = r0 + Null;
    if(idxs == NULL)
84202532:	a9 60       	if EQ jump (m) Lc_build_sidetone_graph_29;

84202534 <Lc_build_sidetone_graph_16>:
    {
        return(FALSE);
    }

    /* Allocate sidetone graph */
    sidetone_graph = cbops_alloc_graph(num_io);
84202534:	42 08       	r0 = r6 + Null;
84202536:	ff fd a4 f0 	call (m) 0x16d76;
8420253a:	21 e2 
8420253c:	10 09       	r6 = r0 + Null;
    if(!sidetone_graph)
8420253e:	9f 60       	if EQ jump (m) Lc_build_sidetone_graph_28;

84202540 <Lc_build_sidetone_graph_17>:
    {
        goto aFailed;
    }
    op_extra_data->sidetone_graph = sidetone_graph;
84202540:	68 f0 99 8e 	M[r4 + 612] = r6;

    /* set mic input buffer */
    cbops_set_input_io_buffer(sidetone_graph,
                              st_mic_idx,
                              st_mic_idx,
                              op_extra_data->sidetone_mic_buf);
84202544:	65 f0 9a 88 	r3 = M[r4 + 616];
84202548:	04 00       	r2 = Null + Null;
8420254a:	03 00       	r1 = Null + Null;
8420254c:	ff fd a4 f0 	call (m) 0x16e02;
84202550:	37 e5 
     * into speakers by override operator)
     */
    cbops_set_output_io_buffer(sidetone_graph,
                               sidetone_idx,
                               sidetone_idx,
                               op_extra_data->sidetone_buf);
84202552:	65 f0 31 88 	r3 = M[r4 + 196];
84202556:	54 08       	r2 = r8 + Null;
84202558:	53 08       	r1 = r8 + Null;
8420255a:	42 08       	r0 = r6 + Null;
8420255c:	ff fd a4 f0 	call (m) 0x16e34;
84202560:	39 e6 
      Note:  Sidetone is before resampler.
      Better solution is to place it at lowest sample rate
    */
    op_ptr = create_sidetone_filter_op(st_mic_idx, st_filter_out_idx, 3,
                                       (cbops_sidetone_params*)&op_extra_data->params.OFFSET_ST_CLIP_POINT,
                                       (void*)&op_extra_data->params.OFFSET_ST_PEQ_CONFIG);
84202562:	01 f0 0c ff 	push r4 + 268;
84202566:	16 cf 
84202568:	65 f0 f0 20 	r3 = r4 + 240;
8420256c:	c4 20       	r2 = Null + 3;
8420256e:	43 20       	r1 = Null + 1;
84202570:	02 00       	r0 = Null + Null;
84202572:	04 f0 27 e4 	call (m) $_create_sidetone_filter_op;
84202576:	7f 4c       	SP = SP + -4;
    op_extra_data->mic_sidetone_op = op_ptr;
    if(!op_ptr)
84202578:	62 f0 6c 8e 	M[r4 + 432] = r0;
8420257c:	80 60       	if EQ jump (m) Lc_build_sidetone_graph_28;

8420257e <Lc_build_sidetone_graph_18>:
    {
        goto aFailed;
    }
    cbops_append_operator_to_graph(sidetone_graph,op_ptr);
8420257e:	13 00       	r1 = r0 + Null;
84202580:	42 08       	r0 = r6 + Null;
84202582:	ff fd a4 f0 	call (m) 0x16e96;
84202586:	35 e8 

    /* DC remove on sidetone */
    op_ptr = create_dc_remove_op(1, &idxs[st_filter_out_idx], &idxs[st_filter_out_idx]);
84202588:	94 f0 04 20 	r2 = r7 + 4;
8420258c:	93 f0 04 20 	r1 = r7 + 4;
84202590:	42 20       	r0 = Null + 1;
84202592:	ff fd 1c f1 	call (m) 0x25e40;
84202596:	2f e5 
    if(!op_ptr)
84202598:	10 04       	Null = r0 - Null;
8420259a:	71 60       	if EQ jump (m) Lc_build_sidetone_graph_28;

8420259c <Lc_build_sidetone_graph_19>:
    {
        goto aFailed;
    }
    cbops_append_operator_to_graph(sidetone_graph, op_ptr);
8420259c:	13 00       	r1 = r0 + Null;
8420259e:	42 08       	r0 = r6 + Null;
842025a0:	ff fd a4 f0 	call (m) 0x16e96;
842025a4:	37 e7 

    /* see if we need resampler in sidetone path */
    if(resampler_out_idx != 0)
842025a6:	41 d8       	rMAC = M[FP + 32];
842025a8:	29 60       	if EQ jump (m) Lc_build_sidetone_graph_22;

842025aa <Lc_build_sidetone_graph_20>:
    {
        /* sidetone filter will write into scratch buff */
        cbops_set_internal_io_buffer(sidetone_graph,
                                     st_filter_out_idx,
                                     st_filter_out_idx,
                                     op_extra_data->scratch_bufs[0]);
842025aa:	65 f0 21 88 	r3 = M[r4 + 132];
842025ae:	44 20       	r2 = Null + 1;
842025b0:	23 00       	r1 = r2 + Null;
842025b2:	42 08       	r0 = r6 + Null;
842025b4:	ff fd a4 f0 	call (m) 0x16e66;
842025b8:	33 e5 
                                           &idxs[st_filter_out_idx],
                                           &idxs[resampler_out_idx],
                                           op_extra_data->mic_rate,
                                           op_extra_data->spkr_rate,
                                           op_extra_data->resampler_temp_buffer_size,
                                           op_extra_data->resampler_temp_buffer, 0, 0, 0);
842025ba:	00 f0 30 cf 	push Null;
842025be:	00 f0 30 cf 	push Null;
842025c2:	00 f0 30 cf 	push Null;
842025c6:	61 f0 32 88 	rMAC = M[r4 + 200];
842025ca:	09 1c       	pushm <rMAC>;
842025cc:	61 f0 91 88 	rMAC = M[r4 + 580];
842025d0:	09 1c       	pushm <rMAC>;
842025d2:	61 f0 6e 88 	rMAC = M[r4 + 440];
842025d6:	09 1c       	pushm <rMAC>;
842025d8:	65 f0 66 88 	r3 = M[r4 + 408];
842025dc:	94 f0 08 20 	r2 = r7 + 8;
842025e0:	93 f0 04 20 	r1 = r7 + 4;
842025e4:	42 20       	r0 = Null + 1;
842025e6:	04 f0 21 e3 	call (m) $_create_iir_resamplerv2_op;
842025ea:	7a 4c       	SP = SP + -24;
        if(!op_ptr)
842025ec:	10 04       	Null = r0 - Null;
842025ee:	47 60       	if EQ jump (m) Lc_build_sidetone_graph_28;

842025f0 <Lc_build_sidetone_graph_21>:
        {
            goto aFailed;
        }
        cbops_append_operator_to_graph(sidetone_graph,op_ptr);
842025f0:	13 00       	r1 = r0 + Null;
842025f2:	42 08       	r0 = r6 + Null;
842025f4:	ff fd a4 f0 	call (m) 0x16e96;
842025f8:	23 e5 

842025fa <Lc_build_sidetone_graph_22>:
    op_ptr = create_sink_overflow_disgard_op(1,                   /* number of channels */
                                             &idxs[sidetone_idx], /* buffer indexes */
                                             /* Minimum space needed in buffer at the beginning of
                                              * process, if not enough space this op will discard some
                                              * samples to free space for new incoming mic sapmples */
                                             spkr_threshold);
842025fa:	01 fa d2 c8 	r0 = r8 LSHIFT 2;
842025fe:	49 08       	rMAC = r7 + Null;
84202600:	51 00       	rMAC = r0 + rMAC;
84202602:	0f 00       	r5 = rMAC + Null;
84202604:	42 20       	r0 = Null + 1;
84202606:	3b 00       	r1 = r5 + Null;
84202608:	4c d8       	r2 = M[FP + 36];
8420260a:	ff fd 4b f1 	call (m) 0x2bdc4;
8420260e:	3b ed 
#if defined(IO_DEBUG)
    st_disgard_op = op_ptr;
84202610:	e0 f0 02 f0 	M[Null + $_st_disgard_op] = r0;
84202614:	5d 8e 
#endif

    if(!op_ptr)
84202616:	10 04       	Null = r0 - Null;
84202618:	32 60       	if EQ jump (m) Lc_build_sidetone_graph_28;

8420261a <Lc_build_sidetone_graph_23>:
    {
        goto aFailed;
    }
    cbops_append_operator_to_graph(sidetone_graph,op_ptr);
8420261a:	13 00       	r1 = r0 + Null;
8420261c:	42 08       	r0 = r6 + Null;
8420261e:	ff fd a4 f0 	call (m) 0x16e96;
84202622:	39 e3 
     */

    /* safety_threshold, this is a small safety zone to make sure
     * sidetone mixing is ahead of reading by HW, (1/4 of a ms)
     */
    safety_threshold = frac_mult(op_extra_data->spkr_rate, FRACTIONAL(0.00025))+1;
84202624:	62 f0 6e 88 	r0 = M[r4 + 440];
84202628:	00 f0 13 f4 	r1 = Null + 536870;
8420262c:	26 61 
8420262e:	00 f3 72 c9 	r0 = r0 * r1 (frac);
84202632:	51 20       	rMAC = r0 + 1;
        &op_extra_data->output_stream[AEC_REF_SPKR_TERMINAL1], /* spkr mmu buffer(s) */
        num_sidetone_spkrs,                                 /* number of speaker(s) */
        &idxs[sidetone_idx],                                /* indexes for sidetone buffer */
        spkr_threshold,                                     /* speaker threshold */
        safety_threshold                                    /* safety threshold */
                                                );
84202634:	09 1c       	pushm <rMAC>;
84202636:	49 d8       	rMAC = M[FP + 36];
84202638:	08 f0 42 e0 	pushm <rMAC, r5>;
8420263c:	64 f0 44 20 	r2 = r4 + 68;
84202640:	b2 88       	r0 = M[r4 + 8];
84202642:	03 00       	r1 = Null + Null;
84202644:	5d 08       	r3 = r9 + Null;
84202646:	03 f0 3d e2 	call (m) $_create_aec_ref_sidetone_op;
8420264a:	7d 4c       	SP = SP + -12;
    if(!override_op_ptr)
8420264c:	10 04       	Null = r0 - Null;
8420264e:	17 60       	if EQ jump (m) Lc_build_sidetone_graph_28;

84202650 <Lc_build_sidetone_graph_24>:
    {
        goto aFailed;
    }
    cbops_set_override_operator(sidetone_graph, override_op_ptr);
84202650:	13 00       	r1 = r0 + Null;
84202652:	42 08       	r0 = r6 + Null;
84202654:	ff fd a4 f0 	call (m) 0x16ec2;
84202658:	2f e3 

    DEBUG_GRAPHS("AEC REFERENCE: Building sidetone graph, Done!");
    pfree(idxs);
8420265a:	4a 08       	r0 = r7 + Null;
8420265c:	ff fd 14 f0 	call (m) 0x4f62;
84202660:	27 e8 

84202662 <Lc_build_sidetone_graph_25>:
    }

    /* see if we need to setup a separate graph for sidetone mixing */
    if(op_extra_data->sidetone_method != AEC_SIDETONE_IN_SW_USING_SEPARATE_GRAPH)
    {
        return TRUE;
84202662:	42 20       	r0 = Null + 1;
84202664:	11 6e       	jump (m) Lc_build_sidetone_graph_30;

84202666 <Lc_build_sidetone_graph_26>:
    /* limit to available speakers */
    num_sidetone_spkrs = MIN(num_sidetone_spkrs, op_extra_data->num_spkr_channels);

    /* we don't expect Sidetone buffer already existing at this point */
    PL_ASSERT(op_extra_data->sidetone_buf == NULL);
    PL_ASSERT(op_extra_data->sidetone_mic_buf == NULL);
84202666:	61 f0 9a 88 	rMAC = M[r4 + 616];
8420266a:	34 61       	if EQ jump (m) Lc_build_sidetone_graph_11;

8420266c <Lc_build_sidetone_graph_27>:
8420266c:	03 f0 bc 41 	r1 = Null + 444;
84202670:	02 f0 13 60 	r0 = Null + 4115;
84202674:	ff fd 8c f0 	call (m) 0x13f12;
84202678:	3f e4 
8420267a:	06 6e       	jump (m) Lc_build_sidetone_graph_30;

8420267c <Lc_build_sidetone_graph_28>:
    pfree(idxs);

    return TRUE;
  aFailed:
    DEBUG_GRAPHS("AEC REFERENCE: Building sidetone graph, Failed!");
    pfree(idxs);
8420267c:	4a 08       	r0 = r7 + Null;
8420267e:	ff fd 14 f0 	call (m) 0x4f62;
84202682:	25 e7 

84202684 <Lc_build_sidetone_graph_29>:
    if(!op_extra_data->sidetone_buf)
    {
        /* Not going ahead with creating sidetone graph if we
         * cannot create shared buffer for sidetone path.
         */
        return FALSE;
84202684:	02 00       	r0 = Null + Null;

84202686 <Lc_build_sidetone_graph_30>:
    return TRUE;
  aFailed:
    DEBUG_GRAPHS("AEC REFERENCE: Building sidetone graph, Failed!");
    pfree(idxs);
    return(FALSE);
}
84202686:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84202688:	d8 4c       	rts;

8420268a <$_aec_reference_cleanup_sidetone_graph>:
 * \brief clean up sidetone graph
 *
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 */
void aec_reference_cleanup_sidetone_graph(AEC_REFERENCE_OP_DATA *op_extra_data)
{
8420268a:	f1 1c       	pushm <FP(=SP), r4, rLink>;
8420268c:	16 00       	r4 = r0 + Null;
    patch_fn_shared(aec_reference);

    /* mic_sidetone_op, no longer is valid` */
    op_extra_data->mic_sidetone_op = NULL;
8420268e:	60 f0 6c 8e 	M[r4 + 432] = Null;

    /* Free cbops sidetone graph */
    if(op_extra_data->sidetone_graph != NULL)
84202692:	62 f0 99 88 	r0 = M[r4 + 612];
84202696:	06 60       	if EQ jump (m) Lc_aec_reference_cleanup_sidetone_graph_3;

84202698 <Lc_aec_reference_cleanup_sidetone_graph_2>:
    {
        destroy_graph(op_extra_data->sidetone_graph);
84202698:	ff fd a3 f0 	call (m) 0x16daa;
8420269c:	33 e8 
        op_extra_data->sidetone_graph = NULL;
8420269e:	60 f0 99 8e 	M[r4 + 612] = Null;

842026a2 <Lc_aec_reference_cleanup_sidetone_graph_3>:
    }

    /* Free Sidetone buffers */
    if(op_extra_data->sidetone_buf != NULL)
842026a2:	62 f0 31 88 	r0 = M[r4 + 196];
842026a6:	06 60       	if EQ jump (m) Lc_aec_reference_cleanup_sidetone_graph_5;

842026a8 <Lc_aec_reference_cleanup_sidetone_graph_4>:
    {
        cbuffer_destroy(op_extra_data->sidetone_buf);
842026a8:	ff fd 80 f0 	call (m) 0x12802;
842026ac:	3b ea 
        op_extra_data->sidetone_buf = NULL;
842026ae:	60 f0 31 8e 	M[r4 + 196] = Null;

842026b2 <Lc_aec_reference_cleanup_sidetone_graph_5>:
    }

    /* free cbuffer structure for clone mic buff */
    if(op_extra_data->sidetone_mic_buf != NULL)
842026b2:	62 f0 9a 88 	r0 = M[r4 + 616];
842026b6:	06 60       	if EQ jump (m) Lc_aec_reference_cleanup_sidetone_graph_7;

842026b8 <Lc_aec_reference_cleanup_sidetone_graph_6>:
    {
        cbuffer_destroy_struct(op_extra_data->sidetone_mic_buf);
842026b8:	ff fd 80 f0 	call (m) 0x12834;
842026bc:	3d eb 
        op_extra_data->sidetone_mic_buf = NULL;
842026be:	60 f0 9a 8e 	M[r4 + 616] = Null;

842026c2 <Lc_aec_reference_cleanup_sidetone_graph_7>:
    }

    DEBUG_GRAPHS("AEC REFERENCE: SIDETONE graph's cleanup done!" );
}
842026c2:	f1 48       	popm <FP, r4, rLink>;
842026c4:	d8 4c       	rts;

842026c6 <Lc_build_mic_graph_is_required_1>:
 */
static bool build_mic_graph_is_required(AEC_REFERENCE_OP_DATA *op_extra_data,
                                        bool sidetone_enabled)
{
    /* check if we have mic config at all */
    if((op_extra_data->channel_status&CHAN_STATE_MIC_MASK) == 0)
842026c6:	21 f0 76 88 	rMAC = M[r0 + 472];
842026ca:	0f f0 14 f8 	r2 = rMAC AND 0x1f000f;
842026ce:	0f 00 
842026d0:	03 62       	if NE jump (m) Lc_build_mic_graph_is_required_3;

842026d2 <Lc_build_mic_graph_is_required_2>:
    {
        /* mic path isn't needed */
        return FALSE;
842026d2:	02 00       	r0 = Null + Null;
842026d4:	12 6e       	jump (m) Lc_build_mic_graph_is_required_8;

842026d6 <Lc_build_mic_graph_is_required_3>:
    }

    /* default: mic path required with output */
    op_extra_data->mic_graph_no_output = FALSE;
842026d6:	20 f0 dd 8e 	M[r0 + 884] = Null;

    if((op_extra_data->channel_status&AEC_REFERENCE_CONSTANT_CONN_MIKE_1_INPUT_ONLY) != 0)
842026da:	08 f0 11 f0 	rMAC = rMAC AND 0x100000;
842026de:	00 00 
842026e0:	0b 60       	if EQ jump (m) Lc_build_mic_graph_is_required_7;

842026e2 <Lc_build_mic_graph_is_required_4>:
        /* This check is only for efficiency, knowing that 1->0 mic config
         * only needed if sidetone is enabled. if sidetone not enabled,
         * or enabled but will be done using separate graph then no need
         * to build mic graph at all.
         */
        if(!sidetone_enabled || op_extra_data->task_decim_factor > 1)
842026e2:	18 04       	Null = r1 - Null;
842026e4:	f7 61       	if EQ jump (m) Lc_build_mic_graph_is_required_2;

842026e6 <Lc_build_mic_graph_is_required_5>:
842026e6:	21 f0 97 88 	rMAC = M[r0 + 604];
842026ea:	48 24       	Null = rMAC - 1;
842026ec:	f8 ff e7 ef 	if HI jump (m) Lc_build_mic_graph_is_required_2;

842026f0 <Lc_build_mic_graph_is_required_6>:
            /* mic path isn't needed */
            return FALSE;
        }

        /* build mic path without output */
        op_extra_data->mic_graph_no_output = TRUE;
842026f0:	41 20       	rMAC = Null + 1;
842026f2:	21 f0 dd 8e 	M[r0 + 884] = rMAC;

842026f6 <Lc_build_mic_graph_is_required_7>:
    }

    return TRUE;
842026f6:	42 20       	r0 = Null + 1;

842026f8 <Lc_build_mic_graph_is_required_8>:
842026f8:	d8 4c       	rts;

842026fa <Lc_build_mic_graph_add_output_subgraph_1>:
static bool build_mic_graph_add_output_subgraph(AEC_REFERENCE_OP_DATA *op_extra_data,
                                                unsigned *idxs,
                                                unsigned intern_idx,
                                                unsigned out_idx,
                                                bool sidetone_enabled)
{
842026fa:	f6 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>, SP = SP + 0x10;
842026fc:	12 09       	r8 = r0 + Null;
842026fe:	43 de       	M[FP + 32] = r1;
84202700:	4c de       	M[FP + 36] = r2;
84202702:	28 09       	r6 = r3 + Null;
84202704:	f9 d9       	rMAC = M[FP + -4];
84202706:	51 de       	M[FP + 40] = rMAC;
    cbops_graph *mic_graph = op_extra_data->mic_graph;
84202708:	ab f0 6a 88 	r9 = M[r8 + 424];
    unsigned num_mics = op_extra_data->num_mic_channels;
8420270c:	a9 f0 78 88 	r7 = M[r8 + 480];
    cbops_op *op_ptr = NULL;
    unsigned i,j;

    /* Setup output Buffers*/
    for(j=0,i=0;(j<MAX_NUMBER_MICS);j++)
84202710:	06 00       	r4 = Null + Null;
84202712:	07 00       	r5 = Null + Null;
84202714:	04 6e       	jump (m) Lc_build_mic_graph_add_output_subgraph_3;

84202716 <Lc_build_mic_graph_add_output_subgraph_2>:
    }
}

inline static unsigned OutputTerminalByIndex(unsigned i)
{
    if(i<4)
84202716:	38 25       	Null = r5 - 4;
84202718:	02 f0 89 e0 	if C jump (m) Lc_build_mic_graph_add_output_subgraph_4;

8420271c <Lc_build_mic_graph_add_output_subgraph_3>:
    {
        return (i + AEC_REF_OUTPUT_TERMINAL1);
8420271c:	fa 20       	r0 = r5 + 3;
8420271e:	02 6e       	jump (m) Lc_build_mic_graph_add_output_subgraph_5;

84202720 <Lc_build_mic_graph_add_output_subgraph_4>:
    }
    else
    {
        return ((i-4) + AEC_REF_OUTPUT_TERMINAL5);
84202720:	7a 22       	r0 = r5 + 9;

84202722 <Lc_build_mic_graph_add_output_subgraph_5>:
    {
        /* MIC outputs may not be consecutive */
        tCbuffer *buffer_ptr_snk = op_extra_data->output_stream[OutputTerminalByIndex(j)];
84202722:	a1 f0 40 20 	rMAC = r8 + 64;
84202726:	52 54       	r0 = r0 LSHIFT 2;
        if(buffer_ptr_snk != NULL)
84202728:	8d e8       	r3 = M[rMAC + r0];
8420272a:	0d 60       	if EQ jump (m) Lc_build_mic_graph_add_output_subgraph_9;

8420272c <Lc_build_mic_graph_add_output_subgraph_6>:
        {
            if(i < num_mics)
8420272c:	9f f6 00 c2 	Null = r4 - r7;
84202730:	02 f0 93 e0 	if C jump (m) Lc_build_mic_graph_add_output_subgraph_8;

84202734 <Lc_build_mic_graph_add_output_subgraph_7>:
            {
                /* Outputs */
                cbops_set_output_io_buffer(mic_graph, out_idx + i, out_idx, buffer_ptr_snk);
84202734:	8f f6 03 c0 	r1 = r4 + r6;
84202738:	44 08       	r2 = r6 + Null;
8420273a:	5a 08       	r0 = r9 + Null;
8420273c:	ff fd a3 f0 	call (m) 0x16e34;
84202740:	39 e7 

84202742 <Lc_build_mic_graph_add_output_subgraph_8>:
            }
            i++;
84202742:	76 20       	r4 = r4 + 1;

84202744 <Lc_build_mic_graph_add_output_subgraph_9>:
    unsigned num_mics = op_extra_data->num_mic_channels;
    cbops_op *op_ptr = NULL;
    unsigned i,j;

    /* Setup output Buffers*/
    for(j=0,i=0;(j<MAX_NUMBER_MICS);j++)
84202744:	7f 20       	r5 = r5 + 1;
84202746:	38 26       	Null = r5 - 8;
84202748:	e7 65       	if NC jump (m) Lc_build_mic_graph_add_output_subgraph_2;

8420274a <Lc_build_mic_graph_add_output_subgraph_10>:
            }
            i++;
        }
    }
    /* expect to have exactly num_mics outputs connected */
    PL_ASSERT(i==num_mics);
8420274a:	9f f6 00 c2 	Null = r4 - r7;
8420274e:	09 60       	if EQ jump (m) Lc_build_mic_graph_add_output_subgraph_12;

84202750 <Lc_build_mic_graph_add_output_subgraph_11>:
84202750:	03 f0 b8 42 	r1 = Null + 696;
84202754:	02 f0 13 60 	r0 = Null + 4115;
84202758:	ff fd 8b f0 	call (m) 0x13f12;
8420275c:	3b ed 
8420275e:	68 6e       	jump (m) Lc_build_mic_graph_add_output_subgraph_26;

84202760 <Lc_build_mic_graph_add_output_subgraph_12>:

    /* Handle output */
    if(op_extra_data->mic_rate!=op_extra_data->output_rate)
84202760:	a5 f0 66 88 	r3 = M[r8 + 408];
84202764:	a1 f0 65 88 	rMAC = M[r8 + 404];
84202768:	68 04       	Null = r3 - rMAC;
8420276a:	21 60       	if EQ jump (m) Lc_build_mic_graph_add_output_subgraph_17;

8420276c <Lc_build_mic_graph_add_output_subgraph_13>:
    {
        /* If only operator then shift input to output */
        unsigned shift_amount = (intern_idx != 0) ? 0 :  op_extra_data->mic_shift;
8420276c:	4a d8       	r0 = M[FP + 36];
8420276e:	03 60       	if EQ jump (m) Lc_build_mic_graph_add_output_subgraph_15;

84202770 <Lc_build_mic_graph_add_output_subgraph_14>:
84202770:	02 00       	r0 = Null + Null;
84202772:	03 6e       	jump (m) Lc_build_mic_graph_add_output_subgraph_16;

84202774 <Lc_build_mic_graph_add_output_subgraph_15>:
84202774:	a2 f0 6d 88 	r0 = M[r8 + 436];

84202778 <Lc_build_mic_graph_add_output_subgraph_16>:
        /*  Add Resampler Operators per channel (mic_rate --> output_rate) */
        op_ptr = create_iir_resamplerv2_op(num_mics,
                                           &idxs[intern_idx], &idxs[out_idx],
                                           op_extra_data->mic_rate,op_extra_data->output_rate,
                                           op_extra_data->resampler_temp_buffer_size,
                                           op_extra_data->resampler_temp_buffer, shift_amount, 0, 0);
84202778:	00 f0 30 cf 	push Null;
8420277c:	00 f0 30 cf 	push Null;
84202780:	11 1c       	pushm <r0>;
84202782:	a2 f0 32 88 	r0 = M[r8 + 200];
84202786:	11 1c       	pushm <r0>;
84202788:	a2 f0 91 88 	r0 = M[r8 + 580];
8420278c:	11 1c       	pushm <r0>;
8420278e:	09 1c       	pushm <rMAC>;
84202790:	01 f8 d2 c8 	r0 = r6 LSHIFT 2;
84202794:	44 d8       	r2 = M[FP + 32];
84202796:	23 00       	r1 = r2 + Null;
84202798:	14 01       	r2 = r0 + r2;
8420279a:	4a d8       	r0 = M[FP + 36];
8420279c:	52 54       	r0 = r0 LSHIFT 2;
8420279e:	d3 00       	r1 = r0 + r1;
842027a0:	4a 08       	r0 = r7 + Null;
842027a2:	03 f0 25 e5 	call (m) $_create_iir_resamplerv2_op;
842027a6:	7a 4c       	SP = SP + -24;
842027a8:	16 00       	r4 = r0 + Null;
842027aa:	11 6e       	jump (m) Lc_build_mic_graph_add_output_subgraph_19;

842027ac <Lc_build_mic_graph_add_output_subgraph_17>:
        {
            return FALSE;
        }
        cbops_append_operator_to_graph(mic_graph,op_ptr);
    }
    else if (sidetone_enabled)
842027ac:	51 d8       	rMAC = M[FP + 40];
842027ae:	1c 60       	if EQ jump (m) Lc_build_mic_graph_add_output_subgraph_23;

842027b0 <Lc_build_mic_graph_add_output_subgraph_18>:
    {
        /* Need to copy internal buffer to output before sidetone */
        op_ptr = create_shift_op(num_mics,&idxs[intern_idx], &idxs[out_idx],0);
842027b0:	01 f8 d2 c8 	r0 = r6 LSHIFT 2;
842027b4:	44 d8       	r2 = M[FP + 32];
842027b6:	05 00       	r3 = Null + Null;
842027b8:	23 00       	r1 = r2 + Null;
842027ba:	14 01       	r2 = r0 + r2;
842027bc:	4a d8       	r0 = M[FP + 36];
842027be:	52 54       	r0 = r0 LSHIFT 2;
842027c0:	d3 00       	r1 = r0 + r1;
842027c2:	4a 08       	r0 = r7 + Null;
842027c4:	ff fd 1b f1 	call (m) 0x25e08;
842027c8:	25 e2 
842027ca:	16 00       	r4 = r0 + Null;

842027cc <Lc_build_mic_graph_add_output_subgraph_19>:
        op_ptr = create_iir_resamplerv2_op(num_mics,
                                           &idxs[intern_idx], &idxs[out_idx],
                                           op_extra_data->mic_rate,op_extra_data->output_rate,
                                           op_extra_data->resampler_temp_buffer_size,
                                           op_extra_data->resampler_temp_buffer, shift_amount, 0, 0);
        if(op_ptr == NULL)
842027cc:	30 04       	Null = r4 - Null;
842027ce:	03 62       	if NE jump (m) Lc_build_mic_graph_add_output_subgraph_21;

842027d0 <Lc_build_mic_graph_add_output_subgraph_20>:
        {
            return FALSE;
842027d0:	02 00       	r0 = Null + Null;
842027d2:	2e 6e       	jump (m) Lc_build_mic_graph_add_output_subgraph_26;

842027d4 <Lc_build_mic_graph_add_output_subgraph_21>:
        }
        cbops_append_operator_to_graph(mic_graph,op_ptr);
842027d4:	33 00       	r1 = r4 + Null;
842027d6:	5a 08       	r0 = r9 + Null;
842027d8:	ff fd a3 f0 	call (m) 0x16e96;
842027dc:	3f e5 
        }
        cbops_append_operator_to_graph(mic_graph,op_ptr);
    }

    /* Handle sidetone */
    if(sidetone_enabled && op_ptr != NULL)
842027de:	51 d8       	rMAC = M[FP + 40];
842027e0:	03 60       	if EQ jump (m) Lc_build_mic_graph_add_output_subgraph_23;

842027e2 <Lc_build_mic_graph_add_output_subgraph_22>:
    {
        /* mic sidetone path will be inserted
         * after this operator so it can do in-place
         * processing.
         */
        op_extra_data->mic_st_point = op_ptr;
842027e2:	a6 f0 dc 8e 	M[r8 + 880] = r4;

842027e6 <Lc_build_mic_graph_add_output_subgraph_23>:
    }

    /* add mute operator, it can be controlled by
     * message to the operator
     */
    op_ptr = create_mute_op(num_mics, &idxs[out_idx]);
842027e6:	01 f8 d2 c8 	r0 = r6 LSHIFT 2;
842027ea:	43 d8       	r1 = M[FP + 32];
842027ec:	d3 00       	r1 = r0 + r1;
842027ee:	4a 08       	r0 = r7 + Null;
842027f0:	07 f0 21 e4 	call (m) $_create_mute_op;
842027f4:	16 00       	r4 = r0 + Null;
    if(!op_ptr)
842027f6:	ed 61       	if EQ jump (m) Lc_build_mic_graph_add_output_subgraph_20;

842027f8 <Lc_build_mic_graph_add_output_subgraph_24>:
    {
        return FALSE;
    }
    cbops_append_operator_to_graph(mic_graph,op_ptr);
842027f8:	33 00       	r1 = r4 + Null;
842027fa:	5a 08       	r0 = r9 + Null;
842027fc:	ff fd a3 f0 	call (m) 0x16e96;
84202800:	3b e4 
    op_extra_data->mic_mute_op = op_ptr;
84202802:	a6 f0 9d 8e 	M[r8 + 628] = r4;
    /* apply user config to mute operator, we don't apply
     * ramping at the beginning, so user can mute right from
     * the beginning.
     */
    cbops_mute_enable(op_extra_data->mic_mute_op, op_extra_data->mic_mute_enable_config, TRUE);
84202806:	44 20       	r2 = Null + 1;
84202808:	a3 f0 de 88 	r1 = M[r8 + 888];
8420280c:	32 00       	r0 = r4 + Null;
8420280e:	03 f0 23 e4 	call (m) $_cbops_mute_enable;

    /* Insert latency operator */
    op_ptr = create_mic_latency_op(out_idx,&op_extra_data->sync_block);
84202812:	a3 f0 14 22 	r1 = r8 + 532;
84202816:	42 08       	r0 = r6 + Null;
84202818:	ff fd 2d f1 	call (m) 0x2822e;
8420281c:	37 e0 
    if(op_ptr == NULL)
8420281e:	10 04       	Null = r0 - Null;
84202820:	d8 61       	if EQ jump (m) Lc_build_mic_graph_add_output_subgraph_20;

84202822 <Lc_build_mic_graph_add_output_subgraph_25>:
    {
        return FALSE;
    }
    cbops_append_operator_to_graph(mic_graph,op_ptr);
84202822:	13 00       	r1 = r0 + Null;
84202824:	5a 08       	r0 = r9 + Null;
84202826:	ff fd a3 f0 	call (m) 0x16e96;
8420282a:	31 e3 

    return TRUE;
8420282c:	42 20       	r0 = Null + 1;

8420282e <Lc_build_mic_graph_add_output_subgraph_26>:
}
8420282e:	f6 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84202830:	d8 4c       	rts;

84202832 <$_create_aec_ref_spkr_op>:

/*
 * create_insert_op
 */
cbops_op* create_aec_ref_spkr_op(unsigned nr_inputs,unsigned* input_idx, unsigned *interm_idxs, unsigned in_threshold,unsigned nr_outputs,unsigned* output_idx,unsigned out_threshold, unsigned max_jitter)
{
84202832:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
84202834:	10 09       	r6 = r0 + Null;
84202836:	19 09       	r7 = r1 + Null;
84202838:	23 09       	r9 = r2 + Null;
8420283a:	2a 09       	r8 = r3 + Null;
8420283c:	ff d9       	r5 = M[FP + -4];
    // cbop param struct size (header plus cbop-specific parameters)
    cbops_op *op = (cbops_op*)xzpmalloc(sizeof_cbops_op(cbops_aec_ref_op, nr_inputs, nr_outputs) +
                                        /* Extend for interim buffers' indexes */
                                        nr_inputs*sizeof(unsigned));
8420283e:	c3 20       	r1 = Null + 3;
84202840:	00 f8 d2 d8 	r0 = r6 LSHIFT 1;
84202844:	ba 00       	r0 = r5 + r0;
84202846:	52 54       	r0 = r0 LSHIFT 2;
84202848:	12 39       	r0 = r0 + 52;
8420284a:	ff fd 13 f0 	call (m) 0x4f2a;
8420284e:	21 e7 
84202850:	16 00       	r4 = r0 + Null;
    if(op)
84202852:	1e 60       	if EQ jump (m) Lc_create_aec_ref_spkr_op_3;

84202854 <Lc_create_aec_ref_spkr_op_2>:
    {
        cbops_aec_ref_op *params;

        /* Setup Operator func table */
        op->function_vector    = cbops_aec_ref_spkr_table;
84202854:	07 f0 01 f0 	rMAC = Null + 7340356;
84202858:	44 41 
8420285a:	b1 8e       	M[r4 + 8] = rMAC;

        /* Setup cbop param struct header info */
        params = (cbops_aec_ref_op*)cbops_populate_param_hdr(op, nr_inputs, nr_outputs, input_idx, output_idx);
8420285c:	f1 d9       	rMAC = M[FP + -8];
8420285e:	09 1c       	pushm <rMAC>;
84202860:	4d 08       	r3 = r7 + Null;
84202862:	3c 00       	r2 = r5 + Null;
84202864:	43 08       	r1 = r6 + Null;
84202866:	ff fd a3 f0 	call (m) 0x16f30;
8420286a:	2b e6 
8420286c:	7f 4c       	SP = SP + -4;
8420286e:	17 00       	r5 = r0 + Null;

        /* Setup cbop-specific parameters - well, just one in this case. Just exemplifies using the
         * generic macro, but in this cbop's case we could get to the param location "directly"
         */
        params->in_threshold  = in_threshold;
84202870:	7a f0 00 ee 	M[r5 + Null] = r8;
        params->max_advance   = out_threshold;
84202874:	e9 d9       	rMAC = M[FP + -12];
84202876:	79 8e       	M[r5 + 4] = rMAC;
        params->max_jitter   = max_jitter;
84202878:	e1 d9       	rMAC = M[FP + -16];
8420287a:	b9 8f       	M[r5 + 24] = rMAC;

        /* copy intermediate idxs */
        memcpy(params->interm_idxs, interm_idxs, sizeof(unsigned)*nr_inputs);
8420287c:	01 f8 d4 c8 	r2 = r6 LSHIFT 2;
84202880:	3a 2b       	r0 = r5 + 28;
84202882:	5b 08       	r1 = r9 + Null;
84202884:	ff fd a4 f0 	call (m) 0x170b8;
84202888:	35 e1 

        params->buffer_adj = 3;
8420288a:	c1 20       	rMAC = Null + 3;
8420288c:	b9 8e       	M[r5 + 8] = rMAC;

8420288e <Lc_create_aec_ref_spkr_op_3>:
    }

    return(op);
8420288e:	32 00       	r0 = r4 + Null;

84202890 <Lc_create_aec_ref_spkr_op_4>:
}
84202890:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84202892:	d8 4c       	rts;

84202894 <$_aec_reference_spkr_ttp_run>:
 * \param op_extra_data Pointer to the AEC reference operator specific data.
 * \param error current TTP error in speaker path
 * \param max_to_process Pointer max amount of data available to process by speaker cbops
 */
void aec_reference_spkr_ttp_run(AEC_REFERENCE_OP_DATA  *op_extra_data, unsigned *max_to_process)
{
84202894:	f5 1d       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>, SP = SP + 0x10;
84202896:	16 00       	r4 = r0 + Null;
84202898:	1a 09       	r8 = r1 + Null;
    TIME_INTERVAL error = 0;
8420289a:	38 de       	M[FP + 28] = Null;
    bool error_valid;
    unsigned amount_can_process = *max_to_process;
8420289c:	a8 f0 00 e8 	r6 = M[r8 + Null];
    /* only used for debug log */
    TIME current_time = hal_get_time();
842028a0:	ff fd 77 f1 	call (m) 0x317e8;
842028a4:	29 ea 
842028a6:	11 09       	r7 = r0 + Null;

    patch_fn_shared(aec_reference_run);

    /* calculate current TTP error */
    error_valid = aec_reference_spkr_ttp_get_error(op_extra_data, &error);
842028a8:	c3 11       	r1 = FP + 28;
842028aa:	32 00       	r0 = r4 + Null;
842028ac:	9d 4e       	call (m) Lc_aec_reference_spkr_ttp_get_error_1;

    /* see if we have received void tags while in TTP mode */
    if(op_extra_data->spkr_void_tag_observed)
842028ae:	60 f0 b5 88 	Null = M[r4 + 724];
842028b2:	0b 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_run_4;

842028b4 <Lc_aec_reference_spkr_ttp_run_2>:
    {
        /* increment a counter, so this shows the time that we have
         * continuously seen void tag
         */
        op_extra_data->spkr_void_tag_counter++;
842028b4:	61 f0 b6 88 	rMAC = M[r4 + 728];
842028b8:	49 20       	rMAC = rMAC + 1;
842028ba:	61 f0 b6 8e 	M[r4 + 728] = rMAC;

        if(op_extra_data->spkr_void_tag_counter == SPKR_TTP_VOID_TAG_COOL_OFF_TIME_MS)
842028be:	88 3c       	Null = rMAC - 50;
842028c0:	06 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_run_5;

842028c2 <Lc_aec_reference_spkr_ttp_run_3>:
             */

            /* error isn't valid anymore, only seeing a timestamp tag will
             * make it valid again
             */
            op_extra_data->spkr_last_timestamp_valid = FALSE;
842028c2:	60 f0 b4 8e 	M[r4 + 720] = Null;
842028c6:	74 6e       	jump (m) Lc_aec_reference_spkr_ttp_run_23;

842028c8 <Lc_aec_reference_spkr_ttp_run_4>:
            error_valid = FALSE;
        }
    }
    else
    {
        op_extra_data->spkr_void_tag_counter = 0;
842028c8:	60 f0 b6 8e 	M[r4 + 728] = Null;

842028cc <Lc_aec_reference_spkr_ttp_run_5>:
    }

    if(!error_valid)
842028cc:	10 04       	Null = r0 - Null;
842028ce:	70 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_run_23;

842028d0 <Lc_aec_reference_spkr_ttp_run_6>:
    L2_DBG_MSG2("AEC REFERENCE SPEAKER: time=%d, ttp error=%d", current_time, error);
#endif

    /* See if the input is too late */
    if(error < -op_extra_data->spkr_error_threshold &&
       amount_can_process > 0)
842028d0:	39 d8       	rMAC = M[FP + 28];
842028d2:	62 f0 b7 88 	r0 = M[r4 + 732];
842028d6:	82 04       	r0 = Null - r0;
842028d8:	88 04       	Null = rMAC - r0;
842028da:	30 66       	if GE jump (m) Lc_aec_reference_spkr_ttp_run_13;

842028dc <Lc_aec_reference_spkr_ttp_run_7>:
842028dc:	0f f8 00 c2 	Null = r6 - Null;
842028e0:	2d 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_run_13;

842028e2 <Lc_aec_reference_spkr_ttp_run_8>:
    {
        /* Calculate how many samples we are late,
         * we discard late samples, as much as available
         */
        unsigned samples_to_trash = convert_time_to_samples((unsigned)(-error), op_extra_data->input_rate);
842028e2:	63 f0 64 88 	r1 = M[r4 + 400];
842028e6:	42 04       	r0 = Null - rMAC;
842028e8:	ff fd 98 f0 	call (m) 0x15932;
842028ec:	2b e2 
842028ee:	13 00       	r1 = r0 + Null;

        /* limit to amount available */
        samples_to_trash = MIN(amount_can_process, samples_to_trash);
842028f0:	2f f8 00 c2 	Null = r6 - r0;
842028f4:	02 f0 e9 e0 	if C jump (m) Lc_aec_reference_spkr_ttp_run_15;

842028f8 <Lc_aec_reference_spkr_ttp_run_9>:
842028f8:	43 08       	r1 = r6 + Null;

842028fa <Lc_aec_reference_spkr_ttp_run_10>:

        if(samples_to_trash > 0)
        {
            /* We have something to trash */
            unsigned samples_trashed = aec_reference_spkr_ttp_discard_samples(op_extra_data,samples_to_trash);
842028fa:	32 00       	r0 = r4 + Null;
842028fc:	ff fd 2d f1 	call (m) 0x284f4;
84202900:	39 ef 
84202902:	17 00       	r5 = r0 + Null;
            L3_DBG_MSG3("AEC REFERENCE SPEAKER TTP - discard samples=%d, time =%d , error=%d",
                        samples_trashed, current_time, error);
84202904:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
84202908:	c8 24       	Null = rMAC - 3;
8420290a:	0a 68       	if LT jump (m) Lc_aec_reference_spkr_ttp_run_12;

8420290c <Lc_aec_reference_spkr_ttp_run_11>:
8420290c:	3d d8       	r3 = M[FP + 28];
8420290e:	55 f1 02 f0 	r0 = Null + 357564977;
84202912:	31 42 
84202914:	4c 08       	r2 = r7 + Null;
84202916:	3b 00       	r1 = r5 + Null;
84202918:	ef fd f0 ff 	call (m) 0x9de;
8420291c:	27 e6 

8420291e <Lc_aec_reference_spkr_ttp_run_12>:

            /* some samples discarded, update error */
            error += convert_samples_to_time(samples_trashed, op_extra_data->input_rate);
8420291e:	63 f0 64 88 	r1 = M[r4 + 400];
84202922:	3a 00       	r0 = r5 + Null;
84202924:	ff fd 97 f0 	call (m) 0x15914;
84202928:	31 ef 
8420292a:	39 d8       	rMAC = M[FP + 28];
8420292c:	51 00       	rMAC = r0 + rMAC;
8420292e:	39 de       	M[FP + 28] = rMAC;

            /* update amount left to process */
            amount_can_process -= samples_trashed;
84202930:	00 f7 38 c2 	r6 = r6 - r5;

            /* ttp play back needs resetting */
            aec_reference_spkr_ttp_reset(op_extra_data);
84202934:	32 00       	r0 = r4 + Null;
84202936:	01 f0 3b e4 	call (m) Lc_aec_reference_spkr_ttp_reset_1;

8420293a <Lc_aec_reference_spkr_ttp_run_13>:
        }
    }

    if (pl_abs_i32(error) < op_extra_data->spkr_error_threshold)
8420293a:	3a d8       	r0 = M[FP + 28];
8420293c:	61 f0 b7 88 	rMAC = M[r4 + 732];
84202940:	4f f2 42 ce 	r0 = ABS r0;
84202944:	50 04       	Null = r0 - rMAC;
84202946:	02 f0 9d e0 	if C jump (m) Lc_aec_reference_spkr_ttp_run_16;

8420294a <Lc_aec_reference_spkr_ttp_run_14>:
    {
        /* This is normal situation, we have on-time input
         * and we can control ttp error
         */
        aec_reference_spkr_ttp_error_control(op_extra_data, error);
8420294a:	3b d8       	r1 = M[FP + 28];
8420294c:	32 00       	r0 = r4 + Null;
8420294e:	01 f0 27 e5 	call (m) Lc_aec_reference_spkr_ttp_error_control_1;

        /* real audio is played, go to higher threshold */
        op_extra_data->spkr_error_threshold = SPKR_TTP_MAX_LATENCY_HIGH_THRESHOLD_US;
84202952:	01 f0 d0 4b 	rMAC = Null + 2000;
84202956:	61 f0 b7 8e 	M[r4 + 732] = rMAC;
8420295a:	28 6e       	jump (m) Lc_aec_reference_spkr_ttp_run_22;

8420295c <Lc_aec_reference_spkr_ttp_run_15>:
        unsigned samples_to_trash = convert_time_to_samples((unsigned)(-error), op_extra_data->input_rate);

        /* limit to amount available */
        samples_to_trash = MIN(amount_can_process, samples_to_trash);

        if(samples_to_trash > 0)
8420295c:	10 04       	Null = r0 - Null;
8420295e:	ce 63       	if NE jump (m) Lc_aec_reference_spkr_ttp_run_10;

84202960 <Lc_4>:
84202960:	ed 6f       	jump (m) Lc_aec_reference_spkr_ttp_run_13;

84202962 <Lc_aec_reference_spkr_ttp_run_16>:
    {
        /* Input is early, so we cannot allow samples from input buffers to be played now
         * instead we need to insert silence until time to play has reached. Silence insertion
         * is managed by cbops, we only tell cbops not to use samples from input buffer.
         */
        unsigned samples_early = convert_time_to_samples((unsigned)(error), op_extra_data->input_rate);
84202962:	63 f0 64 88 	r1 = M[r4 + 400];
84202966:	3a d8       	r0 = M[FP + 28];
84202968:	ff fd 97 f0 	call (m) 0x15932;
8420296c:	2b ee 
        if(samples_early >= op_extra_data->spkr_in_threshold)
8420296e:	63 f0 af 88 	r1 = M[r4 + 700];
84202972:	d0 04       	Null = r0 - r1;
84202974:	03 64       	if NC jump (m) Lc_aec_reference_spkr_ttp_run_18;

84202976 <Lc_aec_reference_spkr_ttp_run_17>:
        {
            /* It's early more than the amount cbops is expected to copy,
             * so allow nothing to copy.
             */
            amount_can_process = 0;
84202976:	00 09       	r6 = Null + Null;
84202978:	07 6e       	jump (m) Lc_aec_reference_spkr_ttp_run_20;

8420297a <Lc_aec_reference_spkr_ttp_run_18>:
        {
            /* It's still early but less than the expected amount, we allow cbops to consume
             * expected amount less the amount early, silence insertion will be used for the amount early.
             * next time we expect to switch to normal TTP playback.
             */
            amount_can_process = MIN(op_extra_data->spkr_in_threshold - samples_early, amount_can_process);
8420297a:	99 04       	rMAC = r1 - r0;
8420297c:	8f f1 00 c2 	Null = rMAC - r6;
84202980:	02 f0 87 e0 	if C jump (m) Lc_aec_reference_spkr_ttp_run_20;

84202984 <Lc_aec_reference_spkr_ttp_run_19>:
84202984:	08 09       	r6 = rMAC + Null;

84202986 <Lc_aec_reference_spkr_ttp_run_20>:
        }

        /* We are not playing real audio, so keep the threshold low */
        op_extra_data->spkr_error_threshold = SPKR_TTP_MAX_LATENCY_LOW_THRESHOLD_US;
84202986:	01 f0 fa 40 	rMAC = Null + 250;
8420298a:	61 f0 b7 8e 	M[r4 + 732] = rMAC;

        L3_DBG_MSG3("AEC REFERENCE SPEAKER TTP: possible silence insertion: time=%d, samples=%d, max_proc=%d",
                    current_time, op_extra_data->spkr_in_threshold-amount_can_process, amount_can_process);
8420298e:	01 f0 28 91 	rMAC = MBS[Null + 0x328];
84202992:	c8 24       	Null = rMAC - 3;
84202994:	0b 68       	if LT jump (m) Lc_aec_reference_spkr_ttp_run_22;

84202996 <Lc_aec_reference_spkr_ttp_run_21>:
84202996:	8f f3 04 c2 	r2 = r1 - r6;
8420299a:	55 f1 02 f0 	r0 = Null + 357565045;
8420299e:	75 42 
842029a0:	45 08       	r3 = r6 + Null;
842029a2:	4b 08       	r1 = r7 + Null;
842029a4:	ef fd f0 ff 	call (m) 0x9de;
842029a8:	3b e1 

842029aa <Lc_aec_reference_spkr_ttp_run_22>:

    }

    /* update amount to process */
    *max_to_process = amount_can_process;
842029aa:	a8 f0 00 ee 	M[r8 + Null] = r6;

842029ae <Lc_aec_reference_spkr_ttp_run_23>:
    return;
}
842029ae:	f5 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, r8, rLink>;
842029b0:	d8 4c       	rts;

842029b2 <$_aec_reference_spkr_ttp_init>:
842029b2:	d8 4c       	rts;

842029b4 <$_aec_reference_spkr_ttp_update_last_timestamp>:
 *        stamp associated with last consumed sample.
 * \param op_extra_data pointer to AEC_REFERENCE_OP_DATA data
 * \param amount_read amount read from input buffer
 */
void aec_reference_spkr_ttp_update_last_timestamp(AEC_REFERENCE_OP_DATA   *op_extra_data, unsigned amount_read)
{
842029b4:	f1 1c       	pushm <FP(=SP), r4, rLink>;
842029b6:	16 00       	r4 = r0 + Null;
842029b8:	1a 00       	r0 = r1 + Null;
    if(op_extra_data->spkr_last_timestamp_valid)
842029ba:	60 f0 b4 88 	Null = M[r4 + 720];
842029be:	0b 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_update_last_timestamp_3;

842029c0 <Lc_aec_reference_spkr_ttp_update_last_timestamp_2>:
    {
        /* work out time stamp for next input block for the just read block,
         * TODO_AEC_REFERENCE_TTP: for further accuracy we could consider the tag sp_adjust as well */
        TIME_INTERVAL time_passed = convert_samples_to_time(amount_read, op_extra_data->input_rate);
842029c0:	63 f0 64 88 	r1 = M[r4 + 400];
842029c4:	ff fd 97 f0 	call (m) 0x15914;
842029c8:	31 ea 
        op_extra_data->spkr_last_timestamp = time_add(op_extra_data->spkr_last_timestamp, time_passed);
842029ca:	61 f0 b3 88 	rMAC = M[r4 + 716];
842029ce:	51 00       	rMAC = r0 + rMAC;
842029d0:	61 f0 b3 8e 	M[r4 + 716] = rMAC;

842029d4 <Lc_aec_reference_spkr_ttp_update_last_timestamp_3>:
    }
}
842029d4:	f1 48       	popm <FP, r4, rLink>;
842029d6:	d8 4c       	rts;

842029d8 <$_aec_reference_spkr_ttp_terminate>:
 */
void aec_reference_spkr_ttp_terminate(AEC_REFERENCE_OP_DATA  *op_extra_data)
{
    patch_fn_shared(aec_reference);

    op_extra_data->spkr_timed_playback_mode = FALSE;
842029d8:	20 f0 b2 8e 	M[r0 + 712] = Null;
    op_extra_data->spkr_last_timestamp_valid = 0;
842029dc:	20 f0 b4 8e 	M[r0 + 720] = Null;
    op_extra_data->spkr_void_tag_counter = 0;
842029e0:	20 f0 b6 8e 	M[r0 + 728] = Null;

842029e4 <Lc_aec_reference_spkr_ttp_terminate_2>:
842029e4:	d8 4c       	rts;

842029e6 <Lc_aec_reference_spkr_ttp_get_error_1>:
 *        and (estimated) actual playback time. So the error will be
 *        positive if ttp is later than actual playback time.
 * return whether the error is valid
 */
static bool aec_reference_spkr_ttp_get_error(AEC_REFERENCE_OP_DATA *op_extra_data, TIME_INTERVAL *error)
{
842029e6:	f4 1d       	pushm <FP(=SP), r4, r5, r6, r7, rLink>, SP = SP + 0x10;
842029e8:	16 00       	r4 = r0 + Null;
842029ea:	18 09       	r6 = r1 + Null;
    /* see if we have valid metadata buffer */
    tCbuffer *met_buf = op_extra_data->spkr_input_metadata_buffer;
    patch_fn_shared(aec_reference_run);

    if (met_buf!= NULL && buff_has_metadata(met_buf))
842029ec:	62 f0 c9 88 	r0 = M[r4 + 804];
842029f0:	97 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_24;

842029f2 <Lc_aec_reference_spkr_ttp_get_error_2>:
842029f2:	51 89       	rMAC = M[r0 + 20];
842029f4:	49 c6       	rMAC = rMAC AND 0x8000;
842029f6:	94 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_24;

842029f8 <Lc_aec_reference_spkr_ttp_get_error_3>:
    {
        /* see if input has a timestamped tag */
        unsigned b4idx = 0;
842029f8:	30 de       	M[FP + 24] = Null;
        metadata_tag *mtag = buff_metadata_peek_ex(met_buf, &b4idx);
842029fa:	83 11       	r1 = FP + 24;
842029fc:	ff fd 79 f0 	call (m) 0x11cd8;
84202a00:	3d e6 
84202a02:	17 00       	r5 = r0 + Null;

        if(mtag != NULL)
84202a04:	5f 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_19;

84202a06 <Lc_aec_reference_spkr_ttp_get_error_4>:
        {
            if(IS_TIMESTAMPED_TAG(mtag))
84202a06:	79 88       	rMAC = M[r5 + 4];
84202a08:	12 f0 30 00 	r0 = rMAC AND 0x30;
84202a0c:	4e 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_15;

84202a0e <Lc_aec_reference_spkr_ttp_get_error_5>:
84202a0e:	ca c2       	r0 = rMAC AND 0x40;
84202a10:	4c 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_get_error_15;

84202a12 <Lc_aec_reference_spkr_ttp_get_error_6>:
            {
                unsigned *err_offset_id;
                unsigned out_length;

                /* go back to first input sample */
                TIME_INTERVAL time_back = convert_samples_to_time(b4idx / OCTETS_PER_SAMPLE, op_extra_data->input_rate);
84202a12:	63 f0 64 88 	r1 = M[r4 + 400];
84202a16:	32 d8       	r0 = M[FP + 24];
84202a18:	52 50       	r0 = r0 LSHIFT -2;
84202a1a:	ff fd 97 f0 	call (m) 0x15914;
84202a1e:	3b e7 

                /* set the time stamp,
                 * TODO_AEC_REFERENCE_TTP: for further accuracy we could consider the tag sp_adjust as well */
                op_extra_data->spkr_last_timestamp = time_sub(mtag->timestamp, time_back);
84202a20:	39 89       	rMAC = M[r5 + 16];
84202a22:	89 04       	rMAC = rMAC - r0;
84202a24:	61 f0 b3 8e 	M[r4 + 716] = rMAC;

                /* See if tag's timestamp has an offset*/
                if (buff_metadata_find_private_data(mtag, META_PRIV_KEY_TTP_OFFSET, &out_length,
                                                    (void **)&err_offset_id))
84202a28:	c5 11       	r3 = FP + 28;
84202a2a:	04 12       	r2 = FP + 32;
84202a2c:	43 20       	r1 = Null + 1;
84202a2e:	3a 00       	r0 = r5 + Null;
84202a30:	ff fd 78 f0 	call (m) 0x11a84;
84202a34:	35 e2 
84202a36:	10 04       	Null = r0 - Null;
84202a38:	0e 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_9;

84202a3a <Lc_aec_reference_spkr_ttp_get_error_7>:
                {
                    int *err_offset_ptr = ttp_info_get(*err_offset_id);
84202a3a:	39 d8       	rMAC = M[FP + 28];
84202a3c:	0a e8       	r0 = M[rMAC + Null];
84202a3e:	ff fd a0 f0 	call (m) 0x16bb8;
84202a42:	3b eb 
                    if (err_offset_ptr != NULL)
84202a44:	10 04       	Null = r0 - Null;
84202a46:	07 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_9;

84202a48 <Lc_aec_reference_spkr_ttp_get_error_8>:
                    {
                        /* subtract the offset */
                        op_extra_data->spkr_last_timestamp =
                            time_sub(op_extra_data->spkr_last_timestamp, *err_offset_ptr);
84202a48:	61 f0 b3 88 	rMAC = M[r4 + 716];
84202a4c:	12 e8       	r0 = M[r0 + Null];
84202a4e:	89 04       	rMAC = rMAC - r0;
84202a50:	61 f0 b3 8e 	M[r4 + 716] = rMAC;

84202a54 <Lc_aec_reference_spkr_ttp_get_error_9>:
                    }
                }

                /* this will stay valid */
                op_extra_data->spkr_last_timestamp_valid = TRUE;
84202a54:	41 20       	rMAC = Null + 1;
84202a56:	61 f0 b4 8e 	M[r4 + 720] = rMAC;

                /* switch to timed playback mode if not already,
                 * this is irreversible
                 */
                if(!op_extra_data->spkr_timed_playback_mode)
84202a5a:	60 f0 b2 88 	Null = M[r4 + 712];
84202a5e:	1b 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_get_error_12;

84202a60 <Lc_aec_reference_spkr_ttp_get_error_10>:
                    /* For the first time we have seen a timestamp,
                     * This means the metadata buffer will supply timestamp tags
                     * that are required for timed playback. Now is the time to
                     * switch to timed playback mode for speaker graph.
                     */
                    op_extra_data->spkr_timed_playback_mode = aec_reference_spkr_ttp_setup_timed_playback(op_extra_data);
84202a60:	32 00       	r0 = r4 + Null;
84202a62:	61 4e       	call (m) Lc_aec_reference_spkr_ttp_setup_timed_playback_1;
84202a64:	62 f0 b2 8e 	M[r4 + 712] = r0;
                    if(op_extra_data->spkr_timed_playback_mode)
84202a68:	60 f0 b2 88 	Null = M[r4 + 712];
84202a6c:	14 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_12;

84202a6e <Lc_aec_reference_spkr_ttp_get_error_11>:
                        /* tell the endpoint that speaker is performing rate adjustment, normally
                         * this is done when enacting config is received from framework, however
                         * in case we haven't received (can happen if input is coming from a2dp
                         * source) we do it here.
                         */
                        set_override_ep_ratematch_enacting(op_extra_data->spkr_endpoint, TRUE);
84202a6e:	43 20       	r1 = Null + 1;
84202a70:	62 f0 80 88 	r0 = M[r4 + 512];
84202a74:	ff fd 0f f0 	call (m) 0x4a3e;
84202a78:	2b ee 

                        /* tell the overridden endpoint that we are in timed playback mode,
                         * this is to prevent extra accumulation of HW warps in endpoint so it
                         * won't mess with PID controller. (only nedded for hw rate adjust)
                         */
                        set_override_ep_set_hw_warp_apply_mode(op_extra_data->spkr_endpoint, TRUE);
84202a7a:	43 20       	r1 = Null + 1;
84202a7c:	62 f0 80 88 	r0 = M[r4 + 512];
84202a80:	02 f0 31 ed 	call (m) $_set_override_ep_set_hw_warp_apply_mode;

                        L2_DBG_MSG1("AEC REFERENCE: Speaker graph switched to timed play back mode: %d",
                                    op_extra_data->spkr_timed_playback_mode);
84202a84:	63 f0 b2 88 	r1 = M[r4 + 712];
84202a88:	55 f1 02 f0 	r0 = Null + 357565133;
84202a8c:	cd 42 
84202a8e:	ef fd ef ff 	call (m) 0x9b4;
84202a92:	27 e9 

84202a94 <Lc_aec_reference_spkr_ttp_get_error_12>:
                    {
                        /* can't do anything except to retry later */
                    }
                }

                if(op_extra_data->spkr_void_tag_observed)
84202a94:	60 f0 b5 88 	Null = M[r4 + 724];
84202a98:	05 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_14;

84202a9a <Lc_aec_reference_spkr_ttp_get_error_13>:
                     * in case that happen, we switch to lower threshold so extra latency will
                     * be discarded immediately. It will quickly go back
                     * to normal threshold.
                     */
                    op_extra_data->spkr_error_threshold =
                        SPKR_TTP_MAX_LATENCY_LOW_THRESHOLD_US;
84202a9a:	01 f0 fa 40 	rMAC = Null + 250;
84202a9e:	61 f0 b7 8e 	M[r4 + 732] = rMAC;

84202aa2 <Lc_aec_reference_spkr_ttp_get_error_14>:
#endif
                }

                /* void tag not seen */
                op_extra_data->spkr_void_tag_observed = FALSE;
84202aa2:	60 f0 b5 8e 	M[r4 + 724] = Null;
84202aa6:	0e 6e       	jump (m) Lc_aec_reference_spkr_ttp_get_error_19;

84202aa8 <Lc_aec_reference_spkr_ttp_get_error_15>:

            } /* IS_TIMESTAMPED_TAG(mtag) */
            else if(IS_VOID_TTP_TAG(mtag) && op_extra_data->spkr_timed_playback_mode)
84202aa8:	11 f0 70 00 	rMAC = rMAC AND 0x70;
84202aac:	10 f0 50 24 	Null = rMAC - 80;
84202ab0:	09 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_get_error_19;

84202ab2 <Lc_aec_reference_spkr_ttp_get_error_16>:
84202ab2:	38 89       	Null = M[r5 + 16];
84202ab4:	07 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_get_error_19;

84202ab6 <Lc_aec_reference_spkr_ttp_get_error_17>:
84202ab6:	60 f0 b2 88 	Null = M[r4 + 712];
84202aba:	04 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_19;

84202abc <Lc_aec_reference_spkr_ttp_get_error_18>:
                if(!op_extra_data->spkr_void_tag_observed)
                {
                    L2_DBG_MSG1("AEC REFERENCE, started seeing VOID tags, time=%d", hal_get_time());
                }
#endif
                op_extra_data->spkr_void_tag_observed = TRUE;
84202abc:	41 20       	rMAC = Null + 1;
84202abe:	61 f0 b5 8e 	M[r4 + 724] = rMAC;

84202ac2 <Lc_aec_reference_spkr_ttp_get_error_19>:
            }
        } /* if(mtag != NULL) */

        if(op_extra_data->spkr_last_timestamp_valid)
84202ac2:	60 f0 b4 88 	Null = M[r4 + 720];
84202ac6:	29 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_23;

84202ac8 <Lc_aec_reference_spkr_ttp_get_error_20>:
             *
             * TODO_AEC_REFERENCE_TTP: since the task for speaker graph is timer based, the time
             * of sampling isn't aligned with the output consuming time, so it
             * could have up to one sample period random jitter.
             */
            TIME cur_time = hal_get_time();
84202ac8:	ff fd 76 f1 	call (m) 0x317e8;
84202acc:	21 e9 
84202ace:	17 00       	r5 = r0 + Null;
            unsigned amount_in_output = cbuffer_calc_amount_data_in_words(op_extra_data->output_stream[AEC_REF_SPKR_TERMINAL1]);
84202ad0:	72 a8       	r0 = M[r4 + 68];
84202ad2:	ff fd 4b f1 	call (m) 0x2c208;
84202ad6:	37 e9 
            TIME_INTERVAL offset = convert_samples_to_time(amount_in_output, op_extra_data->spkr_rate);
84202ad8:	63 f0 6e 88 	r1 = M[r4 + 440];
84202adc:	ff fd 97 f0 	call (m) 0x15914;
84202ae0:	39 e1 
84202ae2:	11 09       	r7 = r0 + Null;
84202ae4:	49 08       	rMAC = r7 + Null;

            /* if we have SW rate adjustment in the graph */
            if(op_extra_data->spkr_sw_rateadj_op != NULL)
84202ae6:	62 f0 7e 88 	r0 = M[r4 + 504];
84202aea:	0f 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_get_error_22;

84202aec <Lc_aec_reference_spkr_ttp_get_error_21>:
            {
                /* adjust for the phase difference between first input and first output sample */
                offset -= (int)frac_mult(SECOND, (int)cbops_sra_get_phase(op_extra_data->spkr_sw_rateadj_op)) / (int) op_extra_data->spkr_rate;
84202aec:	ff fd a1 f0 	call (m) 0x16d48;
84202af0:	3d e2 
84202af2:	00 f0 a3 f7 	r1 = Null + 1000000;
84202af6:	40 42 
84202af8:	61 f0 6e 88 	rMAC = M[r4 + 440];
84202afc:	2f f3 42 c9 	r0 = r1 * r0 (frac);
84202b00:	8a 4c       	Div = r0 / rMAC;
84202b02:	c1 4c       	rMAC = DivResult;
84202b04:	1f f9 01 c2 	rMAC = r7 - rMAC;

84202b08 <Lc_aec_reference_spkr_ttp_get_error_22>:
            /* Add extra delay that might occur in the path
             * (adjustment for any resampler, HW rate matching,
             *  cbops algorithmic delays and any external delay)
             * TODO_AEC_REFERENCE_TTP: spkr_extra_delay isn't set yet
             */
            offset += op_extra_data->spkr_extra_delay;
84202b08:	62 f0 bb 88 	r0 = M[r4 + 748];
84202b0c:	51 00       	rMAC = r0 + rMAC;

            /* compute error */
            *error = time_sub(op_extra_data->spkr_last_timestamp, cur_time) - offset;
84202b0e:	62 f0 b3 88 	r0 = M[r4 + 716];
84202b12:	d2 05       	r0 = r0 - r5;
84202b14:	1f f2 88 c3 	M[r6] = r0 - rMAC;

84202b18 <Lc_aec_reference_spkr_ttp_get_error_23>:
        }

        return op_extra_data->spkr_last_timestamp_valid;
84202b18:	62 f0 b4 88 	r0 = M[r4 + 720];
84202b1c:	02 6e       	jump (m) Lc_aec_reference_spkr_ttp_get_error_25;

84202b1e <Lc_aec_reference_spkr_ttp_get_error_24>:
    } /* buff_has_metadata  */

    /* always return invalid error if we don't have metadata buffer */
    return FALSE;
84202b1e:	02 00       	r0 = Null + Null;

84202b20 <Lc_aec_reference_spkr_ttp_get_error_25>:
}
84202b20:	f4 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, r7, rLink>;
84202b22:	d8 4c       	rts;

84202b24 <Lc_aec_reference_spkr_ttp_setup_timed_playback_1>:
 *
 * \param op_extra_data pointer to AEC_REFERENCE_OP_DATA data
 * return TRUE if setting up was successful else FALSE.
 */
static bool aec_reference_spkr_ttp_setup_timed_playback(AEC_REFERENCE_OP_DATA *op_extra_data)
{
84202b24:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84202b26:	16 00       	r4 = r0 + Null;
    patch_fn_shared(aec_reference);

    /* initialise pid controller parameters */
    timed_set_pid_controller_default_settings(&op_extra_data->spkr_pid_params);
84202b28:	62 f0 f4 22 	r0 = r4 + 756;
84202b2c:	ff fd 95 f0 	call (m) 0x1557c;
84202b30:	31 e2 



    /* reset speaker ttp control */
    aec_reference_spkr_ttp_reset(op_extra_data);
84202b32:	32 00       	r0 = r4 + Null;
84202b34:	4e 4e       	call (m) Lc_aec_reference_spkr_ttp_reset_1;

    /* use ttp SW rate adjust if speaker is capable */
    if(op_extra_data->spkr_rate_ability == RATEMATCHING_SUPPORT_HW)
84202b36:	61 f0 6f 88 	rMAC = M[r4 + 444];
84202b3a:	88 24       	Null = rMAC - 2;
84202b3c:	17 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_setup_timed_playback_6;

84202b3e <Lc_aec_reference_spkr_ttp_setup_timed_playback_2>:
    {
        op_extra_data->spkr_ttp_adjust_type = RATEMATCHING_SUPPORT_HW;
84202b3e:	81 20       	rMAC = Null + 2;
84202b40:	61 f0 bc 8e 	M[r4 + 752] = rMAC;

        /* we want to do HW rate matching in timed playback mode */
        if(op_extra_data->spkr_sw_rateadj_op != NULL)
84202b44:	62 f0 7e 88 	r0 = M[r4 + 504];
84202b48:	05 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_setup_timed_playback_4;

84202b4a <Lc_aec_reference_spkr_ttp_setup_timed_playback_3>:
        {
            /* if we have SW rate adjust, then set it to pass-through mode */
            cbops_rateadjust_passthrough_mode(op_extra_data->spkr_sw_rateadj_op, TRUE);
84202b4a:	43 20       	r1 = Null + 1;
84202b4c:	ff fd a0 f0 	call (m) 0x16c96;
84202b50:	2b ea 

84202b52 <Lc_aec_reference_spkr_ttp_setup_timed_playback_4>:
        }

        /* fresh start from 0 warp value */
        set_override_ep_ratematch_adjustment(op_extra_data->spkr_endpoint, 0);
84202b52:	62 f0 80 88 	r0 = M[r4 + 512];
84202b56:	03 00       	r1 = Null + Null;
84202b58:	ff fd 0f f0 	call (m) 0x4aa0;
84202b5c:	29 ea 

84202b5e <Lc_aec_reference_spkr_ttp_setup_timed_playback_5>:
         */
        return FALSE;
    }

	/* even if we aren't told, speaker graph is enacting */
	op_extra_data->spkr_rate_enactment = op_extra_data->spkr_rate_ability;
84202b5e:	61 f0 6f 88 	rMAC = M[r4 + 444];
84202b62:	61 f0 71 8e 	M[r4 + 452] = rMAC;

    return TRUE;
84202b66:	42 20       	r0 = Null + 1;
84202b68:	32 6e       	jump (m) Lc_aec_reference_spkr_ttp_setup_timed_playback_12;

84202b6a <Lc_aec_reference_spkr_ttp_setup_timed_playback_6>:

        /* fresh start from 0 warp value */
        set_override_ep_ratematch_adjustment(op_extra_data->spkr_endpoint, 0);
    }
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
    else if(0 != op_extra_data->spkr_ext_rate_adjust_op)
84202b6a:	62 f0 ae 88 	r0 = M[r4 + 696];
84202b6e:	19 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_setup_timed_playback_9;

84202b70 <Lc_aec_reference_spkr_ttp_setup_timed_playback_7>:
    {
        /* we will do software TTP using a standalone rate adjust operator */
        op_extra_data->spkr_ttp_adjust_type = RATEMATCHING_SUPPORT_SW;
84202b70:	41 20       	rMAC = Null + 1;
84202b72:	61 f0 bc 8e 	M[r4 + 752] = rMAC;
        op_extra_data->spkr_rate_adjustment = 0;
84202b76:	60 f0 70 8e 	M[r4 + 448] = Null;

        /* reset the current rate */
        stream_delegate_rate_adjust_set_current_rate(op_extra_data->spkr_ext_rate_adjust_op, 0);
84202b7a:	03 00       	r1 = Null + Null;
84202b7c:	02 f0 39 e9 	call (m) $_stream_delegate_rate_adjust_set_current_rate;

        /* not in passthrough mode */
        stream_delegate_rate_adjust_set_passthrough_mode(op_extra_data->spkr_ext_rate_adjust_op, FALSE);
84202b80:	62 f0 ae 88 	r0 = M[r4 + 696];
84202b84:	03 00       	r1 = Null + Null;
84202b86:	02 f0 27 e8 	call (m) $_stream_delegate_rate_adjust_set_passthrough_mode;

        /* we shouldn't have created built-in rate adjust operator */
        PL_ASSERT(op_extra_data->spkr_sw_rateadj_op == NULL);
84202b8a:	61 f0 7e 88 	rMAC = M[r4 + 504];
84202b8e:	e8 61       	if EQ jump (m) Lc_aec_reference_spkr_ttp_setup_timed_playback_5;

84202b90 <Lc_aec_reference_spkr_ttp_setup_timed_playback_8>:
84202b90:	03 f0 06 42 	r1 = Null + 518;
84202b94:	02 f0 13 60 	r0 = Null + 4115;
84202b98:	ff fd 89 f0 	call (m) 0x13f12;
84202b9c:	3b eb 
84202b9e:	17 6e       	jump (m) Lc_aec_reference_spkr_ttp_setup_timed_playback_12;

84202ba0 <Lc_aec_reference_spkr_ttp_setup_timed_playback_9>:
    }
#endif /* INSTALL_DELEGATE_RATE_ADJUST_SUPPORT */
    else if(op_extra_data->spkr_sw_rateadj_op != NULL)
84202ba0:	62 f0 7e 88 	r0 = M[r4 + 504];
84202ba4:	13 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_setup_timed_playback_11;

84202ba6 <Lc_aec_reference_spkr_ttp_setup_timed_playback_10>:
    {
        /* We have a rate adjust operator, so we can do software TTP */
        op_extra_data->spkr_ttp_adjust_type = RATEMATCHING_SUPPORT_SW;
84202ba6:	41 20       	rMAC = Null + 1;
84202ba8:	61 f0 bc 8e 	M[r4 + 752] = rMAC;
        op_extra_data->spkr_rate_adjustment=0;
84202bac:	60 f0 70 8e 	M[r4 + 448] = Null;
        cbops_sra_set_rate_adjust(op_extra_data->spkr_sw_rateadj_op, op_extra_data->num_spkr_channels, 0);
84202bb0:	63 f0 77 88 	r1 = M[r4 + 476];
84202bb4:	04 00       	r2 = Null + Null;
84202bb6:	ff fd a0 f0 	call (m) 0x16c9c;
84202bba:	27 e7 
		/* force coming out of pass-through mode */
        cbops_rateadjust_passthrough_mode(op_extra_data->spkr_sw_rateadj_op, FALSE);
84202bbc:	62 f0 7e 88 	r0 = M[r4 + 504];
84202bc0:	03 00       	r1 = Null + Null;
84202bc2:	ff fd a0 f0 	call (m) 0x16c96;
84202bc6:	35 e6 
84202bc8:	cb 6f       	jump (m) Lc_aec_reference_spkr_ttp_setup_timed_playback_5;

84202bca <Lc_aec_reference_spkr_ttp_setup_timed_playback_11>:
    else
    {
        /* For doing TTP playback either it should support HW rate adjustment
         * or have a SW rate adjust operator in the graph.
         */
        return FALSE;
84202bca:	02 00       	r0 = Null + Null;

84202bcc <Lc_aec_reference_spkr_ttp_setup_timed_playback_12>:

	/* even if we aren't told, speaker graph is enacting */
	op_extra_data->spkr_rate_enactment = op_extra_data->spkr_rate_ability;

    return TRUE;
}
84202bcc:	f1 48       	popm <FP, r4, rLink>;
84202bce:	d8 4c       	rts;

84202bd0 <Lc_aec_reference_spkr_ttp_reset_1>:
 * \brief reset timed playback mode internal state
 * \param op_extra_data pointer to AEC_REFERENCE_OP_DATA data
 * \param error difference between expected ttp and now
 */
static void aec_reference_spkr_ttp_reset(AEC_REFERENCE_OP_DATA *op_extra_data)
{
84202bd0:	c8 1c       	pushm <FP(=SP), rLink>;
    patch_fn_shared(aec_reference);

    op_extra_data->spkr_ttp_error_acc = 0;
84202bd2:	20 f0 b9 8e 	M[r0 + 740] = Null;
    op_extra_data->spkr_ttp_error_acc_cnt = 0;
84202bd6:	20 f0 ba 8e 	M[r0 + 744] = Null;
    op_extra_data->spkr_last_ttp_error = 0;
84202bda:	20 f0 b8 8e 	M[r0 + 736] = Null;
    op_extra_data->spkr_error_threshold = SPKR_TTP_MAX_LATENCY_LOW_THRESHOLD_US;
84202bde:	01 f0 fa 40 	rMAC = Null + 250;
84202be2:	21 f0 b7 8e 	M[r0 + 732] = rMAC;

    /* pid controller will be started */
    timed_reset_pid_controller(&op_extra_data->spkr_pid_state);
84202be6:	02 f0 08 47 	r0 = r0 + 776;
84202bea:	ff fd 94 f0 	call (m) 0x15562;
84202bee:	39 eb 

84202bf0 <Lc_aec_reference_spkr_ttp_reset_2>:
}
84202bf0:	c8 48       	popm <FP, rLink>;
84202bf2:	d8 4c       	rts;

84202bf4 <Lc_aec_reference_spkr_ttp_error_control_1>:
 * \brief running PID controller to minimise the ttp error
 * \param pointer to AEC_REFERENCE_OP_DATA data
 * \param error difference between expected and estimated time to play
 */
static void aec_reference_spkr_ttp_error_control(AEC_REFERENCE_OP_DATA *op_extra_data, TIME_INTERVAL error)
{
84202bf4:	f1 1c       	pushm <FP(=SP), r4, rLink>;
84202bf6:	16 00       	r4 = r0 + Null;
    int error_diff;
    patch_fn_shared(aec_reference);

    /* ignore the error if we have a big jump in error */
    error_diff = error - op_extra_data->spkr_last_ttp_error;
84202bf8:	61 f0 b8 88 	rMAC = M[r4 + 736];
84202bfc:	5a 04       	r0 = r1 - rMAC;
    op_extra_data->spkr_last_ttp_error = error;
84202bfe:	63 f0 b8 8e 	M[r4 + 736] = r1;
    if (pl_abs_i32(error_diff) > SPKR_TTP_MAX_ERROR_JUMP_US)
84202c02:	4f f2 42 ce 	r0 = ABS r0;
84202c06:	90 3c       	Null = r0 - 50;
84202c08:	08 f0 c5 e0 	if HI jump (m) Lc_aec_reference_spkr_ttp_error_control_4;

84202c0c <Lc_aec_reference_spkr_ttp_error_control_2>:
    {
        return;
    }

    /* accumulate error for averaging */
    op_extra_data->spkr_ttp_error_acc_cnt++;
84202c0c:	61 f0 ba 88 	rMAC = M[r4 + 744];
84202c10:	49 20       	rMAC = rMAC + 1;
84202c12:	61 f0 ba 8e 	M[r4 + 744] = rMAC;
    op_extra_data->spkr_ttp_error_acc += error;
84202c16:	62 f0 b9 88 	r0 = M[r4 + 740];
84202c1a:	9a 00       	r0 = r1 + r0;
84202c1c:	62 f0 b9 8e 	M[r4 + 740] = r0;
    if(op_extra_data->spkr_ttp_error_acc_cnt == SPKR_TTP_ERROR_AVERAGING_PERIOD_MS)
84202c20:	88 26       	Null = rMAC - 10;
84202c22:	15 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_error_control_4;

84202c24 <Lc_aec_reference_spkr_ttp_error_control_3>:
    {
        /* calculate average error */
        int error_avg = frac_mult(op_extra_data->spkr_ttp_error_acc,
                                  FRACTIONAL(1.0/SPKR_TTP_ERROR_AVERAGING_PERIOD_MS));
84202c24:	cc f0 63 f6 	r1 = Null + 214748364;
84202c28:	cc 58 
84202c2a:	3f f2 44 c9 	r2 = r0 * r1 (frac);

        /* run controller to minimise the error */
        timed_run_pid_controller(&op_extra_data->spkr_pid_state, &op_extra_data->spkr_pid_params, error_avg);
84202c2e:	63 f0 f4 22 	r1 = r4 + 756;
84202c32:	62 f0 08 23 	r0 = r4 + 776;
84202c36:	ff fd 94 f0 	call (m) 0x15484;
84202c3a:	2f e2 
                    hal_get_time(),
                    error_avg,
                    op_extra_data->spkr_pid_state.warp);
#endif
        /* apply the last calculated warp rate */
        aec_reference_spkr_ttp_adjust_rate(op_extra_data, op_extra_data->spkr_pid_state.warp);         /* reset the averaging accumulator */
84202c3c:	63 f0 c2 88 	r1 = M[r4 + 776];
84202c40:	32 00       	r0 = r4 + Null;
84202c42:	07 4e       	call (m) Lc_aec_reference_spkr_ttp_adjust_rate_1;

        op_extra_data->spkr_ttp_error_acc_cnt = 0;
84202c44:	60 f0 ba 8e 	M[r4 + 744] = Null;
        op_extra_data->spkr_ttp_error_acc = 0;
84202c48:	60 f0 b9 8e 	M[r4 + 740] = Null;

84202c4c <Lc_aec_reference_spkr_ttp_error_control_4>:
    }
}
84202c4c:	f1 48       	popm <FP, r4, rLink>;
84202c4e:	d8 4c       	rts;

84202c50 <Lc_aec_reference_spkr_ttp_adjust_rate_1>:
 * \brief applies warp rate to enacting sra
 * \param pointer to AEC_REFERENCE_OP_DATA data
 * \param warp warp value
 */
static void aec_reference_spkr_ttp_adjust_rate(AEC_REFERENCE_OP_DATA *op_extra_data, int warp)
{
84202c50:	c8 1c       	pushm <FP(=SP), rLink>;
84202c52:	1c 00       	r2 = r1 + Null;
    patch_fn_shared(aec_reference);

    /* expect to come here only in timed playback mode */
    PL_ASSERT(op_extra_data->spkr_timed_playback_mode);
84202c54:	20 f0 b2 88 	Null = M[r0 + 712];
84202c58:	09 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_adjust_rate_3;

84202c5a <Lc_aec_reference_spkr_ttp_adjust_rate_2>:
84202c5a:	03 f0 6b 42 	r1 = Null + 619;
84202c5e:	02 f0 13 60 	r0 = Null + 4115;
84202c62:	ff fd 89 f0 	call (m) 0x13f12;
84202c66:	31 e5 
84202c68:	1b 6e       	jump (m) Lc_aec_reference_spkr_ttp_adjust_rate_9;

84202c6a <Lc_aec_reference_spkr_ttp_adjust_rate_3>:

    if(op_extra_data->spkr_ttp_adjust_type == RATEMATCHING_SUPPORT_HW)
84202c6a:	21 f0 bc 88 	rMAC = M[r0 + 752];
84202c6e:	88 24       	Null = rMAC - 2;
84202c70:	07 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_adjust_rate_5;

84202c72 <Lc_aec_reference_spkr_ttp_adjust_rate_4>:
    {
        /* set the HW warp value by sending that to real audio ep
         * NOTE TODO_AEC_REFERENCE_TTP: HW warp hasn't been tested */
        set_override_ep_ratematch_adjustment(op_extra_data->spkr_endpoint, warp);
84202c72:	22 f0 80 88 	r0 = M[r0 + 512];
84202c76:	ff fd 0f f0 	call (m) 0x4aa0;
84202c7a:	2b e1 
84202c7c:	11 6e       	jump (m) Lc_aec_reference_spkr_ttp_adjust_rate_9;

84202c7e <Lc_aec_reference_spkr_ttp_adjust_rate_5>:
    }
    else if(op_extra_data->spkr_ttp_adjust_type == RATEMATCHING_SUPPORT_SW)
84202c7e:	48 24       	Null = rMAC - 1;
84202c80:	0f 62       	if NE jump (m) Lc_aec_reference_spkr_ttp_adjust_rate_9;

84202c82 <Lc_aec_reference_spkr_ttp_adjust_rate_6>:
    {
#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
        if(0 != op_extra_data->spkr_ext_rate_adjust_op)
84202c82:	21 f0 ae 88 	rMAC = M[r0 + 696];
84202c86:	05 60       	if EQ jump (m) Lc_aec_reference_spkr_ttp_adjust_rate_8;

84202c88 <Lc_aec_reference_spkr_ttp_adjust_rate_7>:
        {
            /* rate adjust using external rate adjust operator */
            stream_delegate_rate_adjust_set_current_rate(op_extra_data->spkr_ext_rate_adjust_op, warp);
84202c88:	0a 00       	r0 = rMAC + Null;
84202c8a:	02 f0 2b e1 	call (m) $_stream_delegate_rate_adjust_set_current_rate;
84202c8e:	08 6e       	jump (m) Lc_aec_reference_spkr_ttp_adjust_rate_9;

84202c90 <Lc_aec_reference_spkr_ttp_adjust_rate_8>:
        }
        else
#endif /* INSTALL_DELEGATE_RATE_ADJUST_SUPPORT */
        {
            /* set the SW rate adjust warp value */
            cbops_sra_set_rate_adjust(op_extra_data->spkr_sw_rateadj_op, op_extra_data->num_spkr_channels, warp);
84202c90:	23 f0 77 88 	r1 = M[r0 + 476];
84202c94:	22 f0 7e 88 	r0 = M[r0 + 504];
84202c98:	ff fd a0 f0 	call (m) 0x16c9c;
84202c9c:	25 e0 

84202c9e <Lc_aec_reference_spkr_ttp_adjust_rate_9>:
        }
    }
}
84202c9e:	c8 48       	popm <FP, rLink>;
84202ca0:	d8 4c       	rts;

84202ca2 <$_create_aec_ref_sidetone_op>:
                                     unsigned nr_spkrs,
                                     unsigned *sidetone_idx,
                                     unsigned spkr_threshold,
                                     unsigned safety_threshold)

{
84202ca2:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
84202ca4:	13 09       	r9 = r0 + Null;
84202ca6:	1a 09       	r8 = r1 + Null;
84202ca8:	21 09       	r7 = r2 + Null;
84202caa:	2f 00       	r5 = r3 + Null;
84202cac:	ee d9       	r4 = M[FP + -12];
    cbops_op *op = NULL;
84202cae:	02 00       	r0 = Null + Null;

    patch_fn_shared(aec_reference);

    /* sidetone can be mixed to 1 or 2 speakers only */
    if(nr_spkrs > 2)
84202cb0:	b8 24       	Null = r5 - 2;
84202cb2:	09 f0 87 e0 	if LS jump (m) Lc_create_aec_ref_sidetone_op_3;

84202cb6 <Lc_create_aec_ref_sidetone_op_2>:
    {
        return op;
84202cb6:	2c 6e       	jump (m) Lc_create_aec_ref_sidetone_op_6;

84202cb8 <Lc_create_aec_ref_sidetone_op_3>:
    }

    // cbop param struct size (header plus cbop-specific parameters)
    op = (cbops_op*)xzpmalloc(sizeof_cbops_op(cbops_aec_ref_sidetone_op, 1, nr_spkrs));
84202cb8:	c3 20       	r1 = Null + 3;
84202cba:	7a 20       	r0 = r5 + 1;
84202cbc:	52 54       	r0 = r0 LSHIFT 2;
84202cbe:	02 f0 58 44 	r0 = r0 + 88;
84202cc2:	ff fd 11 f0 	call (m) 0x4f2a;
84202cc6:	29 e3 
84202cc8:	10 09       	r6 = r0 + Null;
    if(op)
84202cca:	21 60       	if EQ jump (m) Lc_create_aec_ref_sidetone_op_5;

84202ccc <Lc_create_aec_ref_sidetone_op_4>:
    {
        cbops_aec_ref_sidetone_op *params;

        /* Setup Operator func table */
        op->function_vector    = cbops_aec_ref_sidetone_table;
84202ccc:	07 f0 01 f0 	rMAC = Null + 7340368;
84202cd0:	50 41 
84202cd2:	81 f0 02 8e 	M[r6 + 8] = rMAC;
        /* Setup cbop param struct header info */
        params = (cbops_aec_ref_sidetone_op*)cbops_populate_param_hdr(op,
                                                                      1,
                                                                      0,
                                                                      sidetone_idx,
                                                                      NULL);
84202cd6:	00 f0 30 cf 	push Null;
84202cda:	fd d9       	r3 = M[FP + -4];
84202cdc:	43 20       	r1 = Null + 1;
84202cde:	04 00       	r2 = Null + Null;
84202ce0:	ff fd a1 f0 	call (m) 0x16f30;
84202ce4:	31 e2 
84202ce6:	7f 4c       	SP = SP + -4;

        /* Setup cbop-specific parameters */
        params->spkr_threshold  = spkr_threshold;
84202ce8:	f1 d9       	rMAC = M[FP + -8];
84202cea:	51 9e       	M[r0 + 36] = rMAC;
        params->safety_threshold_low = safety_threshold;
84202cec:	96 8f       	M[r0 + 24] = r4;
        params->safety_threshold_high = safety_threshold*2;
84202cee:	33 54       	r1 = r4 LSHIFT 1;
84202cf0:	d3 8f       	M[r0 + 28] = r1;
        params->safety_set_threshold = (params->safety_threshold_low + params->safety_threshold_high)/2;
84202cf2:	f3 00       	r1 = r4 + r1;
84202cf4:	1b 50       	r1 = r1 LSHIFT -1;
84202cf6:	13 9e       	M[r0 + 32] = r1;
        params->mic_buf = mic_buf;
84202cf8:	2b f0 01 8e 	M[r0 + 4] = r9;
        params->spkr_bufs = spkr_bufs;
84202cfc:	29 f0 00 ee 	M[r0 + Null] = r7;
        params->mic_idx = mic_idx;
84202d00:	2a f0 05 8e 	M[r0 + 20] = r8;
        params->nr_spkrs = nr_spkrs;
84202d04:	97 8e       	M[r0 + 8] = r5;

        /* initialise the operator */
        aec_ref_sidetone_initialise(op);
84202d06:	42 08       	r0 = r6 + Null;
84202d08:	04 f0 21 e9 	call (m) $_aec_ref_sidetone_initialise;

84202d0c <Lc_create_aec_ref_sidetone_op_5>:
    }

    return(op);
84202d0c:	42 08       	r0 = r6 + Null;

84202d0e <Lc_create_aec_ref_sidetone_op_6>:
}
84202d0e:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84202d10:	d8 4c       	rts;

84202d12 <$_AEC_REFERENCE_GetDefaults>:
   0x00000001u,			// ST_PEQ_SCALE2
   0x00000001u			// ST_PEQ_SCALE3
};

unsigned *AEC_REFERENCE_GetDefaults(unsigned capid){
	switch(capid){
84202d12:	20 f0 43 24 	Null = r0 - 67;
84202d16:	05 60       	if EQ jump (m) Lc_AEC_REFERENCE_GetDefaults_3;

84202d18 <Lc_AEC_REFERENCE_GetDefaults_2>:
84202d18:	01 f0 20 f0 	Null = r0 - 16391;
84202d1c:	07 24 
84202d1e:	05 62       	if NE jump (m) Lc_AEC_REFERENCE_GetDefaults_4;

84202d20 <Lc_AEC_REFERENCE_GetDefaults_3>:
		case 0x0043: return defaults_aec_referenceAECREF;
84202d20:	f8 ff 02 f0 	r0 = Null + -8388604;
84202d24:	04 40 
84202d26:	02 6e       	jump (m) Lc_AEC_REFERENCE_GetDefaults_5;

84202d28 <Lc_AEC_REFERENCE_GetDefaults_4>:
		case 0x4007: return defaults_aec_referenceAECREF;
	}
	return((unsigned *)0);
84202d28:	02 00       	r0 = Null + Null;

84202d2a <Lc_AEC_REFERENCE_GetDefaults_5>:
84202d2a:	d8 4c       	rts;

84202d2c <$_cbops_remove_operator_from_graph>:
        pfree(op);
    }
}

void cbops_remove_operator_from_graph(cbops_graph *graph,cbops_op *op)
{
84202d2c:	c8 1c       	pushm <FP(=SP), rLink>;
    cbops_op   *prev_op = op->prev_operator_addr;
84202d2e:	19 e8       	rMAC = M[r1 + Null];
    cbops_op   *next_op = op->next_operator_addr;
84202d30:	5c 88       	r2 = M[r1 + 4];

   if(graph->first == op)
84202d32:	15 e8       	r3 = M[r0 + Null];
84202d34:	e8 04       	Null = r3 - r1;
84202d36:	07 62       	if NE jump (m) Lc_cbops_remove_operator_from_graph_5;

84202d38 <Lc_cbops_remove_operator_from_graph_2>:
   {
       /* we are removing the first operator in the graph,
        * next op will become new first
        */
       graph->first = next_op;
       if(next_op == NULL)
84202d38:	14 ee       	M[r0 + Null] = r2;
84202d3a:	03 62       	if NE jump (m) Lc_cbops_remove_operator_from_graph_4;

84202d3c <Lc_cbops_remove_operator_from_graph_3>:
       {
           /* this op was the only op in the graph
            * now graph is empty
            */
           graph->last = NULL;
84202d3c:	50 8e       	M[r0 + 4] = Null;
84202d3e:	0a 6e       	jump (m) Lc_cbops_remove_operator_from_graph_8;

84202d40 <Lc_cbops_remove_operator_from_graph_4>:
       else
       {
           /* there is still op remaing,
            * just config the new first
            */
           next_op->prev_operator_addr = NULL;
84202d40:	20 ee       	M[r2 + Null] = Null;
84202d42:	08 6e       	jump (m) Lc_cbops_remove_operator_from_graph_8;

84202d44 <Lc_cbops_remove_operator_from_graph_5>:
       }
   }
   else if(next_op == NULL)
84202d44:	20 04       	Null = r2 - Null;
84202d46:	04 62       	if NE jump (m) Lc_cbops_remove_operator_from_graph_7;

84202d48 <Lc_cbops_remove_operator_from_graph_6>:
   {
       /* This isn't the only operator in the graph,
        * but it is the last one in chain
        */
       prev_op->next_operator_addr = NULL;
84202d48:	48 8e       	M[rMAC + 4] = Null;
       graph->last = prev_op;
84202d4a:	51 8e       	M[r0 + 4] = rMAC;
84202d4c:	03 6e       	jump (m) Lc_cbops_remove_operator_from_graph_8;

84202d4e <Lc_cbops_remove_operator_from_graph_7>:
   else
   {
       /* easy part, the op is neither first
        * nor last
        */
       prev_op->next_operator_addr = next_op;
84202d4e:	4c 8e       	M[rMAC + 4] = r2;
       next_op->prev_operator_addr = prev_op;
84202d50:	21 ee       	M[r2 + Null] = rMAC;

84202d52 <Lc_cbops_remove_operator_from_graph_8>:
   }

   /* op removed from the graph, now
    * destroy the operator
    */
   destroy_operator(op);
84202d52:	1a 00       	r0 = r1 + Null;
84202d54:	1c 4e       	call (m) Lc_destroy_operator_1;

84202d56 <Lc_cbops_remove_operator_from_graph_9>:
}
84202d56:	c8 48       	popm <FP, rLink>;
84202d58:	d8 4c       	rts;

84202d5a <$_cbops_insert_operator_into_graph>:


void cbops_insert_operator_into_graph(cbops_graph *graph,cbops_op *op, cbops_op *after)
{
84202d5a:	c8 1c       	pushm <FP(=SP), rLink>;
    if(after->next_operator_addr == NULL)
84202d5c:	61 88       	rMAC = M[r2 + 4];
84202d5e:	05 62       	if NE jump (m) Lc_cbops_insert_operator_into_graph_3;

84202d60 <Lc_cbops_insert_operator_into_graph_2>:
    {
        /* if this is the last operator in the graph
         * then append it to end of graph
         */
        cbops_append_operator_to_graph(graph, op);
84202d60:	ff fd a0 f0 	call (m) 0x16e96;
84202d64:	37 e9 
84202d66:	07 6e       	jump (m) Lc_cbops_insert_operator_into_graph_4;

84202d68 <Lc_cbops_insert_operator_into_graph_3>:
    }
    else
    {
        /* put the operator between after and after->next */
        op->prev_operator_addr = after;
84202d68:	1c ee       	M[r1 + Null] = r2;
        op->next_operator_addr = after->next_operator_addr;
84202d6a:	61 88       	rMAC = M[r2 + 4];
84202d6c:	59 8e       	M[r1 + 4] = rMAC;
        after->next_operator_addr->prev_operator_addr = op;        
84202d6e:	61 88       	rMAC = M[r2 + 4];
84202d70:	0b ee       	M[rMAC + Null] = r1;
        after->next_operator_addr = op;
84202d72:	63 8e       	M[r2 + 4] = r1;

84202d74 <Lc_cbops_insert_operator_into_graph_4>:
    }
}
84202d74:	c8 48       	popm <FP, rLink>;
84202d76:	d8 4c       	rts;

84202d78 <$_cbops_unset_buffer>:

void cbops_unset_buffer(cbops_graph *graph,unsigned index)
{
    cbops_buffer *buffer = &graph->buffers[index];
84202d78:	19 47       	rMAC = r1 * 28 (int);
84202d7a:	51 00       	rMAC = r0 + rMAC;
    if(buffer != NULL)
84202d7c:	09 31       	rMAC = rMAC + 36;
84202d7e:	06 60       	if EQ jump (m) Lc_cbops_unset_buffer_3;

84202d80 <Lc_cbops_unset_buffer_2>:
    {
        /* make the buffer index unused */
        buffer->type = 0;
84202d80:	08 ec       	MH[rMAC + Null] = Null;
        buffer->buffer = NULL;
84202d82:	48 8e       	M[rMAC + 4] = Null;
        buffer->transfer_ptr = NULL;
84202d84:	48 8f       	M[rMAC + 20] = Null;
84202d86:	41 20       	rMAC = Null + 1;
84202d88:	d1 8f       	M[r0 + 28] = rMAC;

84202d8a <Lc_cbops_unset_buffer_3>:
84202d8a:	d8 4c       	rts;

84202d8c <Lc_destroy_operator_1>:
 */
#include "cbops_c.h"
#include "pmalloc/pl_malloc.h"

static void destroy_operator(cbops_op *op)
{
84202d8c:	c8 1c       	pushm <FP(=SP), rLink>;
    if(op->function_vector == (void*)cbops_rate_adjust_table)
84202d8e:	91 88       	rMAC = M[r0 + 8];
84202d90:	03 f0 28 42 	r1 = Null + 552;
84202d94:	c8 04       	Null = rMAC - r1;
84202d96:	05 62       	if NE jump (m) Lc_destroy_operator_3;

84202d98 <Lc_destroy_operator_2>:
    {
         destroy_sw_rate_adj_op((cbops_op*)op);
84202d98:	ff fd 9f f0 	call (m) 0x16c7c;
84202d9c:	25 e7 
84202d9e:	0c 6e       	jump (m) Lc_destroy_operator_6;

84202da0 <Lc_destroy_operator_3>:
    }
    else if(op->function_vector == (void*)cbops_iir_resampler_table)
84202da0:	03 f0 4c 42 	r1 = Null + 588;
84202da4:	c8 04       	Null = rMAC - r1;
84202da6:	05 62       	if NE jump (m) Lc_destroy_operator_5;

84202da8 <Lc_destroy_operator_4>:
    {
         destroy_iir_resamplerv2_op(op);
84202da8:	ff fd a1 f0 	call (m) 0x17064;
84202dac:	3d e5 
84202dae:	04 6e       	jump (m) Lc_destroy_operator_6;

84202db0 <Lc_destroy_operator_5>:
    }
    else
    {
        pfree(op);
84202db0:	ff fd 10 f0 	call (m) 0x4f62;
84202db4:	33 ed 

84202db6 <Lc_destroy_operator_6>:
    }
}
84202db6:	c8 48       	popm <FP, rLink>;
84202db8:	d8 4c       	rts;

84202dba <$_create_rate_monitor_operator>:
 * create_rate_monitor_operator
 */
#define RATE_MATCH_OP_NUM_INPUTS    1

cbops_op* create_rate_monitor_operator(unsigned clk_per_sec,unsigned idx)
{
84202dba:	f2 1d       	pushm <FP(=SP), r4, r5, rLink>, SP = SP + 0x10;
84202dbc:	16 00       	r4 = r0 + Null;
84202dbe:	23 de       	M[FP + 16] = r1;
    // cbop param struct size (header plus cbop-specific parameters)
    cbops_op *op = (cbops_op*)xzpmalloc(sizeof_cbops_op(cbops_rate_monitor_op, RATE_MATCH_OP_NUM_INPUTS, 0));
84202dc0:	c3 20       	r1 = Null + 3;
84202dc2:	02 f0 5c 40 	r0 = Null + 92;
84202dc6:	ff fd 10 f0 	call (m) 0x4f2a;
84202dca:	25 eb 
84202dcc:	17 00       	r5 = r0 + Null;

    if(op)
84202dce:	12 60       	if EQ jump (m) Lc_create_rate_monitor_operator_3;

84202dd0 <Lc_create_rate_monitor_operator_2>:
    {
        cbops_rate_monitor_op *params;
        
        /* Setup Operator func table */
        op->function_vector    = cbops_rate_monitor_table;
84202dd0:	01 f0 e4 42 	rMAC = Null + 740;
84202dd4:	b9 8e       	M[r5 + 8] = rMAC;

        /* Setup cbop param struct header info */
        params  = (cbops_rate_monitor_op*)cbops_populate_param_hdr(op, RATE_MATCH_OP_NUM_INPUTS, 0, &idx, NULL);
84202dd6:	00 f0 30 cf 	push Null;
84202dda:	05 11       	r3 = FP + 16;
84202ddc:	43 20       	r1 = Null + 1;
84202dde:	04 00       	r2 = Null + Null;
84202de0:	ff fd a0 f0 	call (m) 0x16f30;
84202de4:	31 ea 
84202de6:	7f 4c       	SP = SP + -4;

        params->period_per_second = clk_per_sec;
84202de8:	16 ee       	M[r0 + Null] = r4;
        params->average_io_rate = FRACTIONAL(0.5);
84202dea:	ff f3 f1 f7 	rMAC = Null + 1073741823;
84202dee:	ff 7b 
84202df0:	11 8f       	M[r0 + 16] = rMAC;

84202df2 <Lc_create_rate_monitor_operator_3>:
    }

    return(op);
84202df2:	3a 00       	r0 = r5 + Null;

84202df4 <Lc_create_rate_monitor_operator_4>:
}
84202df4:	f2 49       	SP = SP - 0x10, popm <FP, r4, r5, rLink>;
84202df6:	d8 4c       	rts;

84202df8 <$_create_sidetone_filter_op>:
 * It fits into multi-channel model, but it only ever actually uses single in/out channel.
 */
cbops_op* create_sidetone_filter_op(unsigned input_idx, unsigned output_idx,
                                          unsigned max_stages, cbops_sidetone_params *st_params,
                                          unsigned *peq_params)
{
84202df8:	f3 1d       	pushm <FP(=SP), r4, r5, r6, rLink>, SP = SP + 0x10;
84202dfa:	26 00       	r4 = r2 + Null;
84202dfc:	28 09       	r6 = r3 + Null;
84202dfe:	33 de       	M[FP + 24] = r1;
84202e00:	2a de       	M[FP + 20] = r0;
    cbops_op *op;
    /* extra 2 words compared to ROM, needed as we use standard PEQ for filtering */
    op = (cbops_op*)xzpmalloc(sizeof_cbops_op(cbops_sidetone_filter_op, 1, 1) +
                              (2*(max_stages+1) + 2)*sizeof(unsigned) );
84202e02:	c3 20       	r1 = Null + 3;
84202e04:	b2 20       	r0 = r4 + 2;
84202e06:	92 54       	r0 = r0 LSHIFT 3;
84202e08:	02 f0 5c 44 	r0 = r0 + 92;
84202e0c:	ff fd 10 f0 	call (m) 0x4f2a;
84202e10:	3f e8 
84202e12:	17 00       	r5 = r0 + Null;
    if(op)
84202e14:	16 60       	if EQ jump (m) Lc_create_sidetone_filter_op_3;

84202e16 <Lc_create_sidetone_filter_op_2>:
    {
        cbops_sidetone_filter_op  *params;

        op->function_vector    = cbops_sidetone_filter_table;
84202e16:	01 f0 cc 42 	rMAC = Null + 716;
84202e1a:	b9 8e       	M[r5 + 8] = rMAC;

        /* Setup cbop param struct header info */
        params = (cbops_sidetone_filter_op*)cbops_populate_param_hdr(op, 1, 1, &input_idx, &output_idx);
84202e1c:	81 11       	rMAC = FP + 24;
84202e1e:	09 1c       	pushm <rMAC>;
84202e20:	45 11       	r3 = FP + 20;
84202e22:	44 20       	r2 = Null + 1;
84202e24:	23 00       	r1 = r2 + Null;
84202e26:	ff fd a0 f0 	call (m) 0x16f30;
84202e2a:	2b e8 
84202e2c:	7f 4c       	SP = SP + -4;

        /* Set up the parameters - there are no channel-specific params as such, as it only works on a
         * single channel.
         */

        params->inv_dac_gain = FRACTIONAL(1.0); // TODO - handle gain adjustment for post volume
84202e2e:	ff f7 f1 f7 	rMAC = Null + 2147483647;
84202e32:	ff 7b 
84202e34:	d1 8e       	M[r0 + 12] = rMAC;

        params->params = st_params;
84202e36:	28 f0 00 ee 	M[r0 + Null] = r6;
        params->peq.max_stages = max_stages;
84202e3a:	16 9e       	M[r0 + 32] = r4;
        params->peq.params = peq_params;
84202e3c:	f9 d9       	rMAC = M[FP + -4];
84202e3e:	51 9e       	M[r0 + 36] = rMAC;

84202e40 <Lc_create_sidetone_filter_op_3>:
    }

    return(op);
84202e40:	3a 00       	r0 = r5 + Null;

84202e42 <Lc_create_sidetone_filter_op_4>:
}
84202e42:	f3 49       	SP = SP - 0x10, popm <FP, r4, r5, r6, rLink>;
84202e44:	d8 4c       	rts;

84202e46 <$_create_iir_resamplerv2_op>:
    unsigned inter_stage_size,
    unsigned *inter_stage,
    int shift,
    unsigned dbl_precision,
    unsigned low_mips)
{
84202e46:	f2 1c       	pushm <FP(=SP), r4, r5, rLink>;
84202e48:	e6 d9       	r4 = M[FP + -16];
        out_rate,
        inter_stage_size,
        inter_stage,
        shift,
        dbl_precision,
        low_mips);
84202e4a:	b1 f0 b3 5b 	rMAC = Null + 94131;
84202e4e:	d7 d9       	r5 = M[FP + -24];
84202e50:	39 1c       	pushm <r5>;
84202e52:	df d9       	r5 = M[FP + -20];
84202e54:	39 1c       	pushm <r5>;
84202e56:	31 1c       	pushm <r4>;
84202e58:	ef d9       	r5 = M[FP + -12];
84202e5a:	39 1c       	pushm <r5>;
84202e5c:	f7 d9       	r5 = M[FP + -8];
84202e5e:	39 1c       	pushm <r5>;
84202e60:	ff d9       	r5 = M[FP + -4];
84202e62:	39 1c       	pushm <r5>;
84202e64:	d1 4c       	call rMAC;
84202e66:	7a 4c       	SP = SP + -24;

    if(op_ptr != NULL)
84202e68:	10 04       	Null = r0 - Null;
84202e6a:	11 60       	if EQ jump (m) Lc_create_iir_resamplerv2_op_5;

84202e6c <Lc_create_iir_resamplerv2_op_2>:
    {
        /* increase the headroom by 1 bit (6dB) */
        cbops_param_hdr *params_hdr = (cbops_param_hdr*)CBOPS_OPERATOR_DATA_PTR(op_ptr);
84202e6c:	11 23       	rMAC = r0 + 12;

        cbops_iir_resampler_op *params =
            (cbops_iir_resampler_op *) params_hdr->operator_data_ptr;
84202e6e:	09 e8       	rMAC = M[rMAC + Null];
         * will increase the headroom by 1 bit or 6dB.
         */
        COMPILE_TIME_ASSERT(IIR_RESAMPLEV2_IO_SCALE_FACTOR == 9,
                        IIR_RESAMPLEV2_IO_SCALE_FACTOR_Not_Accepted);

        if(shift >= 0)
84202e70:	30 04       	Null = r4 - Null;
84202e72:	04 f0 91 e0 	if NEG jump (m) Lc_create_iir_resamplerv2_op_4;

84202e76 <Lc_create_iir_resamplerv2_op_3>:
        {
            params->common.input_scale =  shift - IIR_RESAMPLEV2_IO_SCALE_FACTOR;
84202e76:	63 f3 f7 3b 	r1 = r4 + -9;
84202e7a:	4b 8e       	M[rMAC + 4] = r1;
            params->common.output_scale =  IIR_RESAMPLEV2_IO_SCALE_FACTOR;
84202e7c:	43 22       	r1 = Null + 9;
84202e7e:	8b 8e       	M[rMAC + 8] = r1;
84202e80:	06 6e       	jump (m) Lc_create_iir_resamplerv2_op_5;

84202e82 <Lc_create_iir_resamplerv2_op_4>:
        }
        else
        {
            params->common.input_scale = -IIR_RESAMPLEV2_IO_SCALE_FACTOR;
84202e82:	bb 78       	r1 = Null + -9;
84202e84:	4b 8e       	M[rMAC + 4] = r1;
            params->common.output_scale =  IIR_RESAMPLEV2_IO_SCALE_FACTOR - shift;
84202e86:	04 f6 53 d6 	r1 = 9 - r4;
84202e8a:	8b 8e       	M[rMAC + 8] = r1;

84202e8c <Lc_create_iir_resamplerv2_op_5>:
        }
    }

    return op_ptr;
84202e8c:	f2 48       	popm <FP, r4, r5, rLink>;
84202e8e:	d8 4c       	rts;

84202e90 <$_cbops_mute_enable>:
 * \param no_ramp if enabled it will be immediate mute/unmute
 *   else a ramping will apply during first processed block of samples.
 */
void cbops_mute_enable(cbops_op *op, bool enable, bool no_ramp)
{
    cbops_mute *params = CBOPS_PARAM_PTR(op, cbops_mute);
84202e90:	d1 88       	rMAC = M[r0 + 12];
    params->mute_enable = enable;
84202e92:	0b ee       	M[rMAC + Null] = r1;
    if(no_ramp)
84202e94:	20 04       	Null = r2 - Null;
84202e96:	02 60       	if EQ jump (m) Lc_cbops_mute_enable_3;

84202e98 <Lc_cbops_mute_enable_2>:
    {
        /* no ramping, apply mute config immediately */
        params->mute_state = enable;
84202e98:	4b 8e       	M[rMAC + 4] = r1;

84202e9a <Lc_cbops_mute_enable_3>:
84202e9a:	d8 4c       	rts;

84202e9c <$_create_multichan_sidetone_mix_op_base>:
                                                unsigned *input_idxs,
                                                unsigned *output_idxs,
                                                unsigned nr_st_channels,
                                                unsigned *st_in_idxs,
                                                unsigned threshold)
{
84202e9c:	f5 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, rLink>;
84202e9e:	17 00       	r5 = r0 + Null;
84202ea0:	1a 09       	r8 = r1 + Null;
84202ea2:	20 09       	r6 = r2 + Null;
84202ea4:	2e 00       	r4 = r3 + Null;
    /* Expect at least one sidetone channel*/
    if(nr_st_channels == 0 || /* At least one sidetone input channel */
       nr_channels == 0    || /* At least one main channel */
       nr_st_channels > CBOPS_SIDETONE_MIX_MAX_ST_CHANNELS)
84202ea6:	06 60       	if EQ jump (m) Lc_create_multichan_sidetone_mix_op_base_4;

84202ea8 <Lc_create_multichan_sidetone_mix_op_base_2>:
84202ea8:	38 04       	Null = r5 - Null;
84202eaa:	04 60       	if EQ jump (m) Lc_create_multichan_sidetone_mix_op_base_4;

84202eac <Lc_create_multichan_sidetone_mix_op_base_3>:
84202eac:	30 26       	Null = r4 - 8;
84202eae:	09 f0 89 e0 	if LS jump (m) Lc_create_multichan_sidetone_mix_op_base_5;

84202eb2 <Lc_create_multichan_sidetone_mix_op_base_4>:
    {
        /* something is wrong with the caller */
        return NULL;
84202eb2:	02 00       	r0 = Null + Null;
84202eb4:	32 6e       	jump (m) Lc_create_multichan_sidetone_mix_op_base_10;

84202eb6 <Lc_create_multichan_sidetone_mix_op_base_5>:
    }

    cbops_op *op = (cbops_op*)xzpmalloc(sizeof_cbops_op(cbops_multichan_sidetone_mix_op, nr_channels, nr_channels)
                                        + (nr_channels + nr_st_channels - 1)*sizeof(unsigned));
84202eb6:	c3 20       	r1 = Null + 3;
84202eb8:	f9 40       	rMAC = r5 * 3 (int);
84202eba:	71 00       	rMAC = r4 + rMAC;
84202ebc:	4a 24       	r0 = rMAC - 1;
84202ebe:	52 54       	r0 = r0 LSHIFT 2;
84202ec0:	12 38       	r0 = r0 + 48;
84202ec2:	ff fd 10 f0 	call (m) 0x4f2a;
84202ec6:	29 e3 
84202ec8:	11 09       	r7 = r0 + Null;
    if(op != NULL)
84202eca:	26 60       	if EQ jump (m) Lc__loop0;

84202ecc <Lc_create_multichan_sidetone_mix_op_base_6>:
    {
        cbops_multichan_sidetone_mix_op  *params;

        op->function_vector    = cbops_multichan_sidetone_mix_table;
84202ecc:	07 f0 01 f0 	rMAC = Null + 7340380;
84202ed0:	5c 41 
84202ed2:	91 f0 02 8e 	M[r7 + 8] = rMAC;

        /* Setup cbops param struct header info */
        params = (cbops_multichan_sidetone_mix_op*)cbops_populate_param_hdr(op, nr_channels, nr_channels, input_idxs, output_idxs);
84202ed6:	10 1c       	pushm <r6>;
84202ed8:	55 08       	r3 = r8 + Null;
84202eda:	3c 00       	r2 = r5 + Null;
84202edc:	3b 00       	r1 = r5 + Null;
84202ede:	ff fd a0 f0 	call (m) 0x16f30;
84202ee2:	33 e2 
84202ee4:	7f 4c       	SP = SP + -4;
84202ee6:	10 09       	r6 = r0 + Null;

        /* Only config param which is threshold which is for all of the
         * sidetone channels
         */
        params->max_samples = threshold;
84202ee8:	f1 d9       	rMAC = M[FP + -8];
84202eea:	81 f0 00 ee 	M[r6 + Null] = rMAC;

        /* number of main channels */
        params->nr_channels = nr_channels;
84202eee:	87 f0 03 8e 	M[r6 + 12] = r5;

        /* number of sidetone channels */
        params->nr_st_channels = nr_st_channels;
84202ef2:	86 f0 04 8e 	M[r6 + 16] = r4;

        /* write cbops buffer indexes for sidetone buffers */
        unsigned *params_st_in_idxs = &params->st_idxs[0];
84202ef6:	82 f0 14 20 	r0 = r6 + 20;
        memcpy(params_st_in_idxs, st_in_idxs, sizeof(unsigned)*nr_st_channels);
84202efa:	74 54       	r2 = r4 LSHIFT 2;
84202efc:	fb d9       	r1 = M[FP + -4];
84202efe:	ff fd a0 f0 	call (m) 0x170b8;
84202f02:	3b ed 

        /* initialise sidetone mixing mapping */
        unsigned i;
        unsigned *params_st_map_idxs = &params->st_idxs[nr_st_channels];
84202f04:	72 54       	r0 = r4 LSHIFT 2;
84202f06:	10 0d       	r6 = r0 + r6;
84202f08:	82 f0 14 20 	r0 = r6 + 20;
        for(i = 0; i < nr_channels; ++i)
84202f0c:	41 24       	rMAC = Null - 1;
84202f0e:	3c 09       	r10 = r5 + Null;
84202f10:	03 4c       	do (m) Lc__loop0;

84202f12 <Lc_create_multichan_sidetone_mix_op_base_7>:
        {
            /* initialise to no sidetone mixing, this needs to be
             * configured later to do any sidetone mixing
             */
            params_st_map_idxs[i] = CBOPS_BUFFER_NOT_SUPPLIED;
84202f12:	11 ee       	M[r0 + Null] = rMAC;
84202f14:	12 21       	r0 = r0 + 4;

84202f16 <Lc__loop0>:
        memcpy(params_st_in_idxs, st_in_idxs, sizeof(unsigned)*nr_st_channels);

        /* initialise sidetone mixing mapping */
        unsigned i;
        unsigned *params_st_map_idxs = &params->st_idxs[nr_st_channels];
        for(i = 0; i < nr_channels; ++i)
84202f16:	4a 08       	r0 = r7 + Null;

84202f18 <Lc_create_multichan_sidetone_mix_op_base_10>:
            params_st_map_idxs[i] = CBOPS_BUFFER_NOT_SUPPLIED;
        }
    }

    return(op);
}
84202f18:	f5 48       	popm <FP, r4, r5, r6, r7, r8, rLink>;
84202f1a:	d8 4c       	rts;

84202f1c <$_cbops_sidetone_mix_map_channel>:
 * \param op cbops multichannel sidetone mix operator (input)
 * \param input_channel main channel number (0 to (nr_channels-1))
 * \param use_st_channel use this sidetone channel (0 to (nr_st_channels-1))
 */
void cbops_sidetone_mix_map_channel(cbops_op *op, unsigned input_channel, unsigned use_st_channel)
{
84202f1c:	c8 1c       	pushm <FP(=SP), rLink>;
    if(NULL != op)
84202f1e:	10 04       	Null = r0 - Null;
84202f20:	20 60       	if EQ jump (m) Lc_cbops_sidetone_mix_map_channel_7;

84202f22 <Lc_cbops_sidetone_mix_map_channel_2>:
    {
        cbops_multichan_sidetone_mix_op  *params = CBOPS_PARAM_PTR(op, cbops_multichan_sidetone_mix_op);
84202f22:	d1 88       	rMAC = M[r0 + 12];
        PL_ASSERT(use_st_channel < params->nr_st_channels);
84202f24:	0d 89       	r3 = M[rMAC + 16];
84202f26:	60 05       	Null = r2 - r3;
84202f28:	09 64       	if NC jump (m) Lc_cbops_sidetone_mix_map_channel_4;

84202f2a <Lc_cbops_sidetone_mix_map_channel_3>:
84202f2a:	03 f0 9a 40 	r1 = Null + 154;
84202f2e:	02 f0 13 60 	r0 = Null + 4115;
84202f32:	ff fd 87 f0 	call (m) 0x13f12;
84202f36:	21 ef 
84202f38:	14 6e       	jump (m) Lc_cbops_sidetone_mix_map_channel_7;

84202f3a <Lc_cbops_sidetone_mix_map_channel_4>:
        PL_ASSERT(input_channel < params->nr_channels);
84202f3a:	ca 88       	r0 = M[rMAC + 12];
84202f3c:	98 04       	Null = r1 - r0;
84202f3e:	09 64       	if NC jump (m) Lc_cbops_sidetone_mix_map_channel_6;

84202f40 <Lc_cbops_sidetone_mix_map_channel_5>:
84202f40:	03 f0 9b 40 	r1 = Null + 155;
84202f44:	02 f0 13 60 	r0 = Null + 4115;
84202f48:	ff fd 87 f0 	call (m) 0x13f12;
84202f4c:	2b ee 
84202f4e:	09 6e       	jump (m) Lc_cbops_sidetone_mix_map_channel_7;

84202f50 <Lc_cbops_sidetone_mix_map_channel_6>:

        /* get sidetone indexes */
        unsigned *st_in_idxs = &params->st_idxs[0];
84202f50:	0a 29       	r0 = rMAC + 20;

        /* get mapping table indexes */
        unsigned *st_map_idxs = &params->st_idxs[params->nr_st_channels];
84202f52:	6d 54       	r3 = r3 LSHIFT 2;
84202f54:	69 00       	rMAC = r3 + rMAC;
84202f56:	09 29       	rMAC = rMAC + 20;

        /* configure this channel to use sidetone mixing from use_st_channel */
        st_map_idxs[input_channel] = st_in_idxs[use_st_channel];
84202f58:	64 54       	r2 = r2 LSHIFT 2;
84202f5a:	5b 54       	r1 = r1 LSHIFT 2;
84202f5c:	12 e9       	r0 = M[r0 + r2];
84202f5e:	ca ee       	M[rMAC + r1] = r0;

84202f60 <Lc_cbops_sidetone_mix_map_channel_7>:
    }
}
84202f60:	c8 48       	popm <FP, rLink>;
84202f62:	d8 4c       	rts;

84202f64 <$_cbops_sidetone_mix_map_one_to_all>:
 * \brief configures a sidetone channel to be mixed into all main channels
 * \param op cbops multichannel sidetone mix operator (input)
 * \param use_st_channel use this sidetone channel to mix into all channels
 */
void cbops_sidetone_mix_map_one_to_all(cbops_op *op, unsigned use_st_channel)
{
84202f64:	f4 1c       	pushm <FP(=SP), r4, r5, r6, r7, rLink>;
84202f66:	18 09       	r6 = r1 + Null;
84202f68:	16 00       	r4 = r0 + Null;
    if(NULL != op)
84202f6a:	1a 60       	if EQ jump (m) Lc_cbops_sidetone_mix_map_one_to_all_7;

84202f6c <Lc_cbops_sidetone_mix_map_one_to_all_2>:
    {
        unsigned i;
        cbops_multichan_sidetone_mix_op  *params = CBOPS_PARAM_PTR(op, cbops_multichan_sidetone_mix_op);
84202f6c:	f7 88       	r5 = M[r4 + 12];
        PL_ASSERT(use_st_channel < params->nr_st_channels);
84202f6e:	39 89       	rMAC = M[r5 + 16];
84202f70:	1f f8 00 c2 	Null = r6 - rMAC;
84202f74:	09 64       	if NC jump (m) Lc_cbops_sidetone_mix_map_one_to_all_4;

84202f76 <Lc_cbops_sidetone_mix_map_one_to_all_3>:
84202f76:	03 f0 b3 40 	r1 = Null + 179;
84202f7a:	02 f0 13 60 	r0 = Null + 4115;
84202f7e:	ff fd 87 f0 	call (m) 0x13f12;
84202f82:	35 ec 
84202f84:	0d 6e       	jump (m) Lc_cbops_sidetone_mix_map_one_to_all_7;

84202f86 <Lc_cbops_sidetone_mix_map_one_to_all_4>:
        for(i = 0; i < params->nr_channels; ++i)
84202f86:	01 09       	r7 = Null + Null;

84202f88 <Lc_cbops_sidetone_mix_map_one_to_all_5>:
84202f88:	f9 88       	rMAC = M[r5 + 12];
84202f8a:	1f f9 00 c2 	Null = r7 - rMAC;
84202f8e:	02 f0 91 e0 	if C jump (m) Lc_cbops_sidetone_mix_map_one_to_all_7;

84202f92 <Lc_cbops_sidetone_mix_map_one_to_all_6>:
        {
            cbops_sidetone_mix_map_channel(op, i, use_st_channel);
84202f92:	44 08       	r2 = r6 + Null;
84202f94:	4b 08       	r1 = r7 + Null;
84202f96:	32 00       	r0 = r4 + Null;
84202f98:	c2 4f       	call (m) $_cbops_sidetone_mix_map_channel;
    if(NULL != op)
    {
        unsigned i;
        cbops_multichan_sidetone_mix_op  *params = CBOPS_PARAM_PTR(op, cbops_multichan_sidetone_mix_op);
        PL_ASSERT(use_st_channel < params->nr_st_channels);
        for(i = 0; i < params->nr_channels; ++i)
84202f9a:	09 75       	r7 = r7 + 1;
84202f9c:	f6 6f       	jump (m) Lc_cbops_sidetone_mix_map_one_to_all_5;

84202f9e <Lc_cbops_sidetone_mix_map_one_to_all_7>:
        {
            cbops_sidetone_mix_map_channel(op, i, use_st_channel);
        }
    }
}
84202f9e:	f4 48       	popm <FP, r4, r5, r6, r7, rLink>;
84202fa0:	d8 4c       	rts;

84202fa2 <$_create_multichan_sidetone_mix_op>:
                                           unsigned first_output_idx,
                                           unsigned nr_st_channels,
                                           unsigned first_st_in_idx,
                                           unsigned threshold
                                           )
{
84202fa2:	f6 1c       	pushm <FP(=SP), r4, r5, r6, r7, r8, r9, rLink>;
84202fa4:	13 09       	r9 = r0 + Null;
84202fa6:	1a 09       	r8 = r1 + Null;
84202fa8:	20 09       	r6 = r2 + Null;
84202faa:	2f 00       	r5 = r3 + Null;
84202fac:	e9 f3 ff b9 	r7 = M[FP + -4];
    /* We have first index only, to create we need an array of indexes,
     * create buffer indexes using maximum index.
     */
    unsigned max_idx = pl_max(first_input_idx, first_output_idx)+nr_channels;
84202fb0:	52 08       	r0 = r8 + Null;
84202fb2:	43 08       	r1 = r6 + Null;
84202fb4:	6f f3 42 ce 	r0 = MAX r1;
84202fb8:	5a 0c       	r0 = r9 + r0;
    max_idx = pl_max(max_idx, nr_st_channels + first_st_in_idx);
84202fba:	7f f9 03 c0 	r1 = r7 + r5;
84202fbe:	6f f3 42 ce 	r0 = MAX r1;
    unsigned *idxs = create_default_indexes(max_idx);
84202fc2:	ff fd 9f f0 	call (m) 0x16f08;
84202fc6:	27 ea 
84202fc8:	16 00       	r4 = r0 + Null;
    if(NULL == idxs)
84202fca:	03 62       	if NE jump (m) Lc_create_multichan_sidetone_mix_op_3;

84202fcc <Lc_create_multichan_sidetone_mix_op_2>:
    {
        return NULL;
84202fcc:	02 00       	r0 = Null + Null;
84202fce:	1a 6e       	jump (m) Lc_create_multichan_sidetone_mix_op_4;

84202fd0 <Lc_create_multichan_sidetone_mix_op_3>:
    cbops_op* op = create_multichan_sidetone_mix_op_base(nr_channels,
                                                         &idxs[first_input_idx],
                                                         &idxs[first_output_idx],
                                                         nr_st_channels,
                                                         &idxs[first_st_in_idx],
                                                         threshold);
84202fd0:	f1 d9       	rMAC = M[FP + -8];
84202fd2:	09 1c       	pushm <rMAC>;
84202fd4:	01 f9 d2 c8 	r0 = r7 LSHIFT 2;
84202fd8:	31 00       	rMAC = r4 + Null;
84202fda:	51 00       	rMAC = r0 + rMAC;
84202fdc:	09 1c       	pushm <rMAC>;
84202fde:	01 f8 d2 c8 	r0 = r6 LSHIFT 2;
84202fe2:	34 00       	r2 = r4 + Null;
84202fe4:	33 00       	r1 = r4 + Null;
84202fe6:	3d 00       	r3 = r5 + Null;
84202fe8:	14 01       	r2 = r0 + r2;
84202fea:	01 fa d2 c8 	r0 = r8 LSHIFT 2;
84202fee:	d3 00       	r1 = r0 + r1;
84202ff0:	5a 08       	r0 = r9 + Null;
84202ff2:	55 4f       	call (m) $_create_multichan_sidetone_mix_op_base;
84202ff4:	7e 4c       	SP = SP + -8;
84202ff6:	17 00       	r5 = r0 + Null;
    pfree(idxs);
84202ff8:	32 00       	r0 = r4 + Null;
84202ffa:	ff fd 0f f0 	call (m) 0x4f62;
84202ffe:	29 eb 
    return op;
84203000:	3a 00       	r0 = r5 + Null;

84203002 <Lc_create_multichan_sidetone_mix_op_4>:
}
84203002:	f6 48       	popm <FP, r4, r5, r6, r7, r8, r9, rLink>;
84203004:	d8 4c       	rts;

84203006 <$_opmgr_op_is_running>:
84203006:	01 00       	rMAC = Null + Null;
 *
 * \param op_data The data structure of the operator to query
 */
bool opmgr_op_is_running(OPERATOR_DATA *op_data)
{
    return op_data->state == OP_RUNNING;
84203008:	10 b0       	Null = MBS[r0 + 24];
8420300a:	20 f0 41 ce 	if EQ rMAC = Null + 1;
8420300e:	0a 00       	r0 = rMAC + Null;

84203010 <Lc_opmgr_op_is_running_2>:
84203010:	d8 4c       	rts;

84203012 <$_get_override_ep_rate_adjust_op>:
84203012:	f1 1e       	pushm <FP(=SP), r4, rLink>, SP = SP + 0x20;
#define EP_CURRENT_HW_WARP ((uint32)0x1001A)

#ifdef INSTALL_DELEGATE_RATE_ADJUST_SUPPORT
/* get_override_ep_rate_adjust_op */
bool get_override_ep_rate_adjust_op(OVERRIDE_EP_HANDLE ep_hdl, uint32* value)
{
84203014:	1e 00       	r4 = r1 + Null;
/** Set the unreliable flag
 * \param rm Rate measurement context
 */
static void inline rate_measure_set_unreliable(RATE_MEASURE* rm)
{
    rm->unreliable = TRUE;
84203016:	c4 10       	r2 = FP + 12;
84203018:	58 dc       	MH[FP + 22] = Null;
8420301a:	80 da       	MB[FP + 16] = Null;
    ENDPOINT_GET_CONFIG_RESULT result;
    result.u.value = 0;
8420301c:	18 de       	M[FP + 12] = Null;
    bool success = stream_get_connected_to_endpoint_config((ENDPOINT*)ep_hdl, EP_RATE_ADJUST_OP, &result);
8420301e:	83 f0 18 40 	r1 = Null + 65560;
84203022:	ff fd 18 f0 	call (m) 0x6128;
84203026:	27 e8 
    *value = result.u.value;
84203028:	19 d8       	rMAC = M[FP + 12];
8420302a:	31 ee       	M[r4 + Null] = rMAC;

8420302c <Lc_get_override_ep_rate_adjust_op_2>:
    return success;
8420302c:	f1 4a       	SP = SP - 0x20, popm <FP, r4, rLink>;
8420302e:	d8 4c       	rts;

84203030 <$_set_override_ep_set_hw_warp_apply_mode>:
}
#endif /* INSTALL_DELEGATE_RATE_ADJUST_SUPPORT */
/* set_override_ep_set_hw_warp_apply_mode */
bool set_override_ep_set_hw_warp_apply_mode(OVERRIDE_EP_HANDLE ep_hdl, uint32 value)
{
84203030:	c8 1c       	pushm <FP(=SP), rLink>;
84203032:	1c 00       	r2 = r1 + Null;
    return stream_configure_connected_to_endpoint((ENDPOINT*)ep_hdl, EP_HW_WARP_APPLY_MODE, value);
84203034:	83 f0 19 40 	r1 = Null + 65561;
84203038:	ff fd 18 f0 	call (m) 0x6146;
8420303c:	2f e8 

8420303e <Lc_set_override_ep_set_hw_warp_apply_mode_2>:
}
8420303e:	c8 48       	popm <FP, rLink>;
84203040:	d8 4c       	rts;

84203042 <$_get_override_ep_current_hw_warp>:


/* get_override_ep_current_hw_warp */
bool get_override_ep_current_hw_warp(OVERRIDE_EP_HANDLE ep_hdl, uint32* value)
{
84203042:	f1 1e       	pushm <FP(=SP), r4, rLink>, SP = SP + 0x20;
84203044:	1e 00       	r4 = r1 + Null;
84203046:	c4 10       	r2 = FP + 12;
84203048:	58 dc       	MH[FP + 22] = Null;
8420304a:	80 da       	MB[FP + 16] = Null;
    ENDPOINT_GET_CONFIG_RESULT result;
    result.u.value = 0;
8420304c:	18 de       	M[FP + 12] = Null;
    bool success = stream_get_connected_to_endpoint_config((ENDPOINT*)ep_hdl, EP_CURRENT_HW_WARP, &result);
8420304e:	83 f0 1a 40 	r1 = Null + 65562;
84203052:	ff fd 18 f0 	call (m) 0x6128;
84203056:	37 e6 
    *value = result.u.value;
84203058:	19 d8       	rMAC = M[FP + 12];
8420305a:	31 ee       	M[r4 + Null] = rMAC;

8420305c <Lc_get_override_ep_current_hw_warp_2>:
    return success;
8420305c:	f1 4a       	SP = SP - 0x20, popm <FP, r4, rLink>;
8420305e:	d8 4c       	rts;

84203060 <$_stream_delegate_rate_adjust_set_target_rate>:
84203060:	c8 1d       	pushm <FP(=SP), rLink>, SP = SP + 0x10;
 *
 * \param opid operator id for the standalone rate adjust operator
 * \param target_rate_addr target rate
 */
void stream_delegate_rate_adjust_set_target_rate(unsigned opid, unsigned target_rate)
{
84203062:	11 00       	rMAC = r0 + Null;
    unsigned params[3];

    /* send SET_TARGET_RATE message to the operator */
    params[0] = OPMSG_COMMON_SET_RATE_ADJUST_TARGET_RATE;
84203064:	12 f0 18 40 	r0 = Null + 8216;
84203068:	12 de       	M[FP + 8] = r0;
    params[1] = (uint16) (target_rate >> 16);
8420306a:	9a 52       	r0 = r1 LSHIFT -16;
8420306c:	1a de       	M[FP + 12] = r0;
    params[2] = (uint16) (target_rate & 0xFFFF);
8420306e:	9a c6       	r0 = r1 AND 0xffff;
84203070:	22 de       	M[FP + 16] = r0;
    opmgr_operator_message(RESPOND_TO_OBPM,
                           opid,
                           sizeof(params)/sizeof(unsigned),
                           params,
                           stream_delegate_rate_adjust_message_callback);
84203072:	42 f0 30 f0 	push Null + 69218529;
84203076:	51 ee 
84203078:	85 10       	r3 = FP + 8;
8420307a:	c4 20       	r2 = Null + 3;
8420307c:	c2 2b       	r0 = Null + 31;
8420307e:	0b 00       	r1 = rMAC + Null;
84203080:	ff fd 03 f0 	call (m) 0x37ca;
84203084:	2b ea 
84203086:	7f 4c       	SP = SP + -4;

84203088 <Lc_stream_delegate_rate_adjust_set_target_rate_2>:
}
84203088:	c8 49       	SP = SP - 0x10, popm <FP, rLink>;
8420308a:	d8 4c       	rts;

8420308c <$_stream_delegate_rate_adjust_set_passthrough_mode>:
 *
 * \param opid operator id for the standalone rate adjust operator
 * \param enable if TRUE enables pass-through mode else disables it
 */
void stream_delegate_rate_adjust_set_passthrough_mode(unsigned opid, bool enable)
{
8420308c:	c8 1d       	pushm <FP(=SP), rLink>, SP = SP + 0x10;
8420308e:	11 00       	rMAC = r0 + Null;
    unsigned params[2];

    /* send PASSTHROUGH_MODE message to the operator */
    params[0] = OPMSG_COMMON_SET_RATE_ADJUST_PASSTHROUGH_MODE;
84203090:	12 f0 19 40 	r0 = Null + 8217;
84203094:	12 de       	M[FP + 8] = r0;
    params[1] = (uint16) enable;
84203096:	9a c6       	r0 = r1 AND 0xffff;
84203098:	1a de       	M[FP + 12] = r0;
    opmgr_operator_message(RESPOND_TO_OBPM,
                           opid,
                           sizeof(params)/sizeof(unsigned),
                           params,
                           stream_delegate_rate_adjust_message_callback);
8420309a:	42 f0 30 f0 	push Null + 69218529;
8420309e:	51 ee 
842030a0:	85 10       	r3 = FP + 8;
842030a2:	84 20       	r2 = Null + 2;
842030a4:	c2 2b       	r0 = Null + 31;
842030a6:	0b 00       	r1 = rMAC + Null;
842030a8:	ff fd 03 f0 	call (m) 0x37ca;
842030ac:	23 e9 
842030ae:	7f 4c       	SP = SP + -4;

842030b0 <Lc_stream_delegate_rate_adjust_set_passthrough_mode_2>:
}
842030b0:	c8 49       	SP = SP - 0x10, popm <FP, rLink>;
842030b2:	d8 4c       	rts;

842030b4 <$_stream_delegate_rate_adjust_set_current_rate>:
 *
 * Note: This message when delivered will directly set the current sra rate,
 *       suitable for TTP-type rate adjustment.
 */
void stream_delegate_rate_adjust_set_current_rate(unsigned opid, unsigned rate)
{
842030b4:	c8 1d       	pushm <FP(=SP), rLink>, SP = SP + 0x10;
842030b6:	11 00       	rMAC = r0 + Null;
    unsigned params[3];

    /* send SET_CURRENT_RATE message to the operator */
    params[0] = OPMSG_COMMON_SET_RATE_ADJUST_CURRENT_RATE;
842030b8:	12 f0 17 40 	r0 = Null + 8215;
842030bc:	12 de       	M[FP + 8] = r0;
    params[1] = (uint16) (rate >> 16);
842030be:	9a 52       	r0 = r1 LSHIFT -16;
842030c0:	1a de       	M[FP + 12] = r0;
    params[2] = (uint16) (rate & 0xFFFF);
842030c2:	9a c6       	r0 = r1 AND 0xffff;
842030c4:	22 de       	M[FP + 16] = r0;
    opmgr_operator_message(RESPOND_TO_OBPM,
                           opid,
                           sizeof(params)/sizeof(unsigned),
                           params,
                           stream_delegate_rate_adjust_message_callback);
842030c6:	42 f0 30 f0 	push Null + 69218529;
842030ca:	51 ee 
842030cc:	85 10       	r3 = FP + 8;
842030ce:	c4 20       	r2 = Null + 3;
842030d0:	c2 2b       	r0 = Null + 31;
842030d2:	0b 00       	r1 = rMAC + Null;
842030d4:	ff fd 03 f0 	call (m) 0x37ca;
842030d8:	37 e7 
842030da:	7f 4c       	SP = SP + -4;

842030dc <Lc_stream_delegate_rate_adjust_set_current_rate_2>:
}
842030dc:	c8 49       	SP = SP - 0x10, popm <FP, rLink>;
842030de:	d8 4c       	rts;

842030e0 <Lc_stream_delegate_rate_adjust_message_callback_1>:
static bool stream_delegate_rate_adjust_message_callback(unsigned con_id,
                                                         unsigned status,
                                                         unsigned op_id,
                                                         unsigned num_resp_params,
                                                         unsigned *resp_params)
{
842030e0:	c8 1c       	pushm <FP(=SP), rLink>;
842030e2:	11 00       	rMAC = r0 + Null;
    /* No action, just log the response if message if it failed */
    if(status != STATUS_OK)
842030e4:	18 04       	Null = r1 - Null;
842030e6:	11 60       	if EQ jump (m) Lc_stream_delegate_rate_adjust_message_callback_6;

842030e8 <Lc_stream_delegate_rate_adjust_message_callback_2>:
    {
        L2_DBG_MSG4("Message to standalone rate adjust op failed: conid=%d, opid=%d, status=%d, messageID=%d",
                    con_id,
                    op_id,
                    status,
                    num_resp_params == 0?-1:resp_params[0]);
842030e8:	28 04       	Null = r3 - Null;
842030ea:	03 62       	if NE jump (m) Lc_stream_delegate_rate_adjust_message_callback_4;

842030ec <Lc_stream_delegate_rate_adjust_message_callback_3>:
842030ec:	42 24       	r0 = Null - 1;
842030ee:	03 6e       	jump (m) Lc_stream_delegate_rate_adjust_message_callback_5;

842030f0 <Lc_stream_delegate_rate_adjust_message_callback_4>:
842030f0:	fa d9       	r0 = M[FP + -4];
842030f2:	12 e8       	r0 = M[r0 + Null];

842030f4 <Lc_stream_delegate_rate_adjust_message_callback_5>:
842030f4:	11 1c       	pushm <r0>;
842030f6:	55 f1 02 f0 	r0 = Null + 357565199;
842030fa:	0f 43 
842030fc:	1d 00       	r3 = r1 + Null;
842030fe:	0b 00       	r1 = rMAC + Null;
84203100:	ef fd ec ff 	call (m) 0x9f6;
84203104:	37 e7 
84203106:	7f 4c       	SP = SP + -4;

84203108 <Lc_stream_delegate_rate_adjust_message_callback_6>:
    }

    return TRUE;
84203108:	42 20       	r0 = Null + 1;

8420310a <Lc_stream_delegate_rate_adjust_message_callback_7>:
}
8420310a:	c8 48       	popm <FP, rLink>;
8420310c:	d8 4c       	rts;

8420310e <$kdc_start>:
.MODULE $M.kdc_start;
.CODESEGMENT PM;
.DATASEGMENT DM;

$kdc_start:
r0 = $_aec_reference_cap_data;
8420310e:	07 f0 02 f0 	r0 = Null + 7340032;
84203112:	00 40 
    /* Force this symbol to be exported in ELF */
    Null = $___kymera_debug_map_addr;
84203114:	20 f0 b0 41 	Null = Null + 16816;

84203118 <$cbops.aec_ref_spkr_op.amount_to_use>:
          
#ifdef PATCH_LIBS
    LIBS_SLOW_SW_ROM_PATCH_POINT($cbops.aec_ref_spkr_op.amount_to_use.PATCH_ID_0, r7)
#endif
          
   push rlink;
84203118:	00 f0 3d cf 	push rLink;
   
   // Get data pointer
   r7 = M[r8 + $cbops.param_hdr.OPERATOR_DATA_PTR_FIELD];
8420311c:	a9 f0 00 88 	r7 = M[r8 + 0];
   // Get amount of input
   r0 = M[r8 + $cbops.param_hdr.CHANNEL_INDEX_START_FIELD];    
84203120:	a2 f0 03 88 	r0 = M[r8 + 12];
   call $cbops.get_amount_ptr;
84203124:	ff fd c6 f2 	call 0x5bd9c;
84203128:	38 e3 
   r5 = M[r0];
8420312a:	17 e8       	r5 = M[r0 + Null];
   // Save data at input and make input large, will re-adjust for insertion
   M[r7 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.AMOUNT_DATA_FIELD] = r5;
8420312c:	97 f0 03 8e 	M[r7 + 12] = r5;
   r5 = 0x7FFF;
84203130:	37 f0 ff 7b 	r5 = Null + 32767;
   M[r0] = r5;
84203134:	87 ee       	M[Null + r0] = r5;

#ifndef CHIP_BASE_A7DA_KAS
   // Get first output index
   r9 = M[r8 + $cbops.param_hdr.NR_INPUT_CHANNELS_FIELD];
84203136:	ab f0 01 88 	r9 = M[r8 + 4];
   Words2Addr(r9);
8420313a:	01 fb 1b c9 	r9 = r9 ASHIFT 2;
   r9 = r9 + $cbops.param_hdr.CHANNEL_INDEX_START_FIELD;
8420313e:	63 75       	r9 = r9 + 12;
   r0 = M[r8 + r9];
84203140:	a2 f0 0b e8 	r0 = M[r8 + r9];
   call $cbops.get_cbuffer;
84203144:	ff fd c6 f2 	call 0x5bd8c;
84203148:	28 e2 
   NULL = r0;
8420314a:	10 00       	Null = r0 + Null;
   if Z jump aec_ref_spkr_op.amount_to_use_done;
8420314c:	16 60       	if EQ jump (m) $M.cbops.aec_ref_spkr_op.aec_ref_spkr_op.amount_to_use_done;

   // First Port (r0);
   r5 = NULL;
8420314e:	07 00       	r5 = Null + Null;
   r6 = M[r7 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.MAX_ADVANCE_FIELD];
84203150:	98 f0 01 88 	r6 = M[r7 + 4];
   r1 = M[r7 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.MAX_JITTER_FIELD];
84203154:	93 f0 06 88 	r1 = M[r7 + 24];
   r6 = r6 + r1;  
84203158:	18 0d       	r6 = r1 + r6;

   call calc_dac_amount_of_data;
8420315a:	d4 4e       	call (m) $M.cbops.aec_ref_spkr_op.calc_dac_amount_of_data;
   // r2 is data in port (negative if wrap), r10 is max advance, r0 is adjustment
   // Limit amount of data after transfer to two times maximum advance
   NULL = r2 + r0;
8420315c:	a0 00       	Null = r2 + r0;
   if POS r1 = r6 - r2;
8420315e:	45 f8 03 c2 	if POS r1 = r6 - r2;
   if NEG r1 = Null;
84203162:	04 f0 03 c0 	if NEG r1 = Null + Null;

   // Setup the limited transfer at output
   r0 = M[r8 + r9];
84203166:	a2 f0 0b e8 	r0 = M[r8 + r9];
   call $cbops.get_amount_ptr;
8420316a:	ff fd c6 f2 	call 0x5bd9c;
8420316e:	32 e1 
   M[r0]=r1;
84203170:	83 ee       	M[Null + r0] = r1;
   if Z call $cbops.force_processing;
84203172:	f0 fd c6 f2 	if EQ call 0x5bdac;
84203176:	3a e1 

84203178 <$M.cbops.aec_ref_spkr_op.aec_ref_spkr_op.amount_to_use_done>:
#endif

aec_ref_spkr_op.amount_to_use_done:
   pop rlink;
84203178:	00 f4 3d cf 	pop rLink;
   rts;
8420317c:	d8 4c       	rts;

8420317e <$cbops.aec_ref_spkr_op.pre_main>:

#ifndef CBOPS_AEC_REF_SPKR_OP_PRE_MAIN_USE_ROM
// Called after amount to use of graph but before main processing of graph
$cbops.aec_ref_spkr_op.pre_main:
   push rLink;
8420317e:	00 f0 3d cf 	push rLink;
    *                       |
    *                       |
    *                Possible Silence Insert
    *-----------------------------------------------------------------------*/
   // Get data pointer
   r7 = M[r8 + $cbops.param_hdr.OPERATOR_DATA_PTR_FIELD];
84203182:	a9 f0 00 88 	r7 = M[r8 + 0];

   // Get intermediate buffer indexes
   I7 = r7 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.INTERM_IDXS_FIELD;
84203186:	97 f8 1c 20 	I7 = r7 + 28;

   // Get input buffer indexes
   I2 = r8 + $cbops.param_hdr.CHANNEL_INDEX_START_FIELD;
8420318a:	a2 f8 0c 20 	I2 = r8 + 12;

   // Get number of input channels
   r0 = M[r8 + $cbops.param_hdr.NR_INPUT_CHANNELS_FIELD];
8420318e:	a2 f0 01 88 	r0 = M[r8 + 4];
   M2 = r0;
84203192:	12 0b       	M2 = r0 + Null;

   // r5 will hold the amount of silence needed
   // to insert this run
   r5 = 0;
84203194:	07 00       	r5 = Null + Null;

   // transfer amount from input
   r0 = M[I2, 0];
84203196:	28 f0 30 c0 	Null = Null + Null, r0 = M[I2,0];
   call $cbops.get_amount_ptr;
8420319a:	ff fd c6 f2 	call 0x5bd9c;
8420319e:	22 e0 
   r10 = r0;
842031a0:	14 09       	r10 = r0 + Null;

   // transfer amount to interm stage
   r0 = M[I7, 0];
842031a2:	2c f0 30 d0 	Null = Null + Null, r0 = M[I7,0];
   call $cbops.get_amount_ptr;
842031a6:	ff fd c5 f2 	call 0x5bd9c;
842031aa:	36 ef 
   r6 = M[r0];
842031ac:	28 f0 00 e8 	r6 = M[r0 + Null];

   // optimisation, early exit if nothing can transfer
   // to interm stage.
   if Z M[r10] = r6;
842031b0:	00 f8 8c c1 	if EQ M[r10] = r6 + Null;
   if Z jump aec_ref_spkr_op.pre_main_done;
842031b4:	4f 60       	if EQ jump (m) $M.cbops.aec_ref_spkr_op.aec_ref_spkr_op.pre_main_done;

   // Get amount of data and threshold. Determine if need to insert.
   r3 = M[r7 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.AMOUNT_DATA_FIELD];
842031b6:	95 f0 03 88 	r3 = M[r7 + 12];
   NULL = r6 - r3;
842031ba:	5f f8 00 c2 	Null = r6 - r3;
   if LE jump aec_ref_spkr_op.pre_main_transfer;
842031be:	0f 6c       	if LE jump (m) $M.cbops.aec_ref_spkr_op.aec_ref_spkr_op.pre_main_transfer;

   // Insufficient data, limit transfer to threshold.
   r2 = M[r7 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.IN_THRESHOLD_FIELD];
842031c0:	94 f0 00 88 	r2 = M[r7 + 0];
   r6 = MIN r2;
842031c4:	5f f4 48 ce 	r6 = MIN r2;
   // r3: amount of data in the input buffer
   // r6: amount of data that "must" be pushed into next stage
   //  if input has enough data then transfer needed samples from
   //  input buffer otherwise silence will be inserted to make sure
   //  exactly r6 samples will be pushed into next stage.
   r5 = r6 - r3;
842031c8:	5f f8 07 c2 	r5 = r6 - r3;
   if LE r5 = 0;
842031cc:	0d f0 07 c0 	if LE r5 = Null + Null;
   if Z jump aec_ref_spkr_op.pre_main_transfer;
842031d0:	06 60       	if EQ jump (m) $M.cbops.aec_ref_spkr_op.aec_ref_spkr_op.pre_main_transfer;
   // Insert (r5) zeroes with this transfer, update counter
   r1 = M[r7 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.NUM_INSERTS_FIELD];
842031d2:	93 f0 05 88 	r1 = M[r7 + 20];
   r1 = r1 + r5;
842031d6:	fb 00       	r1 = r5 + r1;
   M[r7 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.NUM_INSERTS_FIELD]=r1;
842031d8:	93 f0 05 8e 	M[r7 + 20] = r1;

842031dc <$M.cbops.aec_ref_spkr_op.aec_ref_spkr_op.pre_main_transfer>:
   //  r7: data pointer of the operator
   //  r0: transfer amount ptr for intermediate buffer
   //  r10: transfer amount ptr for input buffer

   // update transfer amount for interm bufs
   M[r0] = r6;
842031dc:	08 f0 02 ee 	M[Null + r0] = r6;

   // amount that should be transferred from input
   r6 = r6 - r5;
842031e0:	00 f7 38 c2 	r6 = r6 - r5;

   // update transfer amount for input bufs
   M[r10] = r6;
842031e4:	08 f0 0c ee 	M[Null + r10] = r6;

842031e8 <$M.cbops.aec_ref_spkr_op.transfer_and_silence_insert_channel>:

   // r5: amount of silence to insert
   // r6: amount of transfer from input buffer
   transfer_and_silence_insert_channel:
      // Setup Input Buffer
      r0 = M[I2,0];
842031e8:	28 f0 30 c0 	Null = Null + Null, r0 = M[I2,0];
      call $cbops.get_buffer_address_and_length;
842031ec:	ff fd c5 f2 	call 0x5bd20;
842031f0:	34 e9 
      I0 = r0;
842031f2:	10 0a       	I0 = r0 + Null;
      if Z jump next_transfer_and_silence_insert_channel;
842031f4:	1d 60       	if EQ jump (m) $M.cbops.aec_ref_spkr_op.next_transfer_and_silence_insert_channel;
      L0 = r1;
842031f6:	1c 0b       	L0 = r1 + Null;
      push r2;
842031f8:	00 f0 34 cf 	push r2;
      pop B0;
842031fc:	00 f6 3a cf 	pop B0;

      // Setup Interm Buffer
      r0 = M[I7,0];
84203200:	2c f0 30 d0 	Null = Null + Null, r0 = M[I7,0];
      call $cbops.get_buffer_address_and_length;
84203204:	ff fd c5 f2 	call 0x5bd20;
84203208:	3c e8 
      I4 = r0;
8420320a:	14 0a       	I4 = r0 + Null;
      if Z jump next_transfer_and_silence_insert_channel;
8420320c:	11 60       	if EQ jump (m) $M.cbops.aec_ref_spkr_op.next_transfer_and_silence_insert_channel;
      L4 = r1;
8420320e:	1e 0b       	L4 = r1 + Null;
      push r2;
84203210:	00 f0 34 cf 	push r2;
      pop B4;
84203214:	00 f6 3c cf 	pop B4;

      // first silence insertion if needed
      r10 = r5;
84203218:	3c 09       	r10 = r5 + Null;
      r0 = 0;
8420321a:	02 00       	r0 = Null + Null;
      do silence_insert_loop;
8420321c:	03 4c       	do (m) $M.cbops.aec_ref_spkr_op.silence_insert_loop;
         M[I4, MK1] = r0;
8420321e:	a1 f0 30 d0 	Null = Null + Null, M[I4,4] = r0;

84203222 <$M.cbops.aec_ref_spkr_op.silence_insert_loop>:
      silence_insert_loop:

      // then transfer real audio from input
      r10 = r6;
84203222:	44 09       	r10 = r6 + Null;
      do transfer_loop;
84203224:	05 4c       	do (m) $M.cbops.aec_ref_spkr_op.next_transfer_and_silence_insert_channel;
         r0 = M[I0, MK1];
84203226:	21 f0 30 c0 	Null = Null + Null, r0 = M[I0,4];
         M[I4, MK1] = r0;
8420322a:	a1 f0 30 d0 	Null = Null + Null, M[I4,4] = r0;

8420322e <$M.cbops.aec_ref_spkr_op.next_transfer_and_silence_insert_channel>:
      transfer_loop:

      next_transfer_and_silence_insert_channel:
      r0 = M[I2, MK1], r1 = M[I7, MK1];
8420322e:	3d f9 32 d0 	Null = Null + Null, r0 = M[I2,4], r1 = M[I7,4];
      M2 = M2 - 1;
84203232:	aa fc 01 24 	M2 = M2 - 1;
   if GT jump transfer_and_silence_insert_channel;
84203236:	d9 6b       	if GT jump (m) $M.cbops.aec_ref_spkr_op.transfer_and_silence_insert_channel;

   // Reset Buffering control
   L0 = 0;
84203238:	04 0b       	L0 = Null + Null;
   L4 = 0;
8420323a:	06 0b       	L4 = Null + Null;
   push NULL;
8420323c:	00 f0 30 cf 	push Null;
   pop B0;
84203240:	00 f6 3a cf 	pop B0;
   push NULL;
84203244:	00 f0 30 cf 	push Null;
   pop B4;
84203248:	00 f6 3c cf 	pop B4;

   /* Something written at the interim stage
    * force going ahead
    */
   call $cbops.force_processing;
8420324c:	ff fd c5 f2 	call 0x5bdac;
84203250:	20 eb 

84203252 <$M.cbops.aec_ref_spkr_op.aec_ref_spkr_op.pre_main_done>:

aec_ref_spkr_op.pre_main_done:
   pop rlink;
84203252:	00 f4 3d cf 	pop rLink;
   rts;
84203256:	d8 4c       	rts;

84203258 <$_get_aec_ref_cbops_inserts_total>:
#endif /* #ifndef CBOPS_AEC_REF_SPKR_OP_PRE_MAIN_USE_ROM */
// unsigned get_aec_ref_cbops_inserts_total(cbops_op *op);
$_get_aec_ref_cbops_inserts_total:
    r0 = M[r0 + ($cbops_c.cbops_op_struct.PARAMETER_AREA_START_FIELD+$cbops.param_hdr.OPERATOR_DATA_PTR_FIELD)];
84203258:	d2 88       	r0 = M[r0 + 12];
    r1 = M[r0 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.WRAP_COUNT_FIELD];
8420325a:	13 89       	r1 = M[r0 + 16];
    r0 = M[r0 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.NUM_INSERTS_FIELD];
8420325c:	52 89       	r0 = M[r0 + 20];
    r0 = r0 + r1;
8420325e:	9a 00       	r0 = r1 + r0;
    rts;
84203260:	d8 4c       	rts;

84203262 <$_get_aec_ref_cbops_insert_op_insert_total>:

// unsigned get_aec_ref_cbops_insert_op_insert_total(cbops_op *op);
$_get_aec_ref_cbops_insert_op_insert_total:
    r0 = M[r0 + ($cbops_c.cbops_op_struct.PARAMETER_AREA_START_FIELD+$cbops.param_hdr.OPERATOR_DATA_PTR_FIELD)];
84203262:	d2 88       	r0 = M[r0 + 12];
    r0 = M[r0 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.NUM_INSERTS_FIELD];
84203264:	52 89       	r0 = M[r0 + 20];
    rts;
84203266:	d8 4c       	rts;

84203268 <$_get_aec_ref_cbops_wrap_op_insert_total>:

// unsigned get_aec_ref_cbops_wrap_op_insert_total(cbops_op *op);
$_get_aec_ref_cbops_wrap_op_insert_total:
    r0 = M[r0 + ($cbops_c.cbops_op_struct.PARAMETER_AREA_START_FIELD+$cbops.param_hdr.OPERATOR_DATA_PTR_FIELD)];
84203268:	d2 88       	r0 = M[r0 + 12];
    r0 = M[r0 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.WRAP_COUNT_FIELD];
8420326a:	12 89       	r0 = M[r0 + 16];
    rts;
8420326c:	d8 4c       	rts;

8420326e <$cbops.aec_ref_spkr_op.post_main>:
#ifndef CHIP_BASE_A7DA_KAS
// Called after main processing of graph before buffer update
$cbops.aec_ref_spkr_op.post_main:

   // Check for Buffer Wrapping
    push rLink;
8420326e:	00 f0 3d cf 	push rLink;
#ifdef PATCH_LIBS
    LIBS_SLOW_SW_ROM_PATCH_POINT($cbops.aec_ref_spkr_op.post_main.PATCH_ID_0, r9)
#endif

    // Get first output index
    r9 = M[r8 + $cbops.param_hdr.NR_INPUT_CHANNELS_FIELD];
84203272:	ab f0 01 88 	r9 = M[r8 + 4];
    Words2Addr(r9);
84203276:	01 fb 1b c9 	r9 = r9 ASHIFT 2;
    r9 = r9 + r8;
8420327a:	53 0d       	r9 = r8 + r9;
    I4 = r9 + $cbops.param_hdr.CHANNEL_INDEX_START_FIELD;
8420327c:	b4 f8 0c 20 	I4 = r9 + 12;

    // Get first buffer entry 
    r0 = M[I4,0];
84203280:	20 f0 30 d0 	Null = Null + Null, r0 = M[I4,0];
    r3 = r0 * $CBOP_BUFTAB_ENTRY_SIZE_IN_ADDR (int);
84203284:	15 47       	r3 = r0 * 28 (int);
    r3 = r3 + r4;
84203286:	75 01       	r3 = r4 + r3;

    // Get Cbuffer Ptr
    r0 = M[r3 + $cbops_c.cbops_buffer_struct.BUFFER_FIELD];
84203288:	6a 88       	r0 = M[r3 + 4];
    if Z jump $pop_rLink_and_rts;
8420328a:	7c ff 30 f5 	if EQ jump (m) 0x2cf82;
8420328e:	f9 e9 

#if !defined(CHIP_BASE_BC7)   
    // Get transfer amount (r5)
    r1 = M[r3 + $cbops_c.cbops_buffer_struct.TRANSFER_PTR_FIELD];
84203290:	6b 89       	r1 = M[r3 + 20];
    r5 = M[r1];
84203292:	1f e8       	r5 = M[r1 + Null];
#else
    r5 = NULL;
#endif

    // Compute amount of data in source
    r7 = M[r8 + $cbops.param_hdr.OPERATOR_DATA_PTR_FIELD];
84203294:	a9 f0 00 88 	r7 = M[r8 + 0];
    r6 = M[r7 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.MAX_JITTER_FIELD];
84203298:	98 f0 06 88 	r6 = M[r7 + 24];
    call calc_dac_amount_of_data;
8420329c:	33 4e       	call (m) $M.cbops.aec_ref_spkr_op.calc_dac_amount_of_data;

    r6 = M[r7 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.MAX_ADVANCE_FIELD];
8420329e:	98 f0 01 88 	r6 = M[r7 + 4];

    // r2 is number of samples in port, negative if overflow
    r10 = r6 - r2;
842032a2:	4f f8 0c c2 	r10 = r6 - r2;
    if LE jump $pop_rLink_and_rts;
842032a6:	7c ff 3d f5 	if LE jump (m) 0x2cf82;
842032aa:	dd e9 

    // Increment Wrap count
    r1 = M[r7 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.WRAP_COUNT_FIELD];
842032ac:	93 f0 04 88 	r1 = M[r7 + 16];
    r1 = r1 + r10;    
842032b0:	63 0c       	r1 = r10 + r1;
    M[r7 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.WRAP_COUNT_FIELD]=r1;
842032b2:	93 f0 04 8e 	M[r7 + 16] = r1;
    
    // setup amounts for insertions
    r5 = r5 + r10;
842032b6:	67 0c       	r5 = r10 + r5;
    r6 = r10;
842032b8:	60 09       	r6 = r10 + Null;

    // Number of Ports
    r9 = M[r8 + $cbops.param_hdr.NR_OUTPUT_CHANNELS_FIELD];
842032ba:	ab f0 02 88 	r9 = M[r8 + 8];

842032be <$M.cbops.aec_ref_spkr_op.process_channel>:

    // Perform insertion
 process_channel:
    r0 = M[I4,0];
842032be:	20 f0 30 d0 	Null = Null + Null, r0 = M[I4,0];
    call $cbops.get_buffer_address_and_length;
842032c2:	ff fd c5 f2 	call 0x5bd20;
842032c6:	3e e2 
    I0 = r0;
842032c8:	10 0a       	I0 = r0 + Null;
    if Z jump process_channel_next;
842032ca:	11 60       	if EQ jump (m) $M.cbops.aec_ref_spkr_op.process_channel_next;
      // Insert r6 zeros
      r10 = r6;
842032cc:	44 09       	r10 = r6 + Null;
      L0 = r1;
842032ce:	1c 0b       	L0 = r1 + Null;
      push r2;
842032d0:	00 f0 34 cf 	push r2;
      pop B0;
842032d4:	00 f6 3a cf 	pop B0;
      r1  = Null;
842032d8:	03 00       	r1 = Null + Null;
      do lp_insert_loop;
842032da:	03 4c       	do (m) $M.cbops.aec_ref_spkr_op.lp_insert_loop;
         M[I0, MK1] = r1;
842032dc:	b1 f0 30 c0 	Null = Null + Null, M[I0,4] = r1;

842032e0 <$M.cbops.aec_ref_spkr_op.lp_insert_loop>:
      lp_insert_loop:
      // Update amount (r5)
      r0 = M[I4,MK1];
842032e0:	21 f0 30 d0 	Null = Null + Null, r0 = M[I4,4];
      call $cbops.get_amount_ptr;
842032e4:	ff fd c5 f2 	call 0x5bd9c;
842032e8:	38 e5 
      M[r0]=r5;
842032ea:	87 ee       	M[Null + r0] = r5;

842032ec <$M.cbops.aec_ref_spkr_op.process_channel_next>:
    process_channel_next:
    r9 = r9 - 1;
842032ec:	bb f0 01 24 	r9 = r9 - 1;
    if GT jump process_channel;
842032f0:	e7 6b       	if GT jump (m) $M.cbops.aec_ref_spkr_op.process_channel;

    // Clear circular buffer
    L0=NULL;
842032f2:	04 0b       	L0 = Null + Null;
    push NULL;
842032f4:	00 f0 30 cf 	push Null;
    pop B0;
842032f8:	00 f6 3a cf 	pop B0;

    pop rlink;
842032fc:	00 f4 3d cf 	pop rLink;
    rts;
84203300:	d8 4c       	rts;

84203302 <$M.cbops.aec_ref_spkr_op.calc_dac_amount_of_data>:
// TRASHED REGISTERS:
//    r0,r1,r2
//
// *****************************************************************************
calc_dac_amount_of_data:
    push rLink;
84203302:	00 f0 3d cf 	push rLink;
    call $cbuffer.calc_amount_space_in_words;
84203306:	ff fd 47 f1 	call (m) 0x2c1b6;
8420330a:	31 e5 

#ifdef CHIP_BASE_HYDRA
    // Hydra: r2 is local buffer size in addr
    Addr2Words(r2);
8420330c:	64 58       	r2 = r2 ASHIFT -2;
    // Adjust space for amount written, buffer not port
    r0 = r0 - r5;
8420330e:	d2 05       	r0 = r0 - r5;
#endif

    // r0 is space in port minus one
    // r2 = amount data in port
    // r6 min required space
    r2  = r2 - r0;    
84203310:	a4 04       	r2 = r2 - r0;
    // check minimum space, if less than that
    // wrap has happened
    Null = r0 - r6;
84203312:	8f f2 00 c2 	Null = r0 - r6;
    if NEG r2 = NULL - r0;
84203316:	24 f0 04 c2 	if NEG r2 = Null - r0;

    r0 = M[r7 + $cbops_aec_ref_spkr_op._aec_ref_op_struct.BUFFER_ADJ_FIELD];
8420331a:	92 f0 02 88 	r0 = M[r7 + 8];
    r2 = r2 - r0;
8420331e:	a4 04       	r2 = r2 - r0;
    // r2 is number of samples in port, negative if overflow
    pop rLink;
84203320:	00 f4 3d cf 	pop rLink;
    rts;
84203324:	d8 4c       	rts;

84203326 <$_aec_ref_purge_mics>:
   .CODESEGMENT PM;

// void aec_ref_purge_mics(cbops_graph *mic_graph,unsigned num_mics);
$_aec_ref_purge_mics:
  // Save registers
	push rLink;
84203326:	00 f0 3d cf 	push rLink;
	pushm <r5,r6,r7,r8,r10>;
8420332a:	78 f1 40 e0 	pushm <r5, r6, r7, r8, r10>;
	pushm <M0,L0>;
8420332e:	10 f1 40 e4 	pushm <M0, L0>;
	push I0;
84203332:	00 f1 30 cf 	push I0;
	push B0;
84203336:	00 f2 3a cf 	push B0;

  // Force cbops to update buffers
  M[r0 + $cbops_c.cbops_graph_struct.FORCE_UPDATE_FIELD]=r0;
8420333a:	12 9e       	M[r0 + 32] = r0;

	// Extra parameters
	r7 = r0 + $cbops_c.cbops_graph_struct.BUFFERS_FIELD;
8420333c:	29 f0 24 20 	r7 = r0 + 36;
	r8 = r1;
84203340:	1a 09       	r8 = r1 + Null;
	r6 = MAXINT;
84203342:	ff f7 f8 f7 	r6 = Null + 2147483647;
84203346:	ff 7b 

	// Get minimum data in mics
	r10 = r8;
84203348:	54 09       	r10 = r8 + Null;
	r5  = r7;
8420334a:	4f 08       	r5 = r7 + Null;
	do aec_ref_purge_mics.data_loop;
8420334c:	08 4c       	do (m) $M.cbops.aec_ref_purge_mics.aec_ref_purge_mics.data_loop;
		// Get amount of data in mic
		r0 = M[r5 + $cbops_c.cbops_buffer_struct.BUFFER_FIELD];
8420334e:	7a 88       	r0 = M[r5 + 4];
		call $cbuffer.calc_amount_data_in_words;
84203350:	ff fd 47 f1 	call (m) 0x2c208;
84203354:	39 e5 
		// update minimum
		r6 = MIN r0;
84203356:	5f f2 48 ce 	r6 = MIN r0;
		// Go to next mic
		r5 = r5 + $CBOP_BUFTAB_ENTRY_SIZE_IN_ADDR;
8420335a:	3f 2b       	r5 = r5 + 28;

8420335c <$M.cbops.aec_ref_purge_mics.aec_ref_purge_mics.data_loop>:
	aec_ref_purge_mics.data_loop:

  r0 = r6;
8420335c:	42 08       	r0 = r6 + Null;
   Words2Addr(r0);
8420335e:	52 5c       	r0 = r0 ASHIFT 2;
   M0 = r0;
84203360:	10 0b       	M0 = r0 + Null;
   if Z jump aec_ref_purge_mics_done;
84203362:	1e 60       	if EQ jump (m) $M.cbops.aec_ref_purge_mics.aec_ref_purge_mics_done;

	// Read Data
	r5  = r7;
84203364:	4f 08       	r5 = r7 + Null;

84203366 <$M.cbops.aec_ref_purge_mics.aec_ref_purge_mics.advance_loop>:
aec_ref_purge_mics.advance_loop:
		// Get Input buffer (source)
		r0 = M[r5 + $cbops_c.cbops_buffer_struct.BUFFER_FIELD];
84203366:	7a 88       	r0 = M[r5 + 4];
    call $cbuffer.get_read_address_and_size_and_start_address;
84203368:	ff fd 49 f1 	call (m) 0x2c6a4;
8420336c:	3d e9 
		L0 = r1;
8420336e:	1c 0b       	L0 = r1 + Null;
		push r2;
84203370:	00 f0 34 cf 	push r2;
		pop B0;
84203374:	00 f6 3a cf 	pop B0;
	  I0 = r0;
84203378:	10 0a       	I0 = r0 + Null;
		// Advance buffer
		NULL = r1 - MK1;
8420337a:	18 25       	Null = r1 - 4;
		if NZ jump aec_ref_purge_mics.sw_buf;
8420337c:	06 62       	if NE jump (m) $M.cbops.aec_ref_purge_mics.aec_ref_purge_mics.sw_buf;
			// MMU buffer must be read
			r10 = r6;
8420337e:	44 09       	r10 = r6 + Null;
			do aec_ref_purge_mics.mmu_buf;
84203380:	03 4c       	do (m) $M.cbops.aec_ref_purge_mics.aec_ref_purge_mics.mmu_buf;
				r0 = M[I0,MK1];
84203382:	21 f0 30 c0 	Null = Null + Null, r0 = M[I0,4];

84203386 <$M.cbops.aec_ref_purge_mics.aec_ref_purge_mics.mmu_buf>:
			aec_ref_purge_mics.mmu_buf:

			jump aec_ref_purge_mics.next;
84203386:	03 6e       	jump (m) $M.cbops.aec_ref_purge_mics.aec_ref_purge_mics.next;

84203388 <$M.cbops.aec_ref_purge_mics.aec_ref_purge_mics.sw_buf>:

aec_ref_purge_mics.sw_buf:
			r0 = M[I0,M0];
84203388:	20 f0 20 c0 	Null = Null + Null, r0 = M[I0,M0];

8420338c <$M.cbops.aec_ref_purge_mics.aec_ref_purge_mics.next>:
aec_ref_purge_mics.next:
		// Update buffer
		r0 = M[r5 + $cbops_c.cbops_buffer_struct.BUFFER_FIELD];
8420338c:	7a 88       	r0 = M[r5 + 4];
		r1 = I0;
8420338e:	83 08       	r1 = I0 + Null;
		call $cbuffer.set_read_address;
84203390:	ff fd 49 f1 	call (m) 0x2c708;
84203394:	39 eb 
		// Go to next mic
		r5 = r5 + $CBOP_BUFTAB_ENTRY_SIZE_IN_ADDR;
84203396:	3f 2b       	r5 = r5 + 28;
		r8 = r8 - 1;
84203398:	aa f0 01 24 	r8 = r8 - 1;
		if GT jump aec_ref_purge_mics.advance_loop;
8420339c:	e5 6b       	if GT jump (m) $M.cbops.aec_ref_purge_mics.aec_ref_purge_mics.advance_loop;

8420339e <$M.cbops.aec_ref_purge_mics.aec_ref_purge_mics_done>:

aec_ref_purge_mics_done:
  // Restore registers
	pop B0;
8420339e:	00 f6 3a cf 	pop B0;
	pop I0;
842033a2:	00 f5 30 cf 	pop I0;
	popm <M0,L0>;
842033a6:	10 f1 60 e4 	popm <M0, L0>;
	popm <r5,r6,r7,r8,r10>;
842033aa:	78 f1 60 e0 	popm <r5, r6, r7, r8, r10>;
  pop rLink;
842033ae:	00 f4 3d cf 	pop rLink;
	rts;
842033b2:	d8 4c       	rts;

842033b4 <$_aecref_calc_ref_rate>:
//
// *****************************************************************************
.MODULE $M.aecref_calc_ref_rate;
   .CODESEGMENT PM;
$_aecref_calc_ref_rate:
    push r4;
842033b4:	00 f0 36 cf 	push r4;
    r4 = 0.5;
842033b8:	00 f4 06 f0 	r4 = Null + 1073741824;
842033bc:	00 40 
    // RateAdjREF = ([( mic_ra + 1.0) x (spkr_ra + 1.0) x mic_rt ] / spkr_rt) - 1.0

    // (mic_ra+1) x (spkr_ra+1.0) x 0.25 =
    //       (mic_ra*0.5 + 0.5) x (spkr_ra*0.5 + 0.5)
    r1 = r1 ASHIFT -1;
842033be:	1b 58       	r1 = r1 ASHIFT -1;
    r1 = r1 + r4;
842033c0:	f3 00       	r1 = r4 + r1;
    r3 = r3 ASHIFT -1;
842033c2:	2d 58       	r3 = r3 ASHIFT -1;
    r3 = r3 + r4;
842033c4:	75 01       	r3 = r4 + r3;
    rMAC = r1*r3;
842033c6:	5f f3 c1 cc 	rMAC = r1 * r3 (SS);

    // (mic_ra+1) x (spkr_ra+1.0) x mic_rt x 0.25
    rMAC = rMAC * r0;
842033ca:	2f f1 c1 cc 	rMAC = rMAC * r0 (SS);

    //  Note:  Multiplier is 0.25 instead of 0.5 because it is going
    //         into a fractional divide

    // [(mic_ra+1) x (spkr_ra+1.0) x mic_rt x 0.25]/spkr_rt
    DIV = rMAC / r2;
842033ce:	a1 4c       	Div = rMAC / r2;
    r0 = DivResult;
842033d0:	c2 4c       	r0 = DivResult;

    // Result of the divide is [0.0 ... 1.0], 0.5 is unity
    //   Convert to [-1.0 ... +1.0]
    r0 = r0 - r4;
842033d2:	92 05       	r0 = r0 - r4;
    r0 = r0 ASHIFT 1;
842033d4:	12 5c       	r0 = r0 ASHIFT 1;
    pop r4;
842033d6:	00 f4 36 cf 	pop r4;
    rts;
842033da:	d8 4c       	rts;

842033dc <$_aecref_calc_sync_mic_rate>:
$_aecref_calc_sync_mic_rate:
    // r0 = spkr_ra
    // r1 = spkr_rt
    // r2 = mic_rt
    // return spkr_rt/(mic_rt*(1+spkr_ra))
    rMAC = -r0;
842033dc:	81 04       	rMAC = Null - r0;
    r3 = r0 * r0 (frac);
842033de:	2f f2 45 c9 	r3 = r0 * r0 (frac);
    rMAC = rMAC + r0 * r0;
842033e2:	2f f2 c1 ca 	rMAC = rMAC + r0 * r0 (SS);
    rMAC = rMAC - r0*r3;   // rMAC = -spkr_ra + spkr_ra^2 - spkr_ra^3
842033e6:	5f f2 c1 cb 	rMAC = rMAC - r0 * r3 (SS);
                           // good enough estimation of 1.0/(1.0+spkr_ra) -1.0
    r0 = rMAC;
842033ea:	0a 00       	r0 = rMAC + Null;
    rMAC = r1 - r2;
842033ec:	19 05       	rMAC = r1 - r2;
    if Z rts;              // all done if mic_rt==spkr_rt
842033ee:	00 fd c0 cd 	if EQ rts;
    // calculate (spkr_rt/mic_rt)-1.0
#if DAWTH>24
   // division & rounding
   rMAC0 = r2;
842033f2:	05 f0 00 f4 	rMAC0 = r2 LSHIFT 0;
842033f6:	de c8 
   r2 = r2 + r2;
842033f8:	24 01       	r2 = r2 + r2;
   Div = rMAC / r2;
842033fa:	a1 4c       	Div = rMAC / r2;
   r1 = DivResult;       // r1 = (spkr_rt/mic_rt)-1.0
842033fc:	c3 4c       	r1 = DivResult;
   r1 = r1 - 0.5;    // r1 = 0.5(spkr_rt/mic_rt-1.0)
   r1 = r1 + r1;     // r1 = (spkr_rt/mic_rt)-1.0
#endif
    // r1 = (spkr_rt/mic_rt)-1.0
    // r0 = 1.0/(1.0+spkr_ra)-1.0
    r2 = r1 * r0 (frac);
842033fe:	2f f3 44 c9 	r2 = r1 * r0 (frac);
    r0 = r1 + r0;
84203402:	9a 00       	r0 = r1 + r0;
    r0 = r0 + r2;
84203404:	a2 00       	r0 = r2 + r0;
    // r0 = spkr_rt/mic_rt/(1+spkr_ra) - 1.0
    rts;
84203406:	d8 4c       	rts;

84203408 <$cbops.aec_ref_sidetone_op.amount_to_use>:
// Called before amount_to_use of graph
$cbops.aec_ref_sidetone_op.amount_to_use:
#ifdef PATCH_LIBS
   LIBS_SLOW_SW_ROM_PATCH_POINT($cbops.aec_ref_sidetone_op.amount_to_use.PATCH_ID_0, r7)
#endif
   push rlink;
84203408:	00 f0 3d cf 	push rLink;

   // Get data pointer
   r7 = M[r8 + $cbops.param_hdr.OPERATOR_DATA_PTR_FIELD];
8420340c:	a9 f0 00 88 	r7 = M[r8 + 0];

   // update sidetone mic buffer
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.MIC_BUF_FIELD];
84203410:	92 f0 01 88 	r0 = M[r7 + 4];
   call $cbuffer.get_write_address_and_size_and_start_address;
84203414:	ff fd 49 f1 	call (m) 0x2c6d6;
84203418:	23 e6 
   r6 = r0;
8420341a:	10 09       	r6 = r0 + Null;
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.MIC_IDX_FIELD];
8420341c:	92 f0 05 88 	r0 = M[r7 + 20];
   call $cbops.get_cbuffer;
84203420:	ff fd c4 f2 	call 0x5bd8c;
84203424:	2c eb 
   r1 = r6;
84203426:	43 08       	r1 = r6 + Null;
   r6 = r0;
84203428:	10 09       	r6 = r0 + Null;
   call $cbuffer.set_write_address;
8420342a:	ff fd 49 f1 	call (m) 0x2c73e;
8420342e:	35 e8 

   // update amount to read from mic
   r0 = r6;
84203430:	42 08       	r0 = r6 + Null;
   call $cbuffer.calc_amount_data_in_words;
84203432:	ff fd 46 f1 	call (m) 0x2c208;
84203436:	37 ee 
   r6 = r0;
84203438:	10 09       	r6 = r0 + Null;
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.MIC_IDX_FIELD];
8420343a:	92 f0 05 88 	r0 = M[r7 + 20];
   call $cbops.get_amount_ptr;
8420343e:	ff fd c4 f2 	call 0x5bd9c;
84203442:	3e ea 
   M[r0] = r6;
84203444:	08 f0 02 ee 	M[Null + r0] = r6;

   /* See how many samples speakr has moved, we will mix the same
    * number of samples from sidetone buffer.
    */
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SPKR_BUFS_FIELD];
84203448:	92 f0 00 88 	r0 = M[r7 + 0];
   r0 = M[r0];
8420344c:	12 e8       	r0 = M[r0 + Null];
   call $cbuffer.get_read_address_and_size_and_start_address;
8420344e:	ff fd 49 f1 	call (m) 0x2c6a4;
84203452:	37 e2 
   r3 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.LAST_SPKR_ADDR_FIELD];
84203454:	95 f0 0e 88 	r3 = M[r7 + 56];
   M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.LAST_SPKR_ADDR_FIELD] = r0;
84203458:	92 f0 0e 8e 	M[r7 + 56] = r0;
   r3 = r0 - r3;
8420345c:	55 05       	r3 = r0 - r3;
   if NEG r3 = r3 + r1;
8420345e:	34 f5 05 c0 	if NEG r3 = r3 + r1;
   BUFFER_ADDRS_TO_WORDS_ASM(r3);
84203462:	6d 58       	r3 = r3 ASHIFT -2;
   M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.AMOUNT_TO_MIX_FIELD] = r3;
84203464:	95 f0 0f 8e 	M[r7 + 60] = r3;
   pop rlink;
84203468:	00 f4 3d cf 	pop rLink;
   rts;
8420346c:	d8 4c       	rts;

8420346e <$cbops.aec_ref_sidetone_op.pre_main>:
// TRASHED REGISTERS:
//    Assume anything except r4 and r8
//
// *****************************************************************************
$cbops.aec_ref_sidetone_op.pre_main:
   push rLink;
8420346e:	00 f0 3d cf 	push rLink;
   /* Force processing */
#ifdef PATCH_LIBS
   LIBS_SLOW_SW_ROM_PATCH_POINT($cbops.aec_ref_sidetone_op.pre_main.PATCH_ID_0, r6)
#endif
   call $cbops.force_processing;
84203472:	ff fd c4 f2 	call 0x5bdac;
84203476:	3a e9 
   pop rlink;
84203478:	00 f4 3d cf 	pop rLink;
   rts;
8420347c:	d8 4c       	rts;

8420347e <$cbops.aec_ref_sidetone_op.post_main>:
// *****************************************************************************
$cbops.aec_ref_sidetone_op.post_main:
#ifdef PATCH_LIBS
   LIBS_SLOW_SW_ROM_PATCH_POINT($cbops.aec_ref_sidetone_op.post_main.PATCH_ID_0, r7)
#endif
   push rlink;
8420347e:	00 f0 3d cf 	push rLink;

   // Get data pointer
   r7 = M[r8 + $cbops.param_hdr.OPERATOR_DATA_PTR_FIELD];
84203482:	a9 f0 00 88 	r7 = M[r8 + 0];

   // get speaker buffer
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SPKR_BUFS_FIELD];
84203486:	92 f0 00 88 	r0 = M[r7 + 0];
   r0 = M[r0];
8420348a:	12 e8       	r0 = M[r0 + Null];
   call $cbuffer.get_read_address_and_size_and_start_address;
8420348c:	ff fd 49 f1 	call (m) 0x2c6a4;
84203490:	39 e0 
   I0 = r0;
84203492:	10 0a       	I0 = r0 + Null;
   L0 = r1;
84203494:	1c 0b       	L0 = r1 + Null;
   push r2;
84203496:	00 f0 34 cf 	push r2;
   pop B0;
8420349a:	00 f6 3a cf 	pop B0;
   // save read address for later use
   I6 = r0;
8420349e:	16 0a       	I6 = r0 + Null;
   // I6 = read address of first speaker buffer

   // get threshold
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SAFETY_THRESHOLD_LOW_FIELD];
842034a0:	92 f0 06 88 	r0 = M[r7 + 24];
   BUFFER_WORDS_TO_ADDRS_ASM(r0);
842034a4:	52 5c       	r0 = r0 ASHIFT 2;
   M0 = r0;
842034a6:	10 0b       	M0 = r0 + Null;

   // r6 = spkr_rd + threshold_low
   r0 = M[I0, M0];
842034a8:	20 f0 20 c0 	Null = Null + Null, r0 = M[I0,M0];
   r6 = I0;
842034ac:	80 09       	r6 = I0 + Null;

   // r5 = spkr_rd + threshold_high
   I0 = I6;
842034ae:	b0 0a       	I0 = I6 + Null;
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SAFETY_THRESHOLD_HIGH_FIELD];
842034b0:	92 f0 07 88 	r0 = M[r7 + 28];
   BUFFER_WORDS_TO_ADDRS_ASM(r0);
842034b4:	52 5c       	r0 = r0 ASHIFT 2;
   M0 = r0;
842034b6:	10 0b       	M0 = r0 + Null;
   r0 = M[I0, M0];
842034b8:	20 f0 20 c0 	Null = Null + Null, r0 = M[I0,M0];
   r5 = I0;
842034bc:	87 08       	r5 = I0 + Null;

   r0 = r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SPKR_MIXING_OFFSETS_FIELD;
842034be:	92 f0 0c 20 	r0 = r7 + 12;
   r0 = M[r0];
842034c2:	12 e8       	r0 = M[r0 + Null];
   I0 = r0;
842034c4:	10 0a       	I0 = r0 + Null;
   I7 = r0;
842034c6:	17 0a       	I7 = r0 + Null;
   //            r0
   // --|----|---^---|-------------------------------------|--
   //   RD   Low     High                                 WR
   //
   // ====================================================================
   Null = r5 - r6;
842034c8:	8f f7 00 c2 	Null = r5 - r6;
   if NEG jump neg_part;
842034cc:	04 f0 95 e0 	if NEG jump (m) $M.cbops.aec_ref_sidetone_op.neg_part;

842034d0 <$M.cbops.aec_ref_sidetone_op.pos_part>:
   pos_part:
      // expect: r6 <= r0 < r5
      Null = r0 - r5;
842034d0:	d0 05       	Null = r0 - r5;
      if POS jump reset_mixing_offset;
842034d2:	05 f0 9d e0 	if POS jump (m) $M.cbops.aec_ref_sidetone_op.reset_mixing_offset;
      Null = r0 - r6;
842034d6:	8f f2 00 c2 	Null = r0 - r6;
      if NEG jump reset_mixing_offset;
842034da:	04 f0 95 e0 	if NEG jump (m) $M.cbops.aec_ref_sidetone_op.reset_mixing_offset;
      jump mixing_point_check_done;
842034de:	1a 6e       	jump (m) $M.cbops.aec_ref_sidetone_op.mixing_point_check_done;

842034e0 <$M.cbops.aec_ref_sidetone_op.neg_part>:

   neg_part:
      // expect: r0 < r5 or r0 >= r6
      Null = r0 - r6;
842034e0:	8f f2 00 c2 	Null = r0 - r6;
      if POS jump mixing_point_check_done;
842034e4:	05 f0 af e0 	if POS jump (m) $M.cbops.aec_ref_sidetone_op.mixing_point_check_done;
      Null = r0 - r5;
842034e8:	d0 05       	Null = r0 - r5;
      if NEG jump mixing_point_check_done;
842034ea:	04 f0 a9 e0 	if NEG jump (m) $M.cbops.aec_ref_sidetone_op.mixing_point_check_done;

842034ee <$M.cbops.aec_ref_sidetone_op.reset_mixing_offset>:

reset_mixing_offset:
   /* reset mixing offset */
   r1 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SAFETY_SET_THRESHOLD_FIELD];
842034ee:	93 f0 08 88 	r1 = M[r7 + 32];
   BUFFER_WORDS_TO_ADDRS_ASM(r1);
842034f2:	5b 5c       	r1 = r1 ASHIFT 2;
   M0 = r1;
842034f4:	18 0b       	M0 = r1 + Null;
   I0 = I6;
842034f6:	b0 0a       	I0 = I6 + Null;
   r1 = M[I0, M0];
842034f8:	30 f0 20 c0 	Null = Null + Null, r1 = M[I0,M0];

   // update debug counter showing mixing offset has been re-aligned
   r2 = I0 - r0;
842034fc:	2f f0 84 c6 	r2 = I0 - r0;
   if NEG r2 = r2 + L0;
84203500:	c4 f4 44 c4 	if NEG r2 = r2 + L0;
   BUFFER_ADDRS_TO_WORDS_ASM(r2);
84203504:	64 58       	r2 = r2 ASHIFT -2;
   r1 = M[r7+ $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SIDETONE_ALIGNED_SAMPLES_FIELD];
84203506:	93 f0 0d 88 	r1 = M[r7 + 52];
   r1 = r1 + r2;
8420350a:	e3 00       	r1 = r2 + r1;
   M[r7+ $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SIDETONE_ALIGNED_SAMPLES_FIELD] = r1;
8420350c:	93 f0 0d 8e 	M[r7 + 52] = r1;

   // r0 = mixing offset updated
   r0 = I0;
84203510:	82 08       	r0 = I0 + Null;

84203512 <$M.cbops.aec_ref_sidetone_op.mixing_point_check_done>:
   // L0 = speaker buffer length
   // I6 = speaker buffer read address

   // work out the distance between HW read address and
   // mixing address in samples
   push B0;
84203512:	00 f2 3a cf 	push B0;
   pop r1;
84203516:	00 f4 33 cf 	pop r1;
   r1 = r0 - I6;
8420351a:	6f f2 43 c6 	r1 = r0 - I6;
   if NEG r1 = r1 + L0;
8420351e:	c4 f3 43 c4 	if NEG r1 = r1 + L0;
   BUFFER_ADDRS_TO_WORDS_ASM(r1);
84203522:	5b 58       	r1 = r1 ASHIFT -2;

   // get amount to mix
   r5 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.AMOUNT_TO_MIX_FIELD];
84203524:	97 f0 0f 88 	r5 = M[r7 + 60];
   // r1 = distance before mixing
   // r3 = distance after mixing
   r3 = r5 + r1;
84203528:	fd 00       	r3 = r5 + r1;

   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SPKR_THRESHOLD_FIELD];
8420352a:	92 f0 09 88 	r0 = M[r7 + 36];
   r1 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SAFETY_THRESHOLD_LOW_FIELD];
8420352e:	93 f0 06 88 	r1 = M[r7 + 24];
   r2 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SAFETY_THRESHOLD_HIGH_FIELD];
84203532:	94 f0 07 88 	r2 = M[r7 + 28];
   r9 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SAFETY_SET_THRESHOLD_FIELD];
84203536:	9b f0 08 88 	r9 = M[r7 + 32];
   r1 = r0 + r1;   // low threshold after mixing
8420353a:	d3 00       	r1 = r0 + r1;
   r2 = r0 + r2;   // high threshold after mixing
8420353c:	14 01       	r2 = r0 + r2;
   r9 = r0 + r9;   // good threshold after mixing
8420353e:	13 0d       	r9 = r0 + r9;

   // r6 = samples to insert
   r6 = 0;
84203540:	00 09       	r6 = Null + Null;

   // expect r1 < r3 < r2
   r0 = r1 - r3;
84203542:	5a 05       	r0 = r1 - r3;
   if GT jump insert_sidetone;
84203544:	0c 6a       	if GT jump (m) $M.cbops.aec_ref_sidetone_op.insert_sidetone;
   r0 = r3 - r2;
84203546:	2a 05       	r0 = r3 - r2;
   if LE jump mix_sidetone;
84203548:	12 6c       	if LE jump (m) $M.cbops.aec_ref_sidetone_op.mix_sidetone;

8420354a <$M.cbops.aec_ref_sidetone_op.discard_sidetone>:

discard_sidetone:
   // discard here means ignore, we are doing in-place mixing
   // actual discard if needed will be done by sink_overflow_disgard operator
   r1 = r5 - r9;
8420354a:	bf f7 03 c2 	r1 = r5 - r9;
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SIDETONE_DISCARDED_SAMPLES_FIELD];
8420354e:	92 f0 0a 88 	r0 = M[r7 + 40];
   r0 = r0 + r1;
84203552:	9a 00       	r0 = r1 + r0;
   M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SIDETONE_DISCARDED_SAMPLES_FIELD] = r0;
84203554:	92 f0 0a 8e 	M[r7 + 40] = r0;
   r5 = r9;
84203558:	5f 08       	r5 = r9 + Null;
   jump mix_sidetone;
8420355a:	09 6e       	jump (m) $M.cbops.aec_ref_sidetone_op.mix_sidetone;

8420355c <$M.cbops.aec_ref_sidetone_op.insert_sidetone>:

insert_sidetone:
   // we don't have enough samples to mix, we needs to mix
   // the difference, it will be mixing using last mixed sample
   r6 = r9 - r5;
8420355c:	7f fb 08 c2 	r6 = r9 - r5;
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SIDETONE_INSERTED_SAMPLES_FIELD];
84203560:	92 f0 0b 88 	r0 = M[r7 + 44];
   r0 = r0 + r6;
84203564:	42 0c       	r0 = r6 + r0;
   M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SIDETONE_INSERTED_SAMPLES_FIELD] = r0;
84203566:	92 f0 0b 8e 	M[r7 + 44] = r0;
   r5 = r9;
8420356a:	5f 08       	r5 = r9 + Null;

8420356c <$M.cbops.aec_ref_sidetone_op.mix_sidetone>:
mix_sidetone:

   // M0 = amount to adjust
   M0 = I0 - I7;
8420356c:	7f f0 c8 c7 	M0 = I0 - I7;
   if NEG M0 = M0 + L0;
84203570:	c4 f8 c8 c5 	if NEG M0 = M0 + L0;

   // get number of speakers (1 or 2)
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.NR_SPKRS_FIELD];
84203574:	92 f0 02 88 	r0 = M[r7 + 8];
   M3 = r0;
84203578:	13 0b       	M3 = r0 + Null;

   // mixing offset address
   I2 = r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SPKR_MIXING_OFFSETS_FIELD;
8420357a:	92 f8 0c 20 	I2 = r7 + 12;

   // Get sidetone buffer and see how much we need to read
   r0 = M[r8 + $cbops.param_hdr.CHANNEL_INDEX_START_FIELD];
8420357e:	a2 f0 03 88 	r0 = M[r8 + 12];
   call $cbops.get_cbuffer;
84203582:	ff fd c4 f2 	call 0x5bd8c;
84203586:	2a e0 
   I5 = r0;
84203588:	15 0a       	I5 = r0 + Null;

   // see how much data is in sidetone buffer
   call $cbuffer.calc_amount_data_in_words;
8420358a:	ff fd 46 f1 	call (m) 0x2c208;
8420358e:	3f e3 
   r3 = r0;
84203590:	15 00       	r3 = r0 + Null;
   r0 = M[r8 + $cbops.param_hdr.CHANNEL_INDEX_START_FIELD];
84203592:	a2 f0 03 88 	r0 = M[r8 + 12];
   call $cbops.get_amount_ptr;
84203596:	ff fd c4 f2 	call 0x5bd9c;
8420359a:	26 e0 
   r0 = M[r0];
8420359c:	12 e8       	r0 = M[r0 + Null];
   r0 = r0 + r3;
8420359e:	aa 00       	r0 = r3 + r0;
   // r0: amount we have
   // r5: amount we need
   // r6: amount to invent
   r1 = r5 - r0;
842035a0:	bb 04       	r1 = r5 - r0;
   if LE jump enough_data;
842035a2:	03 6c       	if LE jump (m) $M.cbops.aec_ref_sidetone_op.enough_data;
      // Limit to amount available
      r5 = r5 - r1;
842035a4:	ff 04       	r5 = r5 - r1;
      r6 = r6 + r1;
842035a6:	18 0d       	r6 = r1 + r6;

842035a8 <$M.cbops.aec_ref_sidetone_op.enough_data>:
   enough_data:

   r0 = I5;
842035a8:	aa 08       	r0 = I5 + Null;
   call $cbuffer.get_read_address_and_size_and_start_address;
842035aa:	ff fd 48 f1 	call (m) 0x2c6a4;
842035ae:	3b e7 
   I7 = r0;
842035b0:	17 0a       	I7 = r0 + Null;
   L4 = r1;
842035b2:	1e 0b       	L4 = r1 + Null;
   push r2;
842035b4:	00 f0 34 cf 	push r2;
   pop B4;
842035b8:	00 f6 3c cf 	pop B4;

   // speaker buffers
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SPKR_BUFS_FIELD];
842035bc:	92 f0 00 88 	r0 = M[r7 + 0];
   I3 = r0;
842035c0:	13 0a       	I3 = r0 + Null;

842035c2 <$M.cbops.aec_ref_sidetone_op.channel_mixing_loop>:

channel_mixing_loop:

      // get base address for this speaker channel
      r0 = M[I3, MK1];
842035c2:	2d f0 30 c0 	Null = Null + Null, r0 = M[I3,4];
      r0 = M[r0 + $cbuffer.START_ADDR_FIELD];
842035c6:	d2 88       	r0 = M[r0 + 12];
      push r0;
842035c8:	00 f0 32 cf 	push r0;
      pop B0;
842035cc:	00 f6 3a cf 	pop B0;

      // get sidetone buffer
      I4 = I7;
842035d0:	bc 0a       	I4 = I7 + Null;

      // get speaker mixing point
      r0 = M[I2, 0];
842035d2:	28 f0 30 c0 	Null = Null + Null, r0 = M[I2,0];
      I0 = r0;
842035d6:	10 0a       	I0 = r0 + Null;

      // M0 is amount to fix the mixing point (should be 0 in normal condition)
      r0 = M[I0, M0];
842035d8:	20 f0 20 c0 	Null = Null + Null, r0 = M[I0,M0];

      // get last sidetone sample
      r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.LAST_SIDETONE_SAMPLE_FIELD];
842035dc:	92 f0 0c 88 	r0 = M[r7 + 48];

      r2 = 1.0;
842035e0:	ff f7 f4 f7 	r2 = Null + 2147483647;
842035e4:	ff 7b 

      // r5 = sidetone samples to read and mix
      // r6 = sidetone samples to invent and mix
      r10 = r6;
842035e6:	44 09       	r10 = r6 + Null;
      if Z jump insert_done;
842035e8:	08 60       	if EQ jump (m) $M.cbops.aec_ref_sidetone_op.insert_done;
      do insert_loop;
842035ea:	07 4c       	do (m) $M.cbops.aec_ref_sidetone_op.insert_done;
         rMAC = M[I0, 0];
842035ec:	10 f0 30 c0 	Null = Null + Null, rMAC = M[I0,0];
         rMAC = rMAC + r0 * r2;
842035f0:	4f f2 c1 ca 	rMAC = rMAC + r0 * r2 (SS);
         M[I0, MK1] = rMAC;
842035f4:	91 f0 30 c0 	Null = Null + Null, M[I0,4] = rMAC;

842035f8 <$M.cbops.aec_ref_sidetone_op.insert_done>:
      insert_loop:

      insert_done:
      r10 = r5;
842035f8:	3c 09       	r10 = r5 + Null;
      do mix_loop;
842035fa:	07 4c       	do (m) $M.cbops.aec_ref_sidetone_op.mix_loop;
         rMAC = M[I0, 0], r0 = M[I4,MK1];
842035fc:	21 f0 31 d0 	Null = Null + Null, rMAC = M[I0,0], r0 = M[I4,4];
         rMAC = rMAC + r0 * r2;
84203600:	4f f2 c1 ca 	rMAC = rMAC + r0 * r2 (SS);
         M[I0, MK1] = rMAC;
84203604:	91 f0 30 c0 	Null = Null + Null, M[I0,4] = rMAC;

84203608 <$M.cbops.aec_ref_sidetone_op.mix_loop>:
      mix_loop:
      M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.LAST_SIDETONE_SAMPLE_FIELD] = r0;
84203608:	92 f0 0c 8e 	M[r7 + 48] = r0;

      // update mixing point for next time
      r1 = I0;
8420360c:	83 08       	r1 = I0 + Null;
      M[I2, MK1] = r1;
8420360e:	b9 f0 30 c0 	Null = Null + Null, M[I2,4] = r1;
   // next channel
   M3 = M3 - 1;
84203612:	bb fc 01 24 	M3 = M3 - 1;
   if GT jump channel_mixing_loop;
84203616:	d6 6b       	if GT jump (m) $M.cbops.aec_ref_sidetone_op.channel_mixing_loop;

   // update sidetone buffer
   r0 = I5;
84203618:	aa 08       	r0 = I5 + Null;
   r1 = I4;
8420361a:	a3 08       	r1 = I4 + Null;
   call $cbuffer.set_read_address;
8420361c:	ff fd 48 f1 	call (m) 0x2c708;
84203620:	2d e7 

   pop rlink;
84203622:	00 f4 3d cf 	pop rLink;
   rts;
84203626:	d8 4c       	rts;

84203628 <$_aec_ref_sidetone_initialise>:
// TRASHED REGISTERS:
//    r0 (C callable)
//
// *****************************************************************************
$_aec_ref_sidetone_initialise:
   push rLink;
84203628:	00 f0 3d cf 	push rLink;
   pushm <I2,I3>;
8420362c:	00 f0 4c e4 	pushm <I2, I3>;
   pushm <r1,r2,r3,r7>;
84203630:	23 f0 48 e0 	pushm <r1, r2, r3, r7>;

   // here we got pointer to the cbops structure, so need to get to the
   // parameter struct first.
   r7 = M[r0 + ($cbops_c.cbops_op_struct.PARAMETER_AREA_START_FIELD+$cbops.param_hdr.OPERATOR_DATA_PTR_FIELD)];
84203634:	29 f0 03 88 	r7 = M[r0 + 12];

   // save the read address of first speaker buffer, we use this to see how many
   // samples speaker has read since last run
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SPKR_BUFS_FIELD];
84203638:	92 f0 00 88 	r0 = M[r7 + 0];
   r0 = M[r0];
8420363c:	12 e8       	r0 = M[r0 + Null];
   call $cbuffer.get_read_address_and_size_and_start_address;
8420363e:	ff fd 48 f1 	call (m) 0x2c6a4;
84203642:	27 e3 

   /* initialise mixing points */
   M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.LAST_SPKR_ADDR_FIELD] = r0;
84203644:	92 f0 0e 8e 	M[r7 + 56] = r0;
   r10 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.NR_SPKRS_FIELD];
84203648:	9c f0 02 88 	r10 = M[r7 + 8];
   r0 = M[r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SPKR_BUFS_FIELD];
8420364c:	92 f0 00 88 	r0 = M[r7 + 0];
   I2 = r0;
84203650:	12 0a       	I2 = r0 + Null;
   I3 = r7 + $cbops_aec_ref_sidetone_op.aec_ref_sidetone_op_struct.SPKR_MIXING_OFFSETS_FIELD;
84203652:	93 f8 0c 20 	I3 = r7 + 12;
   do init_mixing_points;
84203656:	06 4c       	do (m) $M.cbops.aec_ref_sidetone_op.init_mixing_points;
      r0 = M[I2, MK1];   // get speaker buffer
84203658:	29 f0 30 c0 	Null = Null + Null, r0 = M[I2,4];
      r0 = M[r0 + $cbuffer.START_ADDR_FIELD];
8420365c:	d2 88       	r0 = M[r0 + 12];
      M[I3, MK1] = r0;   // mixing point
8420365e:	ad f0 30 c0 	Null = Null + Null, M[I3,4] = r0;

84203662 <$M.cbops.aec_ref_sidetone_op.init_mixing_points>:
   init_mixing_points:

   popm <r1,r2,r3,r7>;
84203662:	23 f0 68 e0 	popm <r1, r2, r3, r7>;
   popm <I2,I3>;
84203666:	00 f0 6c e4 	popm <I2, I3>;
   pop rLink;
8420366a:	00 f4 3d cf 	pop rLink;
   rts;
8420366e:	d8 4c       	rts;

84203670 <$_create_mute_op>:
.MODULE $M.download_support_lib.create_mute_op;
.CODESEGMENT PM;
.MINIM;

$_create_mute_op:
    rMAC = M[$_patched_fw_version];
84203670:	01 f0 4b 98 	rMAC = M[Null + 0x92c];
    Null = rMAC - PATCH_BUILD_ID;
84203674:	00 f0 10 f2 	Null = rMAC - 9881;
84203678:	99 2e 
    if EQ jump PATCH_ENTRY_CREATE_MUTE_OP;
8420367a:	fc ff 00 f0 	if EQ jump (m) 0x4003b88;
8420367e:	8f ea 

84203680 <$M.download_support_lib.create_mute_op.L_pb_mismatch>:

L_pb_mismatch:
    /* Stub: return false; */
    r0 = 0;
84203680:	02 00       	r0 = Null + Null;
    rts;
84203682:	d8 4c       	rts;

84203684 <$_set_aec_reference_not_running_from_rom>:
.CODESEGMENT PM;
.MINIM;
$_set_aec_reference_not_running_from_rom:
#ifndef DISABLE_PATCH_BUILD_ID_CHECK
    // panic if not using the right patch
    r0 = 0;
84203684:	02 00       	r0 = Null + Null;
    rMAC = M[$_patched_fw_version];
84203686:	01 f0 4b 98 	rMAC = M[Null + 0x92c];
    Null = rMAC - PATCH_BUILD_ID;
8420368a:	00 f0 10 f2 	Null = rMAC - 9881;
8420368e:	99 2e 
    if NZ call $error;
84203690:	f1 fd 4a f1 	if NE call (m) 0x2cb9c;
84203694:	2d e8 
    // if we have patch entry for setting the downloadable flag
    // then go to that patch.
    jump PATCH_ENTRY_SET_AEC_REFERENCE_NOT_RUNNING_FROM_ROM;
#else
   // otherwise quietly return
   rts;
84203696:	d8 4c       	rts;

84203698 <$_setup_cbops_dc_offset_compensation>:
#ifdef DISABLE_PATCH_BUILD_ID_CHECK
   .const $_setup_cbops_dc_offset_compensation PATCH_ENTRY_SETUP_CBOPS_DC_OFFSET_COMPENSATION;
#else /* PATCH_ENTRY_SETUP_CBOPS_DC_OFFSET_COMPENSATION */
$_setup_cbops_dc_offset_compensation:
   /* Check patch version */
    rMAC = M[$_patched_fw_version];
84203698:	01 f0 4b 98 	rMAC = M[Null + 0x92c];
    Null = rMAC - PATCH_BUILD_ID;
8420369c:	00 f0 10 f2 	Null = rMAC - 9881;
842036a0:	99 2e 
    if EQ jump PATCH_ENTRY_SETUP_CBOPS_DC_OFFSET_COMPENSATION;
842036a2:	fc ff 60 f0 	if EQ jump (m) 0x4006ac8;
842036a6:	a7 e8 

842036a8 <$M.download_support_lib.setup_cbops_dc_offset_compensation.return_null>:
#endif
return_null:
   /* if not matching then just return NULL,
    * so no dc offset op created/added
    */
    r0 = 0;
842036a8:	02 00       	r0 = Null + Null;
    rts;
842036aa:	d8 4c       	rts;

842036ac <$cbops.multichan_sidetone_mix_op.main>:
//    r0-r3, r5, r6, r7, r9, r10, rMAC, M1-M3, I0-I7, L0, L1, L4, DoLoop
//
// *****************************************************************************
$cbops.multichan_sidetone_mix_op.main:
   // push rLink onto stack
   push rLink;
842036ac:	00 f0 3d cf 	push rLink;

   r7 = M[r8 + $cbops.param_hdr.OPERATOR_DATA_PTR_FIELD];
842036b0:	a9 f0 00 88 	r7 = M[r8 + 0];

   // used throughout this function
   M1 = MK1;
842036b4:	21 73       	M1 = Null + 4;
   // Go through all sidetone buffers and and find minimum
   // amount of data among them.
   // Note: We could just look at first buffer since we expect
   // all sidetone buffers to be synchronised but this will
   // prevent failing in dramatic way if they aren't synced.
   r6 = 0x7FFF; // start with reasonably large value
842036b6:	38 f0 ff 7b 	r6 = Null + 32767;
   r10 = M[r7 + $cbops_sidetone_mix_op.multichan_st_mix_struct.NR_ST_CHANNELS_FIELD];
842036ba:	9c f0 04 88 	r10 = M[r7 + 16];
   I6 = r7 + $cbops_sidetone_mix_op.multichan_st_mix_struct.ST_IDXS_FIELD;
842036be:	96 f8 14 20 	I6 = r7 + 20;
   // r6: Minimum amount of data in sidetone buffers
   do sidetone_buffers_get_amount_loop;
842036c2:	0b 4c       	do (m) $M.cbops.sidetone_mix_op.sidetone_buffers_get_amount_loop;
      // Get buffer index for sidetone buffer
      r0 = M[I6, M1];
842036c4:	29 f0 20 d0 	Null = Null + Null, r0 = M[I6,M1];

      // get sidetone buffer
      call $cbops.get_cbuffer;
842036c8:	ff fd c3 f2 	call 0x5bd8c;
842036cc:	24 e6 

      // get the amount of sidetone data
      call $cbuffer.calc_amount_data_in_words;
842036ce:	ff fd 45 f1 	call (m) 0x2c208;
842036d2:	3b e9 

      // r6 holds minimum data in all connected sidetone channels
      r6  = MIN r0;
842036d4:	5f f2 48 ce 	r6 = MIN r0;

842036d8 <$M.cbops.sidetone_mix_op.sidetone_buffers_get_amount_loop>:
  sidetone_buffers_get_amount_loop:

   // Get transfer amount from input to output
   //  r0: transfer amount in samples
   //  r9: offset to output channels in addrs (from the start of index table)
   call $cbops.get_transfer_and_update_multi_channel;
842036d8:	ff fd c3 f2 	call 0x5bcec;
842036dc:	34 e0 

   // M3: amount of sidetone to invent this run
   //     if sidetone buffers don't have enough data.
   M3 = r0 - r6;
842036de:	8f f2 0b c7 	M3 = r0 - r6;
   if NEG M3 = 0;
842036e2:	04 f0 0b c5 	if NEG M3 = Null + Null;

   // update insert counter
   r1 = M[r7 + $cbops_sidetone_mix_op.multichan_st_mix_struct.NUM_INSERTS_FIELD];
842036e6:	93 f0 01 88 	r1 = M[r7 + 4];
   r1 = r1 + M3;
842036ea:	db 0c       	r1 = M3 + r1;
   M[r7 +  $cbops_sidetone_mix_op.multichan_st_mix_struct.NUM_INSERTS_FIELD]=r1;
842036ec:	93 f0 01 8e 	M[r7 + 4] = r1;

   // M2: Amount of real sidetone that will be mixed this run
   M2 = r0 - M3;
842036f0:	bf f2 4a c7 	M2 = r0 - M3;

   // If amount of sidetone after transfer is > 2*SIDETONE_MAX_SAMPLES_FIELD
   // drop sidetone to leave SIDETONE_MAX_SAMPLES_FIELD samples
   // r5 is amount to drop
   r1 = M[r7 + $cbops_sidetone_mix_op.multichan_st_mix_struct.MAX_SAMPLES_FIELD];
842036f4:	93 f0 00 88 	r1 = M[r7 + 0];
   r0 = r6 - r0;    //Amount remaining sidetone samples in the buffers after mix
842036f8:	2f f8 02 c2 	r0 = r6 - r0;
   r5 = r0 - r1;    // remaining sidetone samples - SIDETONE_MAX_SAMPLES_FIELD
842036fc:	d7 04       	r5 = r0 - r1;
   NULL = r5 - r1;
842036fe:	f8 04       	Null = r5 - r1;
   if NEG r5 = NULL; // remaining data < 2*SIDETONE_MAX_SAMPLES_FIELD (no drop)
84203700:	04 f0 07 c0 	if NEG r5 = Null + Null;

   // r5 sidetone samples are dropped to control latency, update the accumulator
   r2 = M[r7 + $cbops_sidetone_mix_op.multichan_st_mix_struct.NUM_DROPS_FIELD];
84203704:	94 f0 02 88 	r2 = M[r7 + 8];
   r2 = r2 + r5;
84203708:	3c 01       	r2 = r5 + r2;
   M[r7 + $cbops_sidetone_mix_op.multichan_st_mix_struct.NUM_DROPS_FIELD]=r2;
8420370a:	94 f0 02 8e 	M[r7 + 8] = r2;

   // Total sidetone samples consumed =
   //   M2: mixed sidetone samples +
   //   r5: dropped sidetone samples
   r5 = M2 + r5;
8420370e:	d7 0c       	r5 = M2 + r5;

   // Go through all sidetone buffers and
   // update transfer amount (=r5)
   r10 = M[r7 + $cbops_sidetone_mix_op.multichan_st_mix_struct.NR_ST_CHANNELS_FIELD];
84203710:	9c f0 04 88 	r10 = M[r7 + 16];
   I6 = r7 + $cbops_sidetone_mix_op.multichan_st_mix_struct.ST_IDXS_FIELD;
84203714:	96 f8 14 20 	I6 = r7 + 20;
   do sidetone_buffers_update_transfer_amount_loop;
84203718:	07 4c       	do (m) $M.cbops.sidetone_mix_op.sidetone_buffers_update_transfer_amount_loop;
      r0 = M[I6, M1];
8420371a:	29 f0 20 d0 	Null = Null + Null, r0 = M[I6,M1];
      call $cbops.get_amount_ptr;
8420371e:	ff fd c3 f2 	call 0x5bd9c;
84203722:	3e e3 
      M[r0] = r5;
84203724:	87 ee       	M[Null + r0] = r5;

84203726 <$M.cbops.sidetone_mix_op.sidetone_buffers_update_transfer_amount_loop>:
   sidetone_buffers_update_transfer_amount_loop:

   // see if we have something to transfer
   // from input to output
   NULL = M2 + M3;
84203726:	bf fa c0 c4 	Null = M2 + M3;
   if LE jump all_done;
8420372a:	6c 6c       	if LE jump (m) $M.cbops.sidetone_mix_op.all_done;

   // set M0 to number of channels
   r0 = M[r7 + $cbops_sidetone_mix_op.multichan_st_mix_struct.NR_CHANNELS_FIELD];
8420372c:	92 f0 03 88 	r0 = M[r7 + 12];
   M0 = r0;
84203730:	10 0b       	M0 = r0 + Null;

   // set I6 to sidetone map indexes
   r0 = M[r7 + $cbops_sidetone_mix_op.multichan_st_mix_struct.NR_ST_CHANNELS_FIELD];
84203732:	92 f0 04 88 	r0 = M[r7 + 16];
   Words2Addr(r0);
84203736:	52 5c       	r0 = r0 ASHIFT 2;
   I6 = r7 +  $cbops_sidetone_mix_op.multichan_st_mix_struct.ST_IDXS_FIELD;
84203738:	96 f8 14 20 	I6 = r7 + 20;
   I6 = I6 + r0;
8420373c:	16 0e       	I6 = r0 + I6;

   // set I2 to input indexes
   I2 = r8 + $cbops.param_hdr.CHANNEL_INDEX_START_FIELD;
8420373e:	a2 f8 0c 20 	I2 = r8 + 12;

   // set I3 to output indexes
   I3 = I2 + r9;
84203742:	bf f2 83 c5 	I3 = I2 + r9;

   // Sidetone attenuation (0dB)
   r5 = 1.0;
84203746:	ff f7 f7 f7 	r5 = Null + 2147483647;
8420374a:	ff 7b 

8420374c <$M.cbops.sidetone_mix_op.transfer_and_sidetone_mix_channel_loop>:

   transfer_and_sidetone_mix_channel_loop:
      // get input, output and sidetone indexes
      // for this channel
      r0 = M[I6, M1];          // get sidetone index
8420374c:	29 f0 20 d0 	Null = Null + Null, r0 = M[I6,M1];
      r7 = r0, r0 = M[I3, M1]; // get output index
84203750:	2d f0 0f f2 	r7 = r0 + Null, r0 = M[I3,M1];
84203754:	09 c0 
      r3 = r0, r0 = M[I2, M1]; // get input index
84203756:	29 f0 0f f2 	r3 = r0 + Null, r0 = M[I2,M1];
8420375a:	05 c0 
      I7 = r3 - r0;
8420375c:	2f f5 07 c7 	I7 = r3 - r0;
      // r3 = output index
      // r0 = input index
      // I7 = output index - input index (useful to skip transfer only)

      // Setup Input Buffer
      call $cbops.get_buffer_address_and_length;
84203760:	ff fd c2 f2 	call 0x5bd20;
84203764:	20 ee 
      I0 = r0;
84203766:	10 0a       	I0 = r0 + Null;
      if Z jump transfer_and_sidetone_mix_next_channel;
84203768:	3f 60       	if EQ jump (m) $M.cbops.sidetone_mix_op.just_transfer_loop;
      L0 = r1;
8420376a:	1c 0b       	L0 = r1 + Null;
      push r2;
8420376c:	00 f0 34 cf 	push r2;
      pop B0;
84203770:	00 f6 3a cf 	pop B0;

      // Setup Output Buffer
      r0 = r3;
84203774:	2a 00       	r0 = r3 + Null;
      call $cbops.get_buffer_address_and_length;
84203776:	ff fd c2 f2 	call 0x5bd20;
8420377a:	2a ed 
      I4 = r0;
8420377c:	14 0a       	I4 = r0 + Null;
      if Z jump transfer_and_sidetone_mix_next_channel;
8420377e:	34 60       	if EQ jump (m) $M.cbops.sidetone_mix_op.just_transfer_loop;
      L4 = r1;
84203780:	1e 0b       	L4 = r1 + Null;
      push r2;
84203782:	00 f0 34 cf 	push r2;
      pop B4;
84203786:	00 f6 3c cf 	pop B4;

      // setup sidetone buffer
      r0 = r7;
8420378a:	4a 08       	r0 = r7 + Null;
      // if not mapped to any sidetone buffer just
      // simple transfer from input to output
      if NEG jump just_transfer_input_to_output;
8420378c:	04 f0 c9 e0 	if NEG jump (m) $M.cbops.sidetone_mix_op.just_transfer_input_to_output;
      call $cbops.get_buffer_address_and_length;
84203790:	ff fd c2 f2 	call 0x5bd20;
84203794:	30 ec 
      push r2;
84203796:	00 f0 34 cf 	push r2;
      pop B1;
8420379a:	00 f6 3b cf 	pop B1;
      // set the length & get the first input sample
      I1 = r0;
8420379e:	11 0a       	I1 = r0 + Null;
      L1 = r1, rMAC = M[I0,M1];
842037a0:	11 f0 3f f0 	L1 = Null + r1, rMAC = M[I0,M1];
842037a4:	0d c5 
      // I1/L1/B1 = Sidetone buffer
      // I0/L0/B0 = Input buffer
      // I4/L4/B4 = Output buffer

      // Mixing loop
      r10 = M2;
842037a6:	d4 09       	r10 = M2 + Null;
      do mix_real_sidetone_loop;
842037a8:	07 4c       	do (m) $M.cbops.sidetone_mix_op.mix_real_sidetone_loop;
         // calculate the current output sample and read a side tone sample
         r0 = M[I1,M1];
842037aa:	25 f0 20 c0 	Null = Null + Null, r0 = M[I1,M1];
         rMAC = rMAC + r0 * r5;
842037ae:	7f f2 c1 ca 	rMAC = rMAC + r0 * r5 (SS);

         // get the next input value and write current output
         rMAC = M[I0,M1], M[I4,M1] = rMAC;
842037b2:	91 f1 21 d0 	Null = Null + Null, rMAC = M[I0,M1], M[I4,M1] = rMAC;

842037b6 <$M.cbops.sidetone_mix_op.mix_real_sidetone_loop>:
      mix_real_sidetone_loop:

      // continue only of we need to invent sidetone samples
      r10 = M3;
842037b6:	dc 09       	r10 = M3 + Null;
      if Z jump transfer_and_sidetone_mix_next_channel;
842037b8:	17 60       	if EQ jump (m) $M.cbops.sidetone_mix_op.just_transfer_loop;
      // Repeat Last sample of sidetone buffer (insert sidetone samples)
      r0 = M[I1,-MK1];
842037ba:	27 f0 30 c0 	Null = Null + Null, r0 = M[I1,-4];
      r0 = M[I1,M1];
842037be:	25 f0 20 c0 	Null = Null + Null, r0 = M[I1,M1];
      // Ensure sidetone is connected repeat last sample, else mix silence
      NULL = r6;
842037c2:	40 08       	Null = r6 + Null;
      if Z r0=NULL;
842037c4:	00 f0 02 c0 	if EQ r0 = Null + Null;
      do mix_invented_sidetone_loop;
842037c8:	05 4c       	do (m) $M.cbops.sidetone_mix_op.mix_invented_sidetone_loop;
         // calculate the current output sample
         rMAC = rMAC + r0 * r5;
842037ca:	7f f2 c1 ca 	rMAC = rMAC + r0 * r5 (SS);
         // get the next input value and write the result
         rMAC = M[I0,M1], M[I4,M1] = rMAC;
842037ce:	91 f1 21 d0 	Null = Null + Null, rMAC = M[I0,M1], M[I4,M1] = rMAC;

842037d2 <$M.cbops.sidetone_mix_op.mix_invented_sidetone_loop>:
      mix_invented_sidetone_loop:
      jump transfer_and_sidetone_mix_next_channel;
842037d2:	0a 6e       	jump (m) $M.cbops.sidetone_mix_op.just_transfer_loop;

842037d4 <$M.cbops.sidetone_mix_op.just_transfer_input_to_output>:

      just_transfer_input_to_output:
      NULL = I7; // if output index == input index then skip transfer
842037d4:	b8 08       	Null = I7 + Null;
      if Z jump transfer_and_sidetone_mix_next_channel;
842037d6:	08 60       	if EQ jump (m) $M.cbops.sidetone_mix_op.just_transfer_loop;
      r10 = M2 + M3;
842037d8:	bf fa cc c4 	r10 = M2 + M3;
      do just_transfer_loop;
842037dc:	05 4c       	do (m) $M.cbops.sidetone_mix_op.just_transfer_loop;
         r0 = M[I0,M1];
842037de:	21 f0 20 c0 	Null = Null + Null, r0 = M[I0,M1];
         M[I4,M1] = r0;
842037e2:	a1 f0 20 d0 	Null = Null + Null, M[I4,M1] = r0;

842037e6 <$M.cbops.sidetone_mix_op.just_transfer_loop>:
      just_transfer_loop:
   transfer_and_sidetone_mix_next_channel:
   M0 = M0 - 1;
842037e6:	88 fc 01 24 	M0 = M0 - 1;
   if NZ jump transfer_and_sidetone_mix_channel_loop;
842037ea:	b1 63       	if NE jump (m) $M.cbops.sidetone_mix_op.transfer_and_sidetone_mix_channel_loop;

   // zero the remaining length registers we have used
   L0 = 0;
842037ec:	04 0b       	L0 = Null + Null;
   L4 = 0;
842037ee:	06 0b       	L4 = Null + Null;
   L1 = 0;
842037f0:	05 0b       	L1 = Null + Null;
   push Null;
842037f2:	00 f0 30 cf 	push Null;
   B0 = M[SP - 1*ADDR_PER_WORD];
842037f6:	fe fa 1a cf 	B0 = M[SP + -0x4];
   B1 = M[SP - 1*ADDR_PER_WORD];
842037fa:	fe fa 1b cf 	B1 = M[SP + -0x4];
   pop B4;
842037fe:	00 f6 3c cf 	pop B4;

84203802 <$M.cbops.sidetone_mix_op.all_done>:
all_done:
   // pop rLink from stack
   pop rLink;
84203802:	00 f4 3d cf 	pop rLink;
   rts;
84203806:	d8 4c       	rts;
